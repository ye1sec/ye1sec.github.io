<!DOCTYPE html><html><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="python面向对象编程"><meta name="keywords" content="python,类"><meta name="author" content="ye1s,undefined"><meta name="copyright" content="ye1s"><title>python面向对象编程【ye1s】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch-theme-algolia.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4"></script><!-- link(rel="dns-prefetch" href="https://cdn.jsdelivr.net")--><!-- link(rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css")--><!-- script(src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer)--><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"LKL6Q0GQJM","apiKey":"03829f64e2f5c11e4a5e2b8e51e24eb9","indexName":"blog","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  gitment: {"owner":"ye1sec","repo":"comments","client_id":"d5ece338867af32b6dfa","client_secret":"2caf36bbd47977524017f95105315fc9e65f0577"},
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="ye1s" type="application/atom+xml">
</head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0x1类的基本用法"><span class="toc-number">1.</span> <span class="toc-text">0x1类的基本用法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x2调用类的三种方法"><span class="toc-number">2.</span> <span class="toc-text">0x2调用类的三种方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x3类的属性"><span class="toc-number">3.</span> <span class="toc-text">0x3类的属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x4类的方法"><span class="toc-number">4.</span> <span class="toc-text">0x4类的方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x5类的对象信息"><span class="toc-number">5.</span> <span class="toc-text">0x5类的对象信息</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x6类的特性"><span class="toc-number">6.</span> <span class="toc-text">0x6类的特性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x7成员保护与访问机制"><span class="toc-number">7.</span> <span class="toc-text">0x7成员保护与访问机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x8Propety装饰器"><span class="toc-number">8.</span> <span class="toc-text">0x8Propety装饰器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x9-init-self-…-‘构造器’方法"><span class="toc-number">9.</span> <span class="toc-text">0x9 __init__(self,…)‘构造器’方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x10使用枚举类"><span class="toc-number">10.</span> <span class="toc-text">0x10使用枚举类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x11使用元类"><span class="toc-number">11.</span> <span class="toc-text">0x11使用元类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x13抽象类"><span class="toc-number">12.</span> <span class="toc-text">0x13抽象类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x14类的内置方法"><span class="toc-number">13.</span> <span class="toc-text">0x14类的内置方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#doc"><span class="toc-number">13.1.</span> <span class="toc-text">doc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#init"><span class="toc-number">13.2.</span> <span class="toc-text">init()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#module-和-class"><span class="toc-number">13.3.</span> <span class="toc-text">module__ 和 __class</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#del"><span class="toc-number">13.4.</span> <span class="toc-text">del()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#call"><span class="toc-number">13.5.</span> <span class="toc-text">call()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dict"><span class="toc-number">13.6.</span> <span class="toc-text">dict</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#str"><span class="toc-number">13.7.</span> <span class="toc-text">str()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getitem-、setitem-、-delitem"><span class="toc-number">13.8.</span> <span class="toc-text">getitem__()、setitem()、__delitem()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iter"><span class="toc-number">13.9.</span> <span class="toc-text">iter()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#len"><span class="toc-number">13.10.</span> <span class="toc-text">len()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#repr"><span class="toc-number">13.11.</span> <span class="toc-text">repr()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#add-加运算-sub-减运算-mul-乘运算-div-除运算-mod-求余运算-pow-幂运算"><span class="toc-number">13.12.</span> <span class="toc-text">add__: 加运算 sub: 减运算 mul: 乘运算 div: 除运算 mod: 求余运算 __pow: 幂运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#author作者信息"><span class="toc-number">13.13.</span> <span class="toc-text">author作者信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#slots"><span class="toc-number">13.14.</span> <span class="toc-text">slots</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">ye1s</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/ye1sec" target="_blank">GitHub<i class="icon-dot bg-color5"></i></a><a class="links-button button-hover" href="mailto:431774437@qq.com" target="_blank">E-Mail<i class="icon-dot bg-color5"></i></a><a class="links-button button-hover" href="tencent://message/?uin=431774437&amp;Site=&amp;Menu=yes" target="_blank">QQ<i class="icon-dot bg-color9"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">183</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">151</span></a><a class="author-info-articles-categories article-meta" href="/categories"><span class="pull-top">分类</span><span class="pull-bottom">12</span></a></div><div class="friend-link"><a class="friend-link-text" href="http://www.m00nback.xyz/" target="_blank">MoonBack</a><a class="friend-link-text" target="_blank">待定</a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="search social-icon"><i class="fas fa-search"></i><span> 搜索</span></a><a class="title-name" href="/">ye1s</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">python面向对象编程</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2019-05-30 | 更新于 2020-04-13</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/">编程算法</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/python/">python</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E7%B1%BB/">类</a></div></div></div><div class="main-content"><p>在Python中使用class关键字定义一个类，类的主体由属性（变量）和方法（函数）组成  <a id="more"></a><br>详情可看此篇文章:<a href="https://mp.weixin.qq.com/s/jEKvWwu5MwCqLbIxmAP4iQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/jEKvWwu5MwCqLbIxmAP4iQ</a><br>面向对象编程和函数式编程（面向过程编程）都是程序设计的方法，不过稍有区别。</p>
<p>面向过程编程：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 导入各种外部库</span><br><span class="line">2. 设计各种全局变量</span><br><span class="line">3. 写一个函数完成某个功能</span><br><span class="line">4. 写一个函数完成某个功能</span><br><span class="line">5. 写一个函数完成某个功能</span><br><span class="line">6. 写一个函数完成某个功能</span><br><span class="line">7. 写一个函数完成某个功能</span><br><span class="line">8. ......</span><br><span class="line">9. 写一个main函数作为程序入口</span><br></pre></td></tr></table></figure>
<p>在多函数程序中，许多重要的数据被放置在全局数据区，这样它们可以被所有的函数访问。每个函数都可以具有它们自己的局部数据，将某些功能代码封装到函数中，日后便无需重复编写，仅调用函数即可。从代码的组织形式来看就是根据业务逻辑从上到下垒代码 。</p>
<p>面向对象编程：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 导入各种外部库</span><br><span class="line">2. 设计各种全局变量</span><br><span class="line">3. 决定你要的类</span><br><span class="line">4. 给每个类提供完整的一组操作</span><br><span class="line">5. 明确地使用继承来表现不同类之间的共同点</span><br><span class="line">6. 根据需要，决定是否写一个main函数作为程序入口</span><br></pre></td></tr></table></figure>
<p>面向对象编程中，将函数和变量进一步封装成类，类才是程序的基本元素，它将数据和操作紧密地连结在一起，并保护数据不会被外界的函数意外地改变。类和和类的实例（也称对象）是面向对象的核心概念，是和面向过程编程、函数式编程的根本区别。</p>
<p>并不是非要用面向对象编程，要看你的程序怎么设计方便，但是就目前来说，基本上都是在使用面向对象编程。</p>
<h1 id="0x1类的基本用法"><a href="#0x1类的基本用法" class="headerlink" title="0x1类的基本用法"></a>0x1类的基本用法</h1><p>面向对象是通过定义class类来定义，这么说面向对象编程就是只使用class类，在class类中有封装，继承的功能，并且还可以构造要传入的参数，方便控制。<br>案例： </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line">import time</span><br><span class="line">class studetn:</span><br><span class="line">    <span class="comment"># 定义一个类名为studetn</span></span><br><span class="line">    def __init__(self,idx):</span><br><span class="line">    <span class="comment"># 定义初始化构造，这里使用init，还有别的属性比如reversed，iter之类的</span></span><br><span class="line">        self.idx=idx</span><br><span class="line">        <span class="comment"># 初始化变量，方便继承</span></span><br><span class="line">    def runx(self):</span><br><span class="line">    <span class="comment"># 定义运行函数，从上面继承变量</span></span><br><span class="line">        <span class="built_in">print</span>(self.idx)</span><br><span class="line">        <span class="comment"># 打印出idx的值，或者做一些别的处理</span></span><br><span class="line">        time.sleep(1)</span><br><span class="line">a=studetn(<span class="string">'a'</span>)</span><br><span class="line">a.runx()</span><br><span class="line"><span class="comment"># 这是类的调用，一定要记得类的使用方法，首先传入参数，类赋值给一个变量a</span></span><br><span class="line"><span class="comment"># 然后调用这个类下面定义的函数</span></span><br></pre></td></tr></table></figure>
<p>一些专业术语概念，既然有面向对象编程这个高大上的定义了，自然要搭配一些高大上的概念。   </p>
<blockquote>
<p>类(Class): 用来描述具有相同属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。其中的对象被称作类的实例。  </p>
</blockquote>
<blockquote>
<p>实例：也称对象。通过类定义的初始化方法，赋予具体的值，成为一个”有血有肉的实体”。</p>
</blockquote>
<blockquote>
<p>实例化：创建类的实例的过程或操作。</p>
</blockquote>
<blockquote>
<p>实例变量：定义在实例中的变量，只作用于当前实例。</p>
</blockquote>
<blockquote>
<p>类变量：类变量是所有实例公有的变量。类变量定义在类中，但在方法体之外。</p>
</blockquote>
<blockquote>
<p>数据成员：类变量、实例变量、方法、类方法、静态方法和属性等的统称。</p>
</blockquote>
<blockquote>
<p>方法：类中定义的函数。</p>
</blockquote>
<blockquote>
<p>静态方法：不需要实例化就可以由类执行的方法</p>
</blockquote>
<blockquote>
<p>类方法：类方法是将类本身作为对象进行操作的方法。</p>
</blockquote>
<blockquote>
<p>方法重写：如果从父类继承的方法不能满足子类的需求，可以对父类的方法进行改写，这个过程也称override。</p>
</blockquote>
<blockquote>
<p>封装：将内部实现包裹起来，对外透明，提供api接口进行调用的机制</p>
</blockquote>
<blockquote>
<p>继承：即一个派生类（derived class）继承父类（base class）的变量和方法。</p>
</blockquote>
<blockquote>
<p>多态：根据对象类型的不同以不同的方式进行处理。</p>
</blockquote>
<h1 id="0x2调用类的三种方法"><a href="#0x2调用类的三种方法" class="headerlink" title="0x2调用类的三种方法"></a>0x2调用类的三种方法</h1><p><strong>0x2.1实例方法</strong> </p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">class dd:</span><br><span class="line">    def __init__(self,url):</span><br><span class="line">        self.url=url</span><br><span class="line">    def runx(self):</span><br><span class="line">        <span class="built_in">print</span>(requests.get(self.url).status_code)</span><br><span class="line"></span><br><span class="line">a = dd(<span class="string">'http://www.baidu.com'</span>)</span><br><span class="line">a.runx()</span><br></pre></td></tr></table></figure>
<p><strong>0x2.2静态方法</strong> </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">class ff:</span><br><span class="line">    @staticmethod</span><br><span class="line">    def runx():</span><br><span class="line">        <span class="built_in">print</span>(requests.get(<span class="string">'http://www.baidu.com'</span>).status_code)</span><br><span class="line">ff.runx()</span><br><span class="line"><span class="comment">#这里就直接调用了类的变量，只在类中运行而不在实例中运行的方法</span></span><br></pre></td></tr></table></figure>
<p>经常有一些跟类有关系的功能但在运行时又不需要实例和类参与的情况下需要用到静态方法. 比如更改环境变量或者修改其他类的属性等能用到静态方法. 这种情况可以直接用函数解决, 但这样同样会扩散类内部的代码，造成维护困难。<br><strong>0x2.3类方法</strong><br>类方法由类调用，采用@classmethod装饰，至少传入一个cls（代指类本身，类似self）参数。执行类方法时，自动将调用该方法的类赋值给cls。建议只使用类名.类方法的调用方式。（虽然也可以使用实例名.类方法的方式调用）          </p>
<p><strong>实际案例</strong><br>如果要构造一个类，接受一个网站和这个网站的状态码，然后打印出来。就像这样：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">class gg:</span><br><span class="line">    def __init__(self,url,<span class="built_in">stat</span>):</span><br><span class="line">        self.url=url</span><br><span class="line">        self.stat=<span class="built_in">stat</span></span><br><span class="line">    def outer(self):</span><br><span class="line">        <span class="built_in">print</span>(self.url)</span><br><span class="line">        <span class="built_in">print</span>(self.stat)</span><br><span class="line">a = gg(<span class="string">'hello'</span>,200)</span><br><span class="line">a.outer()</span><br></pre></td></tr></table></figure>
<p>这样就是使用实例方法，虽然可以实现，但是有的时候传入的参数并不是(‘langzi’,200)这样的格式，而是(‘langzi-200’)这样的，那该怎么做？首先要把这个拆分，但是要使用实例方法实现起来很麻烦，这个时候就可以使用类方法。      </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line">class gg:</span><br><span class="line">    url = 0</span><br><span class="line">    <span class="built_in">stat</span> = 0</span><br><span class="line">    <span class="comment"># 因为使用classmethod后会传入新的变量，所以一开始是需要自己先定义类变量</span></span><br><span class="line">    def __init__(self,url=0,<span class="built_in">stat</span>=0):</span><br><span class="line">    <span class="comment"># 这里按照正常的定义构造函数</span></span><br><span class="line">        self.url=url</span><br><span class="line">        self.stat=<span class="built_in">stat</span></span><br><span class="line">    @classmethod</span><br><span class="line">    <span class="comment"># 装饰器，立马执行下面的函数</span></span><br><span class="line">    def split(cls,info):</span><br><span class="line">        <span class="comment"># 这个函数接受两个参数，默认的cls就是这个类的init函数，info就是外面传入进来的</span></span><br><span class="line">        url,<span class="built_in">stat</span>=map(str,info.split(<span class="string">'-'</span>))</span><br><span class="line">        <span class="comment"># 这里转换成了格式化的结构</span></span><br><span class="line">        data = cls(url,<span class="built_in">stat</span>)</span><br><span class="line">        <span class="comment"># 然后执行这个类第一个方法，这个类构造函数需要传入两个参数，于是就传入了两个参数</span></span><br><span class="line">        <span class="built_in">return</span> data</span><br><span class="line">        <span class="comment"># 这里就直接返回了函数结果</span></span><br><span class="line">    def outer(self):</span><br><span class="line">        <span class="built_in">print</span>(self.url)</span><br><span class="line">        <span class="built_in">print</span>(self.stat)</span><br><span class="line"></span><br><span class="line">r = gg.split((<span class="string">'hello-200'</span>))</span><br><span class="line">r.outer()</span><br><span class="line"><span class="comment"># 这里是调用类方法，与调用实例方法一样</span></span><br></pre></td></tr></table></figure>

<h1 id="0x3类的属性"><a href="#0x3类的属性" class="headerlink" title="0x3类的属性"></a>0x3类的属性</h1><ul>
<li>Python的类的属性一般分为私有属性和公有属性,而Python没有这类关键字，默认情-况下所有的属性都是“公有的”，对公有属性的访问没有任何限制，且都会被子类继承，也能从子类中进行访问。 </li>
<li>若不希望类中的属性在类外被直接访问，就要定义为私有属性。Python使用约定属性名称来划分属性类型。若属性的名字以两个下划线开始，表示私有属性；反之，没有使用双下划线开始的表示公有属性。类的方法也同样使用这样的约定</li>
<li>另外，Python没有保护类型的修饰符。</li>
<li>实例属性是以self为前缀的属性，没有该前缀的属性是普通的局部变量。  </li>
<li>在Python中静态变量称为类变量，类变量可以在该类的所有实例中被共享。</li>
</ul>
<p>类属性仅与其被定义的的类相绑定，主要包括数据属性（静态变量）和方法。方法在类中定义，但却只能被实例调用。如果没有与类的数据属性同名的实例属性，通过实例也可以访问类的数据属性，但是却不能作修改。</p>
<p>类属性和实例属性<br><img src="../../images/python/python/instance.jpg" alt=""></p>
<p>私有变量  </p>
<p><img src="../../images/python/python/private.jpg" alt="">  </p>
<p>内置属性</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C.__name__  类C的名字（字符串）</span><br><span class="line">C.__doc__    类C的文档字符串</span><br><span class="line">C.__bases__   类C的所有父类构成的元组</span><br><span class="line">C.__dict__  类C的属性</span><br><span class="line">C.__module__  类C定义所在的模块</span><br><span class="line">C.__class__   实例C对应的类</span><br></pre></td></tr></table></figure>
<p>范例：</p>
<p><img src="../../images/python/python/build.jpg" alt=""><br>实例仅拥有数据属性，即类属性。实例属性可以动态创建，但是如果属性在条件语句中创建，而该条件语句未执行，则该属性实际并不存在，如果在后面代码访问该属性，就会出错。<br>带默认参数的<strong>init</strong>(self,…)可以更有效的初始化一个实例，这样可以省去显式传值的麻烦，但是默认参数应当是不变的对象，在使用入列表和字典等可变对象时应时刻保持警惕。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class demo_list:</span><br><span class="line">  def __init__(self, l=[]):</span><br><span class="line">    self.l = l</span><br><span class="line">  def add(self, ele):</span><br><span class="line">    self.l.append(ele)</span><br><span class="line">def appender(ele):</span><br><span class="line">  obj = demo_list()</span><br><span class="line">  obj.add(ele)</span><br><span class="line">  <span class="built_in">print</span>(obj.l)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(5):</span><br><span class="line">    appender(i)</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">[0]</span><br><span class="line">[0, 1]</span><br><span class="line">[0, 1, 2]</span><br><span class="line">[0, 1, 2, 3]</span><br><span class="line">[0, 1, 2, 3, 4]</span><br></pre></td></tr></table></figure>
<p>因为默认参数只会计算一次，不会重复使用，在上面的例子中，虽然使用不同的新建实例，可因为构造器的参数使用的是对列表的引用作为默认参数，所以每次的实例属性都指向该列表所在的空间。   </p>
<p><a href="https://segmentfault.com/a/1190000000743526" target="_blank" rel="noopener">点击查看更多相关资料</a>     </p>
<p>使用内建函数dir()可以显示类和实例属性，实例具有<strong>dict</strong>的特殊属性，该属性由字典组成，包含一个实例的所有属性。  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class ReturnInt:</span><br><span class="line">  def __init__(self):</span><br><span class="line">    pass</span><br><span class="line">ri=ReturnInt()</span><br><span class="line">ri.name=<span class="string">'a'</span></span><br><span class="line">ri.age=10</span><br><span class="line"><span class="built_in">print</span>(ri.__dict__)</span><br><span class="line"><span class="built_in">print</span>(dir(ri))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'a'</span>, <span class="string">'age'</span>: 10&#125;</span><br><span class="line">[<span class="string">'__class__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__init_subclass__'</span>, <span class="string">'__le__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__module__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'__weakref__'</span>, <span class="string">'age'</span>, <span class="string">'name'</span>]</span><br></pre></td></tr></table></figure>

<p>从上面的程序中可以看到除了我们添加的实例属性，实例还有许多其他的属性，这些属性是实例的内建类型属性。</p>
<h1 id="0x4类的方法"><a href="#0x4类的方法" class="headerlink" title="0x4类的方法"></a>0x4类的方法</h1><ul>
<li>类的方法也分为公有方法和私有方法。私有方法不能被模块外的类或方法调用，私有方法也不能被外部的类或函数调用。</li>
<li>C++中的静态方法使用关键字static声明，而Python使用函数staticmethod()或@staticmethod修饰器将普通的函数转换为静态方法。Python的静态方法并没有和类的实例进行名称绑定，要调用除了使用通常的方法，使用类名作为其前缀亦可</li>
</ul>
<p><img src="../../images/python/python/mehtod.jpg" alt="">  </p>
<h1 id="0x5类的对象信息"><a href="#0x5类的对象信息" class="headerlink" title="0x5类的对象信息"></a>0x5类的对象信息</h1><p>type() 可以检查类型。用法超级简单  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="built_in">type</span>(123)</span><br><span class="line">&lt;class <span class="string">'int'</span>&gt;</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">type</span>(<span class="string">'helloworld'</span>)</span><br><span class="line">&lt;class <span class="string">'str'</span>&gt;</span><br></pre></td></tr></table></figure>

<p>对于class的继承关系来说，使用type()就很不方便。我们要判断class的类型，可以使用isinstance()函数。   </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object -&gt; Animal -&gt; Dog -&gt; Husky</span><br></pre></td></tr></table></figure>
<p>那么，isinstance()就可以告诉我们，一个对象是否是某种类型。这玩意儿也是上手熟系列： </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = Animal()</span><br><span class="line">&gt;&gt;&gt; b = Dog()</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; isinstance(c, Animal)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>使用内建函数dir()可以显示类和实例属性，实例具有dict的特殊属性，该属性由字典组成，包含一个实例的所有属性。 </p>
<h1 id="0x6类的特性"><a href="#0x6类的特性" class="headerlink" title="0x6类的特性"></a>0x6类的特性</h1><p><strong>0x6.1封装</strong><br>封装是指将数据与具体操作的实现代码放在某个对象内部，外部无法访问。必须要先调用类的方法才能启动。<br>案例:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class cc:</span><br><span class="line">    ccc = <span class="string">'ccc'</span></span><br><span class="line">    <span class="comment"># cc就是类名 如果想要继承别的类 就class cc(threading) 意思就是从threading继承</span></span><br><span class="line">    def __init__(self,a,b,c):</span><br><span class="line">        self.a=a</span><br><span class="line">        self.b=b</span><br><span class="line">        self.c=c</span><br><span class="line">e=cc(1,2,3)</span><br><span class="line"><span class="built_in">print</span>(e.ccc)</span><br><span class="line"><span class="comment">#类变量，在类里面找到定义的变量。</span></span><br><span class="line"><span class="built_in">print</span>(ccc)</span><br><span class="line"><span class="comment"># 这里会报错，这就是封装。类中的函数同理。</span></span><br></pre></td></tr></table></figure>

<p><strong>0x6.2继承</strong><br>当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。<br>比如，我们已经编写了一个名为Animal的class，有一个run()方法可以直接打印    </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Animal(object):</span><br><span class="line">    def run(self):</span><br><span class="line">        <span class="built_in">print</span> <span class="string">'Animal is running...'</span></span><br></pre></td></tr></table></figure>
<p>当我们需要编写Dog和Cat类时，就可以直接从Animal类继承：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Dog(Animal):</span><br><span class="line">    pass</span><br><span class="line">class Cat(Animal):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<p>继承有什么好处？最大的好处是子类获得了父类的全部功能。由于Animial实现了run()方法，因此，Dog和Cat作为它的子类，什么事也没干，就自动拥有了run()方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dog = Dog()</span><br><span class="line">dog.run()</span><br><span class="line">cat = Cat()</span><br><span class="line">cat.run()</span><br></pre></td></tr></table></figure>
<p>当子类和父类都存在相同的run()方法时，我们说，子类的run()覆盖了父类的run()，在代码运行的时候，总是会调用子类的run()。这样，我们就获得了继承的另一个好处：多态。  </p>
<p><em>多重继承</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">多重继承的语法格式：class_name(parent_class1, parent_class2…)</span><br><span class="line"></span><br><span class="line">其中class_name是类名，parent_class1和parent_class2是父类名。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>多重继承关系中的构造函数： 子类从多个父类派生，而子类又没有自己的构造函数时：<br>（1）按顺序继承，哪个父类在最前面且它又有自己的构造函数，就继承它的构造函数；  （2）如果最前面第一个父类没有构造函数，则继承第2个的构造函数，第2个没有的话，再往后找，以此类推。      </p>
</blockquote>
<p>范例:<br><img src="../../images/python/python/class.png" alt=""></p>
<p><strong>0x6.3多态</strong><br>要理解多态的好处，我们还需要再编写一个函数，这个函数接受一个Animal类型的变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def run_twice(animal):</span><br><span class="line">    animal.run()</span><br><span class="line">    animal.run()</span><br></pre></td></tr></table></figure>
<p>当我们传入Animal的实例时，run_twice()就打印出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">run_twice(Animal())</span><br><span class="line">运行结果：</span><br><span class="line">Animal is running...</span><br><span class="line">Animal is running...</span><br></pre></td></tr></table></figure>
<p>当我们传入Dog的实例时，run_twice()就打印出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">run_twice(Dog())</span><br><span class="line">运行结果：</span><br><span class="line">Dog is running...</span><br><span class="line">Dog is running...</span><br></pre></td></tr></table></figure>
<p>当我们传入Cat的实例时，run_twice()就打印出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">run_twice(Cat())</span><br><span class="line">运行结果：</span><br><span class="line">Cat is running...</span><br><span class="line">Cat is running...</span><br></pre></td></tr></table></figure>
<p>看上去没啥意思，但是仔细想想，现在，如果我们再定义一个Tortoise类型，也从Animal派生：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Tortoise(Animal):</span><br><span class="line">    def run(self):</span><br><span class="line">        <span class="built_in">print</span> <span class="string">'Tortoise is running slowly...'</span></span><br></pre></td></tr></table></figure>
<p>当我们调用run_twice()时，传入Tortoise的实例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">run_twice(Tortoise())</span><br><span class="line">运行结果：</span><br><span class="line">Tortoise is running slowly...</span><br><span class="line">Tortoise is running slowly...</span><br></pre></td></tr></table></figure>
<p>你会发现，新增一个Animal的子类，不必对run_twice()做任何修改，实际上，任何依赖Animal作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态。</p>
<p>多态的好处就是，当我们需要传入Dog、Cat、Tortoise……时，我们只需要接收Animal类型就可以了，因为Dog、Cat、Tortoise……都是Animal类型，然后，按照Animal类型进行操作即可。由于Animal类型有run()方法，因此，传入的任意类型，只要是Animal类或者子类，就会自动调用实际类型的run()方法，这就是多态的意思：</p>
<p>对于一个变量，我们只需要知道它是Animal类型，无需确切地知道它的子类型，就可以放心地调用run()方法，而具体调用的run()方法是作用在Animal、Dog、Cat还是Tortoise对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种Animal的子类时，只要确保run()方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：</p>
<p>对扩展开放：允许新增Animal子类；<br>对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。</p>
<blockquote>
<p>继承可以把父类的所有功能都直接拿过来，这样就不必重零做起，子类只需要新增自己特有的方法，也可以把父类不适合的方法覆盖重写；<br>有了继承，才能有多态。在调用类实例方法的时候，尽量把变量视作父类类型，这样，所有子类类型都可以正常被接收；<br>旧的方式定义Python类允许不从object类继承，但这种编程方式已经严重不推荐使用。任何时候，如果没有合适的类可以继承，就继承自object类。  </p>
</blockquote>
<h1 id="0x7成员保护与访问机制"><a href="#0x7成员保护与访问机制" class="headerlink" title="0x7成员保护与访问机制"></a>0x7成员保护与访问机制</h1><p>有些对象你不想外部访问，即使是通过调用类对象也无法访问<br><strong>0x7.1私有成员</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class obj:</span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        self.name=name</span><br><span class="line">    def pri(self):</span><br><span class="line">        <span class="built_in">print</span> self.name</span><br><span class="line">    __age = 18</span><br><span class="line">    <span class="comment"># 加上双下划线的就是私有变量，只能在类的内部访问，外部无法访问</span></span><br><span class="line">a = obj(<span class="string">'zhao'</span>)</span><br><span class="line">a.pri()</span><br><span class="line">运行结果：</span><br><span class="line"></span><br><span class="line">zhao</span><br></pre></td></tr></table></figure>
<p>如果要在类中调用这个私有成员，可以这么用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">class obj:</span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        self.name=name</span><br><span class="line">    def prin(self):</span><br><span class="line">        <span class="built_in">print</span> self.name</span><br><span class="line">    __age = 18</span><br><span class="line">    <span class="comment"># 加上双下划线的就是私有变量，只能在类的内部访问，外部无法访问</span></span><br><span class="line">    @classmethod</span><br><span class="line">    <span class="comment"># 如果要在类中调用，首先调用类方法</span></span><br><span class="line">    def pri(cls):</span><br><span class="line">        <span class="built_in">print</span> cls.__age</span><br><span class="line">        <span class="comment"># 然后在使用</span></span><br><span class="line">a = obj(<span class="string">'zhao'</span>)</span><br><span class="line">a.prin()</span><br><span class="line">obj.pri()</span><br><span class="line"><span class="comment"># 通过这样直接调用类中的私有变量</span></span><br><span class="line">运行结果：</span><br><span class="line"></span><br><span class="line">zhao</span><br><span class="line">18</span><br><span class="line">``` </span><br><span class="line">不过实际上还是可以直接访问的。  </span><br><span class="line"></span><br><span class="line">**0x7.2使用get-set-del方法操作私有成员** </span><br><span class="line">```bash</span><br><span class="line">class obj:</span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        self.name=name</span><br><span class="line">    def prin(self):</span><br><span class="line">        <span class="built_in">print</span> self.name</span><br><span class="line">    __age = 18</span><br><span class="line">    <span class="comment"># 加上双下划线的就是私有变量，只能在类的内部访问，外部无法访问</span></span><br><span class="line">    @classmethod</span><br><span class="line">    <span class="comment"># 如果要在类中调用，首先调用类方法</span></span><br><span class="line">    def pri(cls):</span><br><span class="line">        <span class="built_in">print</span> cls.__age</span><br><span class="line">        <span class="comment"># 然后在使用</span></span><br><span class="line">    @classmethod</span><br><span class="line">    def set_age(cls,value):</span><br><span class="line">        cls.__age = value</span><br><span class="line">        <span class="built_in">return</span> cls.__age</span><br><span class="line">        <span class="comment"># 这个用法就是改变__age的值</span></span><br><span class="line">    @classmethod</span><br><span class="line">    def get_age(cls):</span><br><span class="line">        <span class="built_in">return</span> cls.__age</span><br><span class="line">        <span class="comment"># 这个用法就是直接返回__age的值</span></span><br><span class="line">    @classmethod</span><br><span class="line">    def del_age(cls):</span><br><span class="line">        del cls.__age</span><br><span class="line">        <span class="comment"># 这个用法就是直接删除__age的值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> obj.get_age()</span><br><span class="line"><span class="comment"># 这里是直接调用出__age的值  返回值18</span></span><br><span class="line"><span class="built_in">print</span> obj.set_age(20)</span><br><span class="line"><span class="comment"># 这里是直接改变__age的值  返回值20</span></span><br><span class="line">obj.del_age()</span><br><span class="line"><span class="comment"># 这里是直接删除__age的值</span></span><br></pre></td></tr></table></figure>
<p>思考： 既然是私有变量，不让外部访问，为何有要在后面调用又改变呢？因为可以对私有变量进行额外的检测，处理，加工等等。比如判断value的值，使用isinstance然后做if-else判断。</p>
<p>使用私有变量可以对内部变量进行保护，外部无法改变，但是可以对它进行检测处理。</p>
<p>这里引申一下私有成员的保护机制，使用<strong>age对私有变量其实就是—&gt;obj._obj</strong>age的样子进行保护，说白了你直接使用obj._obj__age就可以直接调用内部私有变量age了。</p>
<h1 id="0x8Propety装饰器"><a href="#0x8Propety装饰器" class="headerlink" title="0x8Propety装饰器"></a>0x8Propety装饰器</h1><p> 把类的方法伪装成属性调用的方式，就是把类里面的一个函数，变成一个属性一样的东西~<br>一开始调用类的方法要使用圆括号，现在变成了属性进行读取设置存储。<br>举个例子来说明：   </p>
<p><strong>常用调用方法</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class obj:</span><br><span class="line">    def __init__(self,name,age):</span><br><span class="line">        self.__name=name</span><br><span class="line">        self.__age=age</span><br><span class="line">        <span class="comment"># 讲这些设置成私有变量</span></span><br><span class="line">    def get_age(self):</span><br><span class="line">        <span class="built_in">return</span> self.__age</span><br><span class="line">    def set_age(self,value):</span><br><span class="line">        <span class="keyword">if</span> isinstance(value,int):</span><br><span class="line">            self.__age=value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            raise ValueError(<span class="string">'非整数类型'</span>)</span><br><span class="line">    def del_age(self):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'delete over'</span>)</span><br><span class="line">a = obj(<span class="string">'langzi'</span>,18)</span><br><span class="line"><span class="built_in">print</span>(a.get_age())</span><br><span class="line">a.set_age(20)</span><br><span class="line"><span class="built_in">print</span>(a.get_age())</span><br></pre></td></tr></table></figure>
<p><strong>使用装饰器</strong>  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class obj:</span><br><span class="line">    def __init__(self,name,age):</span><br><span class="line">        self.__name=name</span><br><span class="line">        self.__age=age</span><br><span class="line">        <span class="comment"># 把这些设置成私有变量</span></span><br><span class="line">    @property</span><br><span class="line">    def age(self):</span><br><span class="line">        <span class="built_in">return</span> self.__age</span><br><span class="line">    @age.setter</span><br><span class="line">    def age(self,value):</span><br><span class="line">        <span class="keyword">if</span> isinstance(value,int):</span><br><span class="line">            self.__age=value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            raise ValueError(<span class="string">'非整数类型'</span>)</span><br><span class="line">    @age.deleter</span><br><span class="line">    def age(self):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'delete over'</span>)</span><br><span class="line">a = obj(<span class="string">'langzi'</span>,18)</span><br><span class="line"><span class="comment"># 使用这些装饰器，可以使用类与对象的方法直接调用</span></span><br><span class="line"><span class="built_in">print</span>(a.age)</span><br><span class="line"><span class="comment"># 这里就是直接调用返回age的值</span></span><br><span class="line">a.age=20</span><br><span class="line"><span class="comment"># 这里就是直接使用setter把值转换</span></span><br><span class="line"><span class="built_in">print</span>(a.age)</span><br><span class="line">del a.age</span><br><span class="line"><span class="comment"># 删除age</span></span><br></pre></td></tr></table></figure>
<p>当然这种调用方法有些麻烦，每次都是一个一个去实例类与对象，有个更加简单直观的方法。</p>
<p>更加减半的使用property()函数<br>除了使用装饰器的方式将一个方法伪装成属性外，Python内置的builtins模块中的property()函数，为我们提供了第二种设置类属性的手段。  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class People:</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        self.__name = name</span><br><span class="line">        self.__age = age</span><br><span class="line"></span><br><span class="line">    def get_age(self):</span><br><span class="line">        <span class="built_in">return</span> self.__age</span><br><span class="line"></span><br><span class="line">    def set_age(self, age):</span><br><span class="line">        <span class="keyword">if</span> isinstance(age, int):</span><br><span class="line">            self.__age = age</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            raise ValueError</span><br><span class="line"></span><br><span class="line">    def del_age(self):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"删除年龄数据！"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 核心在这句</span></span><br><span class="line">    age = property(get_age, set_age, del_age, <span class="string">"年龄"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = People(<span class="string">"jack"</span>, 18)</span><br><span class="line"><span class="built_in">print</span>(obj.age)</span><br><span class="line">obj.age = 19</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"obj.age:  "</span>, obj.age)</span><br><span class="line">del obj.age</span><br></pre></td></tr></table></figure>
<h1 id="0x9-init-self-…-‘构造器’方法"><a href="#0x9-init-self-…-‘构造器’方法" class="headerlink" title="0x9 __init__(self,…)‘构造器’方法"></a>0x9 <code>__init__</code>(self,…)‘构造器’方法</h1><p><strong>init</strong>(self,…)方法实际上并不是一个构造器，其并没有创造一个新的对象，Python通过函数操作符()创建对象。在解释器创建一个实例后，最先调用<strong>init</strong>(self,…)方法，定义额外的行为，如果没有定义或者覆盖<strong>init</strong>(self,…)方法，对实例不会施加任何特别的操作，直接返回它的对象，实例化过程完毕。函数的返回值应当为None,如果返回来任意对象，会导致TypeError异常。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class ReturnInt:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        <span class="built_in">return</span> 1</span><br><span class="line"></span><br><span class="line">ri=ReturnInt()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"E:\code\python27\test12121.py"</span>, line 6, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    ri=ReturnInt()</span><br><span class="line">TypeError: __init__() should <span class="built_in">return</span> None, not <span class="string">'int'</span></span><br></pre></td></tr></table></figure>
<p>重写子类的<strong>init</strong>(self,…)方法不会自动调用基类的<strong>init</strong>(self,…)。所以如果需要在子类中调用基类的<strong>init</strong>(self,…)，需要明确指出。  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class P():</span><br><span class="line">	def __init__(self):</span><br><span class="line">		self.age=20</span><br><span class="line">		self.name=<span class="string">'test'</span></span><br><span class="line"></span><br><span class="line">class C(P):</span><br><span class="line">	def __init__(self):</span><br><span class="line">		P.__init__(self)</span><br><span class="line">c=C()</span><br><span class="line"><span class="built_in">print</span>(c.age)</span><br><span class="line"><span class="built_in">print</span>(c.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">20</span><br><span class="line"><span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>我们可以使用super()函数更方便高效的重写上面的代码：<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class C(P):</span><br><span class="line"> def __init__(self):</span><br><span class="line">   super(C,self).__init__()</span><br></pre></td></tr></table></figure><br> 不需要提供明确的父类，super()函数会帮助我们找到相应的父类，然后方便调用相关的属性。   </p>
<h1 id="0x10使用枚举类"><a href="#0x10使用枚举类" class="headerlink" title="0x10使用枚举类"></a>0x10使用枚举类</h1><p>当我们需要定义常量时，一个办法是用大写变量通过整数来定义，例如月份：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JAN = 1</span><br><span class="line">FEB = 2</span><br><span class="line">MAR = 3</span><br><span class="line">...</span><br><span class="line">NOV = 11</span><br><span class="line">DEC = 12</span><br></pre></td></tr></table></figure>
<p>好处是简单，缺点是类型是int，并且仍然是变量。</p>
<p>更好的方法是为这样的枚举类型定义一个class类型，然后，每个常量都是class的一个唯一实例。Python提供了Enum类来实现这个功能：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from enum import Enum</span><br><span class="line"></span><br><span class="line">Month = Enum(<span class="string">'Month'</span>, (</span><br><span class="line">    <span class="string">'Jan'</span>, <span class="string">'Feb'</span>, <span class="string">'Mar'</span>, <span class="string">'Apr'</span>,</span><br><span class="line">    <span class="string">'May'</span>, <span class="string">'Jun'</span>, <span class="string">'Jul'</span>, <span class="string">'Aug'</span>,</span><br><span class="line">    <span class="string">'Sep'</span>, <span class="string">'Oct'</span>, <span class="string">'Nov'</span>, <span class="string">'Dec'</span></span><br><span class="line">))</span><br><span class="line"><span class="keyword">for</span> name, member <span class="keyword">in</span> Month.__members__.items():</span><br><span class="line">	<span class="built_in">print</span>(name, <span class="string">'=&gt;'</span>, member, <span class="string">','</span>, member.value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">Jan =&gt; Month.Jan , 1</span><br><span class="line">Feb =&gt; Month.Feb , 2</span><br><span class="line">Mar =&gt; Month.Mar , 3</span><br><span class="line">Apr =&gt; Month.Apr , 4</span><br><span class="line">May =&gt; Month.May , 5</span><br><span class="line">Jun =&gt; Month.Jun , 6</span><br><span class="line">Jul =&gt; Month.Jul , 7</span><br><span class="line">Aug =&gt; Month.Aug , 8</span><br><span class="line">Sep =&gt; Month.Sep , 9</span><br><span class="line">Oct =&gt; Month.Oct , 10</span><br><span class="line">Nov =&gt; Month.Nov , 11</span><br><span class="line">Dec =&gt; Month.Dec , 12</span><br></pre></td></tr></table></figure>
<p>这样我们就获得了Month类型的枚举类，可以直接使用Month.Jan来引用一个常量，或者枚举它的所有成员<br>value属性则是自动赋给成员的int常量，默认从1开始计数。</p>
<p>如果需要更精确地控制枚举类型，可以从Enum派生出自定义类：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from enum import Enum, unique</span><br><span class="line"></span><br><span class="line"><span class="comment"># @unique装饰器可以帮助我们检查保证没有重复值。</span></span><br><span class="line">@unique</span><br><span class="line">class Weekday(Enum):</span><br><span class="line">    Sun = 0 <span class="comment"># Sun的value被设定为0</span></span><br><span class="line">    Mon = 1</span><br><span class="line">    Tue = 2</span><br><span class="line">    Wed = 3</span><br><span class="line">    Thu = 4</span><br><span class="line">    Fri = 5</span><br><span class="line">    Sat = 6</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, member <span class="keyword">in</span> Weekday.__members__.items():</span><br><span class="line">	<span class="built_in">print</span>(name, <span class="string">'=&gt;'</span>, member,member.value)</span><br></pre></td></tr></table></figure>
<h1 id="0x11使用元类"><a href="#0x11使用元类" class="headerlink" title="0x11使用元类"></a>0x11使用元类</h1><p>动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是运行时动态创建的。</p>
<p>比方说我们要定义一个Hello的class，就写一个hello.py模块：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Hello(object):</span><br><span class="line">    def hello(self, name=<span class="string">'world'</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'Hello, %s.'</span> % name)</span><br></pre></td></tr></table></figure>
<p>当Python解释器载入hello模块时，就会依次执行该模块的所有语句，执行结果就是动态创建出一个Hello的class对象，测试如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from hello import Hello</span><br><span class="line">&gt;&gt;&gt; h = Hello()</span><br><span class="line">&gt;&gt;&gt; h.hello()</span><br><span class="line">Hello, world.</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(<span class="built_in">type</span>(Hello))</span><br><span class="line">&lt;class <span class="string">'type'</span>&gt;</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(<span class="built_in">type</span>(h))</span><br><span class="line">&lt;class <span class="string">'hello.Hello'</span>&gt;</span><br></pre></td></tr></table></figure>
<p>type()函数可以查看一个类型或变量的类型，Hello是一个class，它的类型就是type，而h是一个实例，它的类型就是class Hello。</p>
<p>class的定义是运行时动态创建的，而创建class的方法就是使用type()函数。</p>
<p>type()函数既可以返回一个对象的类型，又可以创建出新的类型，比如，我们可以通过type()函数创建出Hello类，而无需通过class Hello(object)…的定义：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def fn(self, name=<span class="string">'world'</span>): <span class="comment"># 先定义函数</span></span><br><span class="line">...     <span class="built_in">print</span>(<span class="string">'Hello, %s.'</span> % name)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; Hello = <span class="built_in">type</span>(<span class="string">'Hello'</span>, (object,), dict(hello=fn)) <span class="comment"># 创建Hello class</span></span><br><span class="line">&gt;&gt;&gt; h = Hello()</span><br><span class="line">&gt;&gt;&gt; h.hello()</span><br><span class="line">Hello, world.</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(<span class="built_in">type</span>(Hello))</span><br><span class="line">&lt;class <span class="string">'type'</span>&gt;</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(<span class="built_in">type</span>(h))</span><br><span class="line">&lt;class <span class="string">'__main__.Hello'</span>&gt;</span><br></pre></td></tr></table></figure>
<p>要创建一个class对象，type()函数依次传入3个参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span>(‘Hello’, (object,), dict(hello=fn))</span><br></pre></td></tr></table></figure>
<ul>
<li>class名称；   </li>
<li>继承父类的集合，注意Python支持多重继承，别忘了tuple的单元素写法；   </li>
<li>class的方法名称与函数绑定，这里我们把函数fn绑定到方法名hello上。    </li>
</ul>
<p>通过type()函数创建的类和直接写class是完全一样的，因为Python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用type()函数创建出class。    </p>
<p>正常情况下，我们都用class Xxx…来定义类，但是，type()函数也允许我们动态创建出类来，也就是说，动态语言本身支持运行期动态创建类，这和静态语言有非常大的不同，要在静态语言运行期创建类，必须构造源代码字符串再调用编译器，或者借助一些工具生成字节码实现，本质上都是动态编译，会非常复杂。</p>
<p>除了使用type()动态创建类以外，要控制类的创建行为，还可以使用metaclass。</p>
<p>metaclass，直译为 元类 ，简单的解释就是：</p>
<p>当我们定义了类以后，就可以根据这个类创建出实例，所以：先定义类，然后创建实例。</p>
<p>但是如果我们想创建出类呢？那就必须根据metaclass创建出类，所以：先定义metaclass，然后创建类。</p>
<p>连接起来就是：先定义metaclass，就可以创建类，最后创建实例。</p>
<p>所以，metaclass允许你创建类或者修改类。换句话说，你可以把类看成是metaclass创建出来的“实例”。</p>
<p>来个例子感受一下，按照默认习惯，metaclass的类名总是以Metaclass结尾，以便清楚地表示这是一个metaclass：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># metaclass是类的模板，所以必须从`type`类型派生：</span></span><br><span class="line">class ListMetaclass(<span class="built_in">type</span>):</span><br><span class="line">    def __new__(cls, name, bases, attrs):</span><br><span class="line">        attrs[<span class="string">'add'</span>] = lambda self, value: self.append(value)</span><br><span class="line">        <span class="built_in">return</span> type.__new__(cls, name, bases, attrs)</span><br></pre></td></tr></table></figure>
<p>有了ListMetaclass，我们在定义类的时候还要指示使用ListMetaclass来定制类，传入关键字参数metaclass：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class MyList(list, metaclass=ListMetaclass):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<p>当我们传入关键字参数metaclass时，魔术就生效了，它指示Python解释器在创建MyList时，要通过ListMetaclass.<strong>new</strong>()来创建，在此，我们可以修改类的定义，比如，加上新的方法，然后，返回修改后的定义。</p>
<p><strong>new</strong>()方法接收到的参数依次是：</p>
<p>当前准备创建的类的对象；   </p>
<ul>
<li>类的名字；   </li>
<li>类继承的父类集合；  </li>
<li>类的方法集合。   </li>
</ul>
<h1 id="0x13抽象类"><a href="#0x13抽象类" class="headerlink" title="0x13抽象类"></a>0x13抽象类</h1><p>抽象类中只能有抽象方法，子类继承抽象类时，不能通过实例化使用其抽象方法，必须实现该方法。  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from abc import ABCMeta,abstractmethod <span class="comment">#</span></span><br><span class="line">class Fruit(metaclass=ABCMeta):</span><br><span class="line">	@abstractmethod</span><br><span class="line">	def grow(self):</span><br><span class="line">		pass</span><br><span class="line">class Apple(Fruit):</span><br><span class="line">	def grow(self):</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">'Apple growing'</span>)</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">	apple=Apple()</span><br><span class="line">	apple.grow()</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">Apple growing</span><br></pre></td></tr></table></figure>
<h1 id="0x14类的内置方法"><a href="#0x14类的内置方法" class="headerlink" title="0x14类的内置方法"></a>0x14类的内置方法</h1><p>在上面有提到除了init之外还有iter,reverse的方法，这里就详细说下除了init初始化还有哪些别的方法。  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">__init__ :      构造函数，在生成对象时调用</span><br><span class="line">__del__ :       析构函数，释放对象时使用</span><br><span class="line">__repr__ :      打印，转换</span><br><span class="line">__setitem__ :   按照索引赋值</span><br><span class="line">__getitem__:    按照索引获取值</span><br><span class="line">__len__:        获得长度</span><br><span class="line">__cmp__:        比较运算</span><br><span class="line">__call__:       调用</span><br><span class="line">__add__:        加运算</span><br><span class="line">__sub__:        减运算</span><br><span class="line">__mul__:        乘运算</span><br><span class="line">__div__:        除运算</span><br><span class="line">__mod__:        求余运算</span><br><span class="line">__pow__:        幂</span><br></pre></td></tr></table></figure>
<p>具体使用：  </p>
<h2 id="doc"><a href="#doc" class="headerlink" title="doc"></a>doc</h2><p>说明性文档和信息。Python自建，无需自定义。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    <span class="string">""</span><span class="string">" 描述类信息，可被自动收集 "</span><span class="string">""</span></span><br><span class="line">    def func(self):</span><br><span class="line">        pass</span><br><span class="line"><span class="comment"># 打印类的说明文档 </span></span><br><span class="line"><span class="built_in">print</span>(Foo.__doc__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output: </span><br><span class="line">描述类信息，可被自动收集</span><br></pre></td></tr></table></figure>

<h2 id="init"><a href="#init" class="headerlink" title="init()"></a>init()</h2><p>实例化方法，通过类创建实例时，自动触发执行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = 18</span><br><span class="line">obj = Foo(jack<span class="string">') # 自动执行类中的 __init__ 方法</span></span><br></pre></td></tr></table></figure>
<h2 id="module-和-class"><a href="#module-和-class" class="headerlink" title="module__ 和 __class"></a>module__ 和 __class</h2><p>module 表示当前操作的对象在属于哪个模块。<br>class 表示当前操作的对象属于哪个类。<br>这两者也是Python内建，无需自定义。   </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    pass</span><br><span class="line">obj = Foo()</span><br><span class="line"><span class="built_in">print</span>(obj.__module__)</span><br><span class="line"><span class="built_in">print</span>(obj.__class__)</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">__main__</span><br><span class="line">&lt;class <span class="string">'__main__.Foo'</span>&gt;</span><br></pre></td></tr></table></figure>
<h2 id="del"><a href="#del" class="headerlink" title="del()"></a>del()</h2><p>析构方法，当对象在内存中被释放时，自动触发此方法。</p>
<p>注：此方法一般无须自定义，因为Python自带内存分配和释放机制，除非你需要在释放的时候指定做一些动作。析构函数的调用是由解释器在进行垃圾回收时自动触发执行的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    def __del__(self):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"我被回收了！"</span>)</span><br><span class="line"></span><br><span class="line">obj = Foo()</span><br><span class="line">del obj</span><br><span class="line"><span class="comment"># call()</span></span><br></pre></td></tr></table></figure>
<h2 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h2><p>如果为一个类编写了该方法，那么在该类的实例后面加括号，可会调用这个方法。</p>
<p>注：构造方法的执行是由类加括号执行的，即：对象 = 类名()，而对于call() 方法，是由对象后加括号触发的，即：对象() 或者 类()()</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line">    def __call__(self, *args, **kwargs):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'__call__'</span>)</span><br><span class="line">obj = Foo()     <span class="comment"># 执行 __init__</span></span><br><span class="line">obj()       <span class="comment"># 执行 __call__</span></span><br></pre></td></tr></table></figure>
<p>可以用Python内建的callable()函数进行测试，判断一个对象是否可以被执行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callable(Student())</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">True</span><br></pre></td></tr></table></figure>
<h2 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h2><p>列出类或对象中的所有成员！非常重要和有用的一个属性，Python自建，无需用户自己定义</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Province:</span><br><span class="line">    country = <span class="string">'China'</span></span><br><span class="line">    def __init__(self, name, count):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.count = count</span><br><span class="line">    def func(self, *args, **kwargs):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'func'</span>)</span><br><span class="line"><span class="comment"># 获取类的成员</span></span><br><span class="line"><span class="built_in">print</span>(Province.__dict__)</span><br><span class="line"><span class="comment"># 获取 对象obj1 的成员</span></span><br><span class="line">obj1 = Province(<span class="string">'HeBei'</span>,10000)</span><br><span class="line"><span class="built_in">print</span>(obj1.__dict__)</span><br><span class="line"><span class="comment"># 获取 对象obj2 的成员</span></span><br><span class="line">obj2 = Province(<span class="string">'HeNan'</span>, 3888)</span><br><span class="line"><span class="built_in">print</span>(obj2.__dict__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">&#123;<span class="string">'__module__'</span>: <span class="string">'__main__'</span>, <span class="string">'country'</span>: <span class="string">'China'</span>, <span class="string">'__init__'</span>: &lt;<span class="keyword">function</span> Province.__init__ at 0x000001B139C6A048&gt;, <span class="string">'func'</span>: &lt;<span class="keyword">function</span> Province.func at 0x000001B139C6A1E0&gt;, <span class="string">'__dict__'</span>: &lt;attribute <span class="string">'__dict__'</span> of <span class="string">'Province'</span> objects&gt;, <span class="string">'__weakref__'</span>: &lt;attribute <span class="string">'__weakref__'</span> of <span class="string">'Province'</span> objects&gt;, <span class="string">'__doc__'</span>: None&#125;</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'HeBei'</span>, <span class="string">'count'</span>: 10000&#125;</span><br></pre></td></tr></table></figure>

<h2 id="str"><a href="#str" class="headerlink" title="str()"></a>str()</h2><p>如果一个类中定义了str()方法，那么在打印对象时，默认输出该方法的返回值。这也是一个非常重要的方法，需要用户自己定义。　</p>
<p>下面的类，没有定义str()方法，打印结果是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    pass</span><br><span class="line">obj = Foo()</span><br><span class="line"><span class="built_in">print</span>(obj)</span><br><span class="line"><span class="comment">#定义了__str__()方法后，打印结果是：'jack'。</span></span><br><span class="line">class Foo:</span><br><span class="line">    def __str__(self):</span><br><span class="line">        <span class="built_in">return</span> <span class="string">'jack'</span></span><br><span class="line">obj = Foo()</span><br><span class="line"><span class="built_in">print</span>(obj)</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">&lt;__main__.Foo object at 0x00000267B25CC780&gt;</span><br><span class="line">jack</span><br></pre></td></tr></table></figure>
<h2 id="getitem-、setitem-、-delitem"><a href="#getitem-、setitem-、-delitem" class="headerlink" title="getitem__()、setitem()、__delitem()"></a>getitem__()、<em>setitem</em>()、__delitem()</h2><p>取值、赋值、删除这“三剑客”的套路，在Python中，我们已经见过很多次了，比如前面的@property装饰器。</p>
<p>Python中，标识符后面加圆括号，通常代表执行或调用方法的意思。而在标识符后面加中括号[]，通常代表取值的意思。Python设计了getitem()、setitem()、delitem()这三个特殊成员，用于执行与中括号有关的动作。它们分别表示取值、赋值、删除数据。</p>
<p>也就是如下的操作：</p>
<p>a = 标识符[]　： 　　执行<strong>getitem</strong>方法<br>标识符[] = a  ： 　　执行<strong>setitem</strong>方法<br>del 标识符[]　： 　　执行<strong>delitem</strong>方法<br>如果有一个类同时定义了这三个魔法方法，那么这个类的实例的行为看起来就像一个字典一样，如下例所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    def __getitem__(self, key):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'__getitem__'</span>,key)</span><br><span class="line">    def __setitem__(self, key, value):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'__setitem__'</span>,key,value)</span><br><span class="line">    def __delitem__(self, key):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'__delitem__'</span>,key)</span><br><span class="line">obj = Foo()</span><br><span class="line">result = obj[<span class="string">'k1'</span>]      <span class="comment"># 自动触发执行 __getitem__</span></span><br><span class="line">obj[<span class="string">'k2'</span>] = <span class="string">'jack'</span>      <span class="comment"># 自动触发执行 __setitem__</span></span><br><span class="line">del obj[<span class="string">'k1'</span>]             <span class="comment"># 自动触发执行 __delitem__</span></span><br></pre></td></tr></table></figure>
<h2 id="iter"><a href="#iter" class="headerlink" title="iter()"></a>iter()</h2><p>这是迭代器方法！列表、字典、元组之所以可以进行for循环，是因为其内部定义了 iter()这个方法。如果用户想让自定义的类的对象可以被迭代，那么就需要在类中定义这个方法，并且让该方法的返回值是一个可迭代的对象。当在代码中利用for循环遍历对象时，就会调用类的这个iter()方法。</p>
<p>普通的类：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    pass</span><br><span class="line">obj = Foo()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> obj:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="comment"># 报错：TypeError: 'Foo' object is not iterable</span></span><br><span class="line"><span class="comment"># 原因是Foo对象不可迭代</span></span><br></pre></td></tr></table></figure>
<p>添加一个<strong>iter</strong>()，但什么都不返回：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    def __iter__(self):</span><br><span class="line">        pass</span><br><span class="line">obj = Foo()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> obj:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="comment"># 报错：TypeError: iter() returned non-iterator of type 'NoneType'</span></span><br><span class="line"><span class="comment">#原因是 __iter__方法没有返回一个可迭代的对象</span></span><br></pre></td></tr></table></figure>
<p>返回一个个迭代对象：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    def __init__(self, sq):</span><br><span class="line">        self.sq = sq</span><br><span class="line">    def __iter__(self):</span><br><span class="line">        <span class="built_in">return</span> iter(self.sq)</span><br><span class="line">obj = Foo([11,22,33,44])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> obj:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>
<p>最好的方法是使用生成器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line">    def __iter__(self):</span><br><span class="line">        yield 1</span><br><span class="line">        yield 2</span><br><span class="line">        yield 3</span><br><span class="line">obj = Foo()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> obj:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>
<h2 id="len"><a href="#len" class="headerlink" title="len()"></a>len()</h2><p>在Python中，如果你调用内置的len()函数试图获取一个对象的长度，在后台，其实是去调用该对象的len()方法，所以，下面的代码是等价的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">len(<span class="string">'ABC'</span>)</span><br><span class="line">3</span><br><span class="line"><span class="string">'ABC'</span>.__len__()</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>Python的list、dict、str等内置数据类型都实现了该方法，但是你自定义的类要实现len方法需要好好设计。</p>
<h2 id="repr"><a href="#repr" class="headerlink" title="repr()"></a>repr()</h2><p>这个方法的作用和str()很像，两者的区别是str()返回用户看到的字符串，而repr()返回程序开发者看到的字符串，也就是说，repr()是为调试服务的。通常两者代码一样。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Foo:</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line">    def __str__(self):</span><br><span class="line">        <span class="built_in">return</span> <span class="string">"this is %s"</span> % self.name</span><br><span class="line">    __repr__ = __str__</span><br></pre></td></tr></table></figure>
<h2 id="add-加运算-sub-减运算-mul-乘运算-div-除运算-mod-求余运算-pow-幂运算"><a href="#add-加运算-sub-减运算-mul-乘运算-div-除运算-mod-求余运算-pow-幂运算" class="headerlink" title="add__: 加运算 sub: 减运算 mul: 乘运算 div: 除运算 mod: 求余运算 __pow: 幂运算"></a>add__: 加运算 <em>sub</em>: 减运算 <em>mul</em>: 乘运算 <em>div</em>: 除运算 <em>mod</em>: 求余运算 __pow: 幂运算</h2><p>这些都是算术运算方法，需要你自己为类设计具体运算代码。有些Python内置数据类型，比如int就带有这些方法。Python支持运算符的重载，也就是重写。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Vector:</span><br><span class="line">   def __init__(self, a, b):</span><br><span class="line">      self.a = a</span><br><span class="line">      self.b = b</span><br><span class="line">   def __str__(self):</span><br><span class="line">      <span class="built_in">return</span> <span class="string">'Vector (%d, %d)'</span> % (self.a, self.b)</span><br><span class="line">   def __add__(self,other):</span><br><span class="line">      <span class="built_in">return</span> Vector(self.a + other.a, self.b + other.b)</span><br><span class="line">v1 = Vector(2,10)</span><br><span class="line">v2 = Vector(5,-2)</span><br><span class="line"><span class="built_in">print</span> (v1 + v2)</span><br></pre></td></tr></table></figure>
<h2 id="author作者信息"><a href="#author作者信息" class="headerlink" title="author作者信息"></a>author作者信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__author__ = <span class="string">"Jack"</span></span><br><span class="line">def show():</span><br><span class="line">    <span class="built_in">print</span>(__author__)</span><br><span class="line">show()</span><br></pre></td></tr></table></figure>
<h2 id="slots"><a href="#slots" class="headerlink" title="slots"></a>slots</h2><p>Python作为一种动态语言，可以在类定义完成和实例化后，给类或者对象继续添加随意个数或者任意类型的变量或方法，这是动态语言的特性。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def print_doc(self):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"haha"</span>)</span><br><span class="line"></span><br><span class="line">class Foo:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">obj1 = Foo()</span><br><span class="line">obj2 = Foo()</span><br><span class="line"><span class="comment"># 动态添加实例变量</span></span><br><span class="line">obj1.name = <span class="string">"jack"</span></span><br><span class="line">obj2.age = 18</span><br><span class="line"><span class="comment"># 动态的给类添加实例方法</span></span><br><span class="line">Foo.show = print_doc</span><br><span class="line">obj1.show()</span><br><span class="line">obj2.show()</span><br></pre></td></tr></table></figure>
<p>但是！如果我想限制实例可以添加的变量怎么办？可以使slots限制实例的变量，比如，只允许Foo的实例添加name和age属性。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def print_doc(self):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"haha"</span>)</span><br><span class="line">class Foo:</span><br><span class="line">    __slots__ = (<span class="string">"name"</span>, <span class="string">"age"</span>)</span><br><span class="line">    pass</span><br><span class="line">obj1 = Foo()</span><br><span class="line">obj2 = Foo()</span><br><span class="line"><span class="comment"># 动态添加实例变量</span></span><br><span class="line">obj1.name = <span class="string">"jack"</span></span><br><span class="line">obj2.age = 18</span><br><span class="line">obj1.sex = <span class="string">"male"</span>       <span class="comment"># 这一句会弹出错误</span></span><br><span class="line"><span class="comment"># 但是无法限制给类添加方法</span></span><br><span class="line">Foo.show = print_doc</span><br><span class="line">obj1.show()</span><br><span class="line">obj2.show()</span><br><span class="line">由于<span class="string">'sex'</span>不在__slots__的列表中，所以不能绑定sex属性，试图绑定sex将得到AttributeError的错误。</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"F:/Python/pycharm/201705/1.py"</span>, line 14, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    obj1.sex = <span class="string">"male"</span></span><br><span class="line">AttributeError: <span class="string">'Foo'</span> object has no attribute <span class="string">'sex'</span></span><br></pre></td></tr></table></figure>
<p>需要提醒的是，slots定义的属性仅对当前类的实例起作用，对继承了它的子类是不起作用的。想想也是这个道理，如果你继承一个父类，却莫名其妙发现有些变量无法定义，那不是大问题么？如果非要子类也被限制，除非在子类中也定义slots，这样，子类实例允许定义的属性就是自身的slots加上父类的slots。<br>参考文章:<a href="https://mp.weixin.qq.com/s/jEKvWwu5MwCqLbIxmAP4iQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/jEKvWwu5MwCqLbIxmAP4iQ</a><br>Python 面向对象编程容易忽视的知识点:<a href="https://www.jianshu.com/p/505117d9a693" target="_blank" rel="noopener">https://www.jianshu.com/p/505117d9a693</a><br>陷阱！python参数默认值<a href="https://segmentfault.com/a/1190000000743526" target="_blank" rel="noopener">https://segmentfault.com/a/1190000000743526</a><br>一篇文章搞懂python面向对象编程:<a href="http://yangcongchufang.com/%E9%AB%98%E7%BA%A7python%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/python-object-class.html#dir1" target="_blank" rel="noopener">http://yangcongchufang.com/%E9%AB%98%E7%BA%A7python%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/python-object-class.html#dir1</a><br>Python面向对象编程<a href="https://zhuanlan.zhihu.com/p/34305989" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34305989</a></p>
</div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">ye1s</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="https://blog.cfyqy.com/article/761e66f3.html">https://blog.cfyqy.com/article/761e66f3.html</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.cfyqy.com">ye1s</a>！</span></div></div><div class="post-copyright" id="comments-container"><script src="/js/comments/gitment.js"></script></div><script>let arr = location.href.split('/#more')[0].split('/');
let title = arr[arr.length - 1];
if (title === '') {
    title = arr[arr.length - 2]
}
var flag = false;
var gitFun = function () {
    try {
        var gitmentObj = window.GLOBAL_CONFIG.gitment;
        var gitment = new Gitment({
            id: decodeURI(title), // 可选。默认为 location.href
            owner: gitmentObj.owner,
            repo: gitmentObj.repo,
            oauth: {
                client_id: gitmentObj.client_id,
                client_secret: gitmentObj.client_secret
            },
        });
        gitment.render('comments-container');
        flag = true;
    } catch (e) {
        flag = false;
    }
}
var setIn = setInterval(() => {
    if (!flag) {
        gitFun();
    } else {
        clearInterval(setIn);
    }
}, 200);</script></article><div id="pagination"><div class="prev-post pull-left"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/article/cf5605e2.html"><i class="fas fa-angle-left">&nbsp;</i><span>python的元编程</span></a></div><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/article/2133739f.html"><span>python的IO编程</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2017 ～ 2021 By ye1s</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/daovoice.js"></script><!--script(src=url)--><div class="search-dialog"><div id="algolia-search-title">Algolia</div><div class="search-close-button"><i class="fa fa-times"></i></div><!--div#current-refined-values--><!--div#clear-all--><div id="search-box"></div><!--div#refinement-list--><hr><div id="hits"></div><div id="algolia-pagination"></div></div><div class="search-mask"></div><script src="/js/search/algolia.js"></script></body></html>