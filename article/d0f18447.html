<!DOCTYPE html><html><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="数据结构整理"><meta name="keywords" content="c语言,数据结构"><meta name="author" content="ye1s,undefined"><meta name="copyright" content="ye1s"><title>数据结构整理【ye1s】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch-theme-algolia.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4"></script><!-- link(rel="dns-prefetch" href="https://cdn.jsdelivr.net")--><!-- link(rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css")--><!-- script(src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer)--><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"LKL6Q0GQJM","apiKey":"03829f64e2f5c11e4a5e2b8e51e24eb9","indexName":"blog","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  gitment: {"owner":"ye1sec","repo":"comments","client_id":"d5ece338867af32b6dfa","client_secret":"2caf36bbd47977524017f95105315fc9e65f0577"},
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="ye1s" type="application/atom+xml">
</head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#思维导图"><span class="toc-number">1.</span> <span class="toc-text">思维导图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x1-概述"><span class="toc-number">1.1.</span> <span class="toc-text">0x1 概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x2线性表"><span class="toc-number">1.2.</span> <span class="toc-text">0x2线性表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x3栈"><span class="toc-number">1.3.</span> <span class="toc-text">0x3栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x4队列"><span class="toc-number">1.4.</span> <span class="toc-text">0x4队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x5递归"><span class="toc-number">1.5.</span> <span class="toc-text">0x5递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x6树和二叉树"><span class="toc-number">1.6.</span> <span class="toc-text">0x6树和二叉树</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#代码实现"><span class="toc-number">2.</span> <span class="toc-text">代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#线性表"><span class="toc-number">2.1.</span> <span class="toc-text">线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0x1-顺序表"><span class="toc-number">2.1.1.</span> <span class="toc-text">0x1 顺序表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x2-单链表"><span class="toc-number">2.1.2.</span> <span class="toc-text">0x2 单链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x3-双链表"><span class="toc-number">2.1.3.</span> <span class="toc-text">0x3 双链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x4有序表"><span class="toc-number">2.1.4.</span> <span class="toc-text">0x4有序表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#栈"><span class="toc-number">2.2.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0x1顺序栈"><span class="toc-number">2.2.1.</span> <span class="toc-text">0x1顺序栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x2共享栈"><span class="toc-number">2.2.2.</span> <span class="toc-text">0x2共享栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x3-链栈"><span class="toc-number">2.2.3.</span> <span class="toc-text">0x3 链栈</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#队列"><span class="toc-number">2.3.</span> <span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0x1-顺序队列"><span class="toc-number">2.3.1.</span> <span class="toc-text">0x1 顺序队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x2-循环队列"><span class="toc-number">2.3.2.</span> <span class="toc-text">0x2 循环队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x3-链表队列"><span class="toc-number">2.3.3.</span> <span class="toc-text">0x3 链表队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#串"><span class="toc-number">2.4.</span> <span class="toc-text">串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#树"><span class="toc-number">2.5.</span> <span class="toc-text">树</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">ye1s</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/ye1sec" target="_blank">GitHub<i class="icon-dot bg-color5"></i></a><a class="links-button button-hover" href="mailto:431774437@qq.com" target="_blank">E-Mail<i class="icon-dot bg-color1"></i></a><a class="links-button button-hover" href="tencent://message/?uin=431774437&amp;Site=&amp;Menu=yes" target="_blank">QQ<i class="icon-dot bg-color4"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">173</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">151</span></a><a class="author-info-articles-categories article-meta" href="/categories"><span class="pull-top">分类</span><span class="pull-bottom">12</span></a></div><div class="friend-link"><a class="friend-link-text" href="http://www.m00nback.xyz/" target="_blank">MoonBack</a><a class="friend-link-text" target="_blank">待定</a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="search social-icon"><i class="fas fa-search"></i><span> 搜索</span></a><a class="title-name" href="/">ye1s</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">数据结构整理</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2019-04-08 | 更新于 2020-04-13</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/">编程算法</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/c%E8%AF%AD%E8%A8%80/">c语言</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div></div></div><div class="main-content"><p>已经一年半没有碰过c语言了，c语言编程这块，有点荒废。最近有点想要去学习一下linux的内核，挺高深的，感觉自己有点儿自不量力。不过，趁现在还空闲，就折腾一下吧，准备将数据结构重新再学习一下，将知识点整理成思维导图，让自己好记一些。</p>
<a id="more"></a>
<h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><h2 id="0x1-概述"><a href="#0x1-概述" class="headerlink" title="0x1 概述"></a>0x1 概述</h2><p><img src="../../images/dataStructure/1.png" alt=""></p>
<h2 id="0x2线性表"><a href="#0x2线性表" class="headerlink" title="0x2线性表"></a>0x2线性表</h2><p><img src="../../images/dataStructure/2.png" alt=""></p>
<h2 id="0x3栈"><a href="#0x3栈" class="headerlink" title="0x3栈"></a>0x3栈</h2><p><img src="../../images/dataStructure/3.png" alt=""></p>
<h2 id="0x4队列"><a href="#0x4队列" class="headerlink" title="0x4队列"></a>0x4队列</h2><p><img src="../../images/dataStructure/4.png" alt=""></p>
<h2 id="0x5递归"><a href="#0x5递归" class="headerlink" title="0x5递归"></a>0x5递归</h2><p><img src="../../images/dataStructure/5.png" alt=""></p>
<h2 id="0x6树和二叉树"><a href="#0x6树和二叉树" class="headerlink" title="0x6树和二叉树"></a>0x6树和二叉树</h2><p><img src="../../images/dataStructure/6.png" alt=""></p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="0x1-顺序表"><a href="#0x1-顺序表" class="headerlink" title="0x1 顺序表"></a>0x1 顺序表</h3><p>0x1.1基本操作  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;stdlib.h&gt; </span></span><br><span class="line"><span class="comment">#include&lt;malloc.h&gt;</span></span><br><span class="line"><span class="comment">#define MaxSize 50</span></span><br><span class="line">typedef int ElemType; </span><br><span class="line">//ElemType类型实际上是int</span><br><span class="line">typedef struct&#123;</span><br><span class="line">    ElemType data[MaxSize];  //存放顺序表中的元素</span><br><span class="line">    int length;              //顺序表的长度</span><br><span class="line">&#125;SqList;             //SequenceList,顺序表</span><br><span class="line">//建议： ;</span><br><span class="line">typedef SqList *List; </span><br><span class="line">void InitList(SqList *&amp;L)   //初始化</span><br><span class="line">&#123;    L=(SqList *)malloc(sizeof(SqList));	//分配存放线性表的空间</span><br><span class="line">     L-&gt;length=0;</span><br><span class="line">&#125; </span><br><span class="line">void DestroyList(SqList *&amp;L)//销毁线性表</span><br><span class="line">  &#123;</span><br><span class="line">     free(L);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">bool ListEmpty(SqList *L)//判断是否为空</span><br><span class="line">  &#123;   <span class="built_in">return</span>(L-&gt;length==0); &#125;</span><br><span class="line">  </span><br><span class="line">int ListLength(SqList *L) //求线性表的长度</span><br><span class="line">  &#123;   <span class="built_in">return</span>(L-&gt;length); &#125;</span><br><span class="line">  </span><br><span class="line">void DispList( SqList *L)//输出线性表</span><br><span class="line">  &#123;	int i;</span><br><span class="line">	<span class="keyword">if</span> (ListEmpty(L)) <span class="built_in">return</span>;</span><br><span class="line">	<span class="keyword">for</span> (i=0;i&lt;L-&gt;length;i++)</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"%d"</span>,L-&gt;data[i]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  &#125; </span><br><span class="line"> </span><br><span class="line">bool GetElem(SqList *L,int i,ElemType &amp;e)//获取第i个元素 </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (i&lt;1 || i&gt;L-&gt;length)</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    e=L-&gt;data[i-1]; </span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int LocateElem(SqList *L, ElemType e)//按元素查找</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(int i=0; i&lt;L-&gt;length;i++)</span><br><span class="line">        <span class="keyword">if</span>(L-&gt;data[i]==e)</span><br><span class="line">            <span class="built_in">return</span> i+1;       //返回元素的逻辑位序</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">bool ListInsert(SqList *&amp;L,int i,ElemType e)//插入元素e</span><br><span class="line">&#123;  	int j;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;1 || i&gt;L-&gt;length+1)</span><br><span class="line"> 		<span class="built_in">return</span> <span class="literal">false</span>;	//参数错误时返回<span class="literal">false</span></span><br><span class="line">    i--;	//将顺序表逻辑序号转化为物理序号</span><br><span class="line">    <span class="keyword">for</span>(j=L-&gt;length;j&gt;i;j--)	//将data[i..n]元素后移一个位置</span><br><span class="line">    	L-&gt;data[j]=L-&gt;data[j-1];</span><br><span class="line"> 	L-&gt;data[i]=e;			//插入元素e</span><br><span class="line">    L-&gt;length++;			//顺序表长度增1</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span>;			//成功插入返回<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool ListDelete(SqList *&amp;L,int i,ElemType &amp;e)//删除元素e</span><br><span class="line">&#123;  </span><br><span class="line">   <span class="keyword">if</span> (i&lt;1 || i&gt;L-&gt;length) //删除位置不合法</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">   i--;		    //将顺序表逻辑序号转化为物理序号</span><br><span class="line">   e=L-&gt;data[i];</span><br><span class="line">   <span class="keyword">for</span> (int j=i;j&lt;L-&gt;length-1;j++)         </span><br><span class="line">      L-&gt;data[j]=L-&gt;data[j+1];</span><br><span class="line">   L-&gt;length--;	    //顺序表长度减1</span><br><span class="line">   <span class="built_in">return</span> <span class="literal">true</span>;			</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void CreateList(SqList *&amp;L,int n)//创建 顺序表 </span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    L-&gt;length=n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入线性表la的元素共%d个\n"</span>,n);</span><br><span class="line">	<span class="keyword">for</span>(i=0;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">	  scanf(<span class="string">"%d"</span>,&amp;L-&gt;data[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;   List la;</span><br><span class="line">    int i,j;</span><br><span class="line">    int e,m;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"初始化线性表\n"</span>);</span><br><span class="line">	InitList(la);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"请输入线性表的长度:"</span>);</span><br><span class="line">	scanf(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">    CreateList(la,m); </span><br><span class="line">	DispList(la);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"请输入你要查找的元素位置:"</span>); </span><br><span class="line">	scanf(<span class="string">"%d"</span>,&amp;j);</span><br><span class="line">	GetElem(la,j,e);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"第%d处的元素为%d\n"</span>,j,e);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"输入你要查找的元素:"</span>);</span><br><span class="line">	scanf(<span class="string">"%d"</span>,&amp;e);</span><br><span class="line">	j=LocateElem(la,e);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d元素在%d处\n"</span>,e,j); </span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"请输入要插入的元素以及元素位置:"</span>);</span><br><span class="line">	scanf(<span class="string">"%d%d"</span>,&amp;e,&amp;j);</span><br><span class="line">	ListInsert(la,j,e);</span><br><span class="line">	</span><br><span class="line">	DispList(la);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"请输入要删除的元素位置:"</span>) ;</span><br><span class="line">	scanf(<span class="string">"%d"</span>,&amp;j);</span><br><span class="line">	ListDelete(la,j,e);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"删除%d元素成功!"</span>,e);</span><br><span class="line">	system(<span class="string">"pause"</span>); </span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>0x1.2 题型<br>0x1.2.1 已知长度为n的线性表A采用顺序存储结构，编写一个时间复杂度为O(n)、空间复杂度为O(1)的算法，该算法删除元素值在[x,y]  之间的所有元素<br>解法一:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void delnode(SqList *&amp;L,ElemType x，ElemType y)</span><br><span class="line">&#123;  int k=0,i;		 //k记录值不在[x,y]元素个数</span><br><span class="line">   <span class="keyword">for</span> (i=0;i&lt;L-&gt;length;i++)</span><br><span class="line">	<span class="keyword">if</span> (!(L-&gt;data[i]&gt;=x &amp;&amp; L-&gt;data[i]&lt;=y ))</span><br><span class="line">               //若当前元素不在[x,y],将其插入L中</span><br><span class="line">	&#123; </span><br><span class="line">         L-&gt;data[k]=L-&gt;data[i];</span><br><span class="line">	   k++;		 //不在[x,y]的元素增1</span><br><span class="line">	&#125;</span><br><span class="line">   L-&gt;length-=k;		 //顺序表L的长度等于k</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解法二</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void delnode1(SqList *&amp;L,ElemType x，ElemType y)</span><br><span class="line">&#123;  </span><br><span class="line">   int i,k;</span><br><span class="line">    <span class="keyword">for</span>(i=0;i&lt;L-&gt;Lenth;i++)</span><br><span class="line">	&#123;   </span><br><span class="line">        <span class="keyword">if</span>(x&lt;=L-&gt;data[i] &amp;&amp; L-&gt;data[i]&lt;=y)	k++；</span><br><span class="line">	    <span class="keyword">else</span>  L-&gt;data[i-k]=L-&gt;data[i];</span><br><span class="line">	&#125;</span><br><span class="line">	L-&gt;Lenth-=k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>0x1.2.2 有一个顺序表L，元素类型为整型。设计一算法，以第一个元素为轴，所有小于等于它的元素移到该元素前面，所有大于它的元素移动到该元素后面<br>解法一</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void move1(SqList *&amp;L)</span><br><span class="line">&#123;  int i=0,j=L-&gt;length-1;</span><br><span class="line">   ElemType pivot=L-&gt;data[0];	//以data[0]为基准</span><br><span class="line">   ElemType tmp;</span><br><span class="line">   <span class="keyword">while</span> (i&lt;j)	//从区间两端交替向中间扫描,直至i=j为止</span><br><span class="line">   &#123;	<span class="keyword">while</span> (i&lt;j &amp;&amp; L-&gt;data[j]&gt;pivot)</span><br><span class="line">	   j--;	//从右向左扫描,找一个小于等于pivot的元素</span><br><span class="line">      <span class="keyword">while</span> (i&lt;j &amp;&amp; L-&gt;data[i]&lt;=pivot)</span><br><span class="line">	   i++;	//从左向右扫描,找一个大于pivot的元素</span><br><span class="line">	<span class="keyword">if</span> (i&lt;j)</span><br><span class="line">	&#123;   tmp=L-&gt;data[i];//将L-&gt;data[i]和L-&gt;data[j]交换</span><br><span class="line">	    L-&gt;data[i]=L-&gt;data[j];</span><br><span class="line">	    L-&gt;data[j]=tmp;</span><br><span class="line">	&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   tmp=L-&gt;data[0];  //将L-&gt;data[0]和L-&gt;data[j]进行交换</span><br><span class="line">   L-&gt;data[0]=L-&gt;data[j];</span><br><span class="line">   L-&gt;data[j]=tmp;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"i=%d\n"</span>,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解法二</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void move2(SqList *&amp;L)</span><br><span class="line">&#123;  int i=0,j=L-&gt;length-1;</span><br><span class="line">   ElemType pivot=L-&gt;data[0];	//以data[0]为基准</span><br><span class="line">   <span class="keyword">while</span> (i&lt;j) //从顺序表两端交替向中间扫描,直至i=j为止</span><br><span class="line">   &#123;  <span class="keyword">while</span> (j&gt;i &amp;&amp; L-&gt;data[j]&gt;pivot)</span><br><span class="line">	  j--;   //从右向左扫描,找一个小于等于pivot的data[j]</span><br><span class="line">	L-&gt;data[i]=L-&gt;data[j];	//将其放入data[i]处</span><br><span class="line">	i++;</span><br><span class="line">	<span class="keyword">while</span> (i&lt;j &amp;&amp; L-&gt;data[i]&lt;=pivot)</span><br><span class="line">	  i++;  //从左向右扫描,找一个大于pivot的记录data[i]</span><br><span class="line">	L-&gt;data[j]=L-&gt;data[i];	//将其放入data[j]处</span><br><span class="line">	j--;</span><br><span class="line">   &#125;</span><br><span class="line">   L-&gt;data[i]=pivot;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"i=%d\n"</span>,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="0x2-单链表"><a href="#0x2-单链表" class="headerlink" title="0x2 单链表"></a>0x2 单链表</h3><p>0x2.1基本操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef int ElemType;</span><br><span class="line">typedef struct LNode  		//定义单链表结点类型</span><br><span class="line">&#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">	struct LNode *next;		//指向后继结点</span><br><span class="line">&#125; LNode,*LinkList;</span><br><span class="line">void InitList(LinkList &amp;L);</span><br><span class="line">void CreateListF(LinkList &amp;L,int n); </span><br><span class="line">void CreateListR(LinkList &amp;L,int n);</span><br><span class="line">bool ListEmpty(LinkList L);</span><br><span class="line">void DispList(LinkList L);</span><br><span class="line">void DestroyList(LinkList &amp;L);</span><br><span class="line">bool ListInsert(LinkList &amp;L,int i,ElemType e);</span><br><span class="line">bool ListDelete_L(LinkList &amp;L,int i,ElemType &amp;e);</span><br><span class="line">void sort(LinkList &amp;L);</span><br><span class="line">void split(LinkList &amp;L,LinkList &amp;L1,LinkList &amp;L2);</span><br><span class="line">int Find(LinkList L, int m );</span><br><span class="line">bool GetElem(LinkList L,int i,ElemType &amp;e);</span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	LinkList L,L1,L2;</span><br><span class="line">	int n,m;</span><br><span class="line">	ElemType e;</span><br><span class="line">	cout&lt;&lt;<span class="string">"请输入要创建链表元素个数:"</span>&lt;&lt;endl; </span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	cout&lt;&lt;<span class="string">"请输入"</span>&lt;&lt;n&lt;&lt;<span class="string">"个链表元素。"</span>&lt;&lt;endl; </span><br><span class="line">	CreateListR(L,n);</span><br><span class="line">	cout&lt;&lt;<span class="string">"请输入要查找的元素位置:"</span>&lt;&lt;endl; </span><br><span class="line">	cin&gt;&gt;m;</span><br><span class="line">    GetElem(L,m,e);</span><br><span class="line">    cout&lt;&lt;<span class="string">"该元素为:"</span>&lt;&lt;e&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">"请输入要插入的元素以及元素位置:"</span>&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;e&gt;&gt;m;</span><br><span class="line">    ListInsert(L,m,e); </span><br><span class="line">    DispList(L);</span><br><span class="line">    cout&lt;&lt;endl; </span><br><span class="line">    cout&lt;&lt;<span class="string">"请输入要删除的元素位置:"</span>&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    ListDelete_L(L,m,e);</span><br><span class="line">    DispList(L);</span><br><span class="line">	DestroyList(L);</span><br><span class="line">	//DispList(L);</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">void InitList(LinkList &amp;L)</span><br><span class="line">&#123;</span><br><span class="line">	L=new LNode; 	//创建头结点</span><br><span class="line">	L-&gt;next=NULL;</span><br><span class="line">&#125;</span><br><span class="line">void CreateListF(LinkList &amp;L,int n)&#123;</span><br><span class="line">	int i;</span><br><span class="line">	LinkList s;</span><br><span class="line">	L=new LNode;</span><br><span class="line">	L-&gt;next=NULL; </span><br><span class="line">	<span class="keyword">for</span>(i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		s=new LNode;</span><br><span class="line">		cin&gt;&gt;s-&gt;data;</span><br><span class="line">		s-&gt;next=L-&gt;next;</span><br><span class="line">		L-&gt;next=s;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void CreateListR(LinkList &amp;L,int n)&#123;</span><br><span class="line">	int i;</span><br><span class="line">	LinkList s,r;</span><br><span class="line">	L=new LNode;</span><br><span class="line">	L-&gt;next=NULL;</span><br><span class="line">	r=L; </span><br><span class="line">	<span class="keyword">for</span>(i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		s=new LNode;</span><br><span class="line">		cin&gt;&gt;s-&gt;data;</span><br><span class="line">		r-&gt;next=s;</span><br><span class="line">		r=s;</span><br><span class="line">	&#125;</span><br><span class="line">	r-&gt;next=NULL;</span><br><span class="line">&#125;</span><br><span class="line">void DispList(LinkList L)&#123;</span><br><span class="line">	LinkList p;</span><br><span class="line">	int flag=1;</span><br><span class="line">	p=L-&gt;next;</span><br><span class="line">	<span class="keyword">while</span>(p)&#123;</span><br><span class="line">		<span class="keyword">if</span>(flag) &#123;</span><br><span class="line">			cout&lt;&lt;p-&gt;data;flag=0;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			cout&lt;&lt;<span class="string">" "</span>&lt;&lt;p-&gt;data;	</span><br><span class="line">		&#125;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void DestroyList(LinkList &amp;L)&#123;</span><br><span class="line">	LinkList p=L;</span><br><span class="line">	<span class="keyword">while</span>(L)&#123;</span><br><span class="line">	    p=L;</span><br><span class="line">		L=L-&gt;next;	</span><br><span class="line">		delete p;	</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">bool ListInsert(LinkList &amp;L,int i,ElemType e)//在第i处插入e元素 </span><br><span class="line">&#123;</span><br><span class="line">  int j=0;</span><br><span class="line">  LinkList p=L,s;</span><br><span class="line">  <span class="keyword">while</span>(p&amp;&amp;j&lt;i-1)&#123;</span><br><span class="line">  	p=p-&gt;next;j++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(p==NULL) <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">  s=new LNode;</span><br><span class="line">  s-&gt;data=e;</span><br><span class="line">  s-&gt;next=p-&gt;next;</span><br><span class="line">  p-&gt;next=s;	</span><br><span class="line">  <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">bool ListDelete_L(LinkList &amp;L,int i,ElemType &amp;e)</span><br><span class="line">&#123;</span><br><span class="line">  int j=0;</span><br><span class="line">  LinkList p=L,s,q;</span><br><span class="line">  <span class="keyword">while</span>(p&amp;&amp;j&lt;i-1)&#123;</span><br><span class="line">  	p=p-&gt;next;j++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(p==NULL) <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">	q=p-&gt;next;</span><br><span class="line">	e=q-&gt;data;</span><br><span class="line">	p-&gt;next=q-&gt;next;</span><br><span class="line">	delete q;</span><br><span class="line">	<span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">void split(LinkList &amp;L,LinkList &amp;L1,LinkList &amp;L2)&#123;</span><br><span class="line">	LinkList p=L-&gt;next,r,q;//r为L1尾指针，q为L2指针 </span><br><span class="line">	L1=L;r=L1;</span><br><span class="line">	L1-&gt;next=NULL; //重构L1 </span><br><span class="line">	L2=new LNode;//初始化L2 </span><br><span class="line">	L2-&gt;next=NULL;</span><br><span class="line">	<span class="keyword">while</span>(p)&#123;  </span><br><span class="line">     r-&gt;next=p;//尾插插入L1  </span><br><span class="line">     r=p;  //修改尾指针 </span><br><span class="line">	 p=p-&gt;next;		</span><br><span class="line">	 q=p;//b节点</span><br><span class="line">	 <span class="keyword">if</span>(p)&#123;</span><br><span class="line">	 	p=p-&gt;next;  //保存后继节点 </span><br><span class="line">	    q-&gt;next=L2-&gt;next; </span><br><span class="line">	    L2-&gt;next=q;//头结点插入s </span><br><span class="line">	 &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	r-&gt;next=NULL; //L1尾部指针为空 </span><br><span class="line">&#125;</span><br><span class="line">void sort(LinkList &amp;L)&#123;</span><br><span class="line">	LinkList p,pre,q;</span><br><span class="line">	p=L-&gt;next-&gt;next;</span><br><span class="line">	L-&gt;next-&gt;next=NULL;</span><br><span class="line">	<span class="keyword">while</span>(p)&#123;</span><br><span class="line">	    q=p-&gt;next; //p指针保存下，后面要插入链表中，后续关系会变更。 </span><br><span class="line">		pre=L;</span><br><span class="line">		<span class="keyword">while</span>(pre-&gt;next&amp;&amp;pre-&gt;next-&gt;data&lt;p-&gt;data) pre=pre-&gt;next;</span><br><span class="line">		p-&gt;next=pre-&gt;next;//将*pre之后插入*p</span><br><span class="line">	    pre-&gt;next=p; </span><br><span class="line">		p=q;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool GetElem(LinkList L,int i,ElemType &amp;e)</span><br><span class="line">&#123;  int j=0;</span><br><span class="line">   LinkList p=L;	//p指向头节点,j置为0(即头节点的序号为0)</span><br><span class="line">   <span class="keyword">while</span> (j&lt;i &amp;&amp; p!=NULL)	//找第i个节点</span><br><span class="line">   &#123;	j++;</span><br><span class="line">	p=p-&gt;next;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (p==NULL)	//不存在第i个数据节点,返回<span class="literal">false</span></span><br><span class="line">	<span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">else</span>		//存在第i个数据节点,返回<span class="literal">true</span></span><br><span class="line">   &#123;  e=p-&gt;data;</span><br><span class="line">	<span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>0x2.2例题<br>有一个带头节点的单链表L={a1,b1,a2,b2,…,an,bn}，设计一个算法将其拆分成两个带头节点的单链表L1和L2  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void split(LinkList &amp;L,LinkList &amp;L1,LinkList &amp;L2)&#123;</span><br><span class="line">	LinkList p=L-&gt;next,r,q;//r为L1尾指针，q为L2指针 </span><br><span class="line">	L1=L;r=L1;</span><br><span class="line">	L1-&gt;next=NULL; //重构L1 </span><br><span class="line">	L2=new LNode;//初始化L2 </span><br><span class="line">	L2-&gt;next=NULL;</span><br><span class="line">	<span class="keyword">while</span>(p)&#123;  </span><br><span class="line">     r-&gt;next=p;//尾插插入L1  </span><br><span class="line">     r=p;  //修改尾指针 </span><br><span class="line">	 p=p-&gt;next;		</span><br><span class="line">	 q=p;//b节点</span><br><span class="line">	 <span class="keyword">if</span>(p)&#123;</span><br><span class="line">	 	p=p-&gt;next;  //保存后继节点 </span><br><span class="line">	    q-&gt;next=L2-&gt;next; </span><br><span class="line">	    L2-&gt;next=q;//头结点插入s </span><br><span class="line">	 &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	r-&gt;next=NULL; //L1尾部指针为空 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一个带头节点的单链表L（至少有一个数据节点），设计一个算法使其元素递增有序排列。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void sort(LinkList &amp;L)</span><br><span class="line">&#123;  LinkList p,pre,q;</span><br><span class="line">   p=L-&gt;next-&gt;next;	//p指向L的第2个数据节点</span><br><span class="line">   L-&gt;next-&gt;next=NULL;	//构造只含一个数据节点的有序表</span><br><span class="line">   <span class="keyword">while</span> (p!=NULL)</span><br><span class="line">   &#123;	q=p-&gt;next;		//q保存p节点后继节点的指针</span><br><span class="line">	pre=L;  //从有序表开头进行比较,pre指向插入p的前驱节点</span><br><span class="line">	<span class="keyword">while</span> (pre-&gt;next!=NULL &amp;&amp; pre-&gt;next-&gt;data&lt;p-&gt;data)</span><br><span class="line">	   pre=pre-&gt;next;	//在有序表中找插入*p的前驱节点*pre</span><br><span class="line">	p-&gt;next=pre-&gt;next;//将pre之后插入p</span><br><span class="line">	pre-&gt;next=p;</span><br><span class="line">	p=q;			//扫描原单链表余下的节点</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="0x3-双链表"><a href="#0x3-双链表" class="headerlink" title="0x3 双链表"></a>0x3 双链表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">typedef struct DNode       //声明双链表节点类型</span><br><span class="line">&#123;  	ElemType data;</span><br><span class="line">   	struct DNode *prior;    //指向前驱节点</span><br><span class="line">	struct DNode *next;     //指向后继节点</span><br><span class="line"> &#125;DLinkList;</span><br><span class="line"></span><br><span class="line">//在*p结点之后插入结点*s</span><br><span class="line">s-&gt;next = p-&gt;next</span><br><span class="line">p-&gt;next-&gt;prior = s</span><br><span class="line">s-&gt;prior = p</span><br><span class="line">p-&gt;next = s</span><br><span class="line"></span><br><span class="line">//删除*p结点之后的一个结点 </span><br><span class="line">p-&gt;next-&gt;next-&gt;prior = p</span><br><span class="line">p-&gt;next = p-&gt;next-&gt;next</span><br><span class="line"></span><br><span class="line">//头插法 </span><br><span class="line">void CreateListF(DLinkNode *&amp;L，ElemType a[]，int n)</span><br><span class="line">&#123;　 DLinkNode *s; int i;</span><br><span class="line">       L=(DLinkNode *)malloc(sizeof(DLinkNode));	//创建头结点</span><br><span class="line">       L-&gt;prior=L-&gt;next=NULL;	//前后指针域置为NULL</span><br><span class="line">       <span class="keyword">for</span> (i=0;i&lt;n;i++)		//循环建立数据结点</span><br><span class="line">       &#123;	s=(DLinkNode *)malloc(sizeof(DLinkNode));</span><br><span class="line">	s-&gt;data=a[i];		//创建数据结点*s</span><br><span class="line">	s-&gt;next=L-&gt;next;	//将*s插入到头结点之后</span><br><span class="line">	<span class="keyword">if</span> (L-&gt;next!=NULL)      	//若L存在数据结点，修改前驱指针</span><br><span class="line">  	       L-&gt;next-&gt;prior=s;</span><br><span class="line">	L-&gt;next=s;</span><br><span class="line">	s-&gt;prior=L;</span><br><span class="line"> &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">//尾插法 </span><br><span class="line">void CreateListR(DLinkNode *&amp;L，ElemType a[]，int n)</span><br><span class="line">&#123;     DLinkNode *s，*r;</span><br><span class="line">       int i;</span><br><span class="line">       L=(DLinkNode *)malloc(sizeof(DLinkNode));    //创建头结点</span><br><span class="line">       L-&gt;prior=L-&gt;next=NULL;	//前后指针域置为NULL</span><br><span class="line">       r=L;			//r始终指向尾结点，开始时指向头结点</span><br><span class="line">       <span class="keyword">for</span> (i=0;i&lt;n;i++)		//循环建立数据结点</span><br><span class="line">       &#123;      s=(DLinkNode *)malloc(sizeof(DLinkNode));</span><br><span class="line">	s-&gt;data=a[i];		//创建数据结点*s</span><br><span class="line">	r-&gt;next=s;     </span><br><span class="line">              s-&gt;prior=r;	//将*s插入*r之后</span><br><span class="line">	r=s;			//r指向尾结点</span><br><span class="line">      &#125;</span><br><span class="line">      r-&gt;next=NULL;		//尾结点next域置为NULL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="0x4有序表"><a href="#0x4有序表" class="headerlink" title="0x4有序表"></a>0x4有序表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//为假设有序表元素是以递增方式排列了简单 </span><br><span class="line">//有序顺序表</span><br><span class="line">void ListInsert(SqList *&amp;L，ElemType e)</span><br><span class="line">&#123;     int i=0，j;</span><br><span class="line">      <span class="keyword">while</span> (i&lt;L-&gt;length &amp;&amp; L-&gt;data[i]&lt;e)</span><br><span class="line">	i++;			//查找值为e的元素</span><br><span class="line">      <span class="keyword">for</span> (j=ListLength(L);j&gt;i;j--)	//将data[i..n]后移一个位置</span><br><span class="line">	L-&gt;data[j]=L-&gt;data[j-1]; </span><br><span class="line">      L-&gt;data[i]=e;</span><br><span class="line">      L-&gt;length++;		//有序顺序表长度增1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//有序单链表的ListInsert() </span><br><span class="line">void ListInsert(LinkNode *&amp;L，ElemType e)</span><br><span class="line">&#123;     LinkNode *pre=L，*p;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (pre-&gt;next!=NULL &amp;&amp; pre-&gt;next-&gt;data&lt;e)</span><br><span class="line">	pre=pre-&gt;next; 	//查找插入结点的前驱结点*pre</span><br><span class="line"></span><br><span class="line">      p=new LinkNode;</span><br><span class="line">      p-&gt;data=e;		//创建存放e的数据结点*p</span><br><span class="line">      p-&gt;next=pre-&gt;next;	//在*pre结点之后插入*p结点</span><br><span class="line">      pre-&gt;next=p;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//采用顺序表存放有序表时，二路归并算法</span><br><span class="line">void UnionList(SqList *LA，SqList *LB，SqList *&amp;LC)</span><br><span class="line">&#123;     int i=0，j=0，k=0;//i、j分别为LA、LB的下标，k为LC中元素个数</span><br><span class="line">      LC=new SqList; 		//建立有序顺序表LC</span><br><span class="line">      <span class="keyword">while</span> (i&lt;LA-&gt;length &amp;&amp; j&lt;LB-&gt;length)</span><br><span class="line">      &#123;	<span class="keyword">if</span> (LA-&gt;data[i]&lt;LB-&gt;data[j])</span><br><span class="line">	&#123;     LC-&gt;data[k]=LA-&gt;data[i];</span><br><span class="line">	       i++;k++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>	//LA-&gt;data[i]&gt;LB-&gt;data[j]</span><br><span class="line">	&#123;     LC-&gt;data[k]=LB-&gt;data[j];</span><br><span class="line">	      j++;k++;</span><br><span class="line">	&#125;</span><br><span class="line">   &#125;  </span><br><span class="line">   </span><br><span class="line">      <span class="keyword">while</span> (i&lt;LA-&gt;length)		//LA尚未扫描完，将其余元素插入LC中</span><br><span class="line">     &#123;	LC-&gt;data[k]=LA-&gt;data[i];</span><br><span class="line">	i++;k++;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">while</span> (j&lt;LB-&gt;length)		//LB尚未扫描完，将其余元素插入LC中</span><br><span class="line">     &#123;	LC-&gt;data[k]=LB-&gt;data[j];</span><br><span class="line">	j++;k++;</span><br><span class="line">     &#125;</span><br><span class="line">     LC-&gt;length=k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="0x1顺序栈"><a href="#0x1顺序栈" class="headerlink" title="0x1顺序栈"></a>0x1顺序栈</h3><p>0x1基本操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;malloc.h&gt;</span></span><br><span class="line"><span class="comment">#define MaxSize 100</span></span><br><span class="line">typedef char ElemType;</span><br><span class="line">typedef struct </span><br><span class="line">&#123;	</span><br><span class="line">	ElemType data[MaxSize];</span><br><span class="line">	int top;				//栈指针</span><br><span class="line">&#125; SqStack;					//顺序栈类型定义</span><br><span class="line">void InitStack(SqStack *&amp;s)</span><br><span class="line">&#123;</span><br><span class="line">	s=(SqStack *)malloc(sizeof(SqStack));</span><br><span class="line">	s-&gt;top=-1;</span><br><span class="line">&#125; </span><br><span class="line">void DestroyStack(SqStack *&amp;s)</span><br><span class="line">&#123;</span><br><span class="line">	free(s);</span><br><span class="line">&#125;</span><br><span class="line">bool StackEmpty(SqStack *s)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">return</span>(s-&gt;top==-1);</span><br><span class="line">&#125;</span><br><span class="line">bool Push(SqStack *&amp;s,ElemType e)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (s-&gt;top==MaxSize-1)    //栈满的情况，即栈上溢出</span><br><span class="line">		<span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">	s-&gt;top++;</span><br><span class="line">	s-&gt;data[s-&gt;top]=e;</span><br><span class="line">	<span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">bool Pop(SqStack *&amp;s,ElemType &amp;e)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (s-&gt;top==-1)		//栈为空的情况，即栈下溢出</span><br><span class="line">		<span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">	e=s-&gt;data[s-&gt;top];</span><br><span class="line">	s-&gt;top--;</span><br><span class="line">	<span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; </span><br><span class="line">bool GetTop(SqStack *s,ElemType &amp;e)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (s-&gt;top==-1) 		//栈为空的情况，即栈下溢出</span><br><span class="line">		<span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">	e=s-&gt;data[s-&gt;top];</span><br><span class="line">	<span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">bool symmetry(ElemType str[])</span><br><span class="line">&#123;  int i;  ElemType e;</span><br><span class="line">   SqStack *st;</span><br><span class="line">   InitStack(st);			//初始化栈</span><br><span class="line">   <span class="keyword">for</span> (i=0;str[i]!=<span class="string">'\0'</span>;i++)	//将串所有元素进栈</span><br><span class="line">	Push(st,str[i]);		//元素进栈</span><br><span class="line">   <span class="keyword">for</span> (i=0;str[i]!=<span class="string">'\0'</span>;i++)</span><br><span class="line">   &#123;	Pop(st,e);		  //退栈元素e</span><br><span class="line">	<span class="keyword">if</span> (str[i]!=e)	  //若e与当前串元素不同则不是对称串</span><br><span class="line">	&#123;  DestroyStack(st);//销毁栈</span><br><span class="line">	   <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   DestroyStack(st);	  //销毁栈</span><br><span class="line">   <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	char str[10]=<span class="string">"heterh"</span>;</span><br><span class="line">	<span class="keyword">if</span>(symmetry(str))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"true"</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line"> 		<span class="built_in">printf</span>(<span class="string">"false"</span>);</span><br><span class="line">		</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题型<br>0x1<br> 编写一个算法利用顺序栈判断一个字符串是否是对称串。所谓对称串是指从左向右读和从右向左读的序列相同</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bool symmetry(ElemType str[])</span><br><span class="line">&#123;  int i;  ElemType e;</span><br><span class="line">   SqStack *st;</span><br><span class="line">   InitStack(st);			//初始化栈</span><br><span class="line">   <span class="keyword">for</span> (i=0;str[i]!=<span class="string">'\0'</span>;i++)	//将串所有元素进栈</span><br><span class="line">	Push(st,str[i]);		//元素进栈</span><br><span class="line">   <span class="keyword">for</span> (i=0;str[i]!=<span class="string">'\0'</span>;i++)</span><br><span class="line">   &#123;	Pop(st,e);		  //退栈元素e</span><br><span class="line">	<span class="keyword">if</span> (str[i]!=e)	  //若e与当前串元素不同则不是对称串</span><br><span class="line">	&#123;  DestroyStack(st);//销毁栈</span><br><span class="line">	   <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   DestroyStack(st);	  //销毁栈</span><br><span class="line">   <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>0x2中缀表达式转换成后缀表达式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">char trans(char *exp, char postexp[])		</span><br><span class="line">&#123;   char e;  </span><br><span class="line">    SqStack *Optr;		//定义运算符栈指针</span><br><span class="line">    InitStack(Optr);		//初始化运算符栈</span><br><span class="line">    int i=0;			//i作为postexp的下标</span><br><span class="line">	<span class="keyword">while</span> (*exp!=<span class="string">'\0'</span>)		//exp表达式未扫描完时循环</span><br><span class="line">	&#123; 	switch(*exp)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'('</span>:			//判定为左括号</span><br><span class="line">				Push(Optr,<span class="string">'('</span>); //左括号进栈</span><br><span class="line">				exp++;		//继续扫描其他字符</span><br><span class="line">				<span class="built_in">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">')'</span>:		    //判定为右括号</span><br><span class="line">				Pop(Optr,e);	    //出栈元素e</span><br><span class="line">				<span class="keyword">while</span> (e!=<span class="string">'('</span>)	    //不为<span class="string">'('</span>时循环</span><br><span class="line">				&#123;	postexp[i++]=e;	    //将e存放到postexp中</span><br><span class="line">					Pop(Optr,e);	    //继续出栈元素e</span><br><span class="line">				&#125;</span><br><span class="line">				exp++;		     //继续扫描其他字符</span><br><span class="line">				<span class="built_in">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'+'</span>:				//判定为加或减号</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">				<span class="keyword">while</span> (!StackEmpty(Optr))	//栈不空循环</span><br><span class="line">				&#123;    </span><br><span class="line">					GetTop(Optr,e);		//取栈顶元素e</span><br><span class="line">					<span class="keyword">if</span> (e!=<span class="string">'('</span>)			//e不是<span class="string">'('</span></span><br><span class="line">					&#123;   postexp[i++]=e;	//将e存放到postexp中</span><br><span class="line">						Pop(Optr,e);		//出栈元素e</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span>			//e是<span class="string">'(时退出循环</span></span><br><span class="line"><span class="string">						break;</span></span><br><span class="line"><span class="string">				&#125;</span></span><br><span class="line"><span class="string">				Push(Optr,*exp);		//将'</span>+<span class="string">'或'</span>-<span class="string">'进栈</span></span><br><span class="line"><span class="string">				exp++;				//继续扫描其他字符</span></span><br><span class="line"><span class="string">				break;</span></span><br><span class="line"><span class="string">		case '</span>*<span class="string">':				//判定为'</span>*<span class="string">'或'</span>/<span class="string">'号</span></span><br><span class="line"><span class="string">		case '</span>/<span class="string">':</span></span><br><span class="line"><span class="string">				while (!StackEmpty(Optr))	//栈不空循环</span></span><br><span class="line"><span class="string">				&#123;   GetTop(Optr,e);		//取栈顶元素e</span></span><br><span class="line"><span class="string">					if (e=='</span>*<span class="string">' || e=='</span>/<span class="string">')</span></span><br><span class="line"><span class="string">					&#123;   postexp[i++]=e;	//将e存放到postexp中</span></span><br><span class="line"><span class="string">						Pop(Optr,e);	//出栈元素e</span></span><br><span class="line"><span class="string">					&#125;</span></span><br><span class="line"><span class="string">					else			//e为非'</span>*<span class="string">'或'</span>/<span class="string">'运算符时退出循环</span></span><br><span class="line"><span class="string">						break;</span></span><br><span class="line"><span class="string">				&#125;</span></span><br><span class="line"><span class="string">				Push(Optr,*exp);		//将'</span>*<span class="string">'或'</span>/<span class="string">'进栈</span></span><br><span class="line"><span class="string">				exp++;			//继续扫描其他字符</span></span><br><span class="line"><span class="string">				break;</span></span><br><span class="line"><span class="string">		default:			//处理数字字符</span></span><br><span class="line"><span class="string">				while (*exp&gt;='</span>0<span class="string">' &amp;&amp; *exp&lt;='</span>9<span class="string">')      //判定为数字字符</span></span><br><span class="line"><span class="string">				&#123;   postexp[i++]=*exp;</span></span><br><span class="line"><span class="string">					exp++;</span></span><br><span class="line"><span class="string">				&#125;</span></span><br><span class="line"><span class="string">				postexp[i++]='</span><span class="comment">#';	//用#标识一个数值串结束</span></span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!StackEmpty(Optr))	//此时exp扫描完毕,栈不空时循环</span><br><span class="line">    &#123;   Pop(Optr,e);		//出栈元素e</span><br><span class="line">		postexp[i++]=e;		//将e存放到postexp中</span><br><span class="line">    &#125;</span><br><span class="line">    postexp[i]=<span class="string">'\0'</span>;		//给postexp表达式添加结束标识</span><br><span class="line">    DestroyStack(Optr);	//销毁栈</span><br><span class="line">    //<span class="built_in">return</span> postexp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后缀表达式求值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">double compvalue(char *postexp)	</span><br><span class="line">&#123;   double d, a ,b, c, e;	</span><br><span class="line">    SqStack *Opnd;					//定义操作数栈</span><br><span class="line">    InitStack(Opnd);				//初始化操作数栈</span><br><span class="line">    <span class="keyword">while</span> (*postexp!=<span class="string">'\0'</span>)			//postexp字符串未扫描完时循环</span><br><span class="line">    &#123;	 </span><br><span class="line">		switch (*postexp)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'+'</span>:				//判定为<span class="string">'+'</span>号</span><br><span class="line">				Pop(Opnd,a);		//出栈元素a</span><br><span class="line">				Pop(Opnd,b);		//出栈元素b</span><br><span class="line">				c=b+a;				//计算c</span><br><span class="line">				Push(Opnd,c);		//将计算结果c进栈</span><br><span class="line">				<span class="built_in">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'-'</span>:				//判定为<span class="string">'-'</span>号</span><br><span class="line">				Pop(Opnd,a);		//出栈元素a</span><br><span class="line">				Pop(Opnd,b);		//出栈元素b</span><br><span class="line">				c=b<span class="_">-a</span>;				//计算c</span><br><span class="line">				Push(Opnd,c);		//将计算结果c进栈</span><br><span class="line">				<span class="built_in">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'*'</span>:				//判定为<span class="string">'*'</span>号</span><br><span class="line">				Pop(Opnd,a);		//出栈元素a</span><br><span class="line">				Pop(Opnd,b);		//出栈元素b</span><br><span class="line">				c=b*a;				//计算c</span><br><span class="line">				Push(Opnd,c);		//将计算结果c进栈</span><br><span class="line">				<span class="built_in">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'/'</span>:				//判定为<span class="string">'/'</span>号</span><br><span class="line">				Pop(Opnd,a);		//出栈元素a</span><br><span class="line">				Pop(Opnd,b);		//出栈元素b</span><br><span class="line">				<span class="keyword">if</span> (a!=0)</span><br><span class="line">				&#123;	c=b/a;			//计算c</span><br><span class="line">					Push(Opnd,c);		//将计算结果c进栈</span><br><span class="line">					<span class="built_in">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;		<span class="built_in">printf</span>(<span class="string">"\n\t除零错误!\n"</span>);</span><br><span class="line">					<span class="built_in">exit</span>(0);			//异常退出</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="built_in">break</span>;</span><br><span class="line">			default:			//处理数字字符</span><br><span class="line">				d=0;		//转换成对应的数值存放到d中</span><br><span class="line">				<span class="keyword">while</span> (*postexp&gt;=<span class="string">'0'</span> &amp;&amp; *postexp&lt;=<span class="string">'9'</span>)</span><br><span class="line">				&#123;	d=10*d+*postexp-<span class="string">'0'</span>;</span><br><span class="line">					postexp++;</span><br><span class="line">				&#125;</span><br><span class="line">				Push(Opnd,d);	//将数值d进栈</span><br><span class="line">				<span class="built_in">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		postexp++;		//继续处理其他字符</span><br><span class="line">    &#125;</span><br><span class="line">    GetTop(Opnd,e);		//取栈顶元素e</span><br><span class="line">    DestroyStack(Opnd);	//销毁栈</span><br><span class="line">    <span class="built_in">return</span> e;			//返回e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>0x3迷宫问题</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#define MaxSize 200</span></span><br><span class="line">//1代表无路，0代表有路 </span><br><span class="line"></span><br><span class="line">int mg[10][10]=</span><br><span class="line">&#123;</span><br><span class="line">	&#123;1,1,1,1,1,1,1,1,1,1&#125;,</span><br><span class="line">	&#123;1,0,0,1,0,0,0,1,0,1&#125;,</span><br><span class="line">	&#123;1,0,0,1,0,0,0,1,0,1&#125;,</span><br><span class="line">	&#123;1,0,0,0,0,1,1,0,0,1&#125;,</span><br><span class="line">	&#123;1,0,1,1,1,0,0,0,0,1&#125;,</span><br><span class="line">	&#123;1,0,0,0,1,0,0,0,0,1&#125;,</span><br><span class="line">	&#123;1,0,1,0,0,0,1,0,0,1&#125;,</span><br><span class="line">	&#123;1,0,1,1,1,0,1,1,0,1&#125;,</span><br><span class="line">	&#123;1,1,0,0,0,0,0,0,0,1&#125;,</span><br><span class="line">	&#123;1,1,1,1,1,1,1,1,1,1&#125;</span><br><span class="line">&#125;;</span><br><span class="line">typedef struct&#123;</span><br><span class="line">	int i; //当前方块的行号 </span><br><span class="line">	int j; //当前方块的列号 </span><br><span class="line">	int di; //下一个可走的相邻方块的方位号 </span><br><span class="line">&#125;Box;</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">	Box data[MaxSize];</span><br><span class="line">	int top;</span><br><span class="line">&#125;StType;</span><br><span class="line">bool mgpath(int xi,int yi,int xe,int ye)&#123;</span><br><span class="line">	int i,j,k,di,find;</span><br><span class="line">	StType st; </span><br><span class="line">	st.top=-1;</span><br><span class="line">	st.top++; </span><br><span class="line">	st.data[st.top].i=xi; //初始方块进栈 </span><br><span class="line">	st.data[st.top].j=yi;</span><br><span class="line">	st.data[st.top].di=-1;</span><br><span class="line">	mg[xi][yi]=-1;</span><br><span class="line">	<span class="keyword">while</span>(st.top&gt;-1)&#123;</span><br><span class="line">		i=st.data[st.top].i;</span><br><span class="line">		j=st.data[st.top].j;</span><br><span class="line">		di=st.data[st.top].di;</span><br><span class="line">		<span class="keyword">if</span>(i==xe&amp;&amp;j==ye)&#123; //找到了出口输出路径 </span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"迷宫的路径如下:\n"</span>);</span><br><span class="line">			<span class="keyword">for</span>(k=0;k&lt;=st.top;k++)&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"\t(%d,%d)"</span>,st.data[k].i,st.data[k].j);</span><br><span class="line">				<span class="keyword">if</span>((k+1)%5==0)</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">			<span class="built_in">return</span> <span class="literal">true</span>; </span><br><span class="line">		&#125; </span><br><span class="line">		find=0;</span><br><span class="line">		<span class="keyword">while</span>(di&lt;4&amp;&amp;find==0)&#123; //找下一个可走的方位 </span><br><span class="line">			di++;</span><br><span class="line">			switch(di)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">case</span> 0: i=st.data[st.top].i-1;j=st.data[st.top].j;<span class="built_in">break</span>;</span><br><span class="line">				<span class="keyword">case</span> 1: i=st.data[st.top].i;j=st.data[st.top].j-1;<span class="built_in">break</span>;</span><br><span class="line">				<span class="keyword">case</span> 2: i=st.data[st.top].i;j=st.data[st.top].j+1;<span class="built_in">break</span>;</span><br><span class="line">				<span class="keyword">case</span> 3: i=st.data[st.top].i+1;j=st.data[st.top].j;<span class="built_in">break</span>; </span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(mg[i][j]==0) find=1;</span><br><span class="line">		&#125;</span><br><span class="line">	   <span class="keyword">if</span>(find==1)&#123;</span><br><span class="line">   		st.data[st.top].di=di; //修改原栈顶元素di的值 </span><br><span class="line">   		st.top++;  //下一个可走方块进栈 </span><br><span class="line">   		st.data[st.top].i=i; st.data[st.top].j=j;</span><br><span class="line">   		st.data[st.top].di=-1;</span><br><span class="line">		mg[i][j]=-1;  //避免重复走该方块 </span><br><span class="line">   	  &#125;</span><br><span class="line">   	  <span class="keyword">else</span>&#123;   //没有路劲可走，则退栈 </span><br><span class="line">  	   	 mg[st.data[st.top].i][st.data[st.top].j]=0;</span><br><span class="line">  	   	 st.top--;</span><br><span class="line">  	   &#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int  <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(!mgpath(1,1,5,5))&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"该迷宫问题没有解"</span>); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="0x2共享栈"><a href="#0x2共享栈" class="headerlink" title="0x2共享栈"></a>0x2共享栈</h3><p><img src="../../images/dataStructure/share.png" alt=""></p>
<h3 id="0x3-链栈"><a href="#0x3-链栈" class="headerlink" title="0x3 链栈"></a>0x3 链栈</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;malloc.h&gt;</span></span><br><span class="line">typedef char ElemType;</span><br><span class="line">typedef struct linknode</span><br><span class="line">&#123;	</span><br><span class="line">	ElemType data;				//数据域</span><br><span class="line">	struct linknode *next;		//指针域</span><br><span class="line">&#125; LiStack;						//链栈类型定义</span><br><span class="line">void InitStack(LiStack *&amp;s)</span><br><span class="line">&#123;</span><br><span class="line">	s=(LiStack *)malloc(sizeof(LiStack));</span><br><span class="line">	s-&gt;next=NULL;</span><br><span class="line">&#125;</span><br><span class="line">void DestroyQueue(LiStack *&amp;s)</span><br><span class="line">&#123;</span><br><span class="line">	LiStack *p=s-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (p!=NULL)</span><br><span class="line">	&#123;	</span><br><span class="line">		free(s);</span><br><span class="line">		s=p;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	free(s);	//s指向尾结点,释放其空间</span><br><span class="line">&#125;</span><br><span class="line">int StackLength(LiStack *s)</span><br><span class="line">&#123;</span><br><span class="line">	int i=0;</span><br><span class="line">	LiStack *p;</span><br><span class="line">	p=s-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (p!=NULL)</span><br><span class="line">	&#123;	</span><br><span class="line">		i++;</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">bool StackEmpty(LiStack *s)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">return</span>(s-&gt;next==NULL);</span><br><span class="line">&#125;</span><br><span class="line">void Push(LiStack *&amp;s,ElemType e)</span><br><span class="line">&#123;	LiStack *p;</span><br><span class="line">	p=(LiStack *)malloc(sizeof(LiStack));</span><br><span class="line">	p-&gt;data=e;				//新建元素e对应的节点*p</span><br><span class="line">	p-&gt;next=s-&gt;next;		//插入*p节点作为开始节点</span><br><span class="line">	s-&gt;next=p;</span><br><span class="line">&#125;</span><br><span class="line">bool Pop(LiStack *&amp;s,ElemType &amp;e)</span><br><span class="line">&#123;	LiStack *p;</span><br><span class="line">	<span class="keyword">if</span> (s-&gt;next==NULL)		//栈空的情况</span><br><span class="line">		<span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">	p=s-&gt;next;				//p指向开始节点</span><br><span class="line">	e=p-&gt;data;</span><br><span class="line">	s-&gt;next=p-&gt;next;		//删除*p节点</span><br><span class="line">	free(p);				//释放*p节点</span><br><span class="line">	<span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">bool GetTop(LiStack *s,ElemType &amp;e)</span><br><span class="line">&#123;	<span class="keyword">if</span> (s-&gt;next==NULL)		//栈空的情况</span><br><span class="line">		<span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">	e=s-&gt;next-&gt;data;</span><br><span class="line">	<span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="0x1-顺序队列"><a href="#0x1-顺序队列" class="headerlink" title="0x1 顺序队列"></a>0x1 顺序队列</h3><p>基本操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#define MaxSize 200</span></span><br><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef int ElemType;</span><br><span class="line"></span><br><span class="line">typedef struct </span><br><span class="line">&#123;     ElemType data[MaxSize];</span><br><span class="line">      int front,rear;      //队首和队尾指针</span><br><span class="line">&#125;Queue;</span><br><span class="line">typedef Queue *SqQueue;</span><br><span class="line">void InitQueue(SqQueue &amp;q)</span><br><span class="line">&#123;	q=new Queue;</span><br><span class="line">	q-&gt;front=q-&gt;rear=-1;</span><br><span class="line">&#125;</span><br><span class="line">void DestroyQueue(SqQueue &amp;q) //删除队列 </span><br><span class="line">&#123;</span><br><span class="line">  delete q;</span><br><span class="line">&#125;</span><br><span class="line">bool QueueEmpty(SqQueue q)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">return</span>(q-&gt;front==q-&gt;rear);</span><br><span class="line">&#125;</span><br><span class="line">bool enQueue(SqQueue &amp;q,ElemType e)</span><br><span class="line">&#123;  <span class="keyword">if</span> (q-&gt;rear+1==MaxSize)	   <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">                                       //队满上溢出</span><br><span class="line">	q-&gt;rear=q-&gt;rear+1;</span><br><span class="line">	q-&gt;data[q-&gt;rear]=e;</span><br><span class="line">	<span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool deQueue(SqQueue &amp;q,ElemType &amp;e)</span><br><span class="line">&#123;	<span class="keyword">if</span> (q-&gt;front==q-&gt;rear)  //队空下溢出</span><br><span class="line">		<span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">	q-&gt;front=q-&gt;front+1;</span><br><span class="line">	e=q-&gt;data[q-&gt;front];</span><br><span class="line">	<span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="0x2-循环队列"><a href="#0x2-循环队列" class="headerlink" title="0x2 循环队列"></a>0x2 循环队列</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;queue&gt;</span></span><br><span class="line"><span class="comment">#define MaxSize 100</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef char ElemType;</span><br><span class="line">typedef struct </span><br><span class="line">&#123;	</span><br><span class="line">	ElemType data[MaxSize];</span><br><span class="line">	int front,rear;		//队首和队尾指针</span><br><span class="line">&#125; Queue;</span><br><span class="line">typedef Queue *SqQueue;</span><br><span class="line">void InitQueue(SqQueue &amp;q)</span><br><span class="line">&#123;	q=new Queue;</span><br><span class="line">	q-&gt;front=q-&gt;rear=0;</span><br><span class="line">&#125;</span><br><span class="line">//销毁队列 </span><br><span class="line">void DestroyQueue(SqQueue &amp;q)</span><br><span class="line">&#123;</span><br><span class="line">	delete q;</span><br><span class="line">&#125;</span><br><span class="line">//判断队列是否为空 </span><br><span class="line">bool QueueEmpty(SqQueue q)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">return</span>(q-&gt;front==q-&gt;rear);</span><br><span class="line">&#125;</span><br><span class="line">//进环形队列 </span><br><span class="line">bool enQueue(SqQueue &amp;q,ElemType e)</span><br><span class="line">&#123;	<span class="keyword">if</span> ((q-&gt;rear+1)%MaxSize==q-&gt;front)	//队满上溢出</span><br><span class="line">		<span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">	q-&gt;rear=(q-&gt;rear+1)%MaxSize;</span><br><span class="line">	q-&gt;data[q-&gt;rear]=e;</span><br><span class="line">	<span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">//出环形队列 </span><br><span class="line">bool deQueue(SqQueue &amp;q,ElemType &amp;e)</span><br><span class="line">&#123;	<span class="keyword">if</span> (q-&gt;front==q-&gt;rear)		//队空下溢出</span><br><span class="line">		<span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">	q-&gt;front=(q-&gt;front+1)%MaxSize;</span><br><span class="line">	e=q-&gt;data[q-&gt;front];</span><br><span class="line">	<span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">void number1(int n)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    ElemType e;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">void number(int n)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    ElemType e;</span><br><span class="line">    SqQueue q; </span><br><span class="line">    InitQueue(q);</span><br><span class="line">    <span class="keyword">for</span>(i=1;i&lt;=n;i++) enQueue(q,i);</span><br><span class="line">    i=1;</span><br><span class="line">    <span class="keyword">while</span>(!QueueEmpty(q))&#123;</span><br><span class="line">    	deQueue(q,e);</span><br><span class="line">    	cout&lt;&lt;e&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    	<span class="keyword">if</span>(!QueueEmpty(q)) &#123;</span><br><span class="line">    		deQueue(q,e);</span><br><span class="line">    	    enQueue(q,e); //剩下一个元素不进队 </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> int main()</span><br><span class="line"> &#123;</span><br><span class="line"> 	/*int n;</span><br><span class="line"> 	cin&gt;&gt;n;</span><br><span class="line"> 	number(n);</span><br><span class="line"> 	*/</span><br><span class="line"> 	SqQueue Q;</span><br><span class="line"></span><br><span class="line">    InitQueue(Q);</span><br><span class="line"></span><br><span class="line">    char x= <span class="string">'e'</span>, y= <span class="string">'c'</span>;</span><br><span class="line"></span><br><span class="line">    enQueue(Q, <span class="string">'h'</span>);</span><br><span class="line"></span><br><span class="line">    enQueue(Q, <span class="string">'r'</span>);</span><br><span class="line"></span><br><span class="line">    enQueue(Q, y);</span><br><span class="line"></span><br><span class="line">    deQueue(Q, x);</span><br><span class="line"></span><br><span class="line">    enQueue(Q, x);</span><br><span class="line"></span><br><span class="line">    deQueue(Q, x);</span><br><span class="line"></span><br><span class="line">    enQueue(Q, <span class="string">'a'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!QueueEmpty(Q))&#123;</span><br><span class="line"></span><br><span class="line">        deQueue(Q,y);</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;y;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;x;</span><br><span class="line">  <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题目<br>n个人站成一排，从左到右编号分别为1–n，现从左到右报数“1,2,1,2,…”,数到1的人出列，数到“2”的立即站到队伍最右端，报数过程反复进行，直到n个人都出列为止。给出他们的出列顺序<br>C语言</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void number(int n)&#123;</span><br><span class="line">    int i;</span><br><span class="line">    ElemType e;</span><br><span class="line">    SqQueue q; </span><br><span class="line">    InitQueue(q);</span><br><span class="line">    <span class="keyword">for</span>(i=1;i&lt;=n;i++) enQueue(q,i);</span><br><span class="line">    i=1;</span><br><span class="line">    <span class="keyword">while</span>(!QueueEmpty(q))&#123;</span><br><span class="line">    	deQueue(q,e);</span><br><span class="line">    	cout&lt;&lt;e&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    	<span class="keyword">if</span>(!QueueEmpty(q)) &#123;</span><br><span class="line">    		deQueue(q,e);</span><br><span class="line">    	    enQueue(q,e); //剩下一个元素不进队 </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>c++</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;string&gt;    //  使用 string 类时须包含这个文件</span></span><br><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;queue&gt;     //调用c++中的类：queue </span></span><br><span class="line">using namespace std; </span><br><span class="line">void number(int n)</span><br><span class="line">&#123; int i;</span><br><span class="line">  queue&lt;int&gt; q1;  //初始化队列，包含类型 </span><br><span class="line">  <span class="keyword">for</span>(i=1;i&lt;=n;i++)&#123;</span><br><span class="line">	  	q1.push(i);  //入队列 &#125;</span><br><span class="line">  <span class="keyword">while</span>(!q1.empty())   //判断队列是否为空，是返回<span class="literal">true</span>; </span><br><span class="line">	&#123; cout&lt;&lt;q1.front()&lt;&lt;<span class="string">" "</span>;  </span><br><span class="line">        //获取队首元素 ；访问队尾元素：q1.back() </span><br><span class="line">	  q1.pop();</span><br><span class="line">        <span class="keyword">if</span>(!q1.empty())</span><br><span class="line">	   &#123;</span><br><span class="line">		q1.push(q1.front());</span><br><span class="line">		q1.pop();         //出队列，不返回元素 </span><br><span class="line">	   &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	number(8);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印杨辉三角</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void triangle(SqQueue &amp;q,int n)&#123;</span><br><span class="line">	ElemType x,y;</span><br><span class="line">	InitQueue(q);</span><br><span class="line">	enQueue(q,0);</span><br><span class="line">	enQueue(q,1);</span><br><span class="line">	enQueue(q,0);//处理第一行</span><br><span class="line">	cout&lt;&lt;1&lt;&lt;endl;</span><br><span class="line">	<span class="keyword">for</span>(int i=2;i&lt;=n;i++) //第二行开始处理</span><br><span class="line">	&#123;  <span class="keyword">for</span>(int j = 1; j&lt;= i ; j++)//每行出队入队次数</span><br><span class="line">  		&#123;    </span><br><span class="line">       		deQueue(q,x);//出队</span><br><span class="line">      		y = GetFront(q);   //获得队首元素</span><br><span class="line">      		enQueue(q,x+y); //前2个元素相加，再入队</span><br><span class="line">            cout&lt;&lt;x+y;//输出x+y值；  </span><br><span class="line"> 		 &#125; </span><br><span class="line"> 	 	enQueue(q,0);//入队0</span><br><span class="line">   		cout&lt;&lt;endl;//输出回车换行；</span><br><span class="line">	&#125;</span><br><span class="line">			</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迷宫</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#define MaxSize 200</span></span><br><span class="line">//1代表无路，0代表有路 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int mg[10][10]=</span><br><span class="line">&#123;</span><br><span class="line">	&#123;1,1,1,1,1,1,1,1,1,1&#125;,</span><br><span class="line">	&#123;1,0,0,1,0,0,0,1,0,1&#125;,</span><br><span class="line">	&#123;1,0,0,1,0,0,0,1,0,1&#125;,</span><br><span class="line">	&#123;1,0,0,0,0,1,1,0,0,1&#125;,</span><br><span class="line">	&#123;1,0,1,1,1,0,0,0,0,1&#125;,</span><br><span class="line">	&#123;1,0,0,0,1,0,0,0,0,1&#125;,</span><br><span class="line">	&#123;1,0,1,0,0,0,1,0,0,1&#125;,</span><br><span class="line">	&#123;1,0,1,1,1,0,1,1,0,1&#125;,</span><br><span class="line">	&#123;1,1,0,0,0,0,0,0,0,1&#125;,</span><br><span class="line">	&#123;1,1,1,1,1,1,1,1,1,1&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef struct </span><br><span class="line">&#123;</span><br><span class="line">	int i,j;</span><br><span class="line">	int pre;</span><br><span class="line">&#125;Box;</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">	Box data[MaxSize];</span><br><span class="line">	int front,rear; </span><br><span class="line">&#125;QuType;</span><br><span class="line">bool  mgpath(int xi,int yi,int xe,int ye);</span><br><span class="line">void <span class="built_in">print</span>(QuType qu,int front);</span><br><span class="line">bool  mgpath(int xi,int yi,int xe,int ye)&#123;</span><br><span class="line">	int i,j ,find=0,di;</span><br><span class="line">	QuType qu;</span><br><span class="line">	qu.front=qu.rear=-1;</span><br><span class="line">	qu.rear++; //xi,yi进队 </span><br><span class="line">	qu.data[qu.rear].i=xi;</span><br><span class="line">	qu.data[qu.rear].j=yi;</span><br><span class="line">	qu.data[qu.rear].pre=-1;</span><br><span class="line">	mg[xi][yi]=-1; //将其赋值为-1,以避免回过来重复搜索</span><br><span class="line">	<span class="keyword">while</span>(qu.front!=qu.rear&amp;&amp;!find)</span><br><span class="line">	&#123;</span><br><span class="line">		qu.front++;</span><br><span class="line">		i=qu.data[qu.front].i;</span><br><span class="line">		j=qu.data[qu.front].j;</span><br><span class="line">		<span class="keyword">if</span>(i==xe&amp;&amp;j==ye)&#123;</span><br><span class="line">			find=1;</span><br><span class="line">			<span class="built_in">print</span>(qu,qu.front);</span><br><span class="line">			<span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(di=0;di&lt;4;di++)&#123;</span><br><span class="line">			switch(di)&#123;</span><br><span class="line">				<span class="keyword">case</span> 0: i=qu.data[qu.front].i-1;j=qu.data[qu.front].j;<span class="built_in">break</span>;</span><br><span class="line">				<span class="keyword">case</span> 1: i=qu.data[qu.front].i;j=qu.data[qu.front].j+1;<span class="built_in">break</span>;</span><br><span class="line">				<span class="keyword">case</span> 2: i=qu.data[qu.front].i+1;j=qu.data[qu.front].j;<span class="built_in">break</span>;</span><br><span class="line">				<span class="keyword">case</span> 3: i=qu.data[qu.front].i;j=qu.data[qu.front].j-1;<span class="built_in">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(mg[i][j]==0)</span><br><span class="line">			&#123;</span><br><span class="line">				qu.rear++;</span><br><span class="line">				qu.data[qu.rear].i=i;</span><br><span class="line">				qu.data[qu.rear].j=j;</span><br><span class="line">				qu.data[qu.rear].pre=qu.front;//指向路径中上一个方块的下标 </span><br><span class="line">				mg[i][j]=-1;//将其赋值-1，以避免回过来重复搜索 </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125; </span><br><span class="line">	 </span><br><span class="line">		<span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; </span><br><span class="line">void <span class="built_in">print</span>(QuType qu,int front)&#123;</span><br><span class="line">	int k=front,j,ns=0;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		j=k;</span><br><span class="line">		k=qu.data[j].pre;</span><br><span class="line">		qu.data[j].pre=-1;</span><br><span class="line">	&#125;<span class="keyword">while</span>(k!=0);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"迷宫的路径如下:\n"</span>);</span><br><span class="line">	k=0;</span><br><span class="line">	<span class="keyword">while</span>(k&lt;MaxSize)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(qu.data[k].pre==-1)</span><br><span class="line">		&#123;</span><br><span class="line">			ns++;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\t(%d,%d)"</span>,qu.data[k].i,qu.data[k].j);</span><br><span class="line">			<span class="keyword">if</span>(ns%5==0)<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		k++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">if</span>(!mgpath(1,1,5,5))</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"该迷宫问题没有解"</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="0x3-链表队列"><a href="#0x3-链表队列" class="headerlink" title="0x3 链表队列"></a>0x3 链表队列</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line">using namspace std;</span><br><span class="line">typedef char ElemType;</span><br><span class="line">typedef struct qnode</span><br><span class="line">&#123;	</span><br><span class="line">	ElemType data;</span><br><span class="line">	struct qnode *next;</span><br><span class="line">&#125; QNode;		//链队数据结点类型定义</span><br><span class="line">typedef struct</span><br><span class="line">&#123;	</span><br><span class="line">	QNode *front;</span><br><span class="line">	QNode *rear;</span><br><span class="line">&#125; Queue;//链队类型定义</span><br><span class="line">typedef struct Queue *LiQueue;</span><br><span class="line">void InitQueue(LiQueue &amp;q)</span><br><span class="line">&#123;	</span><br><span class="line">	q=new Queue;</span><br><span class="line">	q-&gt;front=q-&gt;rear=NULL;</span><br><span class="line">&#125;</span><br><span class="line">void DestroyQueue(LiQueue &amp;q)</span><br><span class="line">&#123;</span><br><span class="line">	QNode *p=q-&gt;front,*r;	//p指向队头数据节点</span><br><span class="line">	<span class="keyword">if</span> (p!=NULL)			//释放数据节点占用空间</span><br><span class="line">	&#123;	r=p-&gt;next;</span><br><span class="line">		<span class="keyword">while</span> (r!=NULL)</span><br><span class="line">		&#123;	delete p;</span><br><span class="line">			p=r;r=p-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	delete p;delete q;				//释放链队节点占用空间</span><br><span class="line">&#125;</span><br><span class="line">bool QueueEmpty(LiQueue *q)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">return</span>(q-&gt;rear==NULL);</span><br><span class="line">&#125;</span><br><span class="line">void enQueue(LiQueue &amp;q,ElemType e)</span><br><span class="line">&#123;	QNode *p;</span><br><span class="line">	p=new QNode ;</span><br><span class="line">	p-&gt;data=e;</span><br><span class="line">	p-&gt;next=NULL;</span><br><span class="line">	<span class="keyword">if</span> (q-&gt;rear==NULL)		//若链队为空,则新节点是队首节点又是队尾节点</span><br><span class="line">		q-&gt;front=q-&gt;rear=p;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;	q-&gt;rear-&gt;next=p;	//将*p节点链到队尾,并将rear指向它</span><br><span class="line">		q-&gt;rear=p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">bool deQueue(LiQueue &amp;q,ElemType &amp;e)</span><br><span class="line">&#123;	QNode *t;</span><br><span class="line">	<span class="keyword">if</span> (q-&gt;rear==NULL)		//队列为空</span><br><span class="line">		<span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">	t=q-&gt;front;				//t指向第一个数据节点</span><br><span class="line">	<span class="keyword">if</span> (q-&gt;front==q-&gt;rear)  //队列中只有一个节点时</span><br><span class="line">		q-&gt;front=q-&gt;rear=NULL;</span><br><span class="line">	<span class="keyword">else</span>					//队列中有多个节点时</span><br><span class="line">		q-&gt;front=q-&gt;front-&gt;next;</span><br><span class="line">	e=t-&gt;data;</span><br><span class="line">	delete t;</span><br><span class="line">	<span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><p>串的模式匹配算法<br>Brute-Force算法   </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#define MaxSize 200</span></span><br><span class="line">typedef struct&#123;</span><br><span class="line">	char data[MaxSize];</span><br><span class="line">	int length;</span><br><span class="line">&#125;SqString;</span><br><span class="line">strAssign(SqString &amp;s,char cstr[])&#123;</span><br><span class="line">	int i;</span><br><span class="line">	<span class="keyword">for</span>(i=0;cstr[i]!=<span class="string">'\0'</span>;i++)&#123;</span><br><span class="line">		s.data[i]=cstr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	s.length=i;</span><br><span class="line">&#125;</span><br><span class="line">int index(SqString s,SqString t)</span><br><span class="line">&#123;     int i=0,  j=0;</span><br><span class="line">     <span class="keyword">while</span> (i&lt;s.length &amp;&amp; j&lt;t.length) </span><br><span class="line">    &#123;       <span class="keyword">if</span> (s.data[i]==t.data[j])	//继续匹配下一个字符</span><br><span class="line">			&#123;     i++;			//主串和子串依次匹配下一个字符</span><br><span class="line">	     	  	  j++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>			//主串、子串指针回溯重新开始下一次匹配</span><br><span class="line">			&#123;    i=i-j+1;		//主串从下一个位置开始匹配</span><br><span class="line">	    		 j=0; 			//子串从头开始匹配</span><br><span class="line">			&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j&gt;=t.length)</span><br><span class="line">		<span class="built_in">return</span>(i-t.length);	//返回匹配的第一个字符的下标</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">		<span class="built_in">return</span>(-1);		//模式匹配不成功</span><br><span class="line">&#125;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	char a[20]=<span class="string">"aaabcde"</span>,b[20]=<span class="string">"abcde"</span>;</span><br><span class="line">	int i;</span><br><span class="line">	SqString q,p;</span><br><span class="line">	strAssign(q,a);</span><br><span class="line">	strAssign(p,b);</span><br><span class="line">	i=index(q,p);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,i);</span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>KMP算法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">//Brute-Force算法</span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#define MaxSize 200</span></span><br><span class="line">typedef struct&#123;</span><br><span class="line">	char data[MaxSize];</span><br><span class="line">	int length;</span><br><span class="line">&#125;SqString;</span><br><span class="line">strAssign(SqString &amp;s,char cstr[])&#123;</span><br><span class="line">	int i;</span><br><span class="line">	<span class="keyword">for</span>(i=0;cstr[i]!=<span class="string">'\0'</span>;i++)&#123;</span><br><span class="line">		s.data[i]=cstr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	s.length=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void GetNext(SqString t,int next[])	 </span><br><span class="line">&#123;  int j,k;</span><br><span class="line">   j=0;k=-1;next[0]=-1;</span><br><span class="line">   <span class="keyword">while</span> (j&lt;t.length-1)</span><br><span class="line">   &#123;	<span class="keyword">if</span> (k==-1 || t.data[j]==t.data[k])</span><br><span class="line">		&#123;   j++;k++;</span><br><span class="line">	   		 next[j]=k;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> k=next[k];</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">int KMPIndex(SqString s,SqString t) </span><br><span class="line">&#123;  int next[MaxSize],i=0,j=0;</span><br><span class="line">   GetNext(t,next);</span><br><span class="line">   <span class="keyword">while</span> (i&lt;s.length &amp;&amp; j&lt;t.length) </span><br><span class="line">   &#123;  <span class="keyword">if</span> (j==-1 || s.data[i]==t.data[j]) </span><br><span class="line">	&#123;  i++;</span><br><span class="line">	   j++;			//i,j各增1</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> j=next[j]; 		//i不变,j后退</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (j&gt;=t.length)</span><br><span class="line">	<span class="built_in">return</span>(i-t.length);	//匹配模式串首字符下标</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">	<span class="built_in">return</span>(-1);			//返回不匹配标志</span><br><span class="line">&#125;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	char a[20]=<span class="string">"aaabaaaab"</span>,b[20]=<span class="string">"aaaab"</span>;</span><br><span class="line">	int next[20];</span><br><span class="line">	int i;</span><br><span class="line">	SqString s,t;</span><br><span class="line">	strAssign(s,a);</span><br><span class="line">	strAssign(t,b);</span><br><span class="line">	i=KMPIndex(s,t); </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>,i);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>0x1 二叉树创建、遍历<br><img src="../../images/dataStructure/tree.png" alt=""></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"><span class="comment">#include&lt;queue&gt;</span></span><br><span class="line">typedef char ElemType;</span><br><span class="line"><span class="comment">#define MaxSize 200</span></span><br><span class="line">typedef struct node</span><br><span class="line">&#123;     ElemType data;</span><br><span class="line">       struct node *lchild, *rchild;</span><br><span class="line">&#125;BTNode;    </span><br><span class="line">typedef BTNode *BTree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">//创建树 </span><br><span class="line">//输入序列:A,  B,  C,  D,  F,  G,  I,  0,  0,  E,  0,  0,  H,  0,  0,  0,  0,  0,  0</span><br><span class="line">void CreateBTree(BTree &amp;BT,string str)</span><br><span class="line">&#123;     BTree  T;int i=0;</span><br><span class="line">      queue&lt;BTree&gt; Q;//队列 	</span><br><span class="line">	<span class="keyword">if</span>( str[0]!=<span class="string">'0'</span> )&#123; /*分配根结点单元，并将结点地址入队*/</span><br><span class="line">		BT =new BTNode;</span><br><span class="line">		BT-&gt;data = str[0];</span><br><span class="line">		BT-&gt;lchild=BT-&gt;rchild=NULL;</span><br><span class="line">		Q.push(BT);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> BT=NULL; /* 若第1个数据就是0，返回空树 */</span><br><span class="line">	<span class="keyword">while</span>( !Q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		T = Q.front();/*从队列中取出一结点地址*/</span><br><span class="line">		Q.pop();</span><br><span class="line">		i++;</span><br><span class="line">		<span class="keyword">if</span>(str[i]==<span class="string">'0'</span> ) T-&gt;lchild = NULL;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;  /*生成左孩子结点；新结点入队*/</span><br><span class="line">			T-&gt;lchild = new BTNode;</span><br><span class="line">			T-&gt;lchild-&gt;data = str[i];</span><br><span class="line">			T-&gt;lchild-&gt;lchild=T-&gt;lchild-&gt;rchild=NULL;</span><br><span class="line">			Q.push(T-&gt;lchild);</span><br><span class="line">		&#125;</span><br><span class="line">        i++; /* 读入T的右孩子 */</span><br><span class="line">		<span class="keyword">if</span>(str[i]==<span class="string">'0'</span>) T-&gt;rchild = NULL;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		&#123;  /*生成右孩子结点；新结点入队*/</span><br><span class="line">			T-&gt;rchild = new BTNode;;</span><br><span class="line">			T-&gt;rchild-&gt;data = str[i];</span><br><span class="line">		T-&gt;rchild-&gt;lchild=T-&gt;rchild-&gt;rchild=NULL;</span><br><span class="line">			Q.push(T-&gt;rchild);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; /* 结束<span class="keyword">while</span> */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//先序遍历 </span><br><span class="line"> void PreOrder(BTree bt)</span><br><span class="line">&#123;     <span class="keyword">if</span> (bt!=NULL)  </span><br><span class="line">      &#123;     <span class="built_in">printf</span>(<span class="string">"%c "</span>,bt-&gt;data); 	//访问根结点</span><br><span class="line">             PreOrder(bt-&gt;lchild);</span><br><span class="line">             PreOrder(bt-&gt;rchild);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//中序遍历 </span><br><span class="line">void InOrder(BTree bt)</span><br><span class="line">&#123;       <span class="keyword">if</span> (bt!=NULL)  </span><br><span class="line">        &#123;      InOrder(bt-&gt;lchild);</span><br><span class="line">	 <span class="built_in">printf</span>(<span class="string">"%c "</span>,bt-&gt;data); 	//访问根结点</span><br><span class="line">	 InOrder(bt-&gt;rchild);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;		</span><br><span class="line">//后序遍历 </span><br><span class="line">void PostOrder(BTree bt) </span><br><span class="line">&#123;      <span class="keyword">if</span> (bt!=NULL)  </span><br><span class="line">        &#123;      PostOrder(bt-&gt;lchild);</span><br><span class="line">	 PostOrder(bt-&gt;rchild);</span><br><span class="line">	 <span class="built_in">printf</span>(<span class="string">"%c "</span>,bt-&gt;data); 	//访问根结点</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line">//求所有节点的值 </span><br><span class="line">int FindSum(BTree  bt)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>(bt==NULL)   <span class="built_in">return</span> 0;</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">   <span class="built_in">return</span> (bt-&gt;data+FindSum(bt-&gt;lchild)</span><br><span class="line">                              +FindSum(bt-&gt;rchild));</span><br><span class="line">&#125;</span><br><span class="line">//访问所有的叶子节点 </span><br><span class="line">void DispLeaf(BTNode *b)</span><br><span class="line">&#123;      <span class="keyword">if</span> (b!=NULL)</span><br><span class="line">        &#123;	<span class="keyword">if</span> (b-&gt;lchild==NULL &amp;&amp; b-&gt;rchild==NULL)</span><br><span class="line">	        <span class="built_in">printf</span>(<span class="string">"%c "</span>,b-&gt;data);    //访问叶子结点</span><br><span class="line">	DispLeaf(b-&gt;lchild);	        //输出左子树中的叶子结点</span><br><span class="line">	DispLeaf(b-&gt;rchild);	        //输出右子树中的叶子结点</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">//输出值为x节点所有祖先</span><br><span class="line">bool ancestor(BTree bt,ElemType x)</span><br><span class="line">&#123;    <span class="keyword">if</span>(bt==NULL) <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span>(bt-&gt;lchild!=NULL &amp;&amp; bt-&gt;lchild-&gt;data==x || bt-&gt;rchild!=NULL &amp;&amp; bt-&gt;rchild-&gt;data==x) &#123;</span><br><span class="line">			cout&lt;&lt;bt-&gt;data&lt;&lt;<span class="string">" "</span>;  //找到孩子为x结点</span><br><span class="line">			<span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(ancestor(bt-&gt;lchild,x) || ancestor(bt-&gt;rchild,x))&#123;</span><br><span class="line">	   		 	cout&lt;&lt;bt-&gt;data;//先序遍历</span><br><span class="line">	   			<span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">//层次遍历 </span><br><span class="line">void LevelOrder(BTree bt)</span><br><span class="line">&#123;  queue&lt;BTree&gt; q;    //初始化队列，元素为树节点</span><br><span class="line">  BTree p;                 //树指针p</span><br><span class="line">  <span class="keyword">if</span>(bt!=NULL) q.push(bt);  //根节点入队列</span><br><span class="line">  <span class="keyword">while</span>(!q.empty())</span><br><span class="line">  &#123;      p=q.front();  //访问队头节点</span><br><span class="line">  	q.pop();</span><br><span class="line">  	cout&lt;&lt;p-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">  	<span class="keyword">if</span>(p-&gt;lchild) q.push(p-&gt;lchild);//左右孩子入队</span><br><span class="line">  	<span class="keyword">if</span>(p-&gt;rchild) q.push(p-&gt;rchild);</span><br><span class="line">  &#125;&#125;</span><br><span class="line">  </span><br><span class="line"> //求高度 </span><br><span class="line">int BTNodeHeight(BTNode *b)</span><br><span class="line">&#123;</span><br><span class="line">	int lchildh,rchildh;</span><br><span class="line">	<span class="keyword">if</span>(b==NULL) <span class="built_in">return</span> 0;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		lchildh=BTNodeHeight(b-&gt;lchild);</span><br><span class="line">		rchildh=BTNodeHeight(b-&gt;rchild);</span><br><span class="line">		<span class="built_in">return</span> (lchildh&gt;rchildh)?(lchildh+1):(rchildh+1); </span><br><span class="line">	&#125;</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	char str[100]=&#123;<span class="string">'A'</span>,<span class="string">'B'</span>, <span class="string">'C'</span>,<span class="string">'D'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>, <span class="string">'I'</span>,<span class="string">'0'</span>,<span class="string">'0'</span>,<span class="string">'E'</span>, <span class="string">'0'</span>, <span class="string">'0'</span>, <span class="string">'H'</span>, <span class="string">'0'</span>, <span class="string">'0'</span>, <span class="string">'0'</span>, <span class="string">'0'</span>, <span class="string">'0'</span>, <span class="string">'0'</span>&#125;;</span><br><span class="line">	char a=<span class="string">'E'</span>;</span><br><span class="line">	int height;</span><br><span class="line">	BTree BT;</span><br><span class="line">	CreateBTree(BT,str);</span><br><span class="line">	cout&lt;&lt;<span class="string">"先序遍历:"</span>;</span><br><span class="line">	PreOrder(BT);</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">"中序遍历:"</span>;</span><br><span class="line">	InOrder(BT);</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">"后序遍历:"</span>;</span><br><span class="line">	PostOrder(BT);</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">"叶子节点:"</span>;</span><br><span class="line">	DispLeaf(BT); </span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;a&lt;&lt;<span class="string">"的祖先结点:"</span>;</span><br><span class="line">	ancestor(BT,a);</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">"层次遍历:"</span>;</span><br><span class="line">	LevelOrder(BT); </span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;<span class="string">"高度为:"</span>;</span><br><span class="line">	height=BTNodeHeight(BT);</span><br><span class="line">	cout&lt;&lt;height;</span><br><span class="line">	 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>0x2 二叉树构造、线索二叉树</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;malloc.h&gt; </span></span><br><span class="line">using namespace std;</span><br><span class="line"><span class="comment">#include&lt;queue&gt;</span></span><br><span class="line">typedef char ElemType;</span><br><span class="line"><span class="comment">#define MaxSize 200</span></span><br><span class="line">typedef struct node</span><br><span class="line">&#123;     ElemType data;</span><br><span class="line">       struct node *lchild, *rchild;</span><br><span class="line">&#125;BTNode;    </span><br><span class="line">typedef BTNode *BTree;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//层次遍历 </span><br><span class="line">void LevelOrder(BTree bt)</span><br><span class="line">&#123;  queue&lt;BTree&gt; q;    //初始化队列，元素为树节点</span><br><span class="line">  BTree p;                 //树指针p</span><br><span class="line">  <span class="keyword">if</span>(bt!=NULL) q.push(bt);  //根节点入队列</span><br><span class="line">  <span class="keyword">while</span>(!q.empty())</span><br><span class="line">  &#123;      p=q.front();  //访问队头节点</span><br><span class="line">  	q.pop();</span><br><span class="line">  	cout&lt;&lt;p-&gt;data&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">  	<span class="keyword">if</span>(p-&gt;lchild) q.push(p-&gt;lchild);//左右孩子入队</span><br><span class="line">  	<span class="keyword">if</span>(p-&gt;rchild) q.push(p-&gt;rchild);</span><br><span class="line">  &#125;&#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">//先序中序构造二叉树 </span><br><span class="line">BTNode *CreateBT1(char *pre,char *<span class="keyword">in</span>,int n)</span><br><span class="line">&#123;  BTNode *s;  char *p;  int k;</span><br><span class="line">   <span class="keyword">if</span> (n&lt;=0) <span class="built_in">return</span> NULL;</span><br><span class="line">   s=new BTNode;</span><br><span class="line">   s-&gt;data=*pre;                                                                   //创建根节点              </span><br><span class="line">   <span class="keyword">for</span> (p=<span class="keyword">in</span>;p&lt;<span class="keyword">in</span>+n;p++)      //在中序中找为*ppos的位置k</span><br><span class="line">	 <span class="keyword">if</span> (*p==*pre)</span><br><span class="line">	      <span class="built_in">break</span>;</span><br><span class="line">   k=p-in;</span><br><span class="line">   s-&gt;lchild=CreateBT1(pre+1,<span class="keyword">in</span>,k);   //构造左子树</span><br><span class="line">   s-&gt;rchild=CreateBT1(pre+k+1,p+1,n-k-1); //右子树                                                                                                                                            //右子树</span><br><span class="line">   <span class="built_in">return</span> s;</span><br><span class="line">&#125; </span><br><span class="line">//中序和后序构造二叉树 </span><br><span class="line">BTNode *CreateBT2(char *post,char *<span class="keyword">in</span>,int n)</span><br><span class="line">&#123;  BTNode *s;  char *p;  int k;</span><br><span class="line">   <span class="keyword">if</span> (n&lt;=0) <span class="built_in">return</span> NULL;</span><br><span class="line">   s=(BTNode *)malloc(sizeof(BTNode));//创建节点</span><br><span class="line">   s-&gt;data=*(post+n-1);        //构造根节点。</span><br><span class="line">   <span class="keyword">for</span> (p=<span class="keyword">in</span>;p&lt;<span class="keyword">in</span>+n;p++)//在中序中找为*ppos的位置k</span><br><span class="line">	 <span class="keyword">if</span> (*p==*(post+n-1))</span><br><span class="line">	      <span class="built_in">break</span>;</span><br><span class="line">   k=p-in;</span><br><span class="line">   s-&gt;lchild=CreateBT2(post,<span class="keyword">in</span>,k);	//构造左子树</span><br><span class="line">   s-&gt;rchild=CreateBT2(post+k,p+1,n-k-1);//构造右子树</span><br><span class="line">   <span class="built_in">return</span> s;</span><br><span class="line">&#125; </span><br><span class="line">//ABCD<span class="comment">#EF#G######顺序存储结构转成二叉链 有点问题，以后再探索 </span></span><br><span class="line">BTree CreateBTree(string str,int i)</span><br><span class="line">&#123;</span><br><span class="line">   int len;</span><br><span class="line">   BTree bt;</span><br><span class="line">   bt=new BTNode;</span><br><span class="line">   len=str.size();</span><br><span class="line">   <span class="keyword">if</span>(i&gt;len || i&lt;=0) <span class="built_in">return</span> NULL;</span><br><span class="line">   <span class="keyword">if</span>(str[i]==<span class="string">'#'</span>) <span class="built_in">return</span> NULL;</span><br><span class="line">   bt-&gt;data =str[i];</span><br><span class="line">   bt-&gt;lchild =CreateBTree(str,2*i); </span><br><span class="line">   bt-&gt;rchild =CreateBTree(str,2*i+1); </span><br><span class="line">   <span class="built_in">return</span> bt;</span><br><span class="line">&#125;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	char str[100]=&#123;<span class="string">'A'</span>,<span class="string">'B'</span>, <span class="string">'C'</span>,<span class="string">'D'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>, <span class="string">'I'</span>,<span class="string">'0'</span>,<span class="string">'0'</span>,<span class="string">'E'</span>, <span class="string">'0'</span>, <span class="string">'0'</span>, <span class="string">'H'</span>, <span class="string">'0'</span>, <span class="string">'0'</span>, <span class="string">'0'</span>, <span class="string">'0'</span>, <span class="string">'0'</span>, <span class="string">'0'</span>&#125;;</span><br><span class="line">	char pre[40]=<span class="string">"ABDFCEGH"</span>;</span><br><span class="line">	char <span class="keyword">in</span>[40]=<span class="string">"BFDAGEHC"</span>;</span><br><span class="line">	char in1[40]=<span class="string">"BDCEAFHG"</span>;</span><br><span class="line">	char ord[40]=<span class="string">"DECBHGFA"</span>;</span><br><span class="line">	string seq=<span class="string">"ABCD#EF#G######"</span>;</span><br><span class="line">	int height;</span><br><span class="line">	BTree BT;</span><br><span class="line">	BTree BT1;</span><br><span class="line">	BTree BT2; </span><br><span class="line">	BT=CreateBT1(pre,<span class="keyword">in</span>,8);</span><br><span class="line">	LevelOrder(BT);</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">    BT1=CreateBT2(ord,in1,8);</span><br><span class="line">    LevelOrder(BT1);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    BT2=CreateBTree(seq,0);</span><br><span class="line">    LevelOrder(BT2); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>0x3哈夫曼编码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;	char data;		//节点值</span><br><span class="line">	<span class="built_in">float</span> weight;	//权重</span><br><span class="line">	int parent;		//双亲节点</span><br><span class="line">	int lchild;		//左孩子节点</span><br><span class="line">	int rchild;		//右孩子节点</span><br><span class="line">&#125; HTNode; </span><br><span class="line"></span><br><span class="line">//初始化哈夫曼编码 </span><br><span class="line">void CreateHT(HTNode ht[],int n)</span><br><span class="line">&#123;  int i,j,k,lnode,rnode; <span class="built_in">float</span> min1,min2;</span><br><span class="line">   //此处补充叶子节点相关设置</span><br><span class="line">   <span class="keyword">for</span> (i=0;i&lt;2*n-1;i++)	  	//所有节点的相关域置初值-1</span><br><span class="line">      ht[i].parent=ht[i].lchild=ht[i].rchild=-1;</span><br><span class="line">   <span class="keyword">for</span> (i=n;i&lt;2*n-1;i++)		//构造哈夫曼树</span><br><span class="line">   &#123;  min1=min2=32767; lnode=rnode=-1;</span><br><span class="line">	<span class="keyword">for</span> (k=0;k&lt;=i-1;k++)</span><br><span class="line">	  <span class="keyword">if</span> (ht[k].parent==-1)		//未构造二叉树的节点中查找</span><br><span class="line">	  &#123;  <span class="keyword">if</span> (ht[k].weight&lt;min1)</span><br><span class="line">	     &#123;  min2=min1;rnode=lnode;</span><br><span class="line">		  min1=ht[k].weight;lnode=k;  &#125;</span><br><span class="line">	     <span class="keyword">else</span> <span class="keyword">if</span> (ht[k].weight&lt;min2)</span><br><span class="line">	     &#123;  min2=ht[k].weight;rnode=k;  &#125;   </span><br><span class="line">        &#125; //<span class="keyword">if</span></span><br><span class="line">	  ht[lnode].parent=i;ht[rnode].parent=i;</span><br><span class="line">        ht[i].weight=ht[lnode].weight+ht[rnode].weight;</span><br><span class="line">	  ht[i].lchild=lnode;ht[i].rchild=rnode;</span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">typedef struct&#123;  </span><br><span class="line">	 char <span class="built_in">cd</span>[10];  //存放当前节点的哈夫曼码   </span><br><span class="line">	 int start;//哈夫曼码在<span class="built_in">cd</span>中的起始位置</span><br><span class="line">&#125;HCode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//根据哈夫曼树求对应的哈夫曼编码的算法如下：</span><br><span class="line">void CreateHCode(HTNode ht[],HCode hcd[],int n)</span><br><span class="line">&#123;  int i,f,c; HCode hc;</span><br><span class="line">   <span class="keyword">for</span> (i=0;i&lt;n;i++)		//根据哈夫曼树求哈夫曼编码</span><br><span class="line">   &#123;  hc.start=n;c=i; f=ht[i].parent;</span><br><span class="line">	<span class="keyword">while</span> (f!=-1)   //循环直到无双亲节点即到达树根节点</span><br><span class="line">	&#123;  <span class="keyword">if</span> (ht[f].lchild==c)	//当前节点是左孩子节点</span><br><span class="line">	      hc.cd[hc.start--]=<span class="string">'0'</span>;</span><br><span class="line">	   <span class="keyword">else</span>	  		//当前节点是双亲节点的右孩子节点</span><br><span class="line">	      hc.cd[hc.start--]=<span class="string">'1'</span>;</span><br><span class="line">	   c=f;f=ht[f].parent; //再对双亲节点进行同样的操作</span><br><span class="line"> 	 &#125;</span><br><span class="line">	 hc.start++;		//start指向哈夫曼编码最开始字符</span><br><span class="line">       hcd[i]=hc;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">ye1s</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="https://blog.cfyqy.com/article/d0f18447.html">https://blog.cfyqy.com/article/d0f18447.html</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.cfyqy.com">ye1s</a>！</span></div></div><div class="post-copyright" id="comments-container"><script src="/js/comments/gitment.js"></script></div><script>let arr = location.href.split('/#more')[0].split('/');
let title = arr[arr.length - 1];
if (title === '') {
    title = arr[arr.length - 2]
}
var flag = false;
var gitFun = function () {
    try {
        var gitmentObj = window.GLOBAL_CONFIG.gitment;
        var gitment = new Gitment({
            id: decodeURI(title), // 可选。默认为 location.href
            owner: gitmentObj.owner,
            repo: gitmentObj.repo,
            oauth: {
                client_id: gitmentObj.client_id,
                client_secret: gitmentObj.client_secret
            },
        });
        gitment.render('comments-container');
        flag = true;
    } catch (e) {
        flag = false;
    }
}
var setIn = setInterval(() => {
    if (!flag) {
        gitFun();
    } else {
        clearInterval(setIn);
    }
}, 200);</script></article><div id="pagination"><div class="prev-post pull-left"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/article/4589eaf5.html"><i class="fas fa-angle-left">&nbsp;</i><span>c++思维导图</span></a></div><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/article/55e0ef1f.html"><span>c语言思维导图</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2017 ～ 2021 By ye1s</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/daovoice.js"></script><!--script(src=url)--><div class="search-dialog"><div id="algolia-search-title">Algolia</div><div class="search-close-button"><i class="fa fa-times"></i></div><!--div#current-refined-values--><!--div#clear-all--><div id="search-box"></div><!--div#refinement-list--><hr><div id="hits"></div><div id="algolia-pagination"></div></div><div class="search-mask"></div><script src="/js/search/algolia.js"></script></body></html>