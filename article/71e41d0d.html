<!DOCTYPE html><html><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="python的迭代器和生成器"><meta name="keywords" content="python,迭代器,生成器"><meta name="author" content="ye1s,undefined"><meta name="copyright" content="ye1s"><title>python的迭代器和生成器【ye1s】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch-theme-algolia.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4"></script><!-- link(rel="dns-prefetch" href="https://cdn.jsdelivr.net")--><!-- link(rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css")--><!-- script(src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer)--><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"LKL6Q0GQJM","apiKey":"03829f64e2f5c11e4a5e2b8e51e24eb9","indexName":"blog","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  gitment: {"owner":"ye1sec","repo":"comments","client_id":"d5ece338867af32b6dfa","client_secret":"2caf36bbd47977524017f95105315fc9e65f0577"},
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="ye1s" type="application/atom+xml">
</head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0x1容器-container"><span class="toc-number">1.</span> <span class="toc-text">0x1容器(container)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x2可迭代对象-iterable"><span class="toc-number">2.</span> <span class="toc-text">0x2可迭代对象(iterable)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x3迭代器"><span class="toc-number">3.</span> <span class="toc-text">0x3迭代器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x4生成器"><span class="toc-number">4.</span> <span class="toc-text">0x4生成器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x5-迭代器的问题与解法-扩展"><span class="toc-number">5.</span> <span class="toc-text">0x5 迭代器的问题与解法(扩展)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x5-1手动访问迭代器中的元素"><span class="toc-number">5.1.</span> <span class="toc-text">0x5.1手动访问迭代器中的元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x5-2委托迭代"><span class="toc-number">5.2.</span> <span class="toc-text">0x5.2委托迭代</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x5-3用生成器来创建新的迭代模式"><span class="toc-number">5.3.</span> <span class="toc-text">0x5.3用生成器来创建新的迭代模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x5-5反向迭代"><span class="toc-number">5.4.</span> <span class="toc-text">0x5.5反向迭代</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x5-6定义带有额外状态的生成器函数"><span class="toc-number">5.5.</span> <span class="toc-text">0x5.6定义带有额外状态的生成器函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x5-7对迭代器做切片操作"><span class="toc-number">5.6.</span> <span class="toc-text">0x5.7对迭代器做切片操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x5-8跳过不需要的迭代部分"><span class="toc-number">5.7.</span> <span class="toc-text">0x5.8跳过不需要的迭代部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x5-9迭代所有可能的组合或排列"><span class="toc-number">5.8.</span> <span class="toc-text">0x5.9迭代所有可能的组合或排列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x5-10以索引-值对的形式迭代序列"><span class="toc-number">5.9.</span> <span class="toc-text">0x5.10以索引-值对的形式迭代序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x5-11同时迭代多个序列"><span class="toc-number">5.10.</span> <span class="toc-text">0x5.11同时迭代多个序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x5-12-在不同容器中进行迭代"><span class="toc-number">5.11.</span> <span class="toc-text">0x5.12 在不同容器中进行迭代</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x5-13扁平化处理嵌套型序列"><span class="toc-number">5.12.</span> <span class="toc-text">0x5.13扁平化处理嵌套型序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x5-14合并多个有序序列再迭代"><span class="toc-number">5.13.</span> <span class="toc-text">0x5.14合并多个有序序列再迭代</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x5-15迭代器代替while循环"><span class="toc-number">5.14.</span> <span class="toc-text">0x5.15迭代器代替while循环</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">ye1s</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/ye1sec" target="_blank">GitHub<i class="icon-dot bg-color9"></i></a><a class="links-button button-hover" href="mailto:431774437@qq.com" target="_blank">E-Mail<i class="icon-dot bg-color1"></i></a><a class="links-button button-hover" href="tencent://message/?uin=431774437&amp;Site=&amp;Menu=yes" target="_blank">QQ<i class="icon-dot bg-color1"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">200</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">149</span></a><a class="author-info-articles-categories article-meta" href="/categories"><span class="pull-top">分类</span><span class="pull-bottom">12</span></a></div><div class="friend-link"><a class="friend-link-text" href="http://www.m00nback.xyz/" target="_blank">MoonBack</a><a class="friend-link-text" target="_blank">待定</a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="search social-icon"><i class="fas fa-search"></i><span> 搜索</span></a><a class="title-name" href="/">ye1s</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">python的迭代器和生成器</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2019-05-28 | 更新于 2020-04-13</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/">编程算法</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/python/">python</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8/">迭代器</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E7%94%9F%E6%88%90%E5%99%A8/">生成器</a></div></div></div><div class="main-content"><p>容器(container)、可迭代对象(iterable)、迭代器(iterator)、生成器(generator)、列表/集合/字典推导式(list,set,dict comprehension)众多概念,有点复杂，整理一下。    </p>
<a id="more"></a>
<p><img src="../../images/python/python/cig.png" alt=""><br>详情可以看一篇文章:<a href="https://foofish.net/iterators-vs-generators.ht" target="_blank" rel="noopener">https://foofish.net/iterators-vs-generators.ht</a></p>
<h1 id="0x1容器-container"><a href="#0x1容器-container" class="headerlink" title="0x1容器(container)"></a>0x1容器(container)</h1><p>容器是一种把多个元素组织在一起的数据结构，容器中的元素可以逐个地迭代获取，可以用in, not in关键字判断元素是否包含在容器中。通常这类数据结构把所有的元素存储在内存中（也有一些特例，并不是所有的元素都放在内存，比如迭代器和生成器对象）<br>在Python中，常见的容器对象有： </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list, deque, ....</span><br><span class="line"><span class="built_in">set</span>, frozensets, ....</span><br><span class="line">dict, defaultdict, OrderedDict, Counter, ....</span><br><span class="line">tuple, namedtuple, …</span><br><span class="line">str</span><br></pre></td></tr></table></figure>
<p>容器比较容易理解，因为你就可以把它看作是一个盒子、一栋房子、一个柜子，里面可以塞任何东西。从技术角度来说，当它可以用来询问某个元素是否包含在其中时，那么这个对象就可以认为是一个容器，比如 list，set，tuples都是容器对象： </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 4 not <span class="keyword">in</span> [1, 2, 3]</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; 1 <span class="keyword">in</span> [1, 2, 3]</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>尽管绝大多数容器都提供了某种方式来获取其中的每一个元素，但这并不是容器本身提供的能力，而是可迭代对象赋予了容器这种能力，当然并不是所有的容器都是可迭代的，比如：<a href="https://zh.wikipedia.org/wiki/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8" target="_blank" rel="noopener">Bloom filter</a>，虽然Bloom filter可以用来检测某个元素是否包含在容器中，但是并不能从容器中获取其中的每一个值，因为Bloom filter压根就没把元素存储在容器中，而是通过一个散列函数映射成一个值保存在数组中。  </p>
<h1 id="0x2可迭代对象-iterable"><a href="#0x2可迭代对象-iterable" class="headerlink" title="0x2可迭代对象(iterable)"></a>0x2可迭代对象(iterable)</h1><p><strong>0x2.1可迭代对象的理解</strong>   </p>
<p>迭代器协议是指：对象需要提供next方法，它要么返回迭代中的下一项，要么就引起一个StopIteration异常，以终止迭代<br>可迭代对象就是：实现了迭代器协议的对象<br>协议是一种约定，可迭代对象实现迭代器协议，Python的内置工具(如for循环，sum，min，max函数等)使用迭代器协议访问对象。<br>举个例子理解一下:  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; y = iter(x)</span><br><span class="line">&gt;&gt;&gt; z = iter(x)</span><br><span class="line">&gt;&gt;&gt; next(y)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; next(y)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; next(z)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">type</span>(x)</span><br><span class="line">&lt;class <span class="string">'list'</span>&gt;</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">type</span>(y)</span><br><span class="line">&lt;class <span class="string">'list_iterator'</span>&gt;</span><br></pre></td></tr></table></figure>
<p>这里x是一个可迭代对象，可迭代对象和容器一样是一种通俗的叫法，并不是指某种具体的数据类型，list是可迭代对象，dict是可迭代对象，set也是可迭代对象。y和z是两个独立的迭代器，迭代器内部持有一个状态，该状态用于记录当前迭代所在的位置，以方便下次迭代的时候获取正确的元素。迭代器有一种具体的迭代器类型，比如list_iterator，set_iterator。可迭代对象实现了<strong>iter</strong>方法，该方法返回一个迭代器对象。<br>当运行代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = [1, 2, 3]</span><br><span class="line"><span class="keyword">for</span> elem <span class="keyword">in</span> x:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>实际执行情况是：<br><img src="../../images/python/python/iterable-vs-iterator.png" alt=""><br>反编译该段代码，你可以看到解释器显示地调用GET_ITER指令，相当于调用iter(x)，FOR_ITER指令就是调用next()方法，不断地获取迭代器中的下一个元素，但是你没法直接从指令中看出来，因为他被解释器优化过了。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import dis</span><br><span class="line">&gt;&gt;&gt; x=[1,2,3]</span><br><span class="line">&gt;&gt;&gt; dis.dis(<span class="string">'for _ in x:pass'</span>)</span><br><span class="line">  1           0 SETUP_LOOP              12 (to 14)</span><br><span class="line">              2 LOAD_NAME                0 (x)</span><br><span class="line">              4 GET_ITER</span><br><span class="line">        &gt;&gt;    6 FOR_ITER                 4 (to 12)</span><br><span class="line">              8 STORE_NAME               1 (_)</span><br><span class="line">             10 JUMP_ABSOLUTE            6</span><br><span class="line">        &gt;&gt;   12 POP_BLOCK</span><br><span class="line">        &gt;&gt;   14 LOAD_CONST               0 (None)</span><br><span class="line">             16 RETURN_VALUE</span><br></pre></td></tr></table></figure>

<p><strong>0x2.2 可迭代对象的判断</strong><br>可以直接作用于for循环的数据类型有以下几种：<br>一类是集合数据类型，如list、tuple、dict、set、str等；<br>一类是generator，包括生成器和带yield的generator function。<br>这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。<br>可以使用isinstance()判断一个对象是否是Iterable对象：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from collections import Iterable</span><br><span class="line">&gt;&gt;&gt; isinstance([], Iterable)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(&#123;&#125;, Iterable)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(<span class="string">'abc'</span>, Iterable)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance((x <span class="keyword">for</span> x <span class="keyword">in</span> range(10)), Iterable)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(100, Iterable)</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<h1 id="0x3迭代器"><a href="#0x3迭代器" class="headerlink" title="0x3迭代器"></a>0x3迭代器</h1><p><strong>0x3.1迭代器的概念</strong><br>实现了<code>__iter__</code>和<code>__next__</code>方法的对象都称为迭代器。迭代器是一个有状态的对象，在调用next() 的时候返回下一个值，如果容器中没有更多元素了，则抛出StopIteration异常<br>所以，迭代器就是实现了工厂模式的对象，它在你每次你询问要下一个值的时候给你返回。<br><strong>0x3.2迭代器的特点</strong><br>迭代是Python最强大的功能之一，是访问集合元素的一种方式。<br>迭代器是一个可以记住遍历的位置的对象。<br>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。  迭代器只能往前不会后退。<br>迭代器有两个基本的方法：iter() 和 next()。<br><strong>0x3.3迭代器的例子</strong><br>有很多关于迭代器的例子，比如itertools函数返回的都是迭代器对象。<br>生成无限序列：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from itertools import count</span><br><span class="line">&gt;&gt;&gt; counter = count(start=13)</span><br><span class="line">&gt;&gt;&gt; next(counter)</span><br><span class="line">13</span><br><span class="line">&gt;&gt;&gt; next(counter)</span><br><span class="line">14</span><br></pre></td></tr></table></figure>
<p>从一个有限序列中生成无限序列：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from itertools import cycle</span><br><span class="line">&gt;&gt;&gt; colors = cycle([<span class="string">'red'</span>, <span class="string">'white'</span>, <span class="string">'blue'</span>])</span><br><span class="line">&gt;&gt;&gt; next(colors)</span><br><span class="line"><span class="string">'red'</span></span><br><span class="line">&gt;&gt;&gt; next(colors)</span><br><span class="line"><span class="string">'white'</span></span><br><span class="line">&gt;&gt;&gt; next(colors)</span><br><span class="line"><span class="string">'blue'</span></span><br><span class="line">&gt;&gt;&gt; next(colors)</span><br><span class="line"><span class="string">'red'</span></span><br></pre></td></tr></table></figure>
<p>从无限的序列中生成有限序列：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from itertools import islice</span><br><span class="line">&gt;&gt;&gt; colors = cycle([<span class="string">'red'</span>, <span class="string">'white'</span>, <span class="string">'blue'</span>])  <span class="comment"># infinite</span></span><br><span class="line">&gt;&gt;&gt; limited = islice(colors, 0, 4)            <span class="comment"># finite</span></span><br><span class="line">&gt;&gt;&gt; <span class="keyword">for</span> x <span class="keyword">in</span> limited:                         </span><br><span class="line">...     <span class="built_in">print</span>(x)</span><br><span class="line">red</span><br><span class="line">white</span><br><span class="line">blue</span><br><span class="line">red</span><br></pre></td></tr></table></figure>
<p><strong>0x3.4迭代器的创建</strong><br>把一个类作为一个迭代器使用需要在类中实现两个方法 <strong>iter</strong>() 与 <strong>next</strong>() 。<br><code>__iter__()</code> :方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 <code>__next__()</code> 方法并通过 StopIteration 异常标识迭代的完成。<br><code>__next__()</code> :方法（Python 2 里是 next()）会返回下一个迭代器对象。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from itertools import islice</span><br><span class="line">class Fib:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.prev = 0</span><br><span class="line">        self.curr = 1</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        <span class="built_in">return</span> self</span><br><span class="line"></span><br><span class="line">    def __next__(self):</span><br><span class="line">        value = self.curr</span><br><span class="line">        self.curr += self.prev</span><br><span class="line">        self.prev = value</span><br><span class="line">        <span class="built_in">return</span> value</span><br><span class="line">f=Fib()</span><br><span class="line"><span class="built_in">print</span>(list(islice(f,0,10)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</span><br><span class="line">[Finished <span class="keyword">in</span> 0.2s]</span><br></pre></td></tr></table></figure>
<p>Fib既是一个可迭代对象（因为它实现了<strong>iter</strong>方法），又是一个迭代器（因为实现了<strong>next</strong>方法）。实例变量prev和curr用户维护迭代器内部的状态。每次调用next()方法的时候做两件事：     </p>
<p>为下一次调用next()方法修改状态<br>为当前这次调用生成返回结果    </p>
<p>迭代器就像一个懒加载的工厂，等到有人需要的时候才给它生成值返回，没调用的时候就处于休眠状态等待下一次调用。<br><strong>0x3.5StopIteration</strong><br>StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在 <strong>next</strong>() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。<br>斐波那契数列范例：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class MyNumbers:</span><br><span class="line">  def __iter__(self):</span><br><span class="line">    self.a = 1</span><br><span class="line">    <span class="built_in">return</span> self</span><br><span class="line"></span><br><span class="line">  def __next__(self):</span><br><span class="line">    <span class="keyword">if</span> self.a &lt;= 21:</span><br><span class="line">      x = self.a</span><br><span class="line">      self.a += 1</span><br><span class="line">      <span class="built_in">return</span> x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      raise StopIteration</span><br><span class="line"></span><br><span class="line">myclass = MyNumbers()</span><br><span class="line">myiter = iter(myclass)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> myiter:</span><br><span class="line">  <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>

<h1 id="0x4生成器"><a href="#0x4生成器" class="headerlink" title="0x4生成器"></a>0x4生成器</h1><p><strong>0x4.1生成器的概念以及范例</strong><br>生成器其实是一种特殊的迭代器，但是不需要像迭代器一样实现<strong>iter</strong>和<strong>next</strong>方法，只需要使用关键字yield就可以。<br>在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。    </p>
<p>调用一个生成器函数，返回的是一个迭代器对象<br>斐波那契数列例子:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def fib():</span><br><span class="line">    prev, curr = 0, 1</span><br><span class="line">    <span class="keyword">while</span> True:</span><br><span class="line">        yield curr</span><br><span class="line">        prev, curr = curr, curr + prev</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; f = fib()</span><br><span class="line">&gt;&gt;&gt; list(islice(f, 0, 10))</span><br><span class="line">[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]</span><br></pre></td></tr></table></figure>
<p>fib就是一个普通的python函数，它特殊的地方在于函数体中没有return关键字，函数的返回值是一个生成器对象。当执行f=fib()返回的是一个生成器对象，此时函数体中的代码并不会执行，只有显示或隐示地调用next的时候才会真正执行里面的代码。<br>生成器在Python中是一个非常强大的编程结构，可以用更少地中间变量写流式代码，此外，相比其它容器对象它更能节省内存和CPU，当然它可以用更少的代码来实现相似的功能。现在就可以动手重构你的代码了，但凡看到类似：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def something():</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> ... <span class="keyword">in</span> ...:</span><br><span class="line">        result.append(x)</span><br><span class="line">    <span class="built_in">return</span> result</span><br></pre></td></tr></table></figure>

<p>都可以用生成器函数来替换：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def iter_something():</span><br><span class="line">    <span class="keyword">for</span> ... <span class="keyword">in</span> ...:</span><br><span class="line">        yield x</span><br></pre></td></tr></table></figure>

<p><strong>0x4.2生成器表达式</strong><br>生成器表达式是列表推倒式的生成器版本，看起来像列表推导式，但是它返回的是一个生成器对象而不是列表对象。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = (x*x <span class="keyword">for</span> x <span class="keyword">in</span> range(10))</span><br><span class="line">&gt;&gt;&gt; a</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at 0x401f08&gt;</span><br><span class="line">&gt;&gt;&gt; sum(a)</span><br><span class="line">285</span><br></pre></td></tr></table></figure>
<h1 id="0x5-迭代器的问题与解法-扩展"><a href="#0x5-迭代器的问题与解法-扩展" class="headerlink" title="0x5 迭代器的问题与解法(扩展)"></a>0x5 迭代器的问题与解法(扩展)</h1><h2 id="0x5-1手动访问迭代器中的元素"><a href="#0x5-1手动访问迭代器中的元素" class="headerlink" title="0x5.1手动访问迭代器中的元素"></a>0x5.1手动访问迭代器中的元素</h2><p>问题:<br>在处理某个可迭代对象中的元素，因为某些原因，不能也不想使用for循环。<br>解决方案:<br>使用next()函数。<br>例子: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">with open(<span class="string">'h://flag.txt'</span>,<span class="string">'r'</span>) as f:</span><br><span class="line">	try:</span><br><span class="line">		<span class="keyword">while</span> True:</span><br><span class="line">			line=next(f)</span><br><span class="line">			<span class="built_in">print</span>(line,end=<span class="string">''</span>)</span><br><span class="line">	except StopIteration:</span><br><span class="line">		pass</span><br></pre></td></tr></table></figure>
<p>如果是手动使用next(),也可以命令它返回一个结束值，比如说None<br>示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">with open(<span class="string">'h://flag.txt'</span>,<span class="string">'r'</span>) as f:</span><br><span class="line">	<span class="keyword">while</span> True:</span><br><span class="line">		line=next(f,None)</span><br><span class="line">		<span class="keyword">if</span> line is None:</span><br><span class="line">			<span class="built_in">break</span></span><br><span class="line">		<span class="built_in">print</span>(line,end=<span class="string">''</span>)</span><br></pre></td></tr></table></figure>
<h2 id="0x5-2委托迭代"><a href="#0x5-2委托迭代" class="headerlink" title="0x5.2委托迭代"></a>0x5.2委托迭代</h2><p>问题:<br>我们构建了一个自定义的容器对象，其内部持有一个列表、元组或其他的可迭代对象。我们想让自己的容器能够完成迭代操作。<br>解决方案:<br>一般来说，我们所要做的就是定义一个<code>__iter__()</code>方法,将迭代请求委托到对象内部持有的容器上。   </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Node():</span><br><span class="line">	def __init__(self,value):</span><br><span class="line">		self._value=value</span><br><span class="line">		self._children=[]</span><br><span class="line">	def __repr__(self):<span class="comment">#这个函数就是在打印类的时候，控制类输出的字符串相当于java中的toString()</span></span><br><span class="line">		<span class="built_in">return</span> <span class="string">'Node(&#123;&#125;)'</span>.format(self._value)</span><br><span class="line">	def add_child(self,node):</span><br><span class="line">		self._children.append(node)</span><br><span class="line">	def __iter__(self):</span><br><span class="line">		<span class="built_in">return</span> iter(self._children)</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">	root=Node(0)</span><br><span class="line">	child1=Node(1)</span><br><span class="line">	child2=Node(2)</span><br><span class="line">	root.add_child(child1)</span><br><span class="line">	root.add_child(child2)</span><br><span class="line">	<span class="keyword">for</span> ch <span class="keyword">in</span> root:</span><br><span class="line">		<span class="built_in">print</span>(ch)</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">Node(1)</span><br><span class="line">Node(2)</span><br><span class="line">[Finished <span class="keyword">in</span> 0.2s]</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>__iter__</code>方法只是简单地将迭代请求转发 给对象内部持有 的<code>_childer</code>属相上。<br>iter(s)通过调用 <code>s.__iter__()</code>来简单的返回底层迭代器。   </p>
<h2 id="0x5-3用生成器来创建新的迭代模式"><a href="#0x5-3用生成器来创建新的迭代模式" class="headerlink" title="0x5.3用生成器来创建新的迭代模式"></a>0x5.3用生成器来创建新的迭代模式</h2><p>问题：<br>我们向自定义一个迭代模式，使其区别于常见的内建函数(即range(),reversed()等)<br>解决方法:<br>可使用生成器函数来定义 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def frange(start,stop,increment):</span><br><span class="line">	x=start</span><br><span class="line">	<span class="keyword">while</span> x&lt;stop:</span><br><span class="line">		yield x</span><br><span class="line">		x+=increment</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> frange(0,2,0.4):</span><br><span class="line">	<span class="built_in">print</span>(n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">0</span><br><span class="line">0.4</span><br><span class="line">0.8</span><br><span class="line">1.2000000000000002</span><br><span class="line">1.6</span><br><span class="line"><span class="comment">#主要还是因浮点数在计算机中实际是以二进制保存的，有些数不精确</span></span><br></pre></td></tr></table></figure>
<p>0x5.4实现迭代协议<br>问题:<br>我们正在构建一个自定义的对象，希望它可以支持迭代操作，但是也希望有一种简单的方式来实现迭代协议。<br>解决方案:<br>目前来看，要在对象上实现可迭代功能，最简单的方式就是使用生成器函数。<br>范例:<br>实现一个迭代器能够以深度优先的模式遍历树的节点    </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Node(object):</span><br><span class="line">	def __init__(self, value):</span><br><span class="line">		self._value = value</span><br><span class="line">		self._children =[]</span><br><span class="line"></span><br><span class="line">	def __repr__(self):</span><br><span class="line">		<span class="built_in">return</span> <span class="string">"Node&#123;!r&#125;"</span>.format(self._value)</span><br><span class="line"></span><br><span class="line">	def __iter__(self):</span><br><span class="line">		<span class="built_in">return</span> iter(self._children)</span><br><span class="line"></span><br><span class="line">	def add_child(self, node):</span><br><span class="line">		<span class="built_in">return</span> self._children.append(node)</span><br><span class="line"></span><br><span class="line">	def depth_first(self):</span><br><span class="line"></span><br><span class="line">		yield self</span><br><span class="line">		<span class="keyword">for</span> c <span class="keyword">in</span> self:</span><br><span class="line">			<span class="comment">#下面的代码相当于yield from c.depth_first()</span></span><br><span class="line">			<span class="keyword">for</span> items <span class="keyword">in</span> c.depth_first():</span><br><span class="line">				yield items</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">	root = Node(0)</span><br><span class="line">	child1 = Node(1)</span><br><span class="line">	child2 = Node(2)</span><br><span class="line">	root.add_child(child1)</span><br><span class="line">	root.add_child(child2)</span><br><span class="line">	child1.add_child(Node(3))</span><br><span class="line">	child2.add_child(Node(4))</span><br><span class="line">	child1.add_child(Node(5))</span><br><span class="line">	<span class="keyword">for</span> ch <span class="keyword">in</span> root.depth_first():</span><br><span class="line">		<span class="built_in">print</span>(ch)</span><br></pre></td></tr></table></figure>
<h2 id="0x5-5反向迭代"><a href="#0x5-5反向迭代" class="headerlink" title="0x5.5反向迭代"></a>0x5.5反向迭代</h2><p>问题：<br>我们想要反向迭代序列中的元素<br>解决方案:<br>可以使用内建的reversed()函数实现反向迭代   </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=[1,2,3,4]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> reversed(a):</span><br><span class="line">	<span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>
<p>反向迭代的条件:<br>只有在待处理的对象有用可确定的大小，或者对象实现了<code>__reversed__()</code>特殊方法时,才能奏效。<br>如果这两个条件都无法满足，则必须首先将这个对象转化为列表。   </p>
<p>可以在自定义的类上实现<code>__reversed__()</code>方法，实现反向迭代<br>例如:   </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Countdown(object):</span><br><span class="line">    def __init__(self, start):</span><br><span class="line">        self.start = start</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        n = self.start</span><br><span class="line">        <span class="keyword">while</span> n &gt; 0:</span><br><span class="line">            yield n</span><br><span class="line">            n -= 1</span><br><span class="line"></span><br><span class="line">    def __reversed__(self):</span><br><span class="line">        n = 1</span><br><span class="line">        <span class="keyword">while</span> n &lt;= self.start:</span><br><span class="line">            yield n</span><br><span class="line">            n += 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> rr <span class="keyword">in</span> reversed(Countdown(30)):</span><br><span class="line">        <span class="built_in">print</span>(rr)</span><br><span class="line">    <span class="keyword">for</span> rr <span class="keyword">in</span> Countdown(30):</span><br><span class="line">        <span class="built_in">print</span>(rr)</span><br></pre></td></tr></table></figure>
<h2 id="0x5-6定义带有额外状态的生成器函数"><a href="#0x5-6定义带有额外状态的生成器函数" class="headerlink" title="0x5.6定义带有额外状态的生成器函数"></a>0x5.6定义带有额外状态的生成器函数</h2><p>问题：<br>我们想要定义一个生成器函数，但是它涉及一些额外的状态，我们希望能以某种形式将这些状态暴露给用户。<br>解决方案:<br>如果想让生成器将状态暴露给用户，别忘了可以轻易地将其实现为一个类，然后生成器函数的代码放到<code>__iter__()</code>方法中。   </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">from collections import deque</span><br><span class="line"></span><br><span class="line">class LineHistory:</span><br><span class="line">    def __init__(self, lines, hislen=3):</span><br><span class="line">        self.lines = lines</span><br><span class="line">        self.history = deque(maxlen=hislen)</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        <span class="keyword">for</span> lineno, line <span class="keyword">in</span> enumerate(self.lines, 1):</span><br><span class="line">            self.history.append((lineno, line))</span><br><span class="line">            yield line</span><br><span class="line"></span><br><span class="line">    def clear(self):</span><br><span class="line">        self.history.clear()</span><br><span class="line">with open(<span class="string">'h://flag.txt'</span>,<span class="string">'r'</span>) as f:</span><br><span class="line">	lines=LineHistory(f)</span><br><span class="line">	<span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">		<span class="keyword">if</span> <span class="string">'hello'</span> <span class="keyword">in</span> line:</span><br><span class="line">			<span class="keyword">for</span> lineno,hline <span class="keyword">in</span> lines.history:</span><br><span class="line">				<span class="built_in">print</span>(<span class="string">'&#123;&#125;:&#123;&#125;'</span>.format(lineno,hline,end=<span class="string">''</span>))</span><br></pre></td></tr></table></figure>
<h2 id="0x5-7对迭代器做切片操作"><a href="#0x5-7对迭代器做切片操作" class="headerlink" title="0x5.7对迭代器做切片操作"></a>0x5.7对迭代器做切片操作</h2><p>问题：<br>我们相对迭代器产生的数据做切片处理，但是普通的切片操作符在这里不管用。<br>解决方案:<br>要对迭代器和生成器做切片操作，itertools.islice()函数是完美的选择。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import itertools</span><br><span class="line">def count(n):</span><br><span class="line">    <span class="keyword">while</span> True:</span><br><span class="line">        yield n</span><br><span class="line">        n += 1</span><br><span class="line">c = count(0)</span><br><span class="line"><span class="comment"># c[10:20]  &gt;&gt;&gt;TypeError: 'generator' object has no attribute '__getitem__'</span></span><br><span class="line"><span class="keyword">for</span> items <span class="keyword">in</span> itertools.islice(c, 10, 21):</span><br><span class="line">    <span class="built_in">print</span>(items)</span><br></pre></td></tr></table></figure>
<p>函数 islice() 返回一个可以生成指定元素的迭代器,它通过遍<br>历并丢弃直到切片开始索引位置的所有元素。然后才开始一个个的返回元素,并直到切片结束索引位置。缺点不能重复使用迭代器里面的数据   </p>
<h2 id="0x5-8跳过不需要的迭代部分"><a href="#0x5-8跳过不需要的迭代部分" class="headerlink" title="0x5.8跳过不需要的迭代部分"></a>0x5.8跳过不需要的迭代部分</h2><p>使用itertools.dropwhile()函数实现<br>范例:  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from itertools import dropwhile</span><br><span class="line">with open(<span class="string">'h://flag.txt'</span>,<span class="string">'r'</span>) as f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> dropwhile(lambda line: line.startswith(<span class="string">"h"</span>), f):</span><br><span class="line">        <span class="built_in">print</span>(line,end=<span class="string">''</span>)</span><br></pre></td></tr></table></figure>
<h2 id="0x5-9迭代所有可能的组合或排列"><a href="#0x5-9迭代所有可能的组合或排列" class="headerlink" title="0x5.9迭代所有可能的组合或排列"></a>0x5.9迭代所有可能的组合或排列</h2><p><code>itertools.permutaions()</code> 接受一个元素集合，将其中所有的元素重排列为所有可能的情况，并以元组序列的形式返回<br><code>itertools.conbiations()</code>可产生输入序列中所有元素的全部组合形式 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from itertools import permutations,combinations, combinations_with_replacement</span><br><span class="line">items = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> permutations(items): <span class="comment"># 排列A33</span></span><br><span class="line">	<span class="built_in">print</span>(c)</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> permutations(items, 2): <span class="comment"># 排列A33</span></span><br><span class="line">	<span class="built_in">print</span>(c)</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> combinations(items, 3): <span class="comment"># 组合 C23</span></span><br><span class="line">	<span class="built_in">print</span>(c)</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> combinations_with_replacement(items, 3): <span class="comment"># 同一元素重复使用 3*3*3</span></span><br><span class="line">	<span class="built_in">print</span>(c)</span><br></pre></td></tr></table></figure>
<h2 id="0x5-10以索引-值对的形式迭代序列"><a href="#0x5-10以索引-值对的形式迭代序列" class="headerlink" title="0x5.10以索引-值对的形式迭代序列"></a>0x5.10以索引-值对的形式迭代序列</h2><p>内建的enumerate()函数解决</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="keyword">for</span> idx, val <span class="keyword">in</span> enumerate(my_list, 1):</span><br><span class="line"><span class="built_in">print</span>(idx, val)</span><br></pre></td></tr></table></figure>
<p>zip(a,b)的工作原理是创建出一个迭代器，该迭代器可产生出元组(x,y),这里的x取自序列啊，而y取自序列b。   </p>
<h2 id="0x5-11同时迭代多个序列"><a href="#0x5-11同时迭代多个序列" class="headerlink" title="0x5.11同时迭代多个序列"></a>0x5.11同时迭代多个序列</h2><p>使用zip()函数来同时迭代多个序列  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = [1, 2, 3]</span><br><span class="line">b = [<span class="string">'w'</span>, <span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> zip(a,b):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">(1, <span class="string">'w'</span>)</span><br><span class="line">(2, <span class="string">'x'</span>)</span><br><span class="line">(3, <span class="string">'y'</span>)</span><br><span class="line">[Finished <span class="keyword">in</span> 0.2s]</span><br></pre></td></tr></table></figure>
<p>打包字典。变成序列。  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">headers = [<span class="string">'name'</span>, <span class="string">'shares'</span>, <span class="string">'price'</span>]</span><br><span class="line">values = [<span class="string">'ACME'</span>, 100, 490.1]</span><br><span class="line">s = dict(zip(headers,values))</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line">list(zip(headers, values))</span><br></pre></td></tr></table></figure>
<h2 id="0x5-12-在不同容器中进行迭代"><a href="#0x5-12-在不同容器中进行迭代" class="headerlink" title="0x5.12 在不同容器中进行迭代"></a>0x5.12 在不同容器中进行迭代</h2><p>itetools.chain()可接受一个或多个可迭代对象作为参数，然后它会创建一个迭代器，该迭代器可连续访问你提供的每个可迭代对象中的元素。   </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from itertools import chain</span><br><span class="line">a = (1, 2, 3, 4)</span><br><span class="line">b = [<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> chain(a, b):</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>
<h2 id="0x5-13扁平化处理嵌套型序列"><a href="#0x5-13扁平化处理嵌套型序列" class="headerlink" title="0x5.13扁平化处理嵌套型序列"></a>0x5.13扁平化处理嵌套型序列</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from collections import Iterable</span><br><span class="line">def flatten(items, ignore_types=(str, bytes)):</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> items:</span><br><span class="line">    <span class="comment">#isinstance(x, Iterable) 判断是否可以迭代 ，可以则继续递归</span></span><br><span class="line">    <span class="comment">#not isinstance(x, ignore_types)，排除字符串，字节，这两者也可以迭代</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(x, Iterable) and not isinstance(x, ignore_types):</span><br><span class="line">        	yield from flatten(x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            yield x</span><br><span class="line">items1 = [1, 2, [3, 4, [5, 6], 7], 8]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> flatten(items1):</span><br><span class="line">	<span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure>
<h2 id="0x5-14合并多个有序序列再迭代"><a href="#0x5-14合并多个有序序列再迭代" class="headerlink" title="0x5.14合并多个有序序列再迭代"></a>0x5.14合并多个有序序列再迭代</h2><p>heapq.merge()<br>heapq.merge 生成器迭代特性意味着它不会立马读取所有序列。这就意味着你可以在非<br>常长的序列中使用它,而不会有太大的开销    </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import heapq</span><br><span class="line">a = [1, 4, 7, 10]</span><br><span class="line">b = [2, 5, 6, 11]</span><br><span class="line">l = [x <span class="keyword">for</span> x <span class="keyword">in</span> heapq.merge(a, b)]</span><br></pre></td></tr></table></figure>
<h2 id="0x5-15迭代器代替while循环"><a href="#0x5-15迭代器代替while循环" class="headerlink" title="0x5.15迭代器代替while循环"></a>0x5.15迭代器代替while循环</h2><p>其实就是用遍历代替while.<br>途径:iter(functiong, status)能够迭代<br>常见的IO程序,伪代码     </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CHUNKSIZE = 8192</span><br><span class="line">def reader(s):</span><br><span class="line">    <span class="keyword">while</span> True:</span><br><span class="line">        data = s.recv(CHUNKSIZE)</span><br><span class="line">        <span class="keyword">if</span> data == b<span class="string">''</span>:</span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">        process_data(data)</span><br><span class="line"> </span><br><span class="line">f = open(<span class="string">"views.py"</span>, <span class="string">"r"</span>)</span><br><span class="line">reader(f)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#用iter()循环代替</span></span><br><span class="line">def reader2(s):</span><br><span class="line">    <span class="keyword">for</span> chunk <span class="keyword">in</span> iter(lambda : s.recv(CHUNKSIZE),b<span class="string">""</span>):</span><br><span class="line">        pass</span><br><span class="line">        <span class="comment">#process_data(data)</span></span><br></pre></td></tr></table></figure>

<p>实例代码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">f = open(<span class="string">"views.py"</span>,<span class="string">"r"</span>)</span><br><span class="line"><span class="keyword">for</span> chunk <span class="keyword">in</span> iter(lambda: f.read(10), <span class="string">""</span>):</span><br><span class="line">    n = sys.stdout.write(chunk)</span><br></pre></td></tr></table></figure>
<p>作者：brother阿张<br>链接：<a href="https://www.jianshu.com/p/083cb153c623" target="_blank" rel="noopener">https://www.jianshu.com/p/083cb153c623</a><br>来源：简书<br>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。<br>参考文章:<br>完全理解Python迭代对象、迭代器、生成器  <a href="https://foofish.net/iterators-vs-generators.html" target="_blank" rel="noopener">https://foofish.net/iterators-vs-generators.html</a><br>廖雪峰的官方网站<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017323698112640" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1016959663602400/1017323698112640</a><br>如何更好地理解Python迭代器和生成器？ <a href="https://www.zhihu.com/question/20829330" target="_blank" rel="noopener">https://www.zhihu.com/question/20829330</a><br>pythoncookbook 第4章 生成器与迭代器<a href="https://www.jianshu.com/p/083cb153c623" target="_blank" rel="noopener">https://www.jianshu.com/p/083cb153c623</a></p>
</div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">ye1s</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="https://blog.cfyqy.com/article/71e41d0d.html">https://blog.cfyqy.com/article/71e41d0d.html</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.cfyqy.com">ye1s</a>！</span></div></div><div class="post-copyright" id="comments-container"><script src="/js/comments/gitment.js"></script></div><script>let arr = location.href.split('/#more')[0].split('/');
let title = arr[arr.length - 1];
if (title === '') {
    title = arr[arr.length - 2]
}
var flag = false;
var gitFun = function () {
    try {
        var gitmentObj = window.GLOBAL_CONFIG.gitment;
        var gitment = new Gitment({
            id: decodeURI(title), // 可选。默认为 location.href
            owner: gitmentObj.owner,
            repo: gitmentObj.repo,
            oauth: {
                client_id: gitmentObj.client_id,
                client_secret: gitmentObj.client_secret
            },
        });
        gitment.render('comments-container');
        flag = true;
    } catch (e) {
        flag = false;
    }
}
var setIn = setInterval(() => {
    if (!flag) {
        gitFun();
    } else {
        clearInterval(setIn);
    }
}, 200);</script></article><div id="pagination"><div class="prev-post pull-left"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/article/8fa1fc40.html"><i class="fas fa-angle-left">&nbsp;</i><span>python的编码与解码</span></a></div><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/article/86b11e8e.html"><span>python的常见数据类型</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2017 ～ 2021 By ye1s</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/daovoice.js"></script><!--script(src=url)--><div class="search-dialog"><div id="algolia-search-title">Algolia</div><div class="search-close-button"><i class="fa fa-times"></i></div><!--div#current-refined-values--><!--div#clear-all--><div id="search-box"></div><!--div#refinement-list--><hr><div id="hits"></div><div id="algolia-pagination"></div></div><div class="search-mask"></div><script src="/js/search/algolia.js"></script></body></html>