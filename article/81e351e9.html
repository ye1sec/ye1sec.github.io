<!DOCTYPE html><html><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="图解算法使用python笔记"><meta name="keywords" content="python,算法"><meta name="author" content="ye1s,undefined"><meta name="copyright" content="ye1s"><title>图解算法使用python笔记【ye1s】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch-theme-algolia.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4"></script><!-- link(rel="dns-prefetch" href="https://cdn.jsdelivr.net")--><!-- link(rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css")--><!-- script(src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer)--><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"LKL6Q0GQJM","apiKey":"03829f64e2f5c11e4a5e2b8e51e24eb9","indexName":"blog","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  gitment: {"owner":"ye1sec","repo":"comments","client_id":"d5ece338867af32b6dfa","client_secret":"2caf36bbd47977524017f95105315fc9e65f0577"},
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="ye1s" type="application/atom+xml">
</head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0x1算法"><span class="toc-number">1.</span> <span class="toc-text">0x1算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x2常见算法"><span class="toc-number">2.</span> <span class="toc-text">0x2常见算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x3数据结构类型"><span class="toc-number">3.</span> <span class="toc-text">0x3数据结构类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x4排序算法"><span class="toc-number">4.</span> <span class="toc-text">0x4排序算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x5查找与哈希算法"><span class="toc-number">5.</span> <span class="toc-text">0x5查找与哈希算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x6-数组与链表算法"><span class="toc-number">6.</span> <span class="toc-text">0x6 数组与链表算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x6-1矩阵"><span class="toc-number">6.1.</span> <span class="toc-text">0x6.1矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x6-2-链表"><span class="toc-number">6.2.</span> <span class="toc-text">0x6.2 链表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x7堆栈与队列算法"><span class="toc-number">7.</span> <span class="toc-text">0x7堆栈与队列算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x7-1堆栈"><span class="toc-number">7.1.</span> <span class="toc-text">0x7.1堆栈</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x7-2-队列"><span class="toc-number">8.</span> <span class="toc-text">0x7.2 队列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x8-树形结构及其算法"><span class="toc-number">9.</span> <span class="toc-text">0x8 树形结构及其算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x9图的数据结构及其算法"><span class="toc-number">10.</span> <span class="toc-text">0x9图的数据结构及其算法</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">ye1s</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/ye1sec" target="_blank">GitHub<i class="icon-dot bg-color0"></i></a><a class="links-button button-hover" href="mailto:431774437@qq.com" target="_blank">E-Mail<i class="icon-dot bg-color2"></i></a><a class="links-button button-hover" href="tencent://message/?uin=431774437&amp;Site=&amp;Menu=yes" target="_blank">QQ<i class="icon-dot bg-color3"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">200</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">149</span></a><a class="author-info-articles-categories article-meta" href="/categories"><span class="pull-top">分类</span><span class="pull-bottom">12</span></a></div><div class="friend-link"><a class="friend-link-text" href="http://www.m00nback.xyz/" target="_blank">MoonBack</a><a class="friend-link-text" target="_blank">待定</a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="search social-icon"><i class="fas fa-search"></i><span> 搜索</span></a><a class="title-name" href="/">ye1s</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">图解算法使用python笔记</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2019-05-23 | 更新于 2021-01-05</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/">编程算法</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/python/">python</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div></div></div><div class="main-content"><p>比较简略的算法书，适合初学者入门。  以下是做的一些简记。</p>
<a id="more"></a>
<h1 id="0x1算法"><a href="#0x1算法" class="headerlink" title="0x1算法"></a>0x1算法</h1><p>0x1.1算法的定义<br>为了解决某项工作或某个问题,所需要有限数量的机械性或重复性指令与计算步骤。<br>这个算法应用相当广泛，如快排序法、递归算法、大整数乘法。   </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">num1=int(input(<span class="string">'输入第一个数:'</span>))</span><br><span class="line">num2=int(input(<span class="string">'输入第二个数:'</span>))</span><br><span class="line"><span class="keyword">while</span> num2!=0:</span><br><span class="line">    temp=num1%num2</span><br><span class="line">    num1=num2</span><br><span class="line">    num2=temp</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'最大公约数:'</span>,num1)</span><br></pre></td></tr></table></figure>
<p>0x1.2算法条件<br>输入、输出、明确性、有限性、有效性<br>0x1.3时间复杂度O(f(n))    </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0(1)&lt;0(log2n)&lt;0(n)&lt;O(nlog2n)&lt;O(n2)&lt;O(2n)</span><br></pre></td></tr></table></figure>
<h1 id="0x2常见算法"><a href="#0x2常见算法" class="headerlink" title="0x2常见算法"></a>0x2常见算法</h1><p>0x2.1分治法<br>核心思想就是将一个难以直接解决的大问题依照相同的概念,分割长两个或更多子问题，以便各个击破，即“分而治之”。<br>0x2.2递归法<br>定义: 一个函数或子程序，是由自身所定义或调用的，就成为递归。<br>至少满足的两个条件:<br>一个可以反复执行的递归过程<br>一个可以离开递归执行过程的出口<br>范例:<br>阶乘函数 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def factorial(i):</span><br><span class="line">    <span class="keyword">if</span> i==0:</span><br><span class="line">        <span class="built_in">return</span> 1</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ans=i*factorial(i-1)</span><br><span class="line">    <span class="built_in">return</span> ans</span><br></pre></td></tr></table></figure>
<p>斐波那契数列  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def fib(n):</span><br><span class="line">    <span class="keyword">if</span> n==0:</span><br><span class="line">        <span class="built_in">return</span> 0</span><br><span class="line">    <span class="keyword">elif</span> n==1 or n==2:</span><br><span class="line">        <span class="built_in">return</span> 1</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">return</span> (fib(n-1)+fib(n-2))</span><br></pre></td></tr></table></figure>
<p>0x2.3 贪心算法<br>方法是从某一七点开始，在每一个解决问题步骤中使用贪心原则，即采用在当前状态下最有利或最优化选择，不断地改进该解答，持续在每一步骤中选择最佳的方法，并且逐步逼近给定的目标，当达到某一步骤不能再继续前进时，算法就停止，就是尽可能快地求得更好的解。<br>经常用于找出图的最小生成树，最短路径与哈弗曼编码等。<br>0x2.4动态规划法<br>主要做法:如果一个问题答案与子问题相关的话，就能将大问题拆解成各个小问题，其中与分治法最大不同的地方是可以让每一个子问题的答案被存储起来，以供下次求解时直接取用。这样的做法不但能减少再次计算的时间，并将这些解组合成大问题的解答，故而使用动态规划可以解决重复计算问题。<br>范例:<br>斐波那契数列    </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">output=[None]*1000</span><br><span class="line">def Fibonacci(n):</span><br><span class="line">    result=output[n]</span><br><span class="line">    <span class="keyword">if</span> result==None:</span><br><span class="line">        <span class="keyword">if</span> n==0:</span><br><span class="line">            result=0</span><br><span class="line">        <span class="keyword">elif</span> n==1:</span><br><span class="line">            result=1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result=Fibonacci(n-1) + Fibonacci(n-2)</span><br><span class="line">        output[n]=result</span><br><span class="line">    <span class="built_in">return</span> result</span><br></pre></td></tr></table></figure>
<p>0x2.5迭代法<br>是指无法使用公式一次求解，而需要使用迭代，例如用循环去重复执行程序代码的某些部分来得到答案。<br>范例:<br>使用for循环来设计一个计算1!~n!阶乘的递归程序   </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sum=1</span><br><span class="line">n=int(input(<span class="string">'请输入n='</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(0,n+1):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i,0,-1):</span><br><span class="line">        sum *=j</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'%d!=%3d'</span>%(i,sum))</span><br><span class="line">    sum=1</span><br></pre></td></tr></table></figure>
<p>0x2.6枚举法<br>又称穷举法，核心思想就是列举所有的可能。<br>范例:<br>当某数1000依次减去1,2,3……直到哪一个数，相减得结果开始为负数。  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x=1</span><br><span class="line">num=1000</span><br><span class="line"><span class="keyword">while</span> num&gt;=0:</span><br><span class="line">    num=num-x</span><br><span class="line">    x=x+1</span><br><span class="line"><span class="built_in">print</span>(x-1)</span><br></pre></td></tr></table></figure>
<p>0x2.7回溯法<br>也算是枚举中的一种。<br>特点主要是在搜索过程中寻找问题的解，当发现不满足求解条件时，就回溯，尝试别的路径，避免无效搜索。<br>常见的迷宫问题    </p>
<h1 id="0x3数据结构类型"><a href="#0x3数据结构类型" class="headerlink" title="0x3数据结构类型"></a>0x3数据结构类型</h1><p>0x3.1数组<br>数组结构其实就是一排紧密相邻的可数内存，并提供一个能够直接访问单一数据内容的计算方法。    </p>
<p>0x3.2链表<br>是由许多相同数据项按特定顺序排列而成的线性表。  </p>
<p>0x3.3 堆栈<br>是一组相同数据类型的组合，具有后进先出的特性，所有操作均在堆栈结构的顶端进行。   </p>
<p>0x3.4队列<br>是一种先进先出的数据结构，和堆栈一样都是一种有序线性表的抽象数据类型。  </p>
<p>0x3.5树形结构<br>基本观念:<br>树是由一个或一个以上的节点所组成的，存在一个特殊的节点，称为树根，每个节点可代表一些数据和指针组合而成的记录。<br>一些专有名词:<br>度数:每个节点所有子树的个数<br>层数:树的层数<br>高度: 树的最大层数<br>树叶或终端节点: 度数为零节点就是树叶<br>父节点:每个节点有连接的上一层节点<br>子节点:每个节点有连接的下一层节点<br>祖先和子孙:所谓祖先，是指从树根到该节点路径上所包含的几点，而子孙则是在该节点往下追溯子树中的任意节点<br>兄弟节点:有共同父亲节点的节点为兄弟节点<br>非终端节点:树叶以外的节点<br>同代: 在同一棵中具有相同层数的节点<br>森林:n棵(n&gt;=0)互斥树的集合<br>二叉树:<br>一般树形结构在计算机内存中的存储方式是以链表为主   </p>
<p>0x3.6图形结构<br>图是由定点和边组成的集合,通常用G=(V,E)来表示，其中V是所有顶点所组成的集合，而E代表所有边所组成的集合。 图的种类有两种;一种是无向图，一种是有向图，无向图以(V1,V2)表示其边，有向图以&lt;V1,V2&gt;表示其边。  </p>
<p>0x3.7哈希表<br>哈希表是一种存储记录的连续内存，通过哈希函数的应用，可以快速存取与查找数据。<br>相关名词<br>bucket（桶): 哈希表总存储数据的位置，每一个位置对应到唯一的一个地址，桶就好比一个记录。<br>solt(槽):每个记录中可能包含好几个字段，而solt就是桶中的字段。<br>collision(碰撞): 两项不同的数据，经过哈希函数运算后，对应到相同的地址。<br>溢出:如果数据经过哈希函数运算后，所对应的bucket已满，就会使bucket发生溢出。<br>哈希表: 存储记录的连续内存。<br>同义词:两个标识符I1和I2经哈希函数运算后所得的数值相同。<br>加载密度: 是指标识符的使用数量除以哈希表内槽的总数。<br>完美哈希: 没有碰撞也没有溢出的哈希函数。    </p>
<h1 id="0x4排序算法"><a href="#0x4排序算法" class="headerlink" title="0x4排序算法"></a>0x4排序算法</h1><p>在排序过程中，根据数据的移动方式，可将排序方式分为：<br>直接移动和逻辑移动两种方式。<br>直接移动：是指直接交换存储数据的位置；缺点是：直接移动会浪费许多时间进行数据的移动。<br>而逻辑移动并不会移动数据存储的位置，仅仅改变指向这些数据的辅助功能指针的值；优点是：只要改变辅助指针指向的位置就能达到排序的目的。   </p>
<p>排序可以按照执行时所使用的内存种类区分为以下两种方式：<br>1）内部排序：排序数量小，可以全部加载到内存中进行排序。<br>2）外部排序：数据量大，无法全部一次性加载到内存中进行排序，而必须借助辅助存储器(如硬盘)进行排序。   </p>
<p>排序算法的分析<br>1）算法稳定与否？<br>稳定的排序是指在经过排序后，两个相同键值的记录仍然保持原来的次序。即同一数字在排序前后的相对位置不会发生改变。  </p>
<p>2）时间复杂度？Time Complexity<br>当数据量较大时，排序算法所花费的时间就显得尤为重要。排序算法的时间复杂度分为:最好情况(Best Case)、平均情况（Average Case）和最差情况（Worst Case）.<br>最好情况就是值原本的数列已经是经过排序之后的结果；最差结果是数列中的每一个值都需要重新排列。<br>3）空间复杂度？Space Complexity<br>空间复杂度是指算法在执行过程中所需要占用的额外内存空间。任何排序算法都有数据的对调操作，数据对调就会暂时用到一个额外的空间，这也是排序中空间复杂度要考虑的问题。排序算法占用的额外空间越小，空间复杂度就越低<br><img src="../../images/arithmetic/python1.png" alt=""></p>
<p>0x4.1冒泡排序法<br>原理:是从第一个元素开始比较相邻元素的大小，若大小顺序有误，则对调后再进行下一个元素的比较，就仿佛气泡逐渐从水底逐渐冒升到水面上一样。如此扫面一次之后，就可以确保最后一个元素位于正确的顺序。接着再逐步进行第二次扫描，直到完成所有元素的排序关系为止。<br>范例: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">data=[16,25,39,27,12,8,45,63]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'冒泡排序法:原始数据为:'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(data)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'%3d'</span>%data[i],end=<span class="string">''</span>)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(data)-1,0,-1): <span class="comment">#扫描次数</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i):</span><br><span class="line">        <span class="keyword">if</span> data[j]&gt;data[j+1]:</span><br><span class="line">            data[j],data[j+1]=data[j+1],data[j]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'第%d次排序后的结果是:'</span>%(8-i),end=<span class="string">''</span>)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(data)):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'%3d'</span>%data[j],end=<span class="string">''</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'排序后的结果为:'</span>)</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(data)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'%3d'</span>%data[j],end=<span class="string">''</span>)</span><br><span class="line"><span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>
<p>0x4.2选择排序法<br>也算是枚举法的一种应用，就是反复从未排序的数列中取出最小的元素，加入到另一个数列中，最后的结果即为已排序的数列。<br>范例:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def showdata(data):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(data)):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'%3d'</span>%data[i],end=<span class="string">''</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">def select(data):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(data)-1):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+1,8):</span><br><span class="line">            <span class="keyword">if</span> data[i]&gt;data[j]:</span><br><span class="line">                data[i],data[j]=data[j],data[i]</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">data=[16,25,39,27,12,8,45,63]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'原始数据为:'</span>)</span><br><span class="line">showdata(data)</span><br><span class="line">select(data)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'排序后的数据为:'</span>)</span><br><span class="line">showdata(data)</span><br></pre></td></tr></table></figure>
<p>0x4.3插入排序法<br>是将数组中的元素，逐一与已排序好的数据进行比较，前两个元素先排好，再将第三个元素插入适当的位置，所以这三个元素仍然是已排序好的，接着讲第四个元素加入，重复此步骤，直到排序完成为止。     </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def showdata(data):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(data)):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'%3d'</span>%data[i],end=<span class="string">''</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">def insert(data):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(1,len(data)):</span><br><span class="line">        tmp=data[i]<span class="comment">#tmp用来暂存数据</span></span><br><span class="line">        no=i-1</span><br><span class="line">        <span class="keyword">while</span> no &gt;=0 and tmp &lt;data[no]:</span><br><span class="line">            data[no+1]=data[no] <span class="comment">#就把所有元素往后推一个元素</span></span><br><span class="line">            no-=1</span><br><span class="line">        data[no+1]=tmp <span class="comment">#最小的元素放到第一个位置</span></span><br><span class="line">def main():</span><br><span class="line">    data = [16, 25, 39, 27, 12, 8, 45, 63]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'原始数据为:'</span>)</span><br><span class="line">    showdata(data)</span><br><span class="line">    insert(data)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'排序后的数据为:'</span>)</span><br><span class="line">    showdata(data)</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<p>0x4.4希尔排序<br>排序的原则是将数据区分成特定间隔的几个小区块，以插入排序法排完区块内的数据后再渐渐减少间隔的距离。   </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">def showdata(data):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(data)):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'%3d'</span> % data[i], end=<span class="string">''</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">def shell(data):</span><br><span class="line">    k = 1  <span class="comment"># 打印计数</span></span><br><span class="line">    j=0</span><br><span class="line">    jmp = len(data) // 2</span><br><span class="line">    <span class="keyword">while</span> jmp &gt;= 1:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(jmp, len(data)):</span><br><span class="line">            tmp = data[i]</span><br><span class="line">            j = i - jmp</span><br><span class="line">            <span class="keyword">while</span> j &gt;= 0 and tmp &lt; data[j]:</span><br><span class="line">                data[j + jmp] = data[j]</span><br><span class="line">                j = j - jmp</span><br><span class="line">            data[jmp + j] = tmp</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'第%d次排序过程:'</span> % k, end=<span class="string">''</span>)</span><br><span class="line">        k += 1</span><br><span class="line">        showdata(data)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'--------------------------------'</span>)</span><br><span class="line">        jmp = jmp // 2</span><br><span class="line">def main():</span><br><span class="line">    data = [16, 25, 39, 27, 12, 8, 45, 63]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'原始数据为:'</span>)</span><br><span class="line">    showdata(data)</span><br><span class="line">    shell(data)</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<p>0x4.5合并排序法<br>工作原理针对已排序好的两个或两个以上的数列通过合并的方式，将其组合成一个大的且已排序好序的数列。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">list3 = []</span><br><span class="line">list1 = [20, 45, 51, 88, 99999]</span><br><span class="line">list2 = [98, 10, 23, 15, 99999]</span><br><span class="line">def select_sort(data): <span class="comment">#选择排序法</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(data)-1):</span><br><span class="line">        small=i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+1,len(data)-1):</span><br><span class="line">            <span class="keyword">if</span> data[j]&lt;data[small]:</span><br><span class="line">                small=j</span><br><span class="line">        data[small],data[i]=data[i],data[small]</span><br><span class="line">def Merge(list1,list2):</span><br><span class="line">    index1=0</span><br><span class="line">    index2=0</span><br><span class="line">    <span class="keyword">for</span> index3 <span class="keyword">in</span> range(len(list1)+len(list2)-1):</span><br><span class="line">        <span class="keyword">if</span> list1[index1]&lt;list2[index2]:</span><br><span class="line">            list3.append(list1[index1])</span><br><span class="line">            index1 +=1</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'此数字%d来自于第1个数列'</span>%list3[index3])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            list3.append(list2[index2])</span><br><span class="line">            index2 +=1</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'此数字%d来自于第2个数列'</span>%list3[index3])</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'目前的合并排序结果为:'</span>,end=<span class="string">''</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(index3+1):</span><br><span class="line">            <span class="built_in">print</span>(list3[i],<span class="string">' '</span>,end=<span class="string">''</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'\n'</span>)</span><br><span class="line">def showdata(data):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(data)):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'%3d'</span> % data[i], end=<span class="string">''</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">def main():</span><br><span class="line">    select_sort(list1)</span><br><span class="line">    showdata(list1)</span><br><span class="line">    select_sort(list2)</span><br><span class="line">    showdata(list2)</span><br><span class="line">    Merge(list1,list2)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>0x4.6 快速排序法<br>又称为分割交换排序法，是目前工人最佳的排序法，也是使用分而治之的方式，先在数据中找到一个虚拟的中间值，并按此中间值将所有打算排序的数据分为两部分。其中，小于中间值的数据值的数据放在左边，大于中间值的数据放在右边，再以同样的方式处理左右两边的数据，直到排序完为止。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line">def inputarr(data, size):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">        data[i] = random.randint(1, 100)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def showdata(data, size):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'%3d'</span> % data[i], end=<span class="string">''</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">        </span><br><span class="line">def quick(d, size, lf, rg):</span><br><span class="line">    <span class="comment"># 第一项键值为d[lf]</span></span><br><span class="line">    <span class="keyword">if</span> lf &lt; rg:  <span class="comment"># 排序数列的左边与右边</span></span><br><span class="line">        lf_idx = lf + 1</span><br><span class="line">        <span class="keyword">while</span> d[lf_idx] &lt; d[lf]:</span><br><span class="line">            <span class="keyword">if</span> lf_idx + 1 &gt; size:</span><br><span class="line">                <span class="built_in">break</span></span><br><span class="line">            lf_idx += 1</span><br><span class="line">        rg_idx = rg</span><br><span class="line">        <span class="keyword">while</span> d[rg_idx] &gt; d[lf]:</span><br><span class="line">            rg_idx -= 1</span><br><span class="line">        <span class="keyword">while</span> lf_idx &lt; rg_idx:</span><br><span class="line">            d[lf_idx], d[rg_idx] = d[rg_idx], d[lf_idx]</span><br><span class="line">            lf_idx += 1</span><br><span class="line">            <span class="keyword">while</span> d[lf_idx] &lt; d[lf]:</span><br><span class="line">                lf_idx += 1</span><br><span class="line">            rg_idx -= 1</span><br><span class="line">            <span class="keyword">while</span> d[rg_idx] &gt; d[lf]:</span><br><span class="line">                rg_idx -= 1</span><br><span class="line">        d[lf], d[rg_idx] = d[rg_idx], d[lf]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'%3d'</span> % d[i], end=<span class="string">''</span>)</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line">        quick(d, size, lf, rg_idx - 1)  <span class="comment"># 以rg_idx为基准点分成左右两半以递归方式</span></span><br><span class="line">        quick(d, size, rg_idx + 1, rg)  <span class="comment"># 分别为左右两半进行排序直至完成排序</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    data = [0] * 100</span><br><span class="line">    size = int(input(<span class="string">'请输入数组大小(100以下)：'</span>))</span><br><span class="line">    inputarr(data, size)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'您输入的原始数据是：'</span>)</span><br><span class="line">    showdata(data, size)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'排序过程如下：'</span>)</span><br><span class="line">    quick(data, size, 0, size - 1)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'最终的排序结果为：'</span>)</span><br><span class="line">    showdata(data, size)</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<p>0x4.7基数排序法<br>基数排序法和之前的冒泡、选择、插入、希尔、合并、快速、堆积排序算法都不相同，它并不需要进行元素之间的比较操作。而是属于一种分配模式的排序方式。<br>   基数排序方法按照比较的方向可分为最高位优先（Most  Significant Digit First，MSD）和最低位优先（Least Significant Digit First,LSD）两种。MSD算法是从最左边的位数开始比较，而LSD是从最右边的位数开始比较。以LSD对三位数的整数数据来加以排序，它是按照个位、十位数、百位数这样的次序进行排序的。</p>
<p>1）首先每个整数按照个位数字放到列表中  + 从左到右合并后成为：……<br>2)按照十位数字，将其放到列表中：  + 从左到右合并后成为 ……<br>3）按照百位数字，按序放到列表中   + 最后合并即可完成最后的排序    </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">def inputarr(data, size):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">        data[i] = random.randint(0, 999)  <span class="comment"># 设置 data 值最大为 3 位数</span></span><br><span class="line"></span><br><span class="line">def showdata(data, size):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'%5d'</span> % data[i], end=<span class="string">''</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">def radix(data, size):</span><br><span class="line">    n = 1  <span class="comment"># n为基数，从个位数开始排序</span></span><br><span class="line">    <span class="keyword">while</span> n &lt;= 100:</span><br><span class="line">        tmp = [[0] * 100 <span class="keyword">for</span> row <span class="keyword">in</span> range(10)]  <span class="comment"># 设置暂存数组，[0~9位数][数据个数]，所有内容均为0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(size):  <span class="comment"># 对比所有数据</span></span><br><span class="line">            m = (data[i] // n) % 10  <span class="comment"># m为 n 位数的值，如 36 取十位数(36/10)%10=3</span></span><br><span class="line">            tmp[m][i] = data[i]  <span class="comment"># 把 data[i] 的值暂存在 tmp 中</span></span><br><span class="line">        k = 0</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(10):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(size):</span><br><span class="line">                <span class="keyword">if</span> tmp[i][j] != 0:  <span class="comment"># 因为一开始设置 tmp =&#123;0&#125;，故不为 0 者即为</span></span><br><span class="line">                    data[k] = tmp[i][j]  <span class="comment"># data 暂存在 tmp 中的值，把 tmp 中的值放</span></span><br><span class="line">                    k += 1  <span class="comment"># 回 data[ ]里</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'经过%3d位数排序后：'</span> % n, end=<span class="string">''</span>)</span><br><span class="line">        showdata(data, size)</span><br><span class="line">        n = 10 * n</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    data = [0] * 100</span><br><span class="line">    size = int(input(<span class="string">'请输入数组大小(100以下)：'</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'您输入的原始数据是：'</span>)</span><br><span class="line">    inputarr(data, size)</span><br><span class="line">    showdata(data, size)</span><br><span class="line">    radix(data, size)</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<p>0x4.8堆积排序法<br>堆积排序算法是选择排序算法的改进版本，他可以减少在选择排序中的比较次数，进而减少排序时间。堆积排序用到了二叉树的技巧，它是利用堆积树来完成排序的。堆积树是一种特殊的二叉树，可分为最大堆积树和最小堆积树。</p>
<p>最大堆积树满足如下三个条件：</p>
<p>1）它是一个完全二叉树</p>
<p>2）所有节点都大于或等于它左右子节点的值</p>
<p>3）树根是堆积树中最大的值</p>
<p>最小堆积树满足如下三个条件：</p>
<p>1）它是一个二叉树</p>
<p>2）所有节点都小于或等于它左右子节点的值</p>
<p>3）树根是对堆积树中最小的值</p>
<p>QQ：二叉树转换为最大堆积树：</p>
<p>从树根往下进行比较，大的值就往上排列，知道到达了树叶节点即可。（从二叉树的树根开始从上往下逐一按堆积树建立原则来改变各节点的值，最终得到一棵最大堆积树）</p>
<p>然后根据建立的最大堆积树，从大到小进行提取数据。</p>
<p>首先提取树根作为排好序数组的第一个值，然后在删除了树根的基础上，重新针对剩下的节点建立最大堆积树，然后再将树根放入数组作为第二个值，……</p>
<p>堆积排序法的分析：</p>
<p>1）在所有情况下，时间复杂度均为o(nlogn)</p>
<p>2）堆积排序不是稳定的排序算法</p>
<p>3）只需要一个额外的空间，空间复杂度为o(n)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">def heap(data, size):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(size / 2), 0, -1):  <span class="comment"># 建立堆积树节点</span></span><br><span class="line">        ad_heap(data, i, size - 1)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'堆积的内容：'</span>, end=<span class="string">''</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(1, size):  <span class="comment"># 原始堆积树的内容</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'[%2d] '</span> % data[i], end=<span class="string">''</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'\n'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(size - 2, 0, -1):  <span class="comment"># 堆积排序</span></span><br><span class="line">        data[i + 1], data[1] = data[1], data[i + 1]  <span class="comment"># 头尾节点交换</span></span><br><span class="line">        ad_heap(data, 1, i)  <span class="comment"># 处理剩余节点</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'处理过程为：'</span>, end=<span class="string">''</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(1, size):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'[%2d] '</span> % data[j], end=<span class="string">''</span>)</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">def ad_heap(data, i, size):</span><br><span class="line">    j = 2 * i</span><br><span class="line">    tmp = data[i]</span><br><span class="line">    post = 0</span><br><span class="line">    <span class="keyword">while</span> j &lt;= size and post == 0:</span><br><span class="line">        <span class="keyword">if</span> j &lt; size:</span><br><span class="line">            <span class="keyword">if</span> data[j] &lt; data[j + 1]:  <span class="comment"># 找出最大节点</span></span><br><span class="line">                j += 1</span><br><span class="line">        <span class="keyword">if</span> tmp &gt;= data[j]:  <span class="comment"># 若树根较大，结束比较过程</span></span><br><span class="line">            post = 1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            data[int(j / 2)] = data[j]  <span class="comment"># 若树根较小，则继续比较</span></span><br><span class="line">            j = 2 * j</span><br><span class="line">    data[int(j / 2)] = tmp  <span class="comment"># 指定树根为父节点</span></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    data = [0, 5, 6, 4, 8, 3, 2, 7, 1]  <span class="comment"># 原始数组的内容</span></span><br><span class="line">    size = 9</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'原始数组为：'</span>, end=<span class="string">''</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(1, size):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'[%2d] '</span> % data[i], end=<span class="string">''</span>)</span><br><span class="line">    heap(data, size)  <span class="comment"># 建立堆积树</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'排序结果为：'</span>, end=<span class="string">''</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(1, size):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'[%2d] '</span> % data[i], end=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h1 id="0x5查找与哈希算法"><a href="#0x5查找与哈希算法" class="headerlink" title="0x5查找与哈希算法"></a>0x5查找与哈希算法</h1><p>通常判断一个查找算法的好坏主要由比较次数及查找所需要时间来判断。<br>0x5.1顺序查找<br>顺序查找法又称线性,是一种简单的查找。它的方法是将数据一项一项地按照顺序逐个查找，所以不管数据顺序如何，都得从头到尾遍历一次。<br>0x5.2二分法查找<br>如果要查找的数据已经事先排好序了，则可以使用二分法来进行查找。二分查找法是将数据分割成二等份，再比较键值与中间值得大小，如果键值小于中间值，可确定查找的数据在前段，否则在后半部分。如此分割数直到找到或确定不存在为止。   </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def bin_search(data,val):</span><br><span class="line">    low=0</span><br><span class="line">    high=len(data)-1</span><br><span class="line">    <span class="keyword">while</span>  low&lt;=high and val!=-1:</span><br><span class="line">        mid=int((low+high)/2)</span><br><span class="line">        <span class="keyword">if</span> val&lt;data[mid]:</span><br><span class="line">            high=mid-1</span><br><span class="line">        <span class="keyword">elif</span> val&gt;data[mid]:</span><br><span class="line">            low=mid+1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">return</span> mid</span><br><span class="line">    <span class="built_in">return</span> -1</span><br><span class="line">data=[1,2,5,6,8,11,14,17]</span><br><span class="line">val=5</span><br><span class="line"><span class="built_in">print</span>(bin_search(data,val))</span><br></pre></td></tr></table></figure>
<p>0x5.3 插值查找法<br>插值查找法(Interpolation Search)又叫插补查找法，是二分查找法的改进版。它是按照数据位置的分布，利用公式预测数据所在的位置，再以二分法的方式渐渐逼近。使用插值法是假设数据平均分布在数组中，而每一项数据的差距相当接近或有一定距离比例。插值法的公式为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mid=low+((key-data[low])/(data[high]-data[low]))*(high-low)</span><br></pre></td></tr></table></figure>
<p>其中key是要查找的键，data[high]和data[low]是剩余待查找记录中的最大值和最小值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def interpolation_search(data,val):</span><br><span class="line">    low=0</span><br><span class="line">    high=len(data)-1</span><br><span class="line">    <span class="keyword">while</span> low&lt;=high and val !=-1:</span><br><span class="line">        mid=low+int((val-data[low])*(high-low)/(data[high]-data[low]))</span><br><span class="line">        <span class="keyword">if</span> val==data[mid]:</span><br><span class="line">            <span class="built_in">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> val &lt;data[mid]:</span><br><span class="line">            high=mid-1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            low=mid+1</span><br><span class="line">data=[1,2,5,6,8,11,14,17]</span><br><span class="line">val=3</span><br><span class="line"><span class="built_in">print</span>(interpolation_search(data,val))</span><br></pre></td></tr></table></figure>
<p>0x5.4常见的哈希法简介<br>哈希法是使用哈希函数来计算一个键值所对应的地址，进而建立哈希表格，然后依靠哈希函数来查找到各个键值存放在表格中的地址，查找速度与数据多少无关，在没有碰撞和溢出的情况下，一次读取即可完成</p>
<p>常见的哈希算法有除留余数法，平方取中法，折叠法及数字分析法<br>0x5.4.1除留余数法<br>最简单的哈希函数是将数据除以某一个常数后，取余数来当索引<br>例子:<br>在一个有13个位置的数组中，只使用到7个地址，值分别是12,65,70,99,33,67,48。我们可以把数组内的值除以13，并以其余数来当数组的下标(作为索引)，可以用以下式子表示：<br>h(key)=key mod B</p>
<p>0x5.4.2平方取中法<br>先计算数据的平方，之后再取中间的某段数字作为索引</p>
<p>例子说明<br>将数据存放在100个地址空间中，其操作步骤如下：<br>第一步：将12,65,70,99,33,67,51平方后如下<br>144,4225,4900,9801,1089,4489,2601</p>
<p>第二步：取百位数和十位数作为键值，分别为<br>14,22,90,80,08,48,60</p>
<p>第三步：存放数据</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">f(14) = 12</span><br><span class="line">f(22) = 65</span><br><span class="line">f(90) = 70</span><br><span class="line">f(80) = 99</span><br><span class="line">f(8)  = 33</span><br><span class="line">f(48) = 67</span><br><span class="line">f(60) = 51</span><br></pre></td></tr></table></figure>
<p>0x5.4.3折叠法<br>折叠法是将数据转换成一串数字后，先将这串数字拆成几个部分，再把它们加起来，就可计算出这个键值的Bucket Address(桶地址)</p>
<p>例子说明<br>有一个数据，转换成数字后为2365479125443，若以每4个数字为一个部分则可拆为2365,4791,2544,3。将这4组数字加起来后即为索引值：2365+4791+2544+3=9703—&gt;桶地址</p>
<p>在折叠法中有两种做法，如上例直接将每一部分相加所得的值作为其bucket address，这种方法称为”移动折叠法”。哈希法的设计原则之一就是降低碰撞，如果希望降低碰撞的机会，就可以将上述每一部分数字中的奇数或偶数反转，再相加来取得其bucket address，这种改进的做法称为”边界折叠法”(folding at the boundaries)</p>
<p>0x5.4.4数字分析法<br>适用于数据不会更改，且为数字类型的静态表。再决定哈希函数时先追一检查数据的相对位置和分布情况，将重复性高的部分删除。<br>0x5.5碰撞与溢出问题的处理<br>在哈希法中，当标识符要放入某个通(Bucket，哈希表中存储数据的位置)时，若该桶已经满了，就会发生溢出(Overflow);另一方面哈希法的理想情况是所有数据经过哈希函数运算后都得到不同的值，但现实情况是即使所有关键字段的值都不相同，还是可能得到相同的地址，于是就发生了碰撞(Collision)问题<br>0x5.5.1线性探测算法<br>原理简介<br>线性探测法是当发生碰撞情况时，若该索引对应的存储位置已有数据，则以线性的方式往后寻找空的存储位置，一旦找到位置就把数据放进去。线性探测法通常把哈希的位置视为环形结构，如此一来若后面的位置已被填满而前面还有位置时，可以将数据放到前面</p>
<p>线性探测算法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def create_table(num,index):</span><br><span class="line">    temp = num % INDEXBOX</span><br><span class="line">    <span class="keyword">while</span> True:</span><br><span class="line">        <span class="keyword">if</span> index[temp]==-1:</span><br><span class="line">            index[temp]=num</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            temp=(temp+1)%INDEXBOX</span><br></pre></td></tr></table></figure>
<p>范例:<br>以除留余数法的哈希函数取得索引值，再以·线性探测法来存储数据</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line">INDEXBOX = 10</span><br><span class="line">MAXNUM = 7</span><br><span class="line"></span><br><span class="line">def print_data(data,max_number):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\t"</span>,end=<span class="string">""</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(max_number):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"[%2d]"</span> %data[i],end=<span class="string">""</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">def create_table(num,index):</span><br><span class="line">    temp = num%INDEXBOX</span><br><span class="line">    <span class="keyword">while</span> True:</span><br><span class="line">        <span class="keyword">if</span> index[temp]==-1:</span><br><span class="line">            index[temp]=num</span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            temp=(temp+1)%INDEXBOX</span><br><span class="line"></span><br><span class="line">index = [None]*INDEXBOX</span><br><span class="line">data = [None]*MAXNUM</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"原始数组值："</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(MAXNUM):</span><br><span class="line">    data[i]=random.randint(1,20)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(INDEXBOX):</span><br><span class="line">    index[i]=-1</span><br><span class="line"></span><br><span class="line">print_data(data,MAXNUM)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"哈希表内容："</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(MAXNUM):</span><br><span class="line">    create_table(data[i],index)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"%2d =&gt;"</span> %data[i],end=<span class="string">""</span>)</span><br><span class="line">    print_data(index,INDEXBOX)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"完成哈希表："</span>)</span><br><span class="line">print_data(index,INDEXBOX)</span><br></pre></td></tr></table></figure>
<p>0x5.5.2平方探测法<br>线性探测法有一个缺点，就是相类似的键值经常会聚集在一起，因此可以考虑以平方探测法来加以改进。在平方探测中，当溢出发生时，下一次查找的地址是(f(x)+i)mod B与(f(x)-i)mod B，即让数据值加或减i的平方</p>
<p>例子说明<br>数据值key，哈希函数f</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">第一次查找：f(key)</span><br><span class="line">第二次查找：(f(key)+1^2)%B</span><br><span class="line">第三次查找：(f(key)-1^2)%B</span><br><span class="line">第四次查找：(f(key)+2^2)%B</span><br><span class="line">第五次查找：(f(key)-2^2)%B</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">第n次查找：(f(key)+-((B-1)/2)^2)%B,其中，B必须为4j+3型的质数，且1&lt;=i&lt;=(B-1)/2</span><br></pre></td></tr></table></figure>
<p>0x5.5.3再哈希法<br>再哈希法就是一开始就先设置一系列的哈希函数，如果使用第一种哈希函数出现溢出时就改用第二种，如果第二种也出现溢出就用第三种，一直到没有发生溢出为止</p>
<p>例子说明<br>数据：681,467,633,511,100,164,472,438,445,366,118<br>其中哈希函数为(此处的m=13)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">f1 = h(key) = key MOD m</span><br><span class="line">f2 = h(key) = (key+2) MOD m</span><br><span class="line">f3 = h(key) = (key+4) MOD m</span><br><span class="line">说明如下：</span><br><span class="line">第一次：使用第一种哈希函数f1 = h(key) = key MOD m，得到的哈希地址如下：</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">681 ---&gt; 5</span><br><span class="line">467 ---&gt; 12</span><br><span class="line">633 ---&gt; 9</span><br><span class="line">511 ---&gt; 4</span><br><span class="line">100 ---&gt; 9</span><br><span class="line">164 ---&gt; 8</span><br><span class="line">472 ---&gt; 4</span><br><span class="line">438 ---&gt; 9</span><br><span class="line">445 ---&gt; 3</span><br><span class="line">366 ---&gt; 2</span><br><span class="line">118 ---&gt; 1</span><br></pre></td></tr></table></figure>
<p>第二步：其中100,472,438都发生碰撞，再使用第二种哈希函数f2 = h(key) = (key+2) MOD m，进行数据的地址</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">100 ---&gt; h(100+2) = 102 mod 13 = 11</span><br><span class="line">472 ---&gt; h(472+2) = 474 mod 13 = 6</span><br><span class="line">438 ---&gt; h(438+2) = 440 mod 13 = 11</span><br></pre></td></tr></table></figure>
<p>第三步：438仍发生碰撞问题，使用第三种哈希函数f3 = h(key) = (key+4) MOD m，重新进行438地址的安排</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">438 ---&gt; h(438+4) = 442 mod 13 = 0</span><br></pre></td></tr></table></figure>
<h1 id="0x6-数组与链表算法"><a href="#0x6-数组与链表算法" class="headerlink" title="0x6 数组与链表算法"></a>0x6 数组与链表算法</h1><p>数组与链表都是相当重要的结构化数据类型(structured data type)，也都是典型线性表的应用。按照内存存储的方式，基本上可分为以下两种方式：<br>1.静态数据结构(static data structure)<br>数据类型就是一种典型的静态数据结构，它使用连续分配的内存空间(contiguous allocation)来存储有序表中的数据。静态数据结构是在编译时就给相关的变量分配好内存空间。缺点是删除或加入数据时，需要移动大量的数据    </p>
<p>2.动态数据结构(dynamic data structure)<br>动态数据结构又称为”链表”(linked list)，它使用不连续的内存空间存储具有线性表特性的数据。优点是数据的插入或删除都相当方便，不需要移动大量数据     </p>
<h2 id="0x6-1矩阵"><a href="#0x6-1矩阵" class="headerlink" title="0x6.1矩阵"></a>0x6.1矩阵</h2><p>0x6.1.1 矩阵相加<br>相加的两个矩阵对应的行数与列数都必须相等，而相加后的矩阵的行数与列数也是相同的        </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">A=[[1,3,5],[7,9,11],[13,15,17]]</span><br><span class="line">B=[[9,8,7],[6,5,4],[3,2,1]]</span><br><span class="line">N=3</span><br><span class="line">C=[[None]*N <span class="keyword">for</span> row <span class="keyword">in</span> range(N)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(3):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(3):</span><br><span class="line">        C[i][j]=A[i][j]+B[i][j]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'[矩阵A和矩阵B相加的结果]'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(3):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(3):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'%d'</span>%C[i][j],end=<span class="string">'\t'</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>
<p>0x6.1.2矩阵相乘<br>两个矩阵A与B相乘受到某些限制。首先，必须符合A为一个mn的矩阵，B为np的矩阵，对AB之后的结果为一个mp的矩阵C   </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">def MatrixMultiply(arrA, arrB,arrC,M,N,P):</span><br><span class="line">    global C</span><br><span class="line">    <span class="keyword">if</span> M&lt;=0 or N&lt;=0 or P&lt;=0:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'[错误:维数M,N,P必须大于0]'</span>)</span><br><span class="line">        <span class="built_in">return</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(M):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(P):</span><br><span class="line">            Temp=0</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(N):</span><br><span class="line">                Temp = Temp + int(arrA[i*N+k])*int(arrB[k*P+j])</span><br><span class="line">            arrC[i*P+j] = Temp</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'请输入矩阵A的维数(M,N): '</span>)</span><br><span class="line">M=int(input(<span class="string">'M= '</span>))</span><br><span class="line">N=int(input(<span class="string">'N= '</span>))</span><br><span class="line">A=[None]*M*N <span class="comment">#声明大小为MxN的列表A</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'[请输入矩阵A的各个元素]'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(M):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(N):</span><br><span class="line">        A[i*N+j]=input(<span class="string">'a%d%d='</span>%(i,j))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'请输入矩阵B的维数(N,P): '</span>)</span><br><span class="line">N=int(input(<span class="string">'N= '</span>))</span><br><span class="line">P=int(input(<span class="string">'P= '</span>))</span><br><span class="line"></span><br><span class="line">B=[None]*N*P <span class="comment">#声明大小为NxP的列表B</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'[请输入矩阵B的各个元素]'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(P):</span><br><span class="line">        B[i*P+j]=input(<span class="string">'b%d%d='</span>%(i,j))</span><br><span class="line"></span><br><span class="line">C=[None]*M*P <span class="comment">#声明大小为MxP的列表C</span></span><br><span class="line">MatrixMultiply(A,B,C,M,N,P)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'[AxB的结果是]'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(M):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(P):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'%d'</span> %C[i*P+j], end=<span class="string">'\t'</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>
<p>0x6.1.3转置矩阵<br>“转置矩阵”(A)就是把原矩阵的行坐标元素与列坐标元素互相调换，假设A为A的转置矩阵，则有A[i,j]=A[j,i]  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">arrA = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]</span><br><span class="line"></span><br><span class="line">N = 4</span><br><span class="line"></span><br><span class="line">arrB = [[None]*N <span class="keyword">for</span> row <span class="keyword">in</span> range(N)]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"原设置的矩阵内容："</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(4):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(4):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"%d"</span> %arrA[i][j],end=<span class="string">"\t"</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(4):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(4):</span><br><span class="line">        arrB[i][j] = arrA[j][i]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"转置矩阵内容："</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(4):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(4):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"%d"</span> % arrB[i][j], end=<span class="string">"\t"</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>
<h2 id="0x6-2-链表"><a href="#0x6-2-链表" class="headerlink" title="0x6.2 链表"></a>0x6.2 链表</h2><p>在python中，如果以动态分配产生链表节点的节点，可以先行定义一个类，接着在该类中定义一个指针字段，作用是指向下一个链表节点，另外该类中至少要有一个数据字段。例如，我们声明一个学生成绩链表节点的结构声明，并且包含姓名(name)，成绩(score)两个数据字段与一个指针字段(next)。在python语言中可以声明如下：       </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class student:</span><br><span class="line">  def __init__(self):</span><br><span class="line">    self.name=<span class="string">""</span></span><br><span class="line">    self.score=0</span><br><span class="line">    self.next=None</span><br></pre></td></tr></table></figure>
<p>完成节点类的声明后，就可以动态建立链表中的每个节点。假设现在要新增一个节点至链表的末尾，且ptr指向链表的第一个节点，在程序上必须设计4个步骤：</p>
<p>动态分配内存空间给新节点使用<br>将原链表尾部的指针(next)指向新元素所在的内存位置<br>将ptr指针指向新的节点的内存位置，表示这是新的链表尾部<br>由于新节点当前为链表的最后一个元素，因此将它的指针(next)指向None<br>例如：将s1的next变量指向s2，而且s2的next变量指向None  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1.next=s2</span><br><span class="line">s2.next=None</span><br></pre></td></tr></table></figure>
<p>python程序片段是建立学生节点的单向链表的算法：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class student:</span><br><span class="line">  def __init__(self):</span><br><span class="line">    self.name=<span class="string">""</span></span><br><span class="line">    self.score=0</span><br><span class="line">    self.next=None</span><br><span class="line"></span><br><span class="line">head = student()</span><br><span class="line">head.next = None</span><br><span class="line">ptr = head</span><br><span class="line">select = 0</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> select!=2:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"(1)添加 (2)离开=&gt;"</span>)</span><br><span class="line">    try:</span><br><span class="line">        select = int(input(<span class="string">"请输入一个选项："</span>))</span><br><span class="line">    except ValueError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"输入错误"</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"请重新输入\n"</span>)</span><br><span class="line">    <span class="keyword">if</span> select==1:</span><br><span class="line">        new_data = student()</span><br><span class="line">        new_data.name = input(<span class="string">"姓名："</span>)</span><br><span class="line">        new_data.no=input(<span class="string">"学号："</span>)</span><br><span class="line">        new_data.Math=<span class="built_in">eval</span>(input(<span class="string">"数学成绩："</span>))</span><br><span class="line">        ptr.next = new_data</span><br><span class="line">        new_data.next = None</span><br><span class="line">        ptr = ptr.next</span><br></pre></td></tr></table></figure>
<p>0x6.2.1 单向链表的连接功能<br>对于两个或两个以上的连接(concatenation，也称为级联)，其实现方法很容易：只要将链表的首尾相连即可<br>范例：<br>将两组学生成绩的链表连接起来，并输出新的学生的成绩链表。   </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">def concatlist(ptr1,ptr2):</span><br><span class="line">    ptr=ptr1</span><br><span class="line">    <span class="keyword">while</span> ptr.next!=None:</span><br><span class="line">        ptr=ptr.next</span><br><span class="line">    ptr.next=ptr2</span><br><span class="line">    <span class="built_in">return</span> ptr1</span><br><span class="line"></span><br><span class="line">class employee:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.num=0</span><br><span class="line">        self.salary=0</span><br><span class="line">        self.name=<span class="string">''</span></span><br><span class="line">        self.next=None</span><br><span class="line"></span><br><span class="line">findword=0</span><br><span class="line">data=[[None]*2 <span class="keyword">for</span> row <span class="keyword">in</span> range(12)]</span><br><span class="line"></span><br><span class="line">namedata1=[<span class="string">'Allen'</span>,<span class="string">'Scott'</span>,<span class="string">'Marry'</span>,<span class="string">'Jon'</span>,<span class="string">'Mark'</span>,<span class="string">'Ricky'</span>,<span class="string">'Lisa'</span>,<span class="string">'Jasica'</span>, <span class="string">'Hanson'</span>,<span class="string">'Amy'</span>,<span class="string">'Bob'</span>,<span class="string">'Jack'</span>]</span><br><span class="line"></span><br><span class="line">namedata2=[<span class="string">'May'</span>,<span class="string">'John'</span>,<span class="string">'Michael'</span>,<span class="string">'Andy'</span>,<span class="string">'Tom'</span>,<span class="string">'Jane'</span>,<span class="string">'Yoko'</span>,<span class="string">'Axel'</span>,<span class="string">'Alex'</span>,<span class="string">'Judy'</span>,<span class="string">'Kelly'</span>,<span class="string">'Lucy'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(12):</span><br><span class="line">    data[i][0]=i+1</span><br><span class="line">    data[i][1]=random.randint(51,100)</span><br><span class="line"></span><br><span class="line">head1=employee()   <span class="comment">#建立第一组链表的头部</span></span><br><span class="line"><span class="keyword">if</span> not head1:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Error!! 内存分配失败!!'</span>)</span><br><span class="line">    sys.exit(0)</span><br><span class="line">	</span><br><span class="line">head1.num=data[0][0]</span><br><span class="line">head1.name=namedata1[0]</span><br><span class="line">head1.salary=data[0][1]</span><br><span class="line">head1.next=None</span><br><span class="line">ptr=head1</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(1,12):  <span class="comment">#建立第一组链表</span></span><br><span class="line">    newnode=employee()</span><br><span class="line">    newnode.num=data[i][0]</span><br><span class="line">    newnode.name=namedata1[i]</span><br><span class="line">    newnode.salary=data[i][1]</span><br><span class="line">    newnode.next=None</span><br><span class="line">    ptr.next=newnode</span><br><span class="line">    ptr=ptr.next</span><br><span class="line">    	</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(12):</span><br><span class="line">    data[i][0]=i+13</span><br><span class="line">    data[i][1]=random.randint(51,100)</span><br><span class="line"></span><br><span class="line">head2=employee()   <span class="comment">#建立第二组链表的头部</span></span><br><span class="line"><span class="keyword">if</span> not head2:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Error!! 内存分配失败!!'</span>)</span><br><span class="line">    sys.exit(0)  </span><br><span class="line">	</span><br><span class="line">head2.num=data[0][0]</span><br><span class="line">head2.name=namedata2[0]</span><br><span class="line">head2.salary=data[0][1]</span><br><span class="line">head2.next=None</span><br><span class="line">ptr=head2</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(1,12):  <span class="comment">#建立第二组链表</span></span><br><span class="line">    newnode=employee()</span><br><span class="line">    newnode.num=data[i][0]</span><br><span class="line">    newnode.name=namedata2[i]</span><br><span class="line">    newnode.salary=data[i][1]</span><br><span class="line">    newnode.next=None</span><br><span class="line">    ptr.next=newnode</span><br><span class="line">    ptr=ptr.next</span><br><span class="line">	</span><br><span class="line">i=0</span><br><span class="line">ptr=concatlist(head1,head2) <span class="comment">#将链表相连</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'两个链表相连的结果为：'</span>)</span><br><span class="line"><span class="keyword">while</span> ptr!=None: <span class="comment">#打印链表的数据</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'[%2d %6s %3d] =&gt; '</span> %(ptr.num,ptr.name,ptr.salary),end=<span class="string">''</span>)</span><br><span class="line">    i=i+1</span><br><span class="line">    <span class="keyword">if</span> i&gt;=3:</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line">        i=0</span><br><span class="line">    ptr=ptr.next</span><br></pre></td></tr></table></figure>
<p>0x6.2.2单向链表的节点<br>在单向链表类型的数据结构中，若要在链表中删除一个节点，如同一列火车中拿掉原来的车厢，根据所删除节点的位置会有以下三种不同的情况：<br>(1)删除链表的第一个节点<br>只要把链表头指针指向第二个节点即可<br><img src="../../images/arithmetic/link1.png" alt=""><br>python算法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">top=head</span><br><span class="line">head=head.next</span><br></pre></td></tr></table></figure>
<p>(2)删除链表的最后一个节点<br>只要指向最后一个节点ptr的指针直接指向None即可<br><img src="../../images/arithmetic/link2.png" alt=""><br>python算法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ptr.next=tail</span><br><span class="line">ptr.next=None</span><br></pre></td></tr></table></figure>
<p>(3)删除链表内的中间节点<br>只要将删除节点的前一个节点的指针指向将要被删除节点的下一个节点即可 !! <img src="../../images/arithmetic/link3.png" alt=""><br>python算法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Y=ptr.next</span><br><span class="line">ptr.next=Y.next</span><br></pre></td></tr></table></figure>
<p>范例:<br>在员工数据的链表中删除节点，并且允许所删除的节点有在链表头部，链表尾部和链表中间三种不同位置的情况。最后离开时，列出此链表的最后所有节点的数据字段的内容。结构成员类型如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class employee:</span><br><span class="line">  def __init__(self):</span><br><span class="line">    self.num=0</span><br><span class="line">    self.salary=0</span><br><span class="line">    self.name=<span class="string">""</span></span><br><span class="line">    self.next=None</span><br></pre></td></tr></table></figure>
<p>代码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">class employee:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.num = 0</span><br><span class="line">        self.salary = 0</span><br><span class="line">        self.name = <span class="string">''</span></span><br><span class="line">        self.next = None</span><br><span class="line"></span><br><span class="line">def del_ptr(head, ptr):  <span class="comment"># 删除节点子程序</span></span><br><span class="line">    top = head</span><br><span class="line">    <span class="keyword">if</span> ptr.num == head.num:  <span class="comment"># [情形1]:要删除的节点在链表头部</span></span><br><span class="line">        head = head.next</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'已删除第 %d 号员工 姓名：%s 薪资:%d'</span> % (ptr.num, ptr.name, ptr.salary))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">while</span> top.next != ptr:  <span class="comment"># 找到删除节点的前一个位置</span></span><br><span class="line">            top = top.next</span><br><span class="line">        <span class="keyword">if</span> ptr.next == None:  <span class="comment"># 删除在链表末尾的节点</span></span><br><span class="line">            top.next = None</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'已删除第 %d 号员工 姓名：%s 薪资:%d'</span> % (ptr.num, ptr.name, ptr.salary))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            top.next = ptr.next  <span class="comment"># 删除在串行中的任一节点</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'已删除第 %d 号员工 姓名：%s 薪资:%d'</span> % (ptr.num, ptr.name, ptr.salary))</span><br><span class="line">    <span class="built_in">return</span> head  <span class="comment"># 返回链表</span></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    findword = 0</span><br><span class="line">    namedata = [<span class="string">'Allen'</span>, <span class="string">'Scott'</span>, <span class="string">'Marry'</span>, <span class="string">'John'</span>, <span class="string">'Mark'</span>, <span class="string">'Ricky'</span>, <span class="string">'Lisa'</span>, <span class="string">'Jasica'</span>, <span class="string">'Hanson'</span>, <span class="string">'Amy'</span>, <span class="string">'Bob'</span>, <span class="string">'Jack'</span>]</span><br><span class="line">    data = [[1001, 32367], [1002, 24388], [1003, 27556], [1007, 31299], [1012, 42660], [1014, 25676], [1018, 44145],</span><br><span class="line">            [1043, 52182], [1031, 32769], [1037, 21100], [1041, 32196], [1046, 25776]]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'员工编号 薪水 员工编号 薪水 员工编号 薪水 员工编号 薪水'</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'-------------------------------------------------------'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(3):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(4):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'%2d  [%3d]  '</span> % (data[j * 3 + i][0], data[j * 3 + i][1]), end=<span class="string">''</span>)</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line">    head = employee()  <span class="comment"># 建立链表头部</span></span><br><span class="line">    <span class="keyword">if</span> not head:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'Error!! 内存分配失败!!'</span>)</span><br><span class="line">        sys.exit(0)</span><br><span class="line">    head.num = data[0][0]</span><br><span class="line">    head.name = namedata[0]</span><br><span class="line">    head.salary = data[0][1]</span><br><span class="line">    head.next = None</span><br><span class="line"></span><br><span class="line">    ptr = head</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(1, 12):  <span class="comment"># 建立链表</span></span><br><span class="line">        newnode = employee()</span><br><span class="line">        newnode.num = data[i][0]</span><br><span class="line">        newnode.name = namedata[i]</span><br><span class="line">        newnode.salary = data[i][1]</span><br><span class="line">        newnode.num = data[i][0]</span><br><span class="line">        newnode.next = None</span><br><span class="line">        ptr.next = newnode</span><br><span class="line">        ptr = ptr.next</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (True):</span><br><span class="line">        findword = int(input(<span class="string">'请输入要删除的员工编号,要结束删除过程,请输入-1：'</span>))</span><br><span class="line">        <span class="keyword">if</span> (findword == -1):  <span class="comment"># 循环中断条件</span></span><br><span class="line">            <span class="built_in">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ptr = head</span><br><span class="line">            find = 0</span><br><span class="line">            <span class="keyword">while</span> ptr != None:</span><br><span class="line">                <span class="keyword">if</span> ptr.num == findword:</span><br><span class="line">                    ptr = del_ptr(head, ptr)</span><br><span class="line">                    find = find + 1</span><br><span class="line">                    head = ptr</span><br><span class="line">                ptr = ptr.next</span><br><span class="line">            <span class="keyword">if</span> find == 0:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">'######没有找到######'</span>)</span><br><span class="line"></span><br><span class="line">    ptr = head</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'\t员工编号    姓名\t薪水'</span>)  <span class="comment"># 打印剩余链表中的数据</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'\t=============================='</span>)</span><br><span class="line">    <span class="keyword">while</span> (ptr != None):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'\t[%2d]\t[ %-10s]\t[%3d]'</span> % (ptr.num, ptr.name, ptr.salary))</span><br><span class="line">        ptr = ptr.next</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<p>0x6.2.3单向链表的反转<br>如果要将单向链表反转，则必须使用三个指针变量<br><img src="../../images/arithmetic/reverse1.png" alt=""><br>python算法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class employee:</span><br><span class="line">  def __init__(self):</span><br><span class="line">    self.num=0</span><br><span class="line">    self.salary=0</span><br><span class="line">    self.name=<span class="string">""</span></span><br><span class="line">    self.next=None</span><br><span class="line">    </span><br><span class="line">def invert(x):          <span class="comment"># x为链表的头指针</span></span><br><span class="line">  p=x                   <span class="comment"># 将p指向链表的开头</span></span><br><span class="line">  q=None                <span class="comment"># q是p的前一个节点</span></span><br><span class="line">  <span class="keyword">while</span> p!=None:</span><br><span class="line">    r=q           <span class="comment"># 将r接到q之后</span></span><br><span class="line">    q=p           <span class="comment"># 将q接到p之后</span></span><br><span class="line">    p=p.next      <span class="comment"># p移到下一个节点</span></span><br><span class="line">    q.next=r      <span class="comment"># q连接到之前的节点</span></span><br><span class="line">   <span class="built_in">return</span> q</span><br></pre></td></tr></table></figure>
<p>在算法invert(X)中，我们使用了p,q,r三个指针变量，它的演变过程如下：<br>第一步：执行while循环前  </p>
<p><img src="../../images/arithmetic/reverse2.png" alt=""><br>第二步：执行whilex<br><img src="../../images/arithmetic/reverse3.png" alt=""><br>第三步：第二次执行while循环<br><img src="../../images/arithmetic/reverse4.png" alt=""><br>当执行到p=None时，整个单向链表就整个反转过来了<br>范例:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">class employee:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.num=0</span><br><span class="line">        self.salary=0</span><br><span class="line">        self.name=<span class="string">''</span></span><br><span class="line">        self.next=None</span><br><span class="line"></span><br><span class="line">findword=0</span><br><span class="line"></span><br><span class="line">namedata=[<span class="string">'Allen'</span>,<span class="string">'Scott'</span>,<span class="string">'Marry'</span>,<span class="string">'Jon'</span>, \</span><br><span class="line">          <span class="string">'Mark'</span>,<span class="string">'Ricky'</span>,<span class="string">'Lisa'</span>,<span class="string">'Jasica'</span>, \</span><br><span class="line">          <span class="string">'Hanson'</span>,<span class="string">'Amy'</span>,<span class="string">'Bob'</span>,<span class="string">'Jack'</span>]</span><br><span class="line"></span><br><span class="line">data=[[1001,32367],[1002,24388],[1003,27556],[1007,31299], \</span><br><span class="line">      [1012,42660],[1014,25676],[1018,44145],[1043,52182], \</span><br><span class="line">      [1031,32769],[1037,21100],[1041,32196],[1046,25776]]</span><br><span class="line"></span><br><span class="line">head=employee() <span class="comment">#建立链表头部</span></span><br><span class="line"><span class="keyword">if</span> not head:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Error!! 内存分配失败!!'</span>)</span><br><span class="line">    sys.exit(0)</span><br><span class="line"></span><br><span class="line">head.num=data[0][0]</span><br><span class="line">head.name=namedata[0]</span><br><span class="line">head.salary=data[0][1]</span><br><span class="line">head.next=None</span><br><span class="line">ptr=head</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(1,12): <span class="comment">#建立链表</span></span><br><span class="line">    newnode=employee()</span><br><span class="line">    newnode.num=data[i][0]</span><br><span class="line">    newnode.name=namedata[i]</span><br><span class="line">    newnode.salary=data[i][1]</span><br><span class="line">    newnode.next=None</span><br><span class="line">    ptr.next=newnode</span><br><span class="line">    ptr=ptr.next</span><br><span class="line"></span><br><span class="line">ptr=head</span><br><span class="line">i=0</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'反转前的员工链表节点数据：'</span>)</span><br><span class="line"><span class="keyword">while</span> ptr !=None:  <span class="comment">#打印链表数据</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'[%2d %6s %3d] =&gt; '</span> %(ptr.num,ptr.name,ptr.salary), end=<span class="string">''</span>)</span><br><span class="line">    i=i+1</span><br><span class="line">    <span class="keyword">if</span> i&gt;=3: <span class="comment">#三个元素为一行</span></span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line">        i=0</span><br><span class="line">    ptr=ptr.next</span><br><span class="line"></span><br><span class="line">ptr=head</span><br><span class="line">before=None</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'\n反转后的链表节点数据：'</span>)</span><br><span class="line"><span class="keyword">while</span> ptr!=None: <span class="comment">#链表反转,利用三个指针</span></span><br><span class="line">    last=before</span><br><span class="line">    before=ptr</span><br><span class="line">    ptr=ptr.next</span><br><span class="line">    before.next=last</span><br><span class="line"></span><br><span class="line">ptr=before</span><br><span class="line"><span class="keyword">while</span> ptr!=None:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'[%2d %6s %3d] =&gt; '</span> %(ptr.num,ptr.name,ptr.salary), end=<span class="string">''</span>)</span><br><span class="line">    i=i+1</span><br><span class="line">    <span class="keyword">if</span> i&gt;=3:</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line">        i=0</span><br><span class="line">    ptr=ptr.next</span><br></pre></td></tr></table></figure>
<h1 id="0x7堆栈与队列算法"><a href="#0x7堆栈与队列算法" class="headerlink" title="0x7堆栈与队列算法"></a>0x7堆栈与队列算法</h1><p>堆栈结构在计算机领域中的应用相当广泛，常用于计算机程序的运行，例如递归调用、子程序调用。<br>队列在计算机领域中的应用也相当广泛，例如计算机的模拟、CPU的作业调度、外围设备联机并发处理系统的应用以及图形遍历的广度优先搜索法。  </p>
<h2 id="0x7-1堆栈"><a href="#0x7-1堆栈" class="headerlink" title="0x7.1堆栈"></a>0x7.1堆栈</h2><p>0x7.1.1数组来实现堆栈<br>优点：用列表实现堆栈设计非常简单<br>缺点：如果堆栈本身的大小是变动的，但列表的大小只能是预先规划和声明的，则列表规划太大会浪费空间，规划过小则不够用。   </p>
<p>范例:<br>使用数组结构来设计一个python程序，用循环来控制元素压入堆栈或弹出堆栈，并仿真堆栈的各种操作，此堆栈的最大容量是100个元素，其中必须包括压入(push)和弹出(pop)，并在最后输出堆栈内的所有元素。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">MAXSTACK = 100  <span class="comment"># 定义堆栈的最大容量</span></span><br><span class="line">global stack</span><br><span class="line">stack = [None] * MAXSTACK  <span class="comment"># 堆栈的数组声明</span></span><br><span class="line">top = -1  <span class="comment"># 堆栈的顶端</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否为空堆栈</span></span><br><span class="line">def isEmpty():</span><br><span class="line">    <span class="keyword">if</span> top == -1:</span><br><span class="line">        <span class="built_in">return</span> True</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">return</span> False</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将指定的数据压入堆栈</span></span><br><span class="line">def push(data):</span><br><span class="line">    global top</span><br><span class="line">    global MAXSTACK</span><br><span class="line">    global stack</span><br><span class="line">    <span class="keyword">if</span> top &gt;= MAXSTACK - 1:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'堆栈已满,无法再加入'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        top += 1</span><br><span class="line">        stack[top] = data  <span class="comment"># 将数据压入堆栈</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从堆栈弹出数据*/</span></span><br><span class="line">def pop():</span><br><span class="line">    global top</span><br><span class="line">    global stack</span><br><span class="line">    <span class="keyword">if</span> isEmpty():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'堆栈是空'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'弹出的元素为: %d'</span> % stack[top])</span><br><span class="line">        top = top - 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主程序</span></span><br><span class="line">i = 2</span><br><span class="line">count = 0</span><br><span class="line"><span class="keyword">while</span> True:</span><br><span class="line">    i = int(input(<span class="string">'要压入堆栈,请输入1,要弹出则输入0,停止操作则输入-1: '</span>))</span><br><span class="line">    <span class="keyword">if</span> i == -1:</span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">    <span class="keyword">elif</span> i == 1:</span><br><span class="line">        value = int(input(<span class="string">'请输入元素值:'</span>))</span><br><span class="line">        push(value)</span><br><span class="line">    <span class="keyword">elif</span> i == 0:</span><br><span class="line">        pop()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'============================'</span>)</span><br><span class="line"><span class="keyword">if</span> top &lt; 0:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'\n 堆栈是空的'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    i = top</span><br><span class="line">    <span class="keyword">while</span> i &gt;= 0:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'堆栈弹出的顺序为:%d'</span> % (stack[i]))</span><br><span class="line">        count += 1</span><br><span class="line">        i = i - 1</span><br><span class="line">    <span class="built_in">print</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'============================'</span>)</span><br></pre></td></tr></table></figure>
<p>范例:<br>设计一个python程序，以数组仿真扑克牌洗牌以及发牌的过程。使用随机数来生成扑克牌放入堆栈，放满52张牌后开始发牌，使用堆栈功能来给4个人发牌。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">global top</span><br><span class="line">top = -1</span><br><span class="line">k = 0</span><br><span class="line"></span><br><span class="line">def push(stack, MAX, val):</span><br><span class="line">    global top</span><br><span class="line">    <span class="keyword">if</span> top &gt;= MAX - 1:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'[堆栈已经满了]'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        top = top + 1</span><br><span class="line">        stack[top] = val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def pop(stack):</span><br><span class="line">    global top</span><br><span class="line">    <span class="keyword">if</span> top &lt; 0:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'[堆栈已经空了]'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        top = top - 1</span><br><span class="line">        <span class="built_in">return</span> stack[top]</span><br><span class="line"></span><br><span class="line">def shuffle(old):</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> old:</span><br><span class="line">        p = random.randrange(0, len(old))</span><br><span class="line">        result.append(old[p])</span><br><span class="line">        old.pop(p)</span><br><span class="line">    <span class="built_in">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">card = [None] * 52</span><br><span class="line">card_new = [None] * 52</span><br><span class="line">stack = [0] * 52</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(52):</span><br><span class="line">    card[i] = i + 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'[洗牌中...请稍候!]'</span>)</span><br><span class="line"></span><br><span class="line">card_new = shuffle(card)</span><br><span class="line"></span><br><span class="line">i = 0</span><br><span class="line"><span class="keyword">while</span> i != 52:</span><br><span class="line">    push(stack, 52, card_new[i])  <span class="comment"># 将52张牌压入堆栈</span></span><br><span class="line">    i = i + 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'[逆时针发牌]'</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'[显示各家的牌] 东家\t  北家\t   西家\t    南家'</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'================================='</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> top &gt;= 0:</span><br><span class="line">    <span class="comment"># print(stack[top])</span></span><br><span class="line">    style = (stack[top]) % 4  <span class="comment"># 计算牌的花色</span></span><br><span class="line">    <span class="comment"># print('style=', style)</span></span><br><span class="line">    <span class="keyword">if</span> style == 0:  <span class="comment"># 梅花</span></span><br><span class="line">        ascVal = <span class="string">'club'</span></span><br><span class="line">    <span class="keyword">elif</span> style == 1:  <span class="comment"># 方块</span></span><br><span class="line">        ascVal = <span class="string">'diamond'</span></span><br><span class="line">    <span class="keyword">elif</span> style == 2:  <span class="comment"># 红心</span></span><br><span class="line">        ascVal = <span class="string">'heart'</span></span><br><span class="line">    <span class="keyword">elif</span> style == 3:</span><br><span class="line">        ascVal = <span class="string">'spade'</span>  <span class="comment"># 黑桃</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'[%s%3d]\t'</span> % (ascVal, stack[top] % 13 + 1), end=<span class="string">''</span>)</span><br><span class="line">    <span class="keyword">if</span> top % 4 == 0:</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line">    top -= 1</span><br></pre></td></tr></table></figure>
<p>0x7.1.2 用链表实现堆栈<br>优点：随时可以动态改变链表的长度，能有效利用内存资源，缺点：设计的算法较为复杂。   </p>
<p>利用链表实现堆栈时，同样需要定义链表节点，包含一个next指针。<br>范例：<br>设计一个python程序以链表来实现堆栈操作，并使用循环来控制元素的压入堆栈或弹出堆栈，其中必须包括压入(push)和弹出(pop)函数，并在最后输出堆栈内的元素。   </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class Node:  <span class="comment"># 堆栈链结节点的声明</span></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.data = 0  <span class="comment"># 堆栈数据的声明</span></span><br><span class="line">        self.next = None  <span class="comment"># 堆栈中用来指向下一个节点</span></span><br><span class="line">top = None</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断堆栈是否为空，是空返回1，否则返回0</span></span><br><span class="line">def isEmpty():</span><br><span class="line">    global top</span><br><span class="line">    <span class="keyword">if</span> (top == None):</span><br><span class="line">        <span class="built_in">return</span> 1</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">return</span> 0</span><br><span class="line"><span class="comment"># 将指定的数据压入堆栈</span></span><br><span class="line">def push(data):</span><br><span class="line">    global top</span><br><span class="line">    new_add_node = Node()</span><br><span class="line">    new_add_node.data = data  <span class="comment"># 将传入的值指定为节点的内容</span></span><br><span class="line">    new_add_node.next = top  <span class="comment"># 将新节点指向堆栈的顶端</span></span><br><span class="line">    top = new_add_node  <span class="comment"># 新节点成为堆栈的顶端</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从堆栈弹出数据</span></span><br><span class="line">def pop():</span><br><span class="line">    global top</span><br><span class="line">    <span class="keyword">if</span> isEmpty():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'===目前为空堆栈==='</span>)</span><br><span class="line">        <span class="built_in">return</span> -1</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ptr = top  <span class="comment"># 指向堆栈的顶端</span></span><br><span class="line">        top = top.next  <span class="comment"># 将堆栈顶端的指针指向下一个节点</span></span><br><span class="line">        temp = ptr.data  <span class="comment"># 弹出堆栈的数据</span></span><br><span class="line">        <span class="built_in">return</span> temp  <span class="comment"># 将从堆栈弹出的数据返回给主程序</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主程序</span></span><br><span class="line"><span class="keyword">while</span> True:</span><br><span class="line">    i = int(input(<span class="string">'要压入堆栈,请输入1,要弹出则输入0,停止操作则输入-1: '</span>))</span><br><span class="line">    <span class="keyword">if</span> i == -1:</span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">    <span class="keyword">elif</span> i == 1:</span><br><span class="line">        value = int(input(<span class="string">'请输入元素值:'</span>))</span><br><span class="line">        push(value)</span><br><span class="line">    <span class="keyword">elif</span> i == 0:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'弹出的元素为%d'</span> % pop())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'============================'</span>)</span><br><span class="line"><span class="keyword">while</span> (not isEmpty()):  <span class="comment"># 将数据陆续从顶端弹出</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'堆栈弹出的顺序为:%d'</span> % pop())</span><br></pre></td></tr></table></figure>
<p>0x7.1.3汉诺塔问题的求解算法<br>该游戏是在一块铜板装置上，有三根杆(编号A、B、C)，在A杆自下而上、由大到小按顺序放置64个金盘(如下图)。游戏的目标：把A杆上的金盘全部移到C杆上，并仍保持原有顺序叠好。操作规则：每次只能移动一个盘子，并且在移动过程中三根杆上都始终保持大盘在下，小盘在上，操作过程中盘子可以置于A、B、C任一杆上<br>汉诺塔问题归纳成三个步骤:<br>1)将n-1个盘子从木杆1移动到了木杆2<br>2)将第n个最大盘子从木桩1移动到木桩3<br>3)将n-1个盘子从木桩2移动到了木桩3   </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def hanoi(n,p1,p2,p3):</span><br><span class="line">    <span class="keyword">if</span> n==1:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'盘子从%d移到%d'</span>%(p1,p3))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        hanoi(n-1,p1,p3,p2)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'盘子从%d移到%d'</span>%(p1,p3))</span><br><span class="line">        hanoi(n-1,p2,p1,p3)</span><br><span class="line">j=int(input(<span class="string">'请输入要移动盘子的数量:'</span>))</span><br><span class="line">hanoi(j,1,2,3)</span><br></pre></td></tr></table></figure>
<p>0x7.1.4八皇后问题<br>八皇后问题也是一种常见的堆栈的应用。现在要放入多个皇后到棋盘上，相互之间还不能吃到对方。后放入的皇后，放入前必须考虑所放位置的直线方向、横线方向或对角线方向是否已经被放置了旧皇后，否则就会被先放入的旧皇后吃掉。   </p>
<p>4皇后在4x4的棋盘上，8皇后问题在8x8的棋盘上，N皇后问题就在NXN的棋盘上。   </p>
<p>在实际过程中也会用到回朔法：如果放置新皇后的该行（列）的8个位置都没有办法放置新皇后（放入都会被之前的吃掉），此时必须从堆栈中弹出前一个皇后的位置，并在该行（列）中重新寻找另一个新的位置来放，再将该位置压入堆栈中，而这种方式就是一种回溯算法的应用。<br><img src="../../images/arithmetic/eightqueen.png" alt=""></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">global queen</span><br><span class="line">global number</span><br><span class="line">EIGHT = 8  <span class="comment"># 定义堆栈的最大容量</span></span><br><span class="line">queen = [None] * 8  <span class="comment"># 存放8个皇后的行位置</span></span><br><span class="line"></span><br><span class="line">number = 0  <span class="comment"># 计算总共有几组解的总数</span></span><br><span class="line"><span class="comment"># 决定皇后存放的位置</span></span><br><span class="line"><span class="comment"># 输出所需要的结果</span></span><br><span class="line">def print_table():</span><br><span class="line">    global number</span><br><span class="line">    x = y = 0</span><br><span class="line">    number += 1</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">''</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'八皇后问题的第%d组解\t'</span> % number)</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(EIGHT):</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> range(EIGHT):</span><br><span class="line">            <span class="keyword">if</span> x == queen[y]:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">'&lt;q&gt;'</span>, end=<span class="string">''</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">'&lt;-&gt;'</span>, end=<span class="string">''</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'\t'</span>)</span><br><span class="line">    input(<span class="string">'\n..按下任意键继续..\n'</span>)</span><br><span class="line"><span class="comment"># 测试在(row,col)上的皇后是否遭受攻击</span></span><br><span class="line"><span class="comment"># 若遭受攻击则返回值为1,否则返回0</span></span><br><span class="line">def attack(row, col):</span><br><span class="line">    global queen</span><br><span class="line">    i = 0</span><br><span class="line">    atk = 0</span><br><span class="line">    offset_row = offset_col = 0</span><br><span class="line">    <span class="keyword">while</span> (atk != 1) and i &lt; col:</span><br><span class="line">        offset_col = abs(i - col)</span><br><span class="line">        offset_row = abs(queen[i] - row)</span><br><span class="line">        <span class="comment"># 判断两皇后是否在同一行或在同一对角线上</span></span><br><span class="line">        <span class="keyword">if</span> queen[i] == row or offset_row == offset_col:</span><br><span class="line">            atk = 1</span><br><span class="line">        i = i + 1</span><br><span class="line">    <span class="built_in">return</span> atk</span><br><span class="line">def decide_position(value):</span><br><span class="line">    global queen</span><br><span class="line">    i = 0</span><br><span class="line">    <span class="keyword">while</span> i &lt; EIGHT:</span><br><span class="line">        <span class="keyword">if</span> attack(i, value) != 1:</span><br><span class="line">            queen[value] = i</span><br><span class="line">            <span class="keyword">if</span> value == 7:</span><br><span class="line">                print_table()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                decide_position(value + 1)</span><br><span class="line">        i = i + 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主程序</span></span><br><span class="line">decide_position(0)</span><br></pre></td></tr></table></figure>
<p>0x7.1.5老鼠走迷宫问题<br>老鼠遵守以下三个原则：</p>
<p>1）一次只能走一格</p>
<p>2）遇到墙无法往前走，退回一步找找看能否有其他的路可走</p>
<p>3）走过的路不会再走第二次</p>
<p>可以采用二维数组MAZE[row][col]，并附和一下规则：</p>
<p>1.MAZE[i][j]=1,表示[i][j]处有墙，无法通过</p>
<p>2.MAZE[i][j]=0,表示[i][j]处无墙，可以通过</p>
<p>3.MAZE[1][1]是入口，MAZE[m][n]是出口。</p>
<p>可以使用链表的方式来记录已经走过的位置，并且将走过的位置对应的数组元素内容标记为2，然后阿静这个位置放入堆栈再进行下一次的选择。</p>
<p>该算法时每次进行移动时所执行的操作，其主要是判断当前所在位置的上、下、左、右是否还有可以前进的方格。如果找到可以前进的方格，则将该方格的编号加入记录移动路径的堆栈中，并往该方格移动；如果四周没有可走的方格时，也就是当前所在的方格无法走出迷宫，必须退回到前一格重新检查是否有其他的可走的路径。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">class Node:</span><br><span class="line">    def __init__(self, x, y):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">        self.next = None</span><br><span class="line">class TraceRecord:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.first = None</span><br><span class="line">        self.last = None</span><br><span class="line"></span><br><span class="line">    def isEmpty(self):</span><br><span class="line">        <span class="built_in">return</span> self.first == None</span><br><span class="line"></span><br><span class="line">    def insert(self, x, y):</span><br><span class="line">        newNode = Node(x, y)</span><br><span class="line">        <span class="keyword">if</span> self.first == None:</span><br><span class="line">            self.first = newNode</span><br><span class="line">            self.last = newNode</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.last.next = newNode</span><br><span class="line">            self.last = newNode</span><br><span class="line"></span><br><span class="line">    def delete(self):</span><br><span class="line">        <span class="keyword">if</span> self.first == None:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'[队列已经空了]'</span>)</span><br><span class="line">            <span class="built_in">return</span></span><br><span class="line">        newNode = self.first</span><br><span class="line">        <span class="keyword">while</span> newNode.next != self.last:</span><br><span class="line">            newNode = newNode.next</span><br><span class="line">        newNode.next = self.last.next</span><br><span class="line">        self.last = newNode</span><br><span class="line"></span><br><span class="line">ExitX = 8  <span class="comment"># 定义出口的X坐标在第8行</span></span><br><span class="line">ExitY = 10  <span class="comment"># 定义出口的Y坐标在第10列</span></span><br><span class="line"><span class="comment"># 声明迷宫数组</span></span><br><span class="line">MAZE = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], \</span><br><span class="line">        [1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1], \</span><br><span class="line">        [1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1], \</span><br><span class="line">        [1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1], \</span><br><span class="line">        [1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1], \</span><br><span class="line">        [1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1], \</span><br><span class="line">        [1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1], \</span><br><span class="line">        [1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1], \</span><br><span class="line">        [1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1], \</span><br><span class="line">        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def chkExit(x, y, ex, ey):</span><br><span class="line">    <span class="keyword">if</span> x == ex and y == ey:</span><br><span class="line">        <span class="keyword">if</span> (MAZE[x - 1][y] == 1 or MAZE[x + 1][y] == 1 or MAZE[x][y - 1] == 1 or MAZE[x][y + 1] == 2):</span><br><span class="line">            <span class="built_in">return</span> 1</span><br><span class="line">        <span class="keyword">if</span> (MAZE[x - 1][y] == 1 or MAZE[x + 1][y] == 1 or MAZE[x][y - 1] == 2 or MAZE[x][y + 1] == 1):</span><br><span class="line">            <span class="built_in">return</span> 1</span><br><span class="line">        <span class="keyword">if</span> (MAZE[x - 1][y] == 1 or MAZE[x + 1][y] == 2 or MAZE[x][y - 1] == 1 or MAZE[x][y + 1] == 1):</span><br><span class="line">            <span class="built_in">return</span> 1</span><br><span class="line">        <span class="keyword">if</span> (MAZE[x - 1][y] == 2 or MAZE[x + 1][y] == 1 or MAZE[x][y - 1] == 1 or MAZE[x][y + 1] == 1):</span><br><span class="line">            <span class="built_in">return</span> 1</span><br><span class="line">    <span class="built_in">return</span> 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主程序</span></span><br><span class="line"></span><br><span class="line">path = TraceRecord()</span><br><span class="line">x = 1</span><br><span class="line">y = 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'[迷宫的路径(0标记的部分)]'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(10):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(12):</span><br><span class="line">        <span class="built_in">print</span>(MAZE[i][j], end=<span class="string">''</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> x &lt;= ExitX and y &lt;= ExitY:</span><br><span class="line">    MAZE[x][y] = 2</span><br><span class="line">    <span class="keyword">if</span> MAZE[x - 1][y] == 0:</span><br><span class="line">        x -= 1</span><br><span class="line">        path.insert(x, y)</span><br><span class="line">    <span class="keyword">elif</span> MAZE[x + 1][y] == 0:</span><br><span class="line">        x += 1</span><br><span class="line">        path.insert(x, y)</span><br><span class="line">    <span class="keyword">elif</span> MAZE[x][y - 1] == 0:</span><br><span class="line">        y -= 1</span><br><span class="line">        path.insert(x, y)</span><br><span class="line">    <span class="keyword">elif</span> MAZE[x][y + 1] == 0:</span><br><span class="line">        y += 1</span><br><span class="line">        path.insert(x, y)</span><br><span class="line">    <span class="keyword">elif</span> chkExit(x, y, ExitX, ExitY) == 1:</span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        MAZE[x][y] = 2</span><br><span class="line">        path.delete()</span><br><span class="line">        x = path.last.x</span><br><span class="line">        y = path.last.y</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'[老鼠走过的路径(2标记的部分)]'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(10):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(12):</span><br><span class="line">        <span class="built_in">print</span>(MAZE[i][j], end=<span class="string">''</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>
<h1 id="0x7-2-队列"><a href="#0x7-2-队列" class="headerlink" title="0x7.2 队列"></a>0x7.2 队列</h1><p>0x7.2.1 数组实现队列<br>与堆栈不同的是需要拥有两种基本操作：加入与删除，而且要使用front与rear两个指针来分别指向队列的前端与末尾，缺点是数组大小无法根据队列的实际需要来动态申请，只能说明固定的大小   </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MAXSIZE=4</span><br><span class="line">queue=[0]*MAXSIZE</span><br><span class="line">front=-1</span><br><span class="line">rear=-1       <span class="comment"># 队列为空时，front=-1,rear=-1</span></span><br></pre></td></tr></table></figure>
<p>队列操作的过程用python语言将以数组操作队列的相关算法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">def enqueue(item):    <span class="comment"># 将新数据加入Q的末尾，返回新队列</span></span><br><span class="line">  global rear</span><br><span class="line">  global MAX_SIZE</span><br><span class="line">  global queue</span><br><span class="line">  <span class="keyword">if</span> rear==MAX_SIZE-1:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"队列已满!"</span>)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    rear+=1</span><br><span class="line">    queue[rear]=item</span><br><span class="line">def dequeue(item):    <span class="comment"># 删除队列前端的数据，返回新队列</span></span><br><span class="line">  global rear</span><br><span class="line">  global MAX_SIZE</span><br><span class="line">  global front</span><br><span class="line">  global queue</span><br><span class="line">  <span class="keyword">if</span> front==rear:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"队列为空!"</span>)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    front+=1</span><br><span class="line">    item=queue[front]</span><br><span class="line">def FRONT_VALUE(Queue):   <span class="comment">#返回队列前端的值</span></span><br><span class="line">  global rear</span><br><span class="line">  global front</span><br><span class="line">  global queue</span><br><span class="line">  <span class="keyword">if</span> front==rear:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"这是空队列!"</span>)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(queue[front])</span><br></pre></td></tr></table></figure>
<p>范例:<br>打印输出队列前端的值  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">MAX=10			<span class="comment">#定义队列的大小</span></span><br><span class="line">queue=[0]*MAX</span><br><span class="line">front=rear=-1</span><br><span class="line">choice=<span class="string">''</span></span><br><span class="line"><span class="keyword">while</span> rear&lt;MAX-1 and choice !=<span class="string">'e'</span>:</span><br><span class="line">    choice=input(<span class="string">'[a]表示加入一个数值，[d]表示取出一个数值，[e]表示跳出此程序: '</span>)</span><br><span class="line">    <span class="keyword">if</span> choice==<span class="string">'a'</span>:</span><br><span class="line">        val=int(input(<span class="string">'[请输入数值]: '</span>))</span><br><span class="line">        rear+=1</span><br><span class="line">        queue[rear]=val</span><br><span class="line">    <span class="keyword">elif</span> choice==<span class="string">'d'</span>:</span><br><span class="line">        <span class="keyword">if</span> rear&gt;front:</span><br><span class="line">            front+=1</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'[取出数值为]: [%d]'</span> %(queue[front]))</span><br><span class="line">            queue[front]=0</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'[队列已经空了]'</span>)</span><br><span class="line">            sys.exit(0)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'------------------------------------------'</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'[输出队列中的所有元素]:'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> rear==MAX-1:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'[队列已满]'</span>)</span><br><span class="line"><span class="keyword">elif</span> front&gt;=rear:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'没有'</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'[队列已空]'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">while</span> rear&gt;front:</span><br><span class="line">        front+=1</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'[%d] '</span> %queue[front],end=<span class="string">''</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'------------------------------------------'</span>)</span><br><span class="line"><span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>
<p>0x7.2.2链表实现队列 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class student:</span><br><span class="line">  def __init__(self):</span><br><span class="line">    self.name=<span class="string">" "</span>*20</span><br><span class="line">    self.score=0</span><br><span class="line">    self.next=None</span><br><span class="line">    </span><br><span class="line">front=student()</span><br><span class="line">rear=student()</span><br><span class="line">front=None</span><br><span class="line">rear=None</span><br></pre></td></tr></table></figure>
<p>在队列中加入新的节点，等于加到此队列的末端；在队列中删除节点，就是将此队列最前端的节点删除</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def enqueue(name,score):</span><br><span class="line">  global front</span><br><span class="line">  global rear</span><br><span class="line">  new_data=student()</span><br><span class="line">  new_data.name=name</span><br><span class="line">  new_data.score=score</span><br><span class="line">  <span class="keyword">if</span> rear==None:</span><br><span class="line">    front=new_data</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    rear.next=new_data</span><br><span class="line">    </span><br><span class="line">  rear=new_data</span><br><span class="line">  new_data.next=None</span><br><span class="line">def dequeue():</span><br><span class="line">  global front</span><br><span class="line">  global rear</span><br><span class="line">  <span class="keyword">if</span> front==None:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"队列已空!"</span>)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"姓名：%s\t成绩：%d...取出"</span> %(front.name,front.score))</span><br><span class="line">    front=front.next</span><br></pre></td></tr></table></figure>
<p>范例:<br>链表中元素节点仍为学生姓名及成绩的结构数据   </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">class student:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.name=<span class="string">' '</span>*20</span><br><span class="line">        self.score=0</span><br><span class="line">        self.next=None</span><br><span class="line">        </span><br><span class="line">front=student()</span><br><span class="line">rear=student()</span><br><span class="line">front=None</span><br><span class="line">rear=None</span><br><span class="line"></span><br><span class="line">def enqueue(name, score):  <span class="comment"># 把数据加入队列</span></span><br><span class="line">    global front</span><br><span class="line">    global rear</span><br><span class="line">    new_data=student()  <span class="comment"># 分配内存给新元素</span></span><br><span class="line">    new_data.name=name  <span class="comment"># 给新元素赋值</span></span><br><span class="line">    new_data.score = score</span><br><span class="line">    <span class="keyword">if</span> rear==None:      <span class="comment"># 如果rear为None，表示这是第一个元素</span></span><br><span class="line">        front = new_data</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        rear.next = new_data    <span class="comment"># 将新元素连接到队列末尾</span></span><br><span class="line"></span><br><span class="line">    rear = new_data         <span class="comment"># 将rear指向新元素，这是新的队列末尾</span></span><br><span class="line">    new_data.next = None    <span class="comment"># 新元素之后无其他元素</span></span><br><span class="line"></span><br><span class="line">def dequeue(): <span class="comment"># 取出队列中的数据</span></span><br><span class="line">    global front</span><br><span class="line">    global rear</span><br><span class="line">    <span class="keyword">if</span> front == None:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'队列已空！'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'姓名：%s\t成绩：%d ....取出'</span> %(front.name, front.score))</span><br><span class="line">        front = front.next    <span class="comment"># 将队列前端移到下一个元素</span></span><br><span class="line">        </span><br><span class="line">def show():     <span class="comment"># 显示队列中的数据</span></span><br><span class="line">    global front</span><br><span class="line">    global rear</span><br><span class="line">    ptr = front</span><br><span class="line">    <span class="keyword">if</span> ptr == None:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'队列已空！'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">while</span> ptr !=None: <span class="comment"># 从front到rear遍历队列</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'姓名：%s\t成绩：%d'</span> %(ptr.name, ptr.score))</span><br><span class="line">            ptr = ptr.next</span><br><span class="line"></span><br><span class="line">select=0</span><br><span class="line"><span class="keyword">while</span> True:</span><br><span class="line">    select=int(input(<span class="string">'(1)加入 (2)取出 (3)显示 (4)离开 =&gt; '</span>))</span><br><span class="line">    <span class="keyword">if</span> select==4:</span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">    <span class="keyword">if</span> select==1:</span><br><span class="line">        name=input(<span class="string">'姓名: '</span>)</span><br><span class="line">        score=int(input(<span class="string">'成绩: '</span>))</span><br><span class="line">        enqueue(name, score)</span><br><span class="line">    <span class="keyword">elif</span> select==2:</span><br><span class="line">        dequeue()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        show()</span><br></pre></td></tr></table></figure>
<p>0x 7.2.3双向队列<br>双向队列(Double Ended Queues,DEQue)为一个有序线性表，加入与删除可在队列的任意一端进行<br><img src="../../images/" alt=""><br>双向队列的应用可以区分为两种：第一种是数据只能从一端加入，但可从两端取出；；另一种则是可从两端加入，但从一端取出<br>范例:  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">class Node:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.data=0</span><br><span class="line">        self.next=None</span><br><span class="line">        </span><br><span class="line">front=Node()</span><br><span class="line">rear=Node()</span><br><span class="line">front=None</span><br><span class="line">rear=None</span><br><span class="line"></span><br><span class="line"><span class="comment">#方法enqueue:队列数据的加入</span></span><br><span class="line">def enqueue(value):</span><br><span class="line">    global front</span><br><span class="line">    global rear</span><br><span class="line">    node=Node()  <span class="comment">#建立节点</span></span><br><span class="line">    node.data=value</span><br><span class="line">    node.next=None</span><br><span class="line">    <span class="comment">#检查是否为空队列</span></span><br><span class="line">    <span class="keyword">if</span> rear==None:</span><br><span class="line">        front=node  <span class="comment">#新建立的节点成为第1个节点</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        rear.next=node  <span class="comment">#将节点加入到队列的末尾</span></span><br><span class="line">    rear=node  <span class="comment">#将队列的末尾指针指向新加入的节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#方法dequeue:队列数据的取出</span></span><br><span class="line">def dequeue(action):</span><br><span class="line">    global front</span><br><span class="line">    global rear</span><br><span class="line">    <span class="comment">#从队列前端取出数据</span></span><br><span class="line">    <span class="keyword">if</span> not(front==None) and action==1:</span><br><span class="line">        <span class="keyword">if</span> front==rear:</span><br><span class="line">            rear=None</span><br><span class="line">        value=front.data  <span class="comment">#将队列数据从前端取出</span></span><br><span class="line">        front=front.next  <span class="comment">#将队列的前端指针指向下一个</span></span><br><span class="line">        <span class="built_in">return</span> value</span><br><span class="line">    <span class="comment">#从队列末尾取出数据</span></span><br><span class="line">    <span class="keyword">elif</span> not(rear==None) and action==2:</span><br><span class="line">        startNode=front  <span class="comment">#先记下队列前端的指针值</span></span><br><span class="line">        value=rear.data  <span class="comment">#取出队列当前末尾的数据</span></span><br><span class="line">        <span class="comment">#查找队列末尾节点的前一个节点</span></span><br><span class="line">        tempNode=front</span><br><span class="line">        <span class="keyword">while</span> front.next!=rear and front.next!=None:</span><br><span class="line">            front=front.next</span><br><span class="line">            tempNode=front</span><br><span class="line">        front=startNode  <span class="comment">#记录从队列末尾取出数据后的队列前端指针</span></span><br><span class="line">        rear=tempNode  <span class="comment">#记录从队列末尾取出数据后的队列末尾指针</span></span><br><span class="line">        <span class="comment">#下一行程序是指当队列中仅剩下最后一个节点时,</span></span><br><span class="line">        <span class="comment">#取出数据后便将front和rear指向None</span></span><br><span class="line">        <span class="keyword">if</span> front.next==None or rear.next==None:</span><br><span class="line">            front=None</span><br><span class="line">            rear=None</span><br><span class="line">        <span class="built_in">return</span> value</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">return</span> -1</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(<span class="string">'用链表来实现双向队列'</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'===================================='</span>)</span><br><span class="line"></span><br><span class="line">ch=<span class="string">'a'</span></span><br><span class="line"><span class="keyword">while</span> True:</span><br><span class="line">    ch=input(<span class="string">'加入请按 a,取出请按 d,结束请按 e:'</span>)</span><br><span class="line">    <span class="keyword">if</span> ch ==<span class="string">'e'</span>:</span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">    <span class="keyword">elif</span> ch==<span class="string">'a'</span>:</span><br><span class="line">        item=int(input(<span class="string">'加入的元素值:'</span>))</span><br><span class="line">        enqueue(item)</span><br><span class="line">    <span class="keyword">elif</span> ch==<span class="string">'d'</span>:</span><br><span class="line">        temp=dequeue(1)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'从双向队列前端按序取出的元素数据值为：%d'</span> %temp)</span><br><span class="line">        temp=dequeue(2)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'从双向队列末尾按序取出的元素数据值为：%d'</span> %temp)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">break</span></span><br></pre></td></tr></table></figure>
<h1 id="0x8-树形结构及其算法"><a href="#0x8-树形结构及其算法" class="headerlink" title="0x8 树形结构及其算法"></a>0x8 树形结构及其算法</h1><p>树形结构是一种应用相当广泛的非线性结构。树状算法在程序中的建立与应用大多使用链表来处理，当然也可以使用数组这样的连续内存来表示二叉树  </p>
<p>由于二叉树的应用相当广泛，因此衍生了许多特殊的二叉树结构<br>1.满二叉树(fully binary tree)<br>如果二叉树的高度为h，树的节点数为2-1，h&gt;=0,就称此树为”满二叉树”<br><img src="../../images/arithmetic/tree1.png" alt=""><br>2.完全二叉树(complete binary tree)<br>如果二叉树的高速为h，所含的节点数小于2-1，但其节点的编号方式如同高度为h的满二叉树一样，从左到右，从上到下的顺序一一对应<br><img src="../../images/arithmetic/tree2.png" alt=""><br>对于完全二叉树而言，假设有N个节点，那么此二叉树的层数h为log(N+1) </p>
<p>3.斜二叉树(skewed binary tree)<br>当一个二叉树完全没有左节点或右节点时，就称为左斜二叉树或右斜二叉树<br><img src="../../images/arithmetic/tree3.png" alt=""><br>4.严格二叉树(strictly binary tree)<br>二叉树中的每一个非终端节点均有非空的左右子树<br><img src="../../images/arithmetic/tree4.png" alt=""><br>0x8.1数组实现二叉树<br>使用有序的一位数组来表示二叉树，首先可将此二叉树假想成一棵满二叉树，而且第K层具有2个节点，按序存放在一维数组中  </p>
<p>首先来看看使用一维数组建立二叉树的表示方法以及数组索引值的设置<br><img src="../../images/arithmetic/tree5.png" alt=""></p>
<table>
<thead>
<tr>
<th>索引值</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
</tr>
</thead>
<tbody><tr>
<td>内容值</td>
<td align="center">A</td>
<td align="center">B</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">C</td>
<td align="center"></td>
<td align="center">D</td>
</tr>
</tbody></table>
<p>一维数组中的索引值有以下关系：<br>1.左子树索引值是父节点索引值乘2<br>2.右子树索引值是父节点索引值乘2加1   </p>
<p>二叉查找树具有以下特点：<br>1.可以是空集合，若不是空集合，则节点上一定要有一个键值<br>2.每一个树根的值需大于左子树的值<br>3.每一个树根的值需小于右子树的值<br>4.左右子树也是二叉查找树<br>5.树的每个节点值都不相同<br>范例：<br>现在示范用一组数据(32,25,16,35,27)来建立一棵二叉查找树，具体过程如下<br><img src="../../images/arithmetic/tree6.png" alt=""></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">def Btree_create(btree,data,length):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(1,length):</span><br><span class="line">        level=1</span><br><span class="line">        <span class="keyword">while</span> btree[level]!=0:</span><br><span class="line">            <span class="keyword">if</span> data[i]&gt;btree[level]: <span class="comment">#如果数组内的值大于树根，则往右子树比较</span></span><br><span class="line">                level=level*2+1</span><br><span class="line">            <span class="keyword">else</span>:               <span class="comment">#如果数组内的值小于或等于树根，则往左子树比较</span></span><br><span class="line">                level=level*2</span><br><span class="line">        btree[level]=data[i]    <span class="comment">#把数组值放入二叉树</span></span><br><span class="line">        </span><br><span class="line">length=9</span><br><span class="line">data=[0,6,3,5,4,7,8,9,2]  <span class="comment">#原始数组</span></span><br><span class="line">btree=[0]*16  <span class="comment">#存放二叉树数组</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'原始数组内容：'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'[%2d] '</span> %data[i],end=<span class="string">''</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">''</span>)</span><br><span class="line">Btree_create(btree,data,9)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'二叉树内容：'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(1,16):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'[%2d] '</span> %btree[i],end=<span class="string">''</span>)</span><br><span class="line"><span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>
<p>0x8.2 链表实现二叉树<br>链表实现二叉树，就是使用功能链表来存储二叉树。使用链表来表示二叉树的好处是对于节点的增加与删除相当容易，缺点是很难找到父节点，除非在每一节点多增加一个父字段  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class tree:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.data=0</span><br><span class="line">        self.left=None</span><br><span class="line">        self.right=None</span><br></pre></td></tr></table></figure>
<p>链表实现二叉树的示意图：<br><img src="../../images/arithmetic/tree7.png" alt=""></p>
<p>以链表方式建立二叉树的python算法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def create_tree(root,val):    <span class="comment">#建立二叉树的函数</span></span><br><span class="line">    newnode=tree()</span><br><span class="line">    newnode.data=val</span><br><span class="line">    newnode.left=None</span><br><span class="line">    newnode.right=None</span><br><span class="line">    <span class="keyword">if</span> root==None:</span><br><span class="line">        root=newnode</span><br><span class="line">        <span class="built_in">return</span> root</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        current=root</span><br><span class="line">        <span class="keyword">while</span> current!=None:</span><br><span class="line">            backup=current</span><br><span class="line">            <span class="keyword">if</span> current.data &gt; val:</span><br><span class="line">                current=current.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                current=current.right</span><br><span class="line">        <span class="keyword">if</span> backup.data &gt;val:</span><br><span class="line">            backup.left=newnode</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            backup.right=newnode</span><br><span class="line">    <span class="built_in">return</span> root</span><br></pre></td></tr></table></figure>
<p>范例:<br>按序输入一棵二叉树10个节点的数据，分别是5,6,24,8,12,3,17,1,9，并使用链表来建立二叉树。最后输出左，右子树   </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class tree:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.data=0</span><br><span class="line">        self.left=None</span><br><span class="line">        self.right=None</span><br><span class="line"></span><br><span class="line">def create_tree(root,val):    <span class="comment">#建立二叉树的函数</span></span><br><span class="line">    newnode=tree()</span><br><span class="line">    newnode.data=val</span><br><span class="line">    newnode.left=None</span><br><span class="line">    newnode.right=None</span><br><span class="line">    <span class="keyword">if</span> root==None:</span><br><span class="line">        root=newnode</span><br><span class="line">        <span class="built_in">return</span> root</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        current=root</span><br><span class="line">        <span class="keyword">while</span> current!=None:</span><br><span class="line">            backup=current</span><br><span class="line">            <span class="keyword">if</span> current.data &gt; val:</span><br><span class="line">                current=current.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                current=current.right</span><br><span class="line">        <span class="keyword">if</span> backup.data &gt;val:</span><br><span class="line">            backup.left=newnode</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            backup.right=newnode</span><br><span class="line">    <span class="built_in">return</span> root</span><br><span class="line"></span><br><span class="line">data=[5,6,24,8,12,3,17,1,9]</span><br><span class="line">ptr=None</span><br><span class="line">root=None</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(9):</span><br><span class="line">    ptr=create_tree(ptr,data[i]) <span class="comment">#建立二叉树</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'左子树:'</span>)</span><br><span class="line">root=ptr.left</span><br><span class="line"><span class="keyword">while</span> root!=None:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'%d'</span> %root.data)</span><br><span class="line">    root=root.left</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'--------------------------------'</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'右子树:'</span>)</span><br><span class="line">root=ptr.right</span><br><span class="line"><span class="keyword">while</span> root!=None:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'%d'</span> %root.data)</span><br><span class="line">    root=root.right</span><br><span class="line"><span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>
<p>0x8.3二叉树遍历<br>所谓二叉树的遍历(Binary Tree Traversal)，最简单的说法就是”访问树中所有的节点各一次”，并且在遍历后，将树中的数据转化为线性关系   </p>
<p>简单二叉树节点而言，每个节点都可分为左右两个分支<br><img src="../../images/arithmetic/traverse1.png" alt=""><br>可以有ABC，ACB，BAC，BCA，CAB，CBA一共6种遍历方法。如果按照二叉树特性，一律从左到右，那么就只剩下三种遍历方式，分别是BAC，ABC，BCA三种。这三种方式的命名与规则如下：   </p>
<p>中序遍历(BAC，Inorder)：左子树—&gt;树根—&gt;右子树<br>前序遍历(ABC，Preorder)：树根—&gt;左子树—&gt;右子树<br>后序遍历(BCA，Postorder)：左子树—&gt;右子树—&gt;树根<br>1.中序遍历<br>中序遍历(Inorder Traversal)是”左中右”的遍历顺序，也就是从树的左侧逐步向下方移动，直到无法移动，再访问此节点，并向右移动一节点。如果无法再向右移动时，可以返回上层的父节点，并重复左，中，右的步骤：  </p>
<p>遍历左子树<br>遍历(或访问)树根<br>遍历右子树<br>中序遍历结果：FDHGIBEAC<br><img src="../../images/arithmetic/traverse2.png" alt=""><br>中序遍历的递归算法如下：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def inorder(ptr):      <span class="comment">#中序遍历子程序</span></span><br><span class="line">    <span class="keyword">if</span> ptr!=None:</span><br><span class="line">        inorder(ptr.left)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'[%2d] '</span> %ptr.data, end=<span class="string">''</span>)</span><br><span class="line">        inorder(ptr.right)</span><br></pre></td></tr></table></figure>
<p>2.后序遍历<br>后序遍历(Postorder Traversal)是”左右中”的遍历顺序，就是先遍历左子树，在遍历右子树，最后遍历(或访问)根节点。反复执行此步骤  </p>
<p>遍历左子树<br>遍历右子树<br>遍历树根<br>后序遍历结果：FHIGDEBCA<br><img src="../../images/arithmetic/traverse3.png" alt=""></p>
<p>后序遍历的递归算法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def postorder(ptr):      <span class="comment">#后序遍历子程序</span></span><br><span class="line">    <span class="keyword">if</span> ptr!=None:</span><br><span class="line">        inorder(ptr.left)</span><br><span class="line">        inorder(ptr.right)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'[%2d] '</span> %ptr.data, end=<span class="string">''</span>)</span><br></pre></td></tr></table></figure>
<p>3.前序遍历<br>前序遍历(Preorder Traversal)是”中左右”的遍历顺序，也就是先从根节点遍历，再往左方移动，当无法继续时，继续向右方移动，接着再重复执行此步骤：   </p>
<p>遍历树根<br>遍历左子树<br>遍历右子树<br>前序遍历结果：ABDFGHIEC<br><img src="../../images/arithmetic/traverse3.png" alt=""></p>
<p>前序遍历的递归算法： </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def preorder(ptr):      <span class="comment">#前序遍历子程序</span></span><br><span class="line">    <span class="keyword">if</span> ptr!=None:</span><br><span class="line">      	<span class="built_in">print</span>(<span class="string">'[%2d] '</span> %ptr.data, end=<span class="string">''</span>)</span><br><span class="line">        inorder(ptr.left)</span><br><span class="line">        inorder(ptr.right)</span><br></pre></td></tr></table></figure>
<p>范例:<br>按序输入一棵二叉树节点的数据，分别是5,6,24,8,12,3,17,1,9，利用链表来建立二叉树，最后进行中序遍历，轻松完成从小到大的排序</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class tree:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.data = 0</span><br><span class="line">        self.left = None</span><br><span class="line">        self.right = None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def inorder(ptr):  <span class="comment"># 中序遍历子程序</span></span><br><span class="line">    <span class="keyword">if</span> ptr != None:</span><br><span class="line">        inorder(ptr.left)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'[%2d] '</span> % ptr.data, end=<span class="string">''</span>)</span><br><span class="line">        inorder(ptr.right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def create_tree(root, val):  <span class="comment"># 建立二叉树的函数</span></span><br><span class="line">    newnode = tree()</span><br><span class="line">    newnode.data = val</span><br><span class="line">    newnode.left = None</span><br><span class="line">    newnode.right = None</span><br><span class="line">    <span class="keyword">if</span> root == None:</span><br><span class="line">        root = newnode</span><br><span class="line">        <span class="built_in">return</span> root</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        current = root</span><br><span class="line">        <span class="keyword">while</span> current != None:</span><br><span class="line">            backup = current</span><br><span class="line">            <span class="keyword">if</span> current.data &gt; val:</span><br><span class="line">                current = current.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                current = current.right</span><br><span class="line">        <span class="keyword">if</span> backup.data &gt; val:</span><br><span class="line">            backup.left = newnode</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            backup.right = newnode</span><br><span class="line">    <span class="built_in">return</span> root</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主程序</span></span><br><span class="line">data = [5, 6, 24, 8, 12, 3, 17, 1, 9]</span><br><span class="line">ptr = None</span><br><span class="line">root = None</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(9):</span><br><span class="line">    ptr = create_tree(ptr, data[i])  <span class="comment"># 建立二叉树</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'===================='</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'排序完成的结果：'</span>)</span><br><span class="line">inorder(ptr)  <span class="comment"># 中序遍历</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">''</span>)</span><br></pre></td></tr></table></figure>
<p>0x 8.4 二叉树的查找<br>二叉树在建立的过程中，是根据左子树&lt;树根&lt;右子树的原则建立的，因此只需从树根出发比较键值，如果比数根大就往右，否则往左而下，直到相等就找到了要查找的值，如果比到None，无法在前进就代表查找不到此值</p>
<p>二叉树查找的算法：   </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def search(ptr,val):     <span class="comment">#查找二叉树中某个值的子程序</span></span><br><span class="line">    <span class="keyword">while</span> True:</span><br><span class="line">        <span class="keyword">if</span> ptr==None:    <span class="comment">#没找到就返回None</span></span><br><span class="line">            <span class="built_in">return</span> None</span><br><span class="line">        <span class="keyword">if</span> ptr.data==val:       <span class="comment">#节点值等于查找值</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'共查找 %3d 次'</span> %i)</span><br><span class="line">            <span class="built_in">return</span> ptr</span><br><span class="line">        <span class="keyword">elif</span> ptr.data &gt; val:  <span class="comment">#节点值大于查找值</span></span><br><span class="line">            ptr=ptr.left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ptr=ptr.right</span><br></pre></td></tr></table></figure>
<p>范例：<br>建立一个二叉树找树，并输入要查找的值。二叉树节点的数据按序依次为7,1,4,2,8,13,12,11,15,9,5   </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">class tree:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.data=0</span><br><span class="line">        self.left=None</span><br><span class="line">        self.right=None</span><br><span class="line"></span><br><span class="line">def create_tree(root,val):  <span class="comment">#建立二叉树的函数</span></span><br><span class="line">    newnode=tree()</span><br><span class="line">    newnode.data=val</span><br><span class="line">    newnode.left=None</span><br><span class="line">    newnode.right=None</span><br><span class="line">    <span class="keyword">if</span> root==None:</span><br><span class="line">        root=newnode</span><br><span class="line">        <span class="built_in">return</span> root</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        current=root</span><br><span class="line">        <span class="keyword">while</span> current!=None:</span><br><span class="line">            backup=current</span><br><span class="line">            <span class="keyword">if</span> current.data &gt; val:</span><br><span class="line">                current=current.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                current=current.right</span><br><span class="line">        <span class="keyword">if</span> backup.data &gt;val:</span><br><span class="line">            backup.left=newnode</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            backup.right=newnode</span><br><span class="line">    <span class="built_in">return</span> root</span><br><span class="line"></span><br><span class="line">def search(ptr,val):     <span class="comment">#查找二叉树中某个值的子程序</span></span><br><span class="line">    i=1</span><br><span class="line">    <span class="keyword">while</span> True:</span><br><span class="line">        <span class="keyword">if</span> ptr==None:    <span class="comment">#没找到就返回None</span></span><br><span class="line">            <span class="built_in">return</span> None</span><br><span class="line">        <span class="keyword">if</span> ptr.data==val:       <span class="comment">#节点值等于查找值</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'共查找 %3d 次'</span> %i)</span><br><span class="line">            <span class="built_in">return</span> ptr</span><br><span class="line">        <span class="keyword">elif</span> ptr.data &gt; val:  <span class="comment">#节点值大于查找值</span></span><br><span class="line">            ptr=ptr.left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ptr=ptr.right</span><br><span class="line">        i+=1</span><br><span class="line"></span><br><span class="line"><span class="comment">#主程序</span></span><br><span class="line">arr=[7,1,4,2,8,13,12,11,15,9,5]</span><br><span class="line">ptr=None</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'[原始数组内容]'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(11):</span><br><span class="line">    ptr=create_tree(ptr,arr[i])  <span class="comment">#建立二叉树</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'[%2d] '</span> %arr[i],end=<span class="string">''</span>)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line">data=int(input(<span class="string">'请输入查找值：'</span>))</span><br><span class="line"><span class="keyword">if</span> search(ptr,data) !=None :    <span class="comment">#在二叉树中查找</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'您要找的值 [%3d] 找到了!!'</span> %data)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'您要找的值没找到!!'</span>)</span><br></pre></td></tr></table></figure>
<p>0x8.5二叉树节点的插入<br>二叉树插入 的情况和查找相似，重点是插入后仍要保持二叉查找数的特性。   </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> search(ptr,data)!=None:      <span class="comment">#在二叉树中查找</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'二叉树中有此节点了!'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    ptr=create_tree(ptr,data)</span><br><span class="line">    inorder(ptr)</span><br></pre></td></tr></table></figure>
<p>范例:<br>二叉树的节点数据按序为7,1,4,2,8,13,12,11,15,9，然后输入一个键值，如果不在此二叉树中，就将其加入到二叉树  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">class tree:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.data=0</span><br><span class="line">        self.left=None</span><br><span class="line">        self.right=None</span><br><span class="line"></span><br><span class="line">def create_tree(root,val):  <span class="comment">#建立二叉树的函数</span></span><br><span class="line">    newnode=tree()</span><br><span class="line">    newnode.data=val</span><br><span class="line">    newnode.left=None</span><br><span class="line">    newnode.right=None</span><br><span class="line">    <span class="keyword">if</span> root==None:</span><br><span class="line">        root=newnode</span><br><span class="line">        <span class="built_in">return</span> root</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        current=root</span><br><span class="line">        <span class="keyword">while</span> current!=None:</span><br><span class="line">            backup=current</span><br><span class="line">            <span class="keyword">if</span> current.data &gt; val:</span><br><span class="line">                current=current.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                current=current.right</span><br><span class="line">        <span class="keyword">if</span> backup.data &gt;val:</span><br><span class="line">            backup.left=newnode</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            backup.right=newnode</span><br><span class="line">    <span class="built_in">return</span> root</span><br><span class="line"></span><br><span class="line">def search(ptr,val):     <span class="comment">#在二叉树中查找某个值的子程序</span></span><br><span class="line">    <span class="keyword">while</span> True:</span><br><span class="line">        <span class="keyword">if</span> ptr==None:    <span class="comment">#没找到就返回None</span></span><br><span class="line">            <span class="built_in">return</span> None</span><br><span class="line">        <span class="keyword">if</span> ptr.data==val:       <span class="comment">#节点值等于查找值</span></span><br><span class="line">            <span class="built_in">return</span> ptr</span><br><span class="line">        <span class="keyword">elif</span> ptr.data &gt; val:    <span class="comment">#节点值大于查找值</span></span><br><span class="line">            ptr=ptr.left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ptr=ptr.right</span><br><span class="line"></span><br><span class="line">def inorder(ptr):      <span class="comment">#中序遍历子程序</span></span><br><span class="line">    <span class="keyword">if</span> ptr!=None:</span><br><span class="line">        inorder(ptr.left)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'[%2d] '</span> %ptr.data, end=<span class="string">''</span>)</span><br><span class="line">        inorder(ptr.right)</span><br><span class="line"></span><br><span class="line"><span class="comment">#主程序</span></span><br><span class="line">arr=[7,1,4,2,8,13,12,11,15,9,5]</span><br><span class="line">ptr=None</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'[原始数组内容]'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(11):</span><br><span class="line">    ptr=create_tree(ptr,arr[i])  <span class="comment">#建立二叉树</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'[%2d] '</span> %arr[i],end=<span class="string">''</span>)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line">data=int(input(<span class="string">'请输入要查找的键值：'</span>))</span><br><span class="line"><span class="keyword">if</span> search(ptr,data)!=None:      <span class="comment">#在二叉树中查找</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'二叉树中有此节点了!'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    ptr=create_tree(ptr,data)</span><br><span class="line">    inorder(ptr)</span><br></pre></td></tr></table></figure>
<p>0x8.6二叉树的删除<br>二叉树节点的删除操作则稍为复杂，可分为以下三种情况：<br>1.删除的节点为树叶，只要将其相连的父节点指向None即可<br>2.删除的节点只有一棵子树。如下图：删除节点1，就将其右指针字段放在父节点的左指针字段<br>3.删除的节点有两棵子树。如下图：要删除节点4，方式有两种，虽然结果不同，但都可符合二叉树特性   </p>
<p>3.1 找出中序立即先行者(inorder immediate predecessor)，就是将欲删除节点的左子树中最大者向上提，在此即为上图中的节点2。简单来说，就是在该节点的左子树，往右寻找，直到右指针为None，这节点就是中序立即先行者 </p>
<p>3.2 找出中序立即后续者(inorder immediate successor)，就是把要删除节点的右子树中最小者向上提，在此即为上图中的节点5。简单来说，就是在该节点的右子树，往左寻找，直到左指针为None，这个节点就是中序立即后续者<br><img src="../../images/arithmetic/del1.png" alt=""><br>0x8.7二叉树的删除<br>堆积排序法算是选择排序法的改进版，它可以减少在选择排序法中的比较次数，进而减少排序时间。堆积树是一种特殊的二叉树，可分为最大堆积树和最小堆积树两种。    </p>
<p>最大堆积树满足以下3个条件：<br>它是一个完全二叉树<br>所有节点的值都大于或等于它左右子节点的值<br>树根是堆积树中最大的     </p>
<p>最小堆积树满足以下3个条件：<br>它是一个完全二叉树<br>所有节点的值都小于或等于它左右子节点的值<br>树根是堆积树中最小的<br>假设有9项数据32,17,16,24,35,87,65,4,12，以二叉树表示：<br><img src="../../images/arithmetic/Accumulation1.png" alt=""><br>如果要将该二叉树转换堆积树(heap tree)，我们可以用数组来存储二叉树所有节点的值，即：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A[0]=32，A[1]=17，A[2]=16，A[3]=24，A[4]=35，A[5]=87</span><br><span class="line"></span><br><span class="line">A[6]=65，A[7]=4，A[8]=12</span><br></pre></td></tr></table></figure>
<p>步骤01：A[0]=32为树根，若A[1]大于父节点，则必须互换。此处A[1]=17&lt;A[0]=32故不交换            </p>
<p>步骤02：A[2]=16&lt;A[0]，故不交换 </p>
<p>步骤03：A[3]=24&gt;A[1]=17，故交换，如下图  </p>
<p><img src="../../images/arithmetic/Accumulation2.png" alt=""><br>步骤04：A[4]=35&gt;A[1]=24，故交换，再与A[0]=32比较，A[1]=35&gt;A[0]=32，故交换，如下图<br><img src="../../images/arithmetic/Accumulation3.png" alt=""><br>步骤05：A[5]=87&gt;A[2]=16，故交换，再与A[0]=35比较，A[2]=87&gt;A[0]=35，故交换，如下图<br><img src="../../images/arithmetic/Accumulation4.png" alt=""><br>步骤06：A[6]=65&gt;A[2]=35，故交换，且A[2]=65&lt;A[0]=87，故不交换，如下图<br><img src="../../images/arithmetic/Accumulation5.png" alt=""><br>步骤07：A[7]=4&lt;A[3]=17，故不交换，A[8]=12&lt;A[3]=17，故不交换<br>范例:<br>使用堆积排序法来排序 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">def heap(data, size):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(size / 2), 0, -1):  <span class="comment"># 建立堆积树节点</span></span><br><span class="line">        ad_heap(data, i, size - 1)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'堆积的内容：'</span>, end=<span class="string">''</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(1, size):  <span class="comment"># 原始堆积树的内容</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'[%2d] '</span> % data[i], end=<span class="string">''</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'\n'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(size - 2, 0, -1):  <span class="comment"># 堆积排序</span></span><br><span class="line">        data[i + 1], data[1] = data[1], data[i + 1]  <span class="comment"># 头尾节点交换</span></span><br><span class="line">        ad_heap(data, 1, i)  <span class="comment"># 处理剩余节点</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'处理过程为：'</span>, end=<span class="string">''</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(1, size):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'[%2d] '</span> % data[j], end=<span class="string">''</span>)</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def ad_heap(data, i, size):</span><br><span class="line">    j = 2 * i</span><br><span class="line">    tmp = data[i]</span><br><span class="line">    post = 0</span><br><span class="line">    <span class="keyword">while</span> j &lt;= size and post == 0:</span><br><span class="line">        <span class="keyword">if</span> j &lt; size:</span><br><span class="line">            <span class="keyword">if</span> data[j] &lt; data[j + 1]:  <span class="comment"># 找出最大节点</span></span><br><span class="line">                j += 1</span><br><span class="line">        <span class="keyword">if</span> tmp &gt;= data[j]:  <span class="comment"># 若树根较大，结束比较过程</span></span><br><span class="line">            post = 1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            data[int(j / 2)] = data[j]  <span class="comment"># 若树根较小，则继续比较</span></span><br><span class="line">            j = 2 * j</span><br><span class="line">    data[int(j / 2)] = tmp  <span class="comment"># 指定树根为父节点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    data = [0, 5, 6, 4, 8, 3, 2, 7, 1]  <span class="comment"># 原始数组的内容</span></span><br><span class="line">    size = 9</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'原始数组为：'</span>, end=<span class="string">''</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(1, size):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'[%2d] '</span> % data[i], end=<span class="string">''</span>)</span><br><span class="line">    heap(data, size)  <span class="comment"># 建立堆积树</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'排序结果为：'</span>, end=<span class="string">''</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(1, size):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'[%2d] '</span> % data[i], end=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h1 id="0x9图的数据结构及其算法"><a href="#0x9图的数据结构及其算法" class="headerlink" title="0x9图的数据结构及其算法"></a>0x9图的数据结构及其算法</h1><p>图除了被应用在数据结构中最短路径搜索，拓扑排序外，还能应用在系统分析中以时间为评审标准的性能评审技术等。采用Dijkstra这种图形算法就能快速寻找出两个节点之间的最短路径<br>图的遍历，可以定义如下：<br>一个图G=(V,E)，存在某一顶点v属于V，我们希望从v开始，通过此节点相邻的节点而去访问图G中的其他节点，这就被称为”图的遍历”。也就是从某一个顶点V1开始，遍历可以经过V1到达的顶点，接着遍历下一个顶点直到全部的顶点遍历完毕为止<br>0x9.1图的遍历算法<br>图遍历的方法有两种：即”深度优先遍历”和”广度优先遍历”，也称为”深度优先搜索”和”广度优先搜索”<br>1.深度优先遍历的方式有点类似于前序遍历，从图的某一顶点开始遍历，被访问过的顶点就做上已访问的记号，接着遍历此顶点所有相邻且未访问过的顶点中的任意一个顶点，并做上已访问的记号，再以该点为新的起点继续进行深度优先搜索     </p>
<p>这种图的遍历方法结合了递归和堆栈两种数据结构的技巧，由于此方法会造成无限循环，因此必须加入一个变量，判断该点是否已经遍历完毕<br>深度优先函数的算法如下：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def dfs(current): <span class="comment">#深度优先函数</span></span><br><span class="line">    run[current]=1</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'[%d] '</span> %current, end=<span class="string">''</span>)</span><br><span class="line">    ptr=head[current].next</span><br><span class="line">    <span class="keyword">while</span> ptr!=None:</span><br><span class="line">        <span class="keyword">if</span> run[ptr.val]==0:        <span class="comment">#如果顶点尚未遍历，</span></span><br><span class="line">            dfs(ptr.val)           <span class="comment">#就进行dfs的递归调用</span></span><br><span class="line">        ptr=ptr.next</span><br></pre></td></tr></table></figure>
<p>范例:   </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">class list_node:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.val = 0</span><br><span class="line">        self.next = None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">head = [list_node()] * 9  <span class="comment"># 声明一个节点类型的链表数组</span></span><br><span class="line"></span><br><span class="line">run = [0] * 9</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def dfs(current):  <span class="comment"># 深度优先函数</span></span><br><span class="line">    run[current] = 1</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'[%d] '</span> % current, end=<span class="string">''</span>)</span><br><span class="line">    ptr = head[current].next</span><br><span class="line">    <span class="keyword">while</span> ptr != None:</span><br><span class="line">        <span class="keyword">if</span> run[ptr.val] == 0:  <span class="comment"># 如果顶点尚未遍历，</span></span><br><span class="line">            dfs(ptr.val)  <span class="comment"># 就进行dfs的递归调用</span></span><br><span class="line">        ptr = ptr.next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明图的边线数组</span></span><br><span class="line">data = [[1, 2], [2, 1], [1, 3], [3, 1], \</span><br><span class="line">        [2, 4], [4, 2], [2, 5], [5, 2], \</span><br><span class="line">        [3, 6], [6, 3], [3, 7], [7, 3], \</span><br><span class="line">        [4, 8], [8, 4], [5, 8], [8, 5], \</span><br><span class="line">        [6, 8], [8, 6], [8, 7], [7, 8]]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(1, 9):  <span class="comment"># 共有八个顶点</span></span><br><span class="line">    run[i] = 0  <span class="comment"># 把所有顶点设置成尚未遍历过</span></span><br><span class="line">    head[i] = list_node()</span><br><span class="line">    head[i].val = i  <span class="comment"># 设置各个链表头的初值</span></span><br><span class="line">    head[i].next = None</span><br><span class="line">    ptr = head[i]  <span class="comment"># 设置指针指向链表头</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(20):  <span class="comment"># 二十条边线</span></span><br><span class="line">        <span class="keyword">if</span> data[j][0] == i:  <span class="comment"># 如果起点和链表头相等，则把顶点加入链表</span></span><br><span class="line">            newnode = list_node()</span><br><span class="line">            newnode.val = data[j][1]</span><br><span class="line">            newnode.next = None</span><br><span class="line">            <span class="keyword">while</span> True:</span><br><span class="line">                ptr.next = newnode  <span class="comment"># 加入新节点</span></span><br><span class="line">                ptr = ptr.next</span><br><span class="line">                <span class="keyword">if</span> ptr.next == None:</span><br><span class="line">                    <span class="built_in">break</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'图的邻接表内容：'</span>)  <span class="comment"># 打印图的邻接表内容</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(1, 9):</span><br><span class="line">    ptr = head[i]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'顶点 %d=&gt; '</span> % i, end=<span class="string">''</span>)</span><br><span class="line">    ptr = ptr.next</span><br><span class="line">    <span class="keyword">while</span> ptr != None:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'[%d] '</span> % ptr.val, end=<span class="string">''</span>)</span><br><span class="line">        ptr = ptr.next</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'深度优先遍历的顶点：'</span>)  <span class="comment"># 打印深度优先遍历的顶点</span></span><br><span class="line">dfs(1)</span><br><span class="line"><span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>
<p>2.广度优先遍历法<br>广度优先(Breadth-FIrst Search，BFS)遍历法则是使用队列和递归技巧来遍历，也是从图的某一顶点开始遍历，被访问过的顶点就做上已访问的记号。接着遍历此顶点的所有相邻且未访问过的顶点中的任意一个顶点，并做上已访问的记号，再以该点为新的起点继续进行广度优先的遍历<br>广度优先函数的python函数：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#广度优先查找法</span></span><br><span class="line">def bfs(current):</span><br><span class="line">    global front</span><br><span class="line">    global rear</span><br><span class="line">    global Head</span><br><span class="line">    global run</span><br><span class="line">    enqueue(current) <span class="comment">#将第一个顶点存入队列</span></span><br><span class="line">    run[current]=1   <span class="comment">#将遍历过的顶点设置为1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'[%d]'</span> %current, end=<span class="string">''</span>) <span class="comment">#打印出该遍历过的顶点</span></span><br><span class="line">    <span class="keyword">while</span> front!=rear:             <span class="comment">#判断当前的队伍是否为空</span></span><br><span class="line">        current=dequeue()            <span class="comment">#将顶点从队列中取出</span></span><br><span class="line">        tempnode=Head[current].first <span class="comment">#先记录当前顶点的位置</span></span><br><span class="line">        <span class="keyword">while</span> tempnode!=None:</span><br><span class="line">            <span class="keyword">if</span> run[tempnode.x]==0:</span><br><span class="line">                enqueue(tempnode.x)</span><br><span class="line">                run[tempnode.x]=1   <span class="comment">#记录已遍历过</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">'[%d]'</span> %tempnode.x,end=<span class="string">''</span>)</span><br><span class="line">            tempnode=tempnode.next</span><br></pre></td></tr></table></figure>
<p>范例:  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">MAXSIZE=10  <span class="comment">#定义队列的最大容量	</span></span><br><span class="line"></span><br><span class="line">front=-1 <span class="comment">#指向队列的前端</span></span><br><span class="line">rear=-1  <span class="comment">#指向队列的末尾</span></span><br><span class="line"></span><br><span class="line">class Node:</span><br><span class="line">    def __init__(self,x):</span><br><span class="line">        self.x=x        <span class="comment">#顶点数据</span></span><br><span class="line">        self.next=None  <span class="comment">#指向下一个顶点的指针</span></span><br><span class="line">        </span><br><span class="line">class GraphLink:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.first=None</span><br><span class="line">        self.last=None</span><br><span class="line">        </span><br><span class="line">    def my_print(self):</span><br><span class="line">        current=self.first</span><br><span class="line">        <span class="keyword">while</span> current!=None:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">'[%d]'</span> %current.x,end=<span class="string">''</span>)</span><br><span class="line">            current=current.next</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">    def insert(self,x):</span><br><span class="line">        newNode=Node(x)</span><br><span class="line">        <span class="keyword">if</span> self.first==None:</span><br><span class="line">            self.first=newNode</span><br><span class="line">            self.last=newNode</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.last.next=newNode</span><br><span class="line">            self.last=newNode</span><br><span class="line"> </span><br><span class="line"><span class="comment">#队列数据的存入</span></span><br><span class="line">def enqueue(value):</span><br><span class="line">    global MAXSIZE</span><br><span class="line">    global rear</span><br><span class="line">    global queue</span><br><span class="line">    <span class="keyword">if</span> rear&gt;=MAXSIZE:</span><br><span class="line">        <span class="built_in">return</span></span><br><span class="line">    rear+=1</span><br><span class="line">    queue[rear]=value</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">#队列数据的取出</span></span><br><span class="line">def dequeue():</span><br><span class="line">    global front</span><br><span class="line">    global queue</span><br><span class="line">    <span class="keyword">if</span> front==rear:</span><br><span class="line">        <span class="built_in">return</span> -1</span><br><span class="line">    front+=1</span><br><span class="line">    <span class="built_in">return</span> queue[front]</span><br><span class="line"></span><br><span class="line"><span class="comment">#广度优先查找法</span></span><br><span class="line">def bfs(current):</span><br><span class="line">    global front</span><br><span class="line">    global rear</span><br><span class="line">    global Head</span><br><span class="line">    global run</span><br><span class="line">    enqueue(current) <span class="comment">#将第一个顶点存入队列</span></span><br><span class="line">    run[current]=1   <span class="comment">#将遍历过的顶点设置为1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'[%d]'</span> %current, end=<span class="string">''</span>) <span class="comment">#打印出该遍历过的顶点</span></span><br><span class="line">    <span class="keyword">while</span> front!=rear:             <span class="comment">#判断当前的队伍是否为空</span></span><br><span class="line">        current=dequeue()            <span class="comment">#将顶点从队列中取出</span></span><br><span class="line">        tempnode=Head[current].first <span class="comment">#先记录当前顶点的位置</span></span><br><span class="line">        <span class="keyword">while</span> tempnode!=None:</span><br><span class="line">            <span class="keyword">if</span> run[tempnode.x]==0:</span><br><span class="line">                enqueue(tempnode.x)</span><br><span class="line">                run[tempnode.x]=1   <span class="comment">#记录已遍历过</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">'[%d]'</span> %tempnode.x,end=<span class="string">''</span>)</span><br><span class="line">            tempnode=tempnode.next</span><br><span class="line"></span><br><span class="line"><span class="comment">#声明图的边线数组</span></span><br><span class="line">Data=[[0]*2 <span class="keyword">for</span> row <span class="keyword">in</span> range(20)]</span><br><span class="line"></span><br><span class="line">Data =[[1,2],[2,1],[1,3],[3,1],[2,4], \</span><br><span class="line">       [4,2],[2,5],[5,2],[3,6],[6,3], \</span><br><span class="line">       [3,7],[7,3],[4,5],[5,4],[6,7],[7,6],[5,8],[8,5],[6,8],[8,6]]</span><br><span class="line"></span><br><span class="line">run=[0]*9 <span class="comment">#用来记录各顶点是否遍历过</span></span><br><span class="line">queue=[0]*MAXSIZE</span><br><span class="line">Head=[GraphLink]*9</span><br><span class="line"> 			</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'图的邻接表内容：'</span>) <span class="comment">#打印图的邻接表内容</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(1,9):      <span class="comment">#共有8个顶点</span></span><br><span class="line">    run[i]=0              <span class="comment">#把所有顶点设置成尚未遍历过</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'顶点%d=&gt;'</span> %i,end=<span class="string">''</span>)</span><br><span class="line">    Head[i]=GraphLink()</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(20):</span><br><span class="line">        <span class="keyword">if</span> Data[j][0]==i: <span class="comment">#如果起点和链表头相等，则把顶点加入链表</span></span><br><span class="line">            DataNum = Data[j][1]</span><br><span class="line">            Head[i].insert(DataNum)</span><br><span class="line">    Head[i].my_print()    <span class="comment">#打印图的邻接标内容</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'广度优先遍历的顶点：'</span>) <span class="comment">#打印广度优先遍历的顶点</span></span><br><span class="line">bfs(1)</span><br><span class="line"><span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>
<p>后面<br>0x9.2最小生成树<br>生成树又称”花费树”，“出本树”或”值树”，一个图的生成树(spanning tree)就是以最少的边来连通图中所有的顶点，且不造成回路(cycle)的树形结构。假设在树的边加上一个权重(weight)值，这种图就成为”加权图(weighted graph)”。如果这个权重值代表两个顶点间的距离(distance)或成本(cost)，这类图就被称为网络(network)<br>介绍以所谓”贪婪法则”(Greedy Rule)为基础来求得一个无向连通图的最小生成树的常见问题，分别是Prim算法和Kruskal算法<br>0x9.3 图的最短路径法<br>图的这章可详细看:<a href="https://blog.csdn.net/V_lq6h/article/details/86743787" target="_blank" rel="noopener">https://blog.csdn.net/V_lq6h/article/details/86743787</a><br>参考书本:<br>图解算法——使用Python <a href="http://m.bookdao.com/book.aspx?bookid=3346564" target="_blank" rel="noopener">http://m.bookdao.com/book.aspx?bookid=3346564</a>  数据结构–python 第八章 排序<a href="https://blog.csdn.net/Jasminexjf/article/details/89379735" target="_blank" rel="noopener">https://blog.csdn.net/Jasminexjf/article/details/89379735</a><br>查找与哈希算法 <a href="https://blog.csdn.net/V_lq6h/article/details/86743773" target="_blank" rel="noopener">https://blog.csdn.net/V_lq6h/article/details/86743773</a><br>数组与链表算法:<a href="https://www.cnblogs.com/LQ6H/p/10346666.html" target="_blank" rel="noopener">https://www.cnblogs.com/LQ6H/p/10346666.html</a><br>堆栈<a href="https://blog.csdn.net/jasminexjf/article/details/89295924" target="_blank" rel="noopener">https://blog.csdn.net/jasminexjf/article/details/89295924</a><br>python算法  <a href="https://www.cnblogs.com/LQ6H/default.html?page=5" target="_blank" rel="noopener">https://www.cnblogs.com/LQ6H/default.html?page=5</a><br>图的数据结构及其算法 <a href="https://blog.csdn.net/V_lq6h/article/details/86743787" target="_blank" rel="noopener">https://blog.csdn.net/V_lq6h/article/details/86743787</a></p>
</div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">ye1s</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="https://blog.cfyqy.com/article/81e351e9.html">https://blog.cfyqy.com/article/81e351e9.html</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.cfyqy.com">ye1s</a>！</span></div></div><div class="post-copyright" id="comments-container"><script src="/js/comments/gitment.js"></script></div><script>let arr = location.href.split('/#more')[0].split('/');
let title = arr[arr.length - 1];
if (title === '') {
    title = arr[arr.length - 2]
}
var flag = false;
var gitFun = function () {
    try {
        var gitmentObj = window.GLOBAL_CONFIG.gitment;
        var gitment = new Gitment({
            id: decodeURI(title), // 可选。默认为 location.href
            owner: gitmentObj.owner,
            repo: gitmentObj.repo,
            oauth: {
                client_id: gitmentObj.client_id,
                client_secret: gitmentObj.client_secret
            },
        });
        gitment.render('comments-container');
        flag = true;
    } catch (e) {
        flag = false;
    }
}
var setIn = setInterval(() => {
    if (!flag) {
        gitFun();
    } else {
        clearInterval(setIn);
    }
}, 200);</script></article><div id="pagination"><div class="prev-post pull-left"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/article/86b11e8e.html"><i class="fas fa-angle-left">&nbsp;</i><span>python的常见数据类型</span></a></div><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/article/93af3f24.html"><span>云计算复习</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2017 ～ 2021 By ye1s</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/daovoice.js"></script><!--script(src=url)--><div class="search-dialog"><div id="algolia-search-title">Algolia</div><div class="search-close-button"><i class="fa fa-times"></i></div><!--div#current-refined-values--><!--div#clear-all--><div id="search-box"></div><!--div#refinement-list--><hr><div id="hits"></div><div id="algolia-pagination"></div></div><div class="search-mask"></div><script src="/js/search/algolia.js"></script></body></html>