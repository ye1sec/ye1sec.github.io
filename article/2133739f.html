<!DOCTYPE html><html><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="python的IO编程"><meta name="keywords" content="python,文件操作"><meta name="author" content="ye1s,undefined"><meta name="copyright" content="ye1s"><title>python的IO编程【ye1s】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch-theme-algolia.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4"></script><!-- link(rel="dns-prefetch" href="https://cdn.jsdelivr.net")--><!-- link(rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css")--><!-- script(src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer)--><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"LKL6Q0GQJM","apiKey":"03829f64e2f5c11e4a5e2b8e51e24eb9","indexName":"blog","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  gitment: {"owner":"ye1sec","repo":"comments","client_id":"d5ece338867af32b6dfa","client_secret":"2caf36bbd47977524017f95105315fc9e65f0577"},
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="ye1s" type="application/atom+xml">
</head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0x1文件操作"><span class="toc-number">1.</span> <span class="toc-text">0x1文件操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x1-1文件的打开"><span class="toc-number">1.1.</span> <span class="toc-text">0x1.1文件的打开</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x1-2字节读取"><span class="toc-number">1.2.</span> <span class="toc-text">0x1.2字节读取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x1-3行读写"><span class="toc-number">1.3.</span> <span class="toc-text">0x1.3行读写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x1-4关闭文件"><span class="toc-number">1.4.</span> <span class="toc-text">0x1.4关闭文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x1-5codecs"><span class="toc-number">1.5.</span> <span class="toc-text">0x1.5codecs</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x2-目录文件操作"><span class="toc-number">2.</span> <span class="toc-text">0x2 目录文件操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#x02-1os-模块"><span class="toc-number">2.1.</span> <span class="toc-text">x02.1os 模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x2-2shutil模块"><span class="toc-number">2.2.</span> <span class="toc-text">0x2.2shutil模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x2-3glob"><span class="toc-number">2.3.</span> <span class="toc-text">0x2.3glob</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x3序列化"><span class="toc-number">3.</span> <span class="toc-text">0x3序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x3-1pickle"><span class="toc-number">3.1.</span> <span class="toc-text">0x3.1pickle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x3-2json"><span class="toc-number">3.2.</span> <span class="toc-text">0x3.2json</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x3-3shelve"><span class="toc-number">3.3.</span> <span class="toc-text">0x3.3shelve</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x4内存读写"><span class="toc-number">4.</span> <span class="toc-text">0x4内存读写</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x4-1StringIO"><span class="toc-number">4.1.</span> <span class="toc-text">0x4.1StringIO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x4-2BytesIO"><span class="toc-number">4.2.</span> <span class="toc-text">0x4.2BytesIO</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">ye1s</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/ye1sec" target="_blank">GitHub<i class="icon-dot bg-color1"></i></a><a class="links-button button-hover" href="mailto:431774437@qq.com" target="_blank">E-Mail<i class="icon-dot bg-color1"></i></a><a class="links-button button-hover" href="tencent://message/?uin=431774437&amp;Site=&amp;Menu=yes" target="_blank">QQ<i class="icon-dot bg-color8"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">200</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">149</span></a><a class="author-info-articles-categories article-meta" href="/categories"><span class="pull-top">分类</span><span class="pull-bottom">12</span></a></div><div class="friend-link"><a class="friend-link-text" href="http://www.m00nback.xyz/" target="_blank">MoonBack</a><a class="friend-link-text" target="_blank">待定</a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="search social-icon"><i class="fas fa-search"></i><span> 搜索</span></a><a class="title-name" href="/">ye1s</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">python的IO编程</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2019-05-29 | 更新于 2020-04-13</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/">编程算法</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/python/">python</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/">文件操作</a></div></div></div><div class="main-content"><p>IO编程包含文件读写及其操作、内存读写。  </p>
<a id="more"></a> 
<p>IO 在编程语言中特指输入和输出「即 input 和 output」。在 IO 编程中 stream （流）是一个重要的概念，一个完整的 IO 操作通常含有 input 和 output 两个数据流，我们称之为输入流和输出流。<br>由于 CPU 和内存的速度远远超过外设的速度，因此 IO 操作通常分为同步和异步两种方式，我们生活中所使用的操作系统通常情况下设计到 IO 操作的均使用的是异步 IO。那么同步 IO 和异步 IO 的区别是什么   </p>
<ol>
<li>同步 IO：即在遇到外设读取数据时，CPU 停止后续代码的执行，等待 IO 读取完成在接着执行剩余的代码。</li>
<li>异步 IO：即在遇到外设读取数据时，CPU 继续执行其他的代码，待 IO 读取完成在返回处理相关数据。</li>
</ol>
<blockquote>
<p>同步 IO 和异步 IO 最大的区别在遇到外设长时间读取数据时，CPU 是否等待 IO 的执行结果  </p>
</blockquote>
<h1 id="0x1文件操作"><a href="#0x1文件操作" class="headerlink" title="0x1文件操作"></a>0x1文件操作</h1><h2 id="0x1-1文件的打开"><a href="#0x1-1文件的打开" class="headerlink" title="0x1.1文件的打开"></a>0x1.1文件的打开</h2><p>文件的打开语法:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = open(name[， mode[， buffering]])</span><br></pre></td></tr></table></figure>
<p>各字段含义：<br>name: 所要打开的文件的名称，<br>mode：打开文件的方式:   </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'t'</span>  :  文本模式(默认)</span><br><span class="line"><span class="string">'x'</span>  :	写模式，新建一个文件，如果该文件已存在则会报错。</span><br><span class="line">‘r’  :  读模式</span><br><span class="line"><span class="string">'w'</span>  :  写模式</span><br><span class="line"><span class="string">'a'</span>  :  追加模式</span><br><span class="line"><span class="string">'b'</span>  :  二进制模式（可添加到其他模式中使用）</span><br><span class="line"><span class="string">'+'</span>  :  读写模式（可添加到其他模式中使用）</span><br><span class="line"><span class="string">'U'</span>  :  就是支持所有的换行模式，也就说‘\r’ <span class="string">'\n'</span> <span class="string">'\r\n'</span>都可表示换行，会有一个tuple用来存贮这个文件中用到过的换行符。</span><br></pre></td></tr></table></figure>
<p>buffering : 是否要缓冲  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 / False ：    代表无缓冲</span><br><span class="line">1 / True   ：    代表有缓冲</span><br><span class="line">大于一的数字：   代表缓冲区大小（单位是字节）</span><br><span class="line">-1   :       默认系统缓冲区大小</span><br></pre></td></tr></table></figure>
<p>上面mode列出的是基本模式，实际应用中的扩展模式有：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"r"</span>   以读方式打开，只能读文件，如果文件不存在，会发生异常。</span><br><span class="line"><span class="string">"w"</span>   以写方式打开，只能写文件， 如果文件不存在，创建该文件。如果文件已存在，先清空，再打开文件。</span><br><span class="line"><span class="string">"rb"</span>  以二进制读方式打开，只能读文件 ， 如果文件不存在，会发生异常</span><br><span class="line"><span class="string">"wb"</span>  以二进制写方式打开，只能写文件， 如果文件不存在，创建该文件；如果文件已存在，先清空，再打开文件</span><br><span class="line"><span class="string">"rt"</span>  以文本读方式打开，只能读文件 ， 如果文件不存在，会发生异常</span><br><span class="line"><span class="string">"wt"</span>  以文本写方式打开，只能写文件， 如果文件不存在，创建该文件，如果文件已存在，先清空，再打开文件 。</span><br><span class="line"><span class="string">"rb+"</span> 以二进制读方式打开，可以读、写文件 ， 如果文件不存在，会发生异常</span><br><span class="line"><span class="string">"wb+"</span> 以二进制写方式打开，可以读、写文件， 如果文件不存在，创建该文件。如果文件已存在，先清空，再打开文件。</span><br></pre></td></tr></table></figure>
<h2 id="0x1-2字节读取"><a href="#0x1-2字节读取" class="headerlink" title="0x1.2字节读取"></a>0x1.2字节读取</h2><ol>
<li>read <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f.read(num)           //读出num个字节</span><br><span class="line">f.read()              //读出全部字节</span><br></pre></td></tr></table></figure></li>
<li>write<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.write(string)         //将string写入文件</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="0x1-3行读写"><a href="#0x1-3行读写" class="headerlink" title="0x1.3行读写"></a>0x1.3行读写</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">F.readline([size])    <span class="comment">#读一行，如果定义了size，size的单位是byte，有可能返回的只是一行的一部分</span></span><br><span class="line">F.readlines([size])   <span class="comment">#把文件每一行作为一个list的一个成员，并返回这个list。其实它的内部是通过循环调用readline()来实现的。如果提供size参数，size是表示读取内容的总长，也就是说可能只读到文件的一部分。</span></span><br><span class="line">F.write(str)          <span class="comment">#把str写到文件中，write()并不会在str后加上一个换行符</span></span><br><span class="line">F.writelines(seq)     <span class="comment">#把seq的内容全部写到文件中。这个函数也只是忠实地写入，不会在每行后面加上任何东西。</span></span><br></pre></td></tr></table></figure>
<h2 id="0x1-4关闭文件"><a href="#0x1-4关闭文件" class="headerlink" title="0x1.4关闭文件"></a>0x1.4关闭文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fd.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">#可以在打开文件时使用with关键字，它会帮我们自动的关闭文件：</span></span><br><span class="line">with open(path, <span class="string">'r'</span>) as f:</span><br><span class="line">	// <span class="keyword">do</span> something</span><br></pre></td></tr></table></figure>
<h2 id="0x1-5codecs"><a href="#0x1-5codecs" class="headerlink" title="0x1.5codecs"></a>0x1.5codecs</h2><p>其实Python对多国语言的处理是支持的很好的，它可以处理当下任意编码的字符。</p>
<p>有一点需要清楚的是，当python要做编码转换的时候，会借助于内部的编码，转换过程是这样的：</p>
<blockquote>
<p>原有编码 -&gt; 内部编码 -&gt; 目的编码</p>
</blockquote>
<p>而codecs提供的方法可以指定一个编码打开文件，使用这个方法打开的文件读取返回的将是unicode。写入时，如果<em>参数是unicode，则使用open()时指定的编码进行编码后写入</em>；如果是<em>str，则先根据源代码文件声明的字符编码，解码成unicode后再进行前述 操作</em>。<br>相对内置的open()来说，这个方法不容易在编码上出现问题。所以，推荐大家在文件读写的时候使用codecs     </p>
<p>python的内部是使用unicode来处理的，但是unicode的使用需要考虑的是它的编码格式有两种，一是UCS-2，它一共有65536个码位，另一种是UCS-4，它有2147483648g个码位。</p>
<p>判断安装的python是用什么编码方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line"><span class="built_in">print</span>(sys.maxunicode)</span><br></pre></td></tr></table></figure>
<p>如果输出的值为65535,那么就是UCS-2,如果输出是1114111就是UCS-4编码。  </p>
<p>转换成内部码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="string">"风卷残云"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(c))</span><br><span class="line">c = bytes(c,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(c))</span><br><span class="line"><span class="built_in">print</span>(c)</span><br><span class="line">b = codecs.decode(c, <span class="string">"utf-8"</span>) <span class="comment">#与c.decode()等效</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(b))</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="built_in">print</span>(c.decode())</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line"></span><br><span class="line">&lt;class <span class="string">'str'</span>&gt;</span><br><span class="line">&lt;class <span class="string">'bytes'</span>&gt;</span><br><span class="line">b<span class="string">'\xe9\xa3\x8e\xe5\x8d\xb7\xe6\xae\x8b\xe4\xba\x91'</span></span><br><span class="line">&lt;class <span class="string">'str'</span>&gt;</span><br><span class="line">风卷残云</span><br><span class="line">风卷残云</span><br></pre></td></tr></table></figure>
<p>在python3.x中可以直接将bytes类型的数据转换成其他编码格式，而不用手动先转成unicode。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import codecs</span><br><span class="line">a = <span class="string">"你好世界"</span></span><br><span class="line"><span class="comment"># 创建utf-8编码器</span></span><br><span class="line">look = codecs.lookup(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="built_in">type</span>(a)</span><br><span class="line">a = bytes(a,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">b = look.decode(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line">输出:</span><br><span class="line">(<span class="string">'你好世界'</span>, 12)</span><br></pre></td></tr></table></figure>
<p>返回的元组中b[0]是数据，b[1]是长度<br><strong>用codecs提供的open方法来指定打开的文件的语言编码，它会在读取的时候自动转换为内部unicode</strong> </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = codecs.open(filepath, <span class="string">'r'</span>, <span class="string">'utf8'</span>)</span><br></pre></td></tr></table></figure>

<h1 id="0x2-目录文件操作"><a href="#0x2-目录文件操作" class="headerlink" title="0x2 目录文件操作"></a>0x2 目录文件操作</h1><h2 id="x02-1os-模块"><a href="#x02-1os-模块" class="headerlink" title="x02.1os 模块"></a>x02.1os 模块</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">os.sep 可以取代操作系统特定的路径分隔符。windows下为 <span class="string">'\\'</span></span><br><span class="line">os.name 字符串指示你正在使用的平台。比如对于Windows，它是<span class="string">'nt'</span>，而对于Linux/Unix用户，它是 <span class="string">'posix'</span></span><br><span class="line">os.getcwd() 函数得到当前工作目录，即当前Python脚本工作的目录路径</span><br><span class="line">os.getenv() 获取一个环境变量，如果没有返回none</span><br><span class="line">os.putenv(key, value) 设置一个环境变量值</span><br><span class="line">os.listdir(path) 返回指定目录下的所有文件和目录名</span><br><span class="line">os.remove(path) 函数用来删除一个文件</span><br><span class="line">os.system(<span class="built_in">command</span>) 函数用来运行shell命令</span><br><span class="line">os.linesep 字符串给出当前平台使用的行终止符。例如，Windows使用 <span class="string">'\r\n'</span>，Linux使用 <span class="string">'\n'</span> 而Mac使用 <span class="string">'\r'</span></span><br><span class="line">os.path.split(path)  函数返回一个路径的目录名和文件名</span><br><span class="line">os.path.isfile() 和os.path.isdir()函数分别检验给出的路径是一个文件还是目录</span><br><span class="line">os.path.exists() 函数用来检验给出的路径是否真地存在</span><br><span class="line">os.curdir  返回当前目录 (<span class="string">'.'</span>)</span><br><span class="line">os.mkdir(path) 创建一个目录</span><br><span class="line">os.makedirs(path) 递归的创建目录</span><br><span class="line">os.chdir(dirname) 改变工作目录到dirname    </span><br><span class="line">os.path.getsize(name) 获得文件大小，如果name是目录返回0L</span><br><span class="line">os.path.abspath(name) 获得绝对路径</span><br><span class="line">os.path.normpath(path) 规范path字符串形式</span><br><span class="line">os.path.splitext()  分离文件名与扩展名</span><br><span class="line">os.path.join(path,name) 连接目录与文件名或目录</span><br><span class="line">os.path.basename(path) 返回文件名</span><br><span class="line">os.path.dirname(path) 返回文件路径</span><br><span class="line">os.walk(top,topdown=True,onerror=None)  遍历迭代目录</span><br><span class="line">os.rename(src, dst)  重命名file或者directory src到dst 如果dst是一个存在的directory, 将抛出OSError. 在Unix, 如果dst在存且是一个file, 如果用户有权限的话，它将被安静的替换. 操作将会失败在某些Unix 中如果src和dst在不同的文件系统中. 如果成功, 这命名操作将会是一个原子操作 (这是POSIX 需要). 在 Windows上, 如果dst已经存在, 将抛出OSError，即使它是一个文件. 在unix，Windows中有效。</span><br><span class="line">os.renames(old, new) 递归重命名文件夹或者文件。像rename()</span><br></pre></td></tr></table></figure>
<h2 id="0x2-2shutil模块"><a href="#0x2-2shutil模块" class="headerlink" title="0x2.2shutil模块"></a>0x2.2shutil模块</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">shutil.copyfile( src, dst) 从源src复制到dst中去。当然前提是目标地址是具备可写权限。抛出的异常信息为IOException. 如果当前的dst已存在的话就会被覆盖掉</span><br><span class="line">shutil.move( src, dst)  移动文件或重命名</span><br><span class="line">shutil.copymode( src, dst) 只是会复制其权限其他的东西是不会被复制的</span><br><span class="line">shutil.copystat( src, dst) 复制权限、最后访问时间、最后修改时间</span><br><span class="line">shutil.copy( src, dst)  复制一个文件到一个文件或一个目录</span><br><span class="line">shutil.copy2( src, dst)  在copy上的基础上再复制文件最后访问时间与修改时间也复制过来了，类似于cp –p的东西</span><br><span class="line">shutil.copy2( src, dst)  如果两个位置的文件系统是一样的话相当于是rename操作，只是改名；如果是不在相同的文件系统的话就是做move操作</span><br><span class="line">shutil.copytree( olddir, newdir, True/Flase)</span><br><span class="line">把olddir拷贝一份newdir，如果第3个参数是True，则复制目录时将保持文件夹下的符号连接，如果第3个参数是False，则将在复制的目录下生成物理副本来替代符号连接</span><br><span class="line">shutil.rmtree( src ) 递归删除一个目录以及目录内的所有内容</span><br></pre></td></tr></table></figure>
<h2 id="0x2-3glob"><a href="#0x2-3glob" class="headerlink" title="0x2.3glob"></a>0x2.3glob</h2><p>例如当我们想要列出当前目录中所有扩展名为.jpg或.gif的文件的时候</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import glob</span><br><span class="line">filelist = glob.glob(<span class="string">'*.jpg'</span>) + glob.glob(<span class="string">'*.gif'</span>)</span><br><span class="line"><span class="built_in">print</span>(filelist)</span><br></pre></td></tr></table></figure>
<h1 id="0x3序列化"><a href="#0x3序列化" class="headerlink" title="0x3序列化"></a>0x3序列化</h1><p>我们把变量从内存中变成可存储或传输的过程称之为序列化。<br>序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。<br>反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化。    </p>
<p><strong>python的序列化可用pickle和json模块</strong>    </p>
<ul>
<li>json：用于（不同平台和多语言）字符串和python数据类型进行转换</li>
<li>pickle：用于python特有的类型和python的数据类型间进行转换（所有python数据类型）</li>
</ul>
<h2 id="0x3-1pickle"><a href="#0x3-1pickle" class="headerlink" title="0x3.1pickle"></a>0x3.1pickle</h2><p>Python提供两个模块来实现序列化：cPickle和pickle。这两个模块功能是一样的，区别在于cPickle是C语言写的，速度快，pickle是纯Python写的，速度慢。<br><strong>python3中已经没有cPickle模块</strong><br>pickle模块的作用:  </p>
<ol>
<li>可以将对象转换为一种可以传输或存储的格式。</li>
<li>pickle模块将任意一个python对象换成一个系统字节的操作过程叫做串行化对象。</li>
<li>pickle模块实现了python的所有数据序列化和反序列化。它不是用于多种语言间的传输，它仅作为python对象的持久化或者python程序间进行互相传输对象的。 </li>
</ol>
<p><strong>dump和dumps的区别：</strong></p>
<ul>
<li>dump是将对象序列化并保存到文件中</li>
<li>dumps是将对象序列化</li>
</ul>
<p><strong>load和loads的区别：</strong></p>
<ul>
<li>load将序列化字符串从文件读取并反序列化</li>
<li>loads将序列化字符串反序列化</li>
</ul>
<p>范例:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import pickle</span><br><span class="line">data1=[1,<span class="string">'a'</span>,2,<span class="string">'b'</span>,3,<span class="string">'c'</span>]</span><br><span class="line">pi=pickle.dumps(data1) <span class="comment">#序列化对象</span></span><br><span class="line"><span class="built_in">print</span>(pi)</span><br><span class="line"><span class="built_in">print</span>(pickle.loads(pi)) <span class="comment">#反序列胡对象</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f=open(<span class="string">'output.txt'</span>,<span class="string">'wb'</span>)</span><br><span class="line">data2=[<span class="string">'py'</span>,<span class="string">'th'</span>,<span class="string">'on'</span>,<span class="string">'123'</span>]</span><br><span class="line">pickle.dump(data2,f)  <span class="comment">#序列化对象到文件</span></span><br><span class="line">f=open(<span class="string">'output.txt'</span>,<span class="string">'rb'</span>)</span><br><span class="line"><span class="built_in">read</span>=pickle.load(f)<span class="comment">#文件中发序列化对象</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">read</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line"></span><br><span class="line">b<span class="string">'\x80\x03]q\x00(K\x01X\x01\x00\x00\x00aq\x01K\x02X\x01\x00\x00\x00bq\x02K\x03X\x01\x00\x00\x00cq\x03e.'</span></span><br><span class="line">[1, <span class="string">'a'</span>, 2, <span class="string">'b'</span>, 3, <span class="string">'c'</span>]</span><br><span class="line">[<span class="string">'py'</span>, <span class="string">'th'</span>, <span class="string">'on'</span>, <span class="string">'123'</span>]</span><br><span class="line">[Finished <span class="keyword">in</span> 0.2s]</span><br></pre></td></tr></table></figure>

<h2 id="0x3-2json"><a href="#0x3-2json" class="headerlink" title="0x3.2json"></a>0x3.2json</h2><p>json.dumps()是将字典类型转化成字符串类型。<br>json.loads()将字符串类型转化成字典类型<br>json.dump()用于将dict类型的数据转成str，并写入到json文件中<br>json.load()用于从json文件中读取数据。<br>范例：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line">data1=&#123;<span class="string">'a'</span>:1,<span class="string">'b'</span>:2,<span class="string">'c'</span>:3&#125;</span><br><span class="line">dus=json.dumps(data1)<span class="comment">#将字典类型转化成字符串类型</span></span><br><span class="line"><span class="built_in">print</span>(dus,<span class="built_in">type</span>(dus))</span><br><span class="line">los=json.loads(dus)</span><br><span class="line"><span class="built_in">print</span>(los,<span class="built_in">type</span>(los))<span class="comment">#将字符串类型转化成字典类型</span></span><br><span class="line"></span><br><span class="line">data2=&#123;<span class="string">'a'</span>:<span class="string">'4'</span>,<span class="string">'b'</span>:<span class="string">'5'</span>,<span class="string">'c'</span>:<span class="string">'6'</span>&#125;</span><br><span class="line">with open(<span class="string">'input.txt'</span>,<span class="string">'w'</span>) as f: <span class="comment">#用于将dict类型的数据转成str，并写入到json文件中</span></span><br><span class="line">	json.dump(data2,f)</span><br><span class="line">with open(<span class="string">"input.txt"</span>,<span class="string">'r'</span>) as f1:<span class="comment">#用于从json文件中读取数据。</span></span><br><span class="line">	<span class="built_in">print</span>(json.load(f1))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">&#123;<span class="string">"a"</span>: 1, <span class="string">"b"</span>: 2, <span class="string">"c"</span>: 3&#125; &lt;class <span class="string">'str'</span>&gt;</span><br><span class="line">&#123;<span class="string">'a'</span>: 1, <span class="string">'b'</span>: 2, <span class="string">'c'</span>: 3&#125; &lt;class <span class="string">'dict'</span>&gt;</span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="string">'4'</span>, <span class="string">'b'</span>: <span class="string">'5'</span>, <span class="string">'c'</span>: <span class="string">'6'</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0x3-3shelve"><a href="#0x3-3shelve" class="headerlink" title="0x3.3shelve"></a>0x3.3shelve</h2><p>shelve是通过key，value将内存中的数据通过文件存储的方式实现持久化，可以支持任何pickle所支持的任何Python数据格式：    </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import shelve</span><br><span class="line">d = shelve.open(<span class="string">"shelve_test"</span>)</span><br><span class="line"></span><br><span class="line">name = <span class="string">"python"</span></span><br><span class="line">info = &#123;<span class="string">"age"</span>:21,<span class="string">"sex"</span>:<span class="string">"man"</span>&#125;</span><br><span class="line"></span><br><span class="line">d[<span class="string">"name"</span>] = name</span><br><span class="line">d[<span class="string">"info"</span>] = info</span><br><span class="line">d.close()</span><br></pre></td></tr></table></figure>
<p>此时就已经完成了将内存数据持久化的一个过程，执行完毕之后，在当前目录下回生成一个名为“shelve_test.db”的文件。那么，我们又该如何将数据取出来呢，请看接下来的操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import shelve</span><br><span class="line">d = shelve.open(<span class="string">"shelve_test"</span>)</span><br><span class="line">name = d[<span class="string">"name"</span>]</span><br><span class="line">info = d[<span class="string">"info"</span>]</span><br><span class="line">d.close()</span><br></pre></td></tr></table></figure>
<p>此时就将数据从磁盘中从新取出来，放置在内存中，我们就可以对它进行操作了。</p>
<h1 id="0x4内存读写"><a href="#0x4内存读写" class="headerlink" title="0x4内存读写"></a>0x4内存读写</h1><p>python 通过 StringIO 和 BytesIO 来读写内存中的数据。     </p>
<h2 id="0x4-1StringIO"><a href="#0x4-1StringIO" class="headerlink" title="0x4.1StringIO"></a>0x4.1StringIO</h2><p><strong>StringIO 顾名思义就是读写内存中的字符串。</strong><br>StringIO的行为与file对象非常像，但它不是磁盘上文件，而是一个内存里的“文件”，我们可以像操作磁盘文件那样来操作StringIO<br>简单实例:  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line">import io</span><br><span class="line"></span><br><span class="line">f = io.StringIO()</span><br><span class="line">f.write(<span class="string">"hello world!"</span>)</span><br><span class="line"><span class="built_in">print</span>(f.getvalue())</span><br></pre></td></tr></table></figure>

<p><code>f=StringIO.StringIO([buf])</code><br>此实例类似于open方法，不同的是它并不会在硬盘中生成文件，而只寄存在缓冲区；可选参数buf是一个str或unicode类型。它将会与其他后续写入的数据存放在一起（注意，若要在初始化数据之后继续写入数据，则在写入数据之前，应先将读写位置移动到结尾，然后再写入，否则，初始化数据会被覆盖掉，因为读写位置默认是0）。</p>
<p>StringIO类中的方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>f.read([n])</td>
<td>参数n限定读取长度，int类型；缺省状态为从当前读写位置读取对象s中存储的所有数据。读取结束后，读写位置被移动。</td>
</tr>
<tr>
<td>f.readline([length])</td>
<td>参数length限定读取的结束位置，int类型，缺省状态为None：从当前读写位置读取至下一个以“\n”为结束符的当前行。读写位置被移动。</td>
</tr>
<tr>
<td>f.readlines([sizehint])</td>
<td>参数sizehint为int类型，缺省状态为读取所有行并作为列表返回，除此之外从当前读写位置读取至下一个以“\n”为结束符的当前行。读写位置被移动。</td>
</tr>
<tr>
<td>f.write(s)</td>
<td>从读写位置将参数s写入给对象s。参数s为str或unicode类型。读写位置被移动。</td>
</tr>
<tr>
<td>f.writelines(list)</td>
<td>读写位置将list写入给对象s。参数list为一个列表，列表的成员为str或unicode类型。读写位置被移动。</td>
</tr>
<tr>
<td>f.getvalue()</td>
<td>此函数没有参数，无论读写位置在哪里，都能够返回对象s中的所有数据。</td>
</tr>
<tr>
<td>f.truncate([size])</td>
<td>1》有size参数,无论读写位置在哪里，都从起始位置开始，裁剪size字节的数据。2》不带size参数,将当前读写位置之前的数据，裁剪下来。</td>
</tr>
<tr>
<td>f.tell()</td>
<td>返回当前读写位置。</td>
</tr>
<tr>
<td>f.seek(pos[,mode])</td>
<td>移动当前读写位置至pos处，可选参数mode为0时将读写位置移动至pos处，为1时将读写位置从当前位置起向前或向后移动pos个长度，为2时将读写位置置于末尾处再向前或向后移动pos个长度；mode的默认值为0。</td>
</tr>
<tr>
<td>f.close()</td>
<td>释放缓冲区，执行此函数后，数据将被释放，也不可再进行操作。</td>
</tr>
<tr>
<td>f.isatty()</td>
<td>此函数总是返回0。</td>
</tr>
<tr>
<td>f.flush()</td>
<td>刷新内部缓冲区。</td>
</tr>
</tbody></table>
<h2 id="0x4-2BytesIO"><a href="#0x4-2BytesIO" class="headerlink" title="0x4.2BytesIO"></a>0x4.2BytesIO</h2><p><strong>BytesIO 用来读写内存中的二进制数据。</strong><br>例子:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line">import io</span><br><span class="line"></span><br><span class="line">f = io.BytesIO()</span><br><span class="line">f.write(<span class="string">'keinYe'</span>.encode(<span class="string">'utf-8'</span>))</span><br><span class="line"><span class="built_in">print</span>(f.getvalue())</span><br></pre></td></tr></table></figure>

<p>参考文章:<br>python文件操作（一）基础文件操作:<a href="http://www.361way.com/python-file-basics/4627.html" target="_blank" rel="noopener">http://www.361way.com/python-file-basics/4627.html</a><br>Python IO 编程  <a href="http://keinye.com/2019/02/python-base-io/" target="_blank" rel="noopener">http://keinye.com/2019/02/python-base-io/</a><br>Python StringIO实现内存缓冲区中读写数据<a href="https://www.cnblogs.com/misswangxing/p/7921665.html" target="_blank" rel="noopener">https://www.cnblogs.com/misswangxing/p/7921665.html</a><br>Python 中文件 I/O 高效操作处理的技巧<a href="https://juejin.im/entry/58ec780f8d6d810058056396" target="_blank" rel="noopener">https://juejin.im/entry/58ec780f8d6d810058056396</a><br>廖雪峰的官方网站 <a href="https://www.liaoxuefeng.com/wiki/897692888725344/92303055545616" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/897692888725344/92303055545616</a><br> python中转换模块codecs的讲解 <a href="http://www.php.cn/python-tutorials-412484.html" target="_blank" rel="noopener">http://www.php.cn/python-tutorials-412484.html</a><br> python–序列化（dump和dumps的区别、load和loads的区别、json与pickle模块的区别）  <a href="https://blog.csdn.net/qq_44525050/article/details/87947301" target="_blank" rel="noopener">https://blog.csdn.net/qq_44525050/article/details/87947301</a></p>
</div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">ye1s</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="https://blog.cfyqy.com/article/2133739f.html">https://blog.cfyqy.com/article/2133739f.html</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.cfyqy.com">ye1s</a>！</span></div></div><div class="post-copyright" id="comments-container"><script src="/js/comments/gitment.js"></script></div><script>let arr = location.href.split('/#more')[0].split('/');
let title = arr[arr.length - 1];
if (title === '') {
    title = arr[arr.length - 2]
}
var flag = false;
var gitFun = function () {
    try {
        var gitmentObj = window.GLOBAL_CONFIG.gitment;
        var gitment = new Gitment({
            id: decodeURI(title), // 可选。默认为 location.href
            owner: gitmentObj.owner,
            repo: gitmentObj.repo,
            oauth: {
                client_id: gitmentObj.client_id,
                client_secret: gitmentObj.client_secret
            },
        });
        gitment.render('comments-container');
        flag = true;
    } catch (e) {
        flag = false;
    }
}
var setIn = setInterval(() => {
    if (!flag) {
        gitFun();
    } else {
        clearInterval(setIn);
    }
}, 200);</script></article><div id="pagination"><div class="prev-post pull-left"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/article/761e66f3.html"><i class="fas fa-angle-left">&nbsp;</i><span>python面向对象编程</span></a></div><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/article/8fa1fc40.html"><span>python的编码与解码</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2017 ～ 2021 By ye1s</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/daovoice.js"></script><!--script(src=url)--><div class="search-dialog"><div id="algolia-search-title">Algolia</div><div class="search-close-button"><i class="fa fa-times"></i></div><!--div#current-refined-values--><!--div#clear-all--><div id="search-box"></div><!--div#refinement-list--><hr><div id="hits"></div><div id="algolia-pagination"></div></div><div class="search-mask"></div><script src="/js/search/algolia.js"></script></body></html>