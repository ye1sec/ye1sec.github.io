<!DOCTYPE html><html><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="HTTP走私协议"><meta name="keywords" content="HTTP"><meta name="author" content="ye1s,undefined"><meta name="copyright" content="ye1s"><title>HTTP走私协议【ye1s】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch-theme-algolia.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4"></script><!-- link(rel="dns-prefetch" href="https://cdn.jsdelivr.net")--><!-- link(rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css")--><!-- script(src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer)--><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"LKL6Q0GQJM","apiKey":"03829f64e2f5c11e4a5e2b8e51e24eb9","indexName":"blog","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  gitment: {"owner":"ye1sec","repo":"comments","client_id":"d5ece338867af32b6dfa","client_secret":"2caf36bbd47977524017f95105315fc9e65f0577"},
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="ye1s" type="application/atom+xml">
</head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#相关概念"><span class="toc-number">1.</span> <span class="toc-text">相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#keep-alive-与-pipeline"><span class="toc-number">1.1.</span> <span class="toc-text">keep-alive 与 pipeline</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CL-与-TE"><span class="toc-number">1.2.</span> <span class="toc-text">CL 与 TE</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#走私原因"><span class="toc-number">2.</span> <span class="toc-text">走私原因</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#走私方式"><span class="toc-number">3.</span> <span class="toc-text">走私方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CL不为0的GET请求"><span class="toc-number">3.1.</span> <span class="toc-text">CL不为0的GET请求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CL-CL"><span class="toc-number">3.2.</span> <span class="toc-text">CL-CL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CL-TE"><span class="toc-number">3.3.</span> <span class="toc-text">CL-TE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TE-CL"><span class="toc-number">3.4.</span> <span class="toc-text">TE-CL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TE-TE"><span class="toc-number">3.5.</span> <span class="toc-text">TE-TE</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#例题"><span class="toc-number">4.</span> <span class="toc-text">例题</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">ye1s</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/ye1sec" target="_blank">GitHub<i class="icon-dot bg-color5"></i></a><a class="links-button button-hover" href="mailto:431774437@qq.com" target="_blank">E-Mail<i class="icon-dot bg-color1"></i></a><a class="links-button button-hover" href="tencent://message/?uin=431774437&amp;Site=&amp;Menu=yes" target="_blank">QQ<i class="icon-dot bg-color1"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">200</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">149</span></a><a class="author-info-articles-categories article-meta" href="/categories"><span class="pull-top">分类</span><span class="pull-bottom">12</span></a></div><div class="friend-link"><a class="friend-link-text" href="http://www.m00nback.xyz/" target="_blank">MoonBack</a><a class="friend-link-text" target="_blank">待定</a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="search social-icon"><i class="fas fa-search"></i><span> 搜索</span></a><a class="title-name" href="/">ye1s</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">HTTP走私协议</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2020-08-11 | 更新于 2021-01-05</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/web%E5%AE%89%E5%85%A8/">web安全</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/HTTP/">HTTP</a></div></div></div><div class="main-content"><p>在复杂的网络环境下，不同的服务器以不同的方式实现RFC标准，利用前后端服务器对数据包的边界了解不一致的情况下，向一个请求数据包中插入下一个请求数据包的一部分，在前端服务器角度看来，它属于一个完整的请求，而在后端服务器看来，它属于两次请求，前端请求的一部分被后端服务器解释为下一个请求的开始。因此，它使攻击者可以绕过安全控制，未经授权访问敏感数据并直接危害其他应用程序用户。   </p>
<a id="more"></a> 
<h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><h2 id="keep-alive-与-pipeline"><a href="#keep-alive-与-pipeline" class="headerlink" title="keep-alive 与 pipeline"></a>keep-alive 与 pipeline</h2><blockquote>
<p>Keep-Alive，就是在 HTTP 请求中增加一个特殊的请求头 Connection: Keep-Alive，告诉服务器，接收完这次 HTTP 请求后，不要关闭 TCP 链接，后面对相同目标服务器的 HTTP 请求，重用这一个 TCP 链接，这样只需要进行一次 TCP 握手的过程，可以减少服务器的开销，节约资源，还能加快访问速度。这个特性在 HTTP1.1 中是默认开启的。</p>
</blockquote>
<blockquote>
<p>有了 Keep-Alive 之后，后续就有了 Pipeline，在这里呢，客户端可以像流水线一样发送自己的 HTTP 请求，而不需要等待服务器的响应，服务器那边接收到请求后，需要遵循先入先出机制，将请求和响应严格对应起来，再将响应发送给客户端。现如今，浏览器默认是不启用 Pipeline 的，但是一般的服务器都提供了对 Pipleline 的支持。</p>
</blockquote>
<h2 id="CL-与-TE"><a href="#CL-与-TE" class="headerlink" title="CL 与 TE"></a>CL 与 TE</h2><p>CL 和 TE 即是 Content-Length 和 Transfer-Encoding 请求头（严格来讲前者是个实体头，为了方便就都用请求头代指）。这里比较有趣的是 Transfer-Encoding（HTTP/2 中不再支持），指定用于传输请求主体的编码方式，可以用的值有 chunked/compress/deflate/gzip/identity 。   </p>
<blockquote>
<p>chunked: Data is sent in a series of chunks. The Content-Length header is omitted in this case and at the beginning of each chunk you need to add the length of the current chunk in hexadecimal format, followed by ‘\r\n’ and then the chunk itself, followed by another ‘\r\n’. The terminating chunk is a regular chunk, with the exception that its length is zero. It is followed by the trailer, which consists of a (possibly empty) sequence of entity header fields.   </p>
</blockquote>
<p>设置了 Transfer-Encoding: chunked 后，请求主体按一系列块的形式发送，并将省略 Content-Length。在每个块的开头需要用十六进制数指明当前块的长度，数值后接 \r\n（占 2 字节），然后是块的内容，再接 \r\n 表示此块结束。最后用长度为 0 的块表示终止块。终止块后是一个 trailer，由 0 或多个实体头组成，可以用来存放对数据的数字签名等  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[chunk size][\r\n][chunk data][\r\n][chunk size][\r\n][chunk data][\r\n][chunk size &#x3D; 0][\r\n][\r\n</span><br></pre></td></tr></table></figure>
<p>在计算长度时有一些需要注意的原则：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-Length 需要将请求主体中的 \r\n 所占的 2 字节计算在内，而块长度要忽略块内容末尾表示终止的 \r\n</span><br><span class="line">请求头与请求主体之间有一个空行，是规范要求的结构，并不计入 Content-Length</span><br></pre></td></tr></table></figure>

<h1 id="走私原因"><a href="#走私原因" class="headerlink" title="走私原因"></a>走私原因</h1><p>在HTTP1.1后，增加了一个特殊的请求头Connection: Keep-Alive，建立tcp持续通道，进行一次tcp握手，就能传送多个请求。但这样子只能是请求一次响应一次。为了提高数据传输的效率，减少阻塞。后来就有了HTTP Pipelining(管线化)字段，它是将多个http请求批量提交,而不用等收到响应再提交的异步技术。如下图就是使用Pipelining和非Pipelining<br><img src="../../images/network/HTTP/1.png" alt=""><br>这意味着前端与后端必须短时间内对每个数据包的边界大小达成一致，否则，攻击者就可以构造发送一个特殊的数据包，在前端看来它是一个请求，但在后端却被解释为了两个不同的HTTP请求。这就导致攻击者可以在下一个用户发送的合法数据包前恶意添加内容。如图，走私的内容(“前缀”)，以橙色突出显示：<br><img src="../../images/network/HTTP/2.png" alt=""><br>假设前端考虑的是内容长度头部(Content-Length)值作为数据包结束的边界，后端优先考虑的是Transfer-Encoding头部。那么从后端角度看，如下图蓝色部份字体属于一个数据包，而红色部份字体属于下一个数据包的开始部份。这样就成功从前端“走私”了一个数据包<br><img src="../../images/network/HTTP/3.png" alt=""></p>
<h1 id="走私方式"><a href="#走私方式" class="headerlink" title="走私方式"></a>走私方式</h1><h2 id="CL不为0的GET请求"><a href="#CL不为0的GET请求" class="headerlink" title="CL不为0的GET请求"></a>CL不为0的GET请求</h2><p>假设前端代理服务器允许GET请求携带请求体，而后端服务器不允许GET请求携带请求体，它会直接忽略掉GET请求中的 Content-Length头，不进行处理。这就有可能导致请求走私。</p>
<p>比如发送下面请求</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host:example.com</span><br><span class="line">Content-Length:44</span><br><span class="line">GET /socket HTTP/1.1</span><br><span class="line">Host: example.com</span><br></pre></td></tr></table></figure>
<p>前端服务器通过读取Content-Length，确认这是个完整的请求，然后转发到后端服务器，而后端服务器因为不对Content-Length进行判断，由于Pipeline的存在，它认为这是两个请求，分别为</p>
<p>第一个</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: example.com</span><br></pre></td></tr></table></figure>
<p>第二个</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /socket HTTP/1.1</span><br><span class="line">Host: example.com</span><br></pre></td></tr></table></figure>
<p>则相当于走私了请求  </p>
<h2 id="CL-CL"><a href="#CL-CL" class="headerlink" title="CL-CL"></a>CL-CL</h2><p>在RFC7230规范中，规定当服务器收到的请求中包含两个 Content-Length，而且两者的值不同时，需要返回400错误。但难免会有服务器不严格遵守该规范。假设前端和后端服务器都收到该类请求，且不报错，其中前端服务器按照第一个Content-Length的值对请求进行为数据包定界，而后端服务器则按照第二个Content-Length的值进行处理。</p>
<p>这时攻击者可以恶意构造一个特殊的请求，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Content-Length: 6</span><br><span class="line">Content-Length: 5</span><br><span class="line">123</span><br><span class="line">A</span><br></pre></td></tr></table></figure>
<p>CDN服务器获取到的数据包的长度6，将上述整个数据包转发给后端的服务器，而后端服务器获取到的数据包长度为5。当读取完前5个字符后，后端服务器认为该请求已经读取完毕，然后发送出去。而此时的缓冲区去还剩余一个字母 A，对于后端服务器来说，这个 A是下一个请求的一部分，但是还没有传输完毕。此时恰巧有一个其他的正常用户对服务器进行了请求，则该A字母会拼凑到下一个正常用户请求的前面，攻击在此展开。</p>
<h2 id="CL-TE"><a href="#CL-TE" class="headerlink" title="CL-TE"></a>CL-TE</h2><p>前置服务器认为 Content-Length 优先级更高（或者根本就不支持 Transfer-Encoding ） ，后端认为 Transfer-Encoding 优先级更高。</p>
<p>举个栗子，假如发送的请求如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: 1.com</span><br><span class="line">Content-Length: 6</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">A</span><br></pre></td></tr></table></figure>
<p>前置服务器根据 Content-Length: 6 判断出这是一个完整的请求，于是整体转发到后端服务器，但后端根据 Transfer-Encoding: chunked 将请求主体截断到 0\r\n\r\n 并认为一个完整的请求结束了，最后剩下的 A 就被认为是下一个请求的一部分，留在缓冲区中等待剩余的请求。如果此时其他用户此时发送了一个 GET 请求，就会与 A 拼接成一个畸形的 AGET，造成服务器解析异常：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AGET / HTTP/1.1</span><br><span class="line">Host: 1.com</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>在做之前记得要把 BurpSuite 的自动更新 Content-Length 功能取消了。<br>注意：需要发送两次请求    </p>
<p>实验：<a href="https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te</a>     </p>
<p>进入靶场抓包，修改为POST请求方式，关闭burp suite自动更新Content-Length功能<br><img src="../../images/network/HTTP/4.png" alt=""><br>修改数据包，添加 Transfer-Encoding: chunked，修改数据包Content-Length的值。<br>Content-Length为10的原因为回车占据两字节，回车+0+回车+HELLO共10字节，接着提交，返回正常。<br><img src="../../images/network/HTTP/5.png" alt=""><br>再次提交，提示：”Unrecognized method HELLOPOST”<br><img src="../../images/network/HTTP/6.png" alt=""></p>
<h2 id="TE-CL"><a href="#TE-CL" class="headerlink" title="TE-CL"></a>TE-CL</h2><p>前置服务器认为 Transfer-Encoding 优先级更高，后端认为 Content-Length 优先级更高（或者不支持 Transfer-Encoding ）。</p>
<p>以如下请求为例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: ac7f1f821ea8d83280cc5eda009200f6.web-security-academy.net</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 4</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">17</span><br><span class="line">POST /rook1e HTTP/1.1</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line">[空白行]</span><br><span class="line">[空白行]</span><br></pre></td></tr></table></figure>
<p>前置服务器将其分块传输，其实就一个长度为 23 的块 POST /rook1e HTTP/1.1\r\n，但后端服务器根据 Content-Length: 4 截取到 17\r\n 即认为是一个完整的请求，剩下的留在缓冲区中等待剩余内容，若此时由用户发送了一个 GET，即被拼接成了一个 POST /rook1e 走私请求。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /rook1e HTTP/1.1</span><br><span class="line"></span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">GET / HTTP/1.1</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>连发两次包，可以发现后端服务器找不到 /rook1e 而返回 404。  </p>
<p>实验: <a href="https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl</a><br><img src="../../images/network/HTTP/7.png" alt=""><br><img src="../../images/network/HTTP/8.png" alt=""></p>
<h2 id="TE-TE"><a href="#TE-TE" class="headerlink" title="TE-TE"></a>TE-TE</h2><p>前端服务器处理第一个Transfer-Encoding请求头，后端服务器处理第二个Transfer-Encoding请求头。</p>
<p>构造数据包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Host:example.com</span><br><span class="line">Content-length: 3</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Transfer-encoding: error</span><br><span class="line">chunkedcode</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>这里是用了两个Transfer-Encoding 字段，并且第二个 TE 字段值为错误值，这里 前端服务器选择对第一个 Transfer-Encoding进行处理，整个请求正常，原封不动转发给后端服务器，而后端服务器则以第二个Transfer-Encoding 字段进行优先处理，而第二个Transfer-Encoding 字段非标准值，根据RPC规范，则会取Content-Length字段进行处理，这样这个请求就会被拆分为两个请求。</p>
<p>在做之前记得要把 BurpSuite 的自动更新 Content-Length 功能取消了。   </p>
<p>注意：需要发送两次请求   </p>
<p>实验：<a href="https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header" target="_blank" rel="noopener">https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header</a><br><img src="../../images/network/HTTP/9.png" alt=""><br><img src="../../images/network/HTTP/10.png" alt="">  </p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://xz.aliyun.com/t/6654#toc-5" target="_blank" rel="noopener">https://xz.aliyun.com/t/6654#toc-5</a>   </p>
<p>参考文章:</p>
<p><a href="http://phoebe233.cn/?p=40" target="_blank" rel="noopener">http走私</a><br><a href="https://www.anquanke.com/post/id/210036" target="_blank" rel="noopener">浅析HTTP走私攻击</a><br><a href="https://xz.aliyun.com/t/7501" target="_blank" rel="noopener">浅谈HTTP请求走私</a><br><a href="https://paper.seebug.org/1048/" target="_blank" rel="noopener">协议层的攻击——HTTP请求走私</a><br><a href="https://xz.aliyun.com/t/6654" target="_blank" rel="noopener">从一道题到协议层攻击之HTTP请求走私</a><br><a href="https://xz.aliyun.com/t/6631" target="_blank" rel="noopener">从一道题深入HTTP协议与HTTP请求走私</a></p>
</div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">ye1s</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="https://blog.cfyqy.com/article/a0cdd9b6.html">https://blog.cfyqy.com/article/a0cdd9b6.html</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.cfyqy.com">ye1s</a>！</span></div></div><div class="post-copyright" id="comments-container"><script src="/js/comments/gitment.js"></script></div><script>let arr = location.href.split('/#more')[0].split('/');
let title = arr[arr.length - 1];
if (title === '') {
    title = arr[arr.length - 2]
}
var flag = false;
var gitFun = function () {
    try {
        var gitmentObj = window.GLOBAL_CONFIG.gitment;
        var gitment = new Gitment({
            id: decodeURI(title), // 可选。默认为 location.href
            owner: gitmentObj.owner,
            repo: gitmentObj.repo,
            oauth: {
                client_id: gitmentObj.client_id,
                client_secret: gitmentObj.client_secret
            },
        });
        gitment.render('comments-container');
        flag = true;
    } catch (e) {
        flag = false;
    }
}
var setIn = setInterval(() => {
    if (!flag) {
        gitFun();
    } else {
        clearInterval(setIn);
    }
}, 200);</script></article><div id="pagination"><div class="prev-post pull-left"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/article/9b9a2941.html"><i class="fas fa-angle-left">&nbsp;</i><span>PGP加密学习</span></a></div><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/article/ff438041.html"><span>Apache浅识</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2017 ～ 2021 By ye1s</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/daovoice.js"></script><!--script(src=url)--><div class="search-dialog"><div id="algolia-search-title">Algolia</div><div class="search-close-button"><i class="fa fa-times"></i></div><!--div#current-refined-values--><!--div#clear-all--><div id="search-box"></div><!--div#refinement-list--><hr><div id="hits"></div><div id="algolia-pagination"></div></div><div class="search-mask"></div><script src="/js/search/algolia.js"></script></body></html>