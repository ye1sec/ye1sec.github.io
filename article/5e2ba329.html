<!DOCTYPE html><html><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="python的函数编程"><meta name="keywords" content="python,函数"><meta name="author" content="ye1s,undefined"><meta name="copyright" content="ye1s"><title>python的函数编程【ye1s】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch-theme-algolia.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4"></script><!-- link(rel="dns-prefetch" href="https://cdn.jsdelivr.net")--><!-- link(rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css")--><!-- script(src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer)--><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"LKL6Q0GQJM","apiKey":"03829f64e2f5c11e4a5e2b8e51e24eb9","indexName":"blog","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  gitment: {"owner":"ye1sec","repo":"comments","client_id":"d5ece338867af32b6dfa","client_secret":"2caf36bbd47977524017f95105315fc9e65f0577"},
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="ye1s" type="application/atom+xml">
</head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="toggle-sidebar-info button-hover"><span data-toggle="文章目录">站点概览</span></div><div class="sidebar-toc"><div class="sidebar-toc-title">目录</div><div class="sidebar-toc-progress"><span class="progress-notice">您已阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc-progress-bar"></div></div><div class="sidebar-toc-content" id="sidebar-toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0x1函数基础"><span class="toc-number">1.</span> <span class="toc-text">0x1函数基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x1-1定义函数"><span class="toc-number">1.1.</span> <span class="toc-text">0x1.1定义函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x1-2函数参数"><span class="toc-number">1.2.</span> <span class="toc-text">0x1.2函数参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x1-2-1必选参数"><span class="toc-number">1.3.</span> <span class="toc-text">0x1.2.1必选参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x1-2-3可变参数"><span class="toc-number">1.4.</span> <span class="toc-text">0x1.2.3可变参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x1-2-4关键字参数"><span class="toc-number">1.5.</span> <span class="toc-text">0x1.2.4关键字参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x1-2-5参数组合"><span class="toc-number">1.6.</span> <span class="toc-text">0x1.2.5参数组合</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x2内置高阶函数"><span class="toc-number">2.</span> <span class="toc-text">0x2内置高阶函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x2-1-map"><span class="toc-number">2.1.</span> <span class="toc-text">0x2.1 map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x2-2reduce"><span class="toc-number">2.2.</span> <span class="toc-text">0x2.2reduce</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x2-3filter"><span class="toc-number">2.3.</span> <span class="toc-text">0x2.3filter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x2-4sorted"><span class="toc-number">2.4.</span> <span class="toc-text">0x2.4sorted</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x4闭包"><span class="toc-number">3.</span> <span class="toc-text">0x4闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x4-1闭包理解"><span class="toc-number">3.1.</span> <span class="toc-text">0x4.1闭包理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x4-2闭包的作用"><span class="toc-number">3.2.</span> <span class="toc-text">0x4.2闭包的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x4-3闭包的误区"><span class="toc-number">3.3.</span> <span class="toc-text">0x4.3闭包的误区</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x5偏函数-partial"><span class="toc-number">4.</span> <span class="toc-text">0x5偏函数(partial)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x6装饰器"><span class="toc-number">5.</span> <span class="toc-text">0x6装饰器</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">ye1s</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/ye1sec" target="_blank">GitHub<i class="icon-dot bg-color1"></i></a><a class="links-button button-hover" href="mailto:431774437@qq.com" target="_blank">E-Mail<i class="icon-dot bg-color7"></i></a><a class="links-button button-hover" href="tencent://message/?uin=431774437&amp;Site=&amp;Menu=yes" target="_blank">QQ<i class="icon-dot bg-color8"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">198</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">149</span></a><a class="author-info-articles-categories article-meta" href="/categories"><span class="pull-top">分类</span><span class="pull-bottom">12</span></a></div><div class="friend-link"><a class="friend-link-text" href="http://www.m00nback.xyz/" target="_blank">MoonBack</a><a class="friend-link-text" target="_blank">待定</a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="search social-icon"><i class="fas fa-search"></i><span> 搜索</span></a><a class="title-name" href="/">ye1s</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><article id="post"><div class="post-header"><div class="title">python的函数编程</div><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 发表于 2019-06-01 | 更新于 2020-04-13</time><!--time.button-hover.post-date #[i.fas.fa-calendar-alt.article-icon(aria-hidden="true")] #[=__('post.modified')] #[=date(page['updated'], config.date_format)]--><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/">编程算法</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/python/">python</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E5%87%BD%E6%95%B0/">函数</a></div></div></div><div class="main-content"><p>函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。  </p>
<a id="more"></a>
<p>详情可看此wiki: <a href="http://funhacks.net/explore-python/Function/" target="_blank" rel="noopener">http://funhacks.net/explore-python/Function/</a></p>
<h1 id="0x1函数基础"><a href="#0x1函数基础" class="headerlink" title="0x1函数基础"></a>0x1函数基础</h1><h2 id="0x1-1定义函数"><a href="#0x1-1定义函数" class="headerlink" title="0x1.1定义函数"></a>0x1.1定义函数</h2><p>在 Python 中，定义函数使用 def 语句。一个函数主要由三部分构成：</p>
<ul>
<li>函数名</li>
<li>函数参数</li>
<li>函数返回值</li>
</ul>
<p>如果函数没有 return 语句，则自动 return None<br>可以定义返回多个值的函数   </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def add_one(x, y, z):</span><br><span class="line">	<span class="built_in">return</span> x+1, y+1, z+1</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(add_one(1,2,3))</span><br></pre></td></tr></table></figure>
<h2 id="0x1-2函数参数"><a href="#0x1-2函数参数" class="headerlink" title="0x1.2函数参数"></a>0x1.2函数参数</h2><p>在 Python 中，定义函数和调用函数都很简单，但如何定义函数参数和传递函数参数，则涉及到一些套路了。总的来说，Python 的函数参数主要分为以下几种：</p>
<ul>
<li>必选参数</li>
<li>默认参数</li>
<li>可变参数</li>
<li>关键字参数</li>
</ul>
<h2 id="0x1-2-1必选参数"><a href="#0x1-2-1必选参数" class="headerlink" title="0x1.2.1必选参数"></a>0x1.2.1必选参数</h2><p>必选参数可以说是最常见的了，顾名思义，必选参数就是在调用函数的时候要传入数量一致的参数，比如：   </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def add(x, y):        <span class="comment"># x, y 是必选参数</span></span><br><span class="line">...     <span class="built_in">print</span> x + y</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; add()                 <span class="comment"># 啥都没传，不行</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line 1, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: add() takes exactly 2 arguments (0 given)</span><br><span class="line">&gt;&gt;&gt; add(1)                <span class="comment"># 只传了一个，也不行</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line 1, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: add() takes exactly 2 arguments (1 given)</span><br><span class="line">&gt;&gt;&gt; add(1, 2)             <span class="comment"># 数量一致，通过</span></span><br><span class="line">3</span><br><span class="line">``` </span><br><span class="line"><span class="comment">## 0x1.2.2默认参数  </span></span><br><span class="line">默认参数是指在定义函数的时候提供一些默认值，如果在调用函数的时候没有传递该参数，则自动使用默认值，否则使用传递时该参数的值。  </span><br><span class="line">看看例子就明白了：</span><br><span class="line">```bash</span><br><span class="line">&gt;&gt;&gt; def add(x, y, z=1):     <span class="comment"># x, y 是必选参数，z 是默认参数，默认值是 1</span></span><br><span class="line">...     <span class="built_in">print</span> x + y + z</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; add(1, 2, 3)            <span class="comment"># 1+2+3</span></span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; add(1, 2)               <span class="comment"># 没有传递 z，自动使用 z=1，即 1+2+1</span></span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>可以看到，默认参数使用起来也很简单，但有两点需要注意的是：</p>
<ul>
<li>默认参数要放在所有必选参数的后面  </li>
<li>默认参数应该使用不可变对象   </li>
</ul>
<p>比如，下面对默认参数的使用是错误的：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def add(x=1, y, z):      <span class="comment"># x 是默认参数，必须放在所有必选参数的后面</span></span><br><span class="line">...     <span class="built_in">return</span> x + y + z</span><br><span class="line">...</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line 1</span><br><span class="line">SyntaxError: non-default argument follows default argument</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; def add(x, y=1, z):      <span class="comment"># y 是默认参数，必须放在所有必选参数的后面</span></span><br><span class="line">...     <span class="built_in">return</span> x + y + z</span><br><span class="line">...</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line 1</span><br><span class="line">SyntaxError: non-default argument follows default argument</span><br></pre></td></tr></table></figure>
<p>再来看看为什么默认参数应该使用不可变对象。</p>
<p>我们看一个例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def add_to_list(L=[]):</span><br><span class="line">...     L.append(<span class="string">'END'</span>)</span><br><span class="line">...     <span class="built_in">return</span> L</span><br></pre></td></tr></table></figure>
<p>在上面的函数中，L 是一个默认参数，默认值是 []，表示空列表。</p>
<p>我们来看看使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; add_to_list([1, 2, 3])          <span class="comment"># 没啥问题</span></span><br><span class="line">[1, 2, 3, <span class="string">'END'</span>]</span><br><span class="line">&gt;&gt;&gt; add_to_list([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])    <span class="comment"># 没啥问题</span></span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'END'</span>]</span><br><span class="line">&gt;&gt;&gt; add_to_list()                   <span class="comment"># 没有传递参数，使用默认值，也没啥问题</span></span><br><span class="line">[<span class="string">'END'</span>]</span><br><span class="line">&gt;&gt;&gt; add_to_list()                   <span class="comment"># 没有传递参数，使用默认值，竟出现两个 'END'</span></span><br><span class="line">[<span class="string">'END'</span>, <span class="string">'END'</span>]</span><br><span class="line">&gt;&gt;&gt; add_to_list()                   <span class="comment"># 糟糕了，三个 'END'</span></span><br><span class="line">[<span class="string">'END'</span>, <span class="string">'END'</span>, <span class="string">'END'</span>]</span><br></pre></td></tr></table></figure>
<p>为啥呢？我们在调用函数的时候没有传递参数，那么就默认使用 L=[]，经过处理，L 应该只有一个元素，怎么会出现调用函数两次，L 就有两个元素呢？</p>
<p>原来，L 指向了可变对象 []，当你调用函数时，L 的内容发生了改变，默认参数的内容也会跟着变，也就是，当你第一次调用时，L 的初始值是 []，当你第二次调用时，L 的初始值是 [‘END’]，等等。</p>
<p>所以，为了避免不必要的错误，我们应该使用不可变对象作为函数的默认参数。  </p>
<h2 id="0x1-2-3可变参数"><a href="#0x1-2-3可变参数" class="headerlink" title="0x1.2.3可变参数"></a>0x1.2.3可变参数</h2><p>在某些情况下，我们在定义函数的时候，无法预估函数应该制定多少个参数，这时我们就可以使用可变参数了，也就是，函数的参数个数是不确定的。</p>
<p>看看例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def add(*numbers):</span><br><span class="line">...     sum = 0</span><br><span class="line">...     <span class="keyword">for</span> i <span class="keyword">in</span> numbers:</span><br><span class="line">...         sum += i</span><br><span class="line">...     <span class="built_in">print</span> <span class="string">'numbers:'</span>, numbers</span><br><span class="line">...     <span class="built_in">return</span> sum</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，numbers 就是一个可变参数，参数前面有一个 * 号，表示是可变的。在函数内部，参数 numbers 接收到的是一个 tuple。  </p>
<p>在调用函数时，我们可以给该函数传递任意个参数，包括 0 个参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; add()           <span class="comment"># 传递 0 个参数</span></span><br><span class="line">numbers: ()</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; add(1)          <span class="comment"># 传递 1 个参数</span></span><br><span class="line">numbers: (1,)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; add(1, 2)       <span class="comment"># 传递 2 个参数</span></span><br><span class="line">numbers: (1, 2)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; add(1, 2, 3)    <span class="comment"># 传递 3 个参数</span></span><br><span class="line">numbers: (1, 2, 3)</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
<p>上面的 * 表示任意参数，实际上，它还有另外一个用法：用来给函数传递参数。</p>
<p>看看例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def add(x, y, z):        <span class="comment"># 有 3 个必选参数</span></span><br><span class="line">...     <span class="built_in">return</span> x + y + z</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; a = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; add(a[0], a[1], a[2])    <span class="comment"># 这样传递参数很累赘</span></span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; add(*a)                  <span class="comment"># 使用 *a，相当于上面的做法</span></span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; b = (4, 5, 6)</span><br><span class="line">&gt;&gt;&gt; add(*b)                  <span class="comment"># 对元组一样适用</span></span><br><span class="line">15</span><br></pre></td></tr></table></figure>
<p>再看一个例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def add(*numbers):       <span class="comment"># 函数参数是可变参数</span></span><br><span class="line">...     sum = 0</span><br><span class="line">...     <span class="keyword">for</span> i <span class="keyword">in</span> numbers:</span><br><span class="line">...         sum += i</span><br><span class="line">...     <span class="built_in">return</span> sum</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; a = [1, 2]</span><br><span class="line">&gt;&gt;&gt; add(*a)                  <span class="comment"># 使用 *a 给函数传递参数</span></span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; a = [1, 2, 3, 4]</span><br><span class="line">&gt;&gt;&gt; add(*a)</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<h2 id="0x1-2-4关键字参数"><a href="#0x1-2-4关键字参数" class="headerlink" title="0x1.2.4关键字参数"></a>0x1.2.4关键字参数</h2><p>可变参数允许你将不定数量的参数传递给函数，而关键字参数则允许你将不定长度的键值对, 作为参数传递给一个函数。</p>
<p>让我们看看例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def add(**kwargs):</span><br><span class="line">    <span class="built_in">return</span> kwargs</span><br><span class="line">&gt;&gt;&gt; add()            <span class="comment"># 没有参数，kwargs 为空字典</span></span><br><span class="line">&#123;&#125;</span><br><span class="line">&gt;&gt;&gt; add(x=1)         <span class="comment"># x=1 =&gt; kwargs=&#123;'x': 1&#125;</span></span><br><span class="line">&#123;<span class="string">'x'</span>: 1&#125;</span><br><span class="line">&gt;&gt;&gt; add(x=1, y=2)    <span class="comment"># x=1, y=2 =&gt; kwargs=&#123;'y': 2, 'x': 1&#125;</span></span><br><span class="line">&#123;<span class="string">'y'</span>: 2, <span class="string">'x'</span>: 1&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，kwargs 就是一个关键字参数，它前面有两个 <code>*</code> 号。kwargs 可以接收不定长度的键值对，在函数内部，它会表示成一个 dict。</p>
<p>和可变参数类似，我们也可以使用 <code>**kwargs</code> 的形式来调用函数，比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def add(x, y, z):</span><br><span class="line">...     <span class="built_in">return</span> x + y + z</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; dict1 = &#123;<span class="string">'z'</span>: 3, <span class="string">'x'</span>: 1, <span class="string">'y'</span>: 6&#125;</span><br><span class="line">&gt;&gt;&gt; add(dict1[<span class="string">'x'</span>], dict1[<span class="string">'y'</span>], dict1[<span class="string">'z'</span>])    <span class="comment"># 这样传参很累赘</span></span><br><span class="line">10</span><br><span class="line">&gt;&gt;&gt; add(**dict1)        <span class="comment"># 使用 **dict1 来传参，等价于上面的做法</span></span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>再看一个例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def sum(**kwargs):               <span class="comment"># 函数参数是关键字参数</span></span><br><span class="line">...     sum = 0</span><br><span class="line">...     <span class="keyword">for</span> k, v <span class="keyword">in</span> kwargs.items():</span><br><span class="line">...         sum += v</span><br><span class="line">...     <span class="built_in">return</span> sum</span><br><span class="line">&gt;&gt;&gt; sum()                            <span class="comment"># 没有参数</span></span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; dict1 = &#123;<span class="string">'x'</span>: 1&#125;</span><br><span class="line">&gt;&gt;&gt; sum(**dict1)                     <span class="comment"># 相当于 sum(x=1)</span></span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; dict2 = &#123;<span class="string">'x'</span>: 2, <span class="string">'y'</span>: 6&#125; </span><br><span class="line">&gt;&gt;&gt; sum(**dict2)                     <span class="comment"># 相当于 sum(x=2, y=6)</span></span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<h2 id="0x1-2-5参数组合"><a href="#0x1-2-5参数组合" class="headerlink" title="0x1.2.5参数组合"></a>0x1.2.5参数组合</h2><p>在实际的使用中，我们经常会同时用到必选参数、默认参数、可变参数和关键字参数或其中的某些。<br>但是,需要注意的是，<strong>它们在使用的时候是有顺序的，依次是必选参数、默认参数、可变参数和关键字参数。</strong>     </p>
<p>比如，定义一个包含上述四种参数的函数：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def func(x, y, z=0, *args, **kwargs):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">'x ='</span>, x</span><br><span class="line">    <span class="built_in">print</span> <span class="string">'y ='</span>, y</span><br><span class="line">    <span class="built_in">print</span> <span class="string">'z ='</span>, z</span><br><span class="line">    <span class="built_in">print</span> <span class="string">'args ='</span>, args</span><br><span class="line">    <span class="built_in">print</span> <span class="string">'kwargs ='</span>, kwargs</span><br></pre></td></tr></table></figure>
<p>在调用函数的时候，Python 会自动按照参数位置和参数名把对应的参数传进去。让我们看看：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; func(1, 2)                     <span class="comment"># 至少提供两个参数，因为 x, y 是必选参数</span></span><br><span class="line">x = 1</span><br><span class="line">y = 2</span><br><span class="line">z = 0</span><br><span class="line">args = ()</span><br><span class="line">kwargs = &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; func(1, 2, 3)                  <span class="comment"># x=1, y=2, z=3</span></span><br><span class="line">x = 1</span><br><span class="line">y = 2</span><br><span class="line">z = 3</span><br><span class="line">args = ()</span><br><span class="line">kwargs = &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; func(1, 2, 3, 4, 5, 6)         <span class="comment"># x=1, y=2, z=3, args=(4, 5, 6), kwargs=&#123;&#125;</span></span><br><span class="line">x = 1</span><br><span class="line">y = 2</span><br><span class="line">z = 3</span><br><span class="line">args = (4, 5, 6)</span><br><span class="line">kwargs = &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; func(1, 2, 4, u=6, v=7)        <span class="comment"># args = (), kwargs = &#123;'u': 6, 'v': 7&#125;</span></span><br><span class="line">x = 1</span><br><span class="line">y = 2</span><br><span class="line">z = 4</span><br><span class="line">args = ()</span><br><span class="line">kwargs = &#123;<span class="string">'u'</span>: 6, <span class="string">'v'</span>: 7&#125;</span><br><span class="line">&gt;&gt;&gt; func(1, 2, 3, 4, 5, u=6, v=7)   <span class="comment"># args = (4, 5), kwargs = &#123;'u': 6, 'v': 7&#125;</span></span><br><span class="line">x = 1</span><br><span class="line">y = 2</span><br><span class="line">z = 3</span><br><span class="line">args = (4, 5)</span><br><span class="line">kwargs = &#123;<span class="string">'u'</span>: 6, <span class="string">'v'</span>: 7&#125;</span><br></pre></td></tr></table></figure>
<p>我们还可以通过下面的形式来传递参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = (1, 2, 3)</span><br><span class="line">&gt;&gt;&gt; b = &#123;<span class="string">'u'</span>: 6, <span class="string">'v'</span>: 7&#125;</span><br><span class="line">&gt;&gt;&gt; func(*a, **b)</span><br><span class="line">x = 1</span><br><span class="line">y = 2</span><br><span class="line">z = 3</span><br><span class="line">args = ()</span><br><span class="line">kwargs = &#123;<span class="string">'u'</span>: 6, <span class="string">'v'</span>: 7&#125;</span><br></pre></td></tr></table></figure>

<h1 id="0x2内置高阶函数"><a href="#0x2内置高阶函数" class="headerlink" title="0x2内置高阶函数"></a>0x2内置高阶函数</h1><p>在函数式编程中，我们可以将函数当作变量一样自由使用。一个函数接收另一个函数作为参数，这种函数称之为高阶函数（Higher-order Functions）。<br>看一个简单的例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def func(g, arr):</span><br><span class="line">    <span class="built_in">return</span> [g(x) <span class="keyword">for</span> x <span class="keyword">in</span> arr]</span><br></pre></td></tr></table></figure>
<p>上面的代码中，func 是一个高阶函数，它接收两个参数，第 1 个参数是函数，第 2 个参数是数组，func 的功能是将函数 g 逐个作用于数组 arr 上，并返回一个新的数组，比如，我们可以这样用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def double(x):</span><br><span class="line">    <span class="built_in">return</span> 2 * x</span><br><span class="line"></span><br><span class="line">def square(x):</span><br><span class="line">    <span class="built_in">return</span> x * x</span><br><span class="line"></span><br><span class="line">arr1 = func(double, [1, 2, 3, 4])</span><br><span class="line">arr2 = func(square, [1, 2, 3, 4])</span><br></pre></td></tr></table></figure>
<p>不难判断出，arr1 是 [2, 4, 6, 8]，arr2 是 [1, 4, 9, 16]。   </p>
<p>map/reduce/filter 是 Python 中较为常用的内建高阶函数，它们为函数式编程提供了不少便利。<br>注意在 python2 和 python3 中，map/reduce/filter 的返回值类型有所不同，<br><strong>python2 返回的是基本数据类型，而 python3 则返回了迭代器；</strong>     </p>
<h2 id="0x2-1-map"><a href="#0x2-1-map" class="headerlink" title="0x2.1 map"></a>0x2.1 map</h2><p>map 函数的使用形式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map(<span class="keyword">function</span>, sequence)</span><br></pre></td></tr></table></figure>
<p>解释：对 <code>sequence</code> 中的 <code>item</code> 依次执行 <code>function(item)</code>，并将结果组成一个 <code>List</code> 返回，也就是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">function</span>(item1), <span class="keyword">function</span>(item2), <span class="keyword">function</span>(item3), ...]</span><br></pre></td></tr></table></figure>

<p>看一些简单的例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def square(x):</span><br><span class="line">...     <span class="built_in">return</span> x * x</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; map(square, [1, 2, 3, 4])</span><br><span class="line">[1, 4, 9, 16]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; map(lambda x: x * x, [1, 2, 3, 4])   <span class="comment"># 使用 lambda</span></span><br><span class="line">[1, 4, 9, 16]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; map(str, [1, 2, 3, 4])</span><br><span class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; map(int, [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>])</span><br><span class="line">[1, 2, 3, 4]</span><br></pre></td></tr></table></figure>
<p>再看一个例子：    </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def double(x):</span><br><span class="line">    <span class="built_in">return</span> 2 * x</span><br><span class="line">def triple(x):</span><br><span class="line">    <span class="built_in">return</span> 3 *x</span><br><span class="line">def square(x):</span><br><span class="line">    <span class="built_in">return</span> x * x</span><br><span class="line">funcs = [double, triple, square]  <span class="comment"># 列表元素是函数对象</span></span><br><span class="line"><span class="comment"># 相当于 [double(4), triple(4), square(4)]</span></span><br><span class="line">value = list(map(lambda f: f(4), funcs))</span><br><span class="line"><span class="built_in">print</span>(value)</span><br></pre></td></tr></table></figure>
<h2 id="0x2-2reduce"><a href="#0x2-2reduce" class="headerlink" title="0x2.2reduce"></a>0x2.2reduce</h2><p>reduce 函数的使用形式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduce(<span class="keyword">function</span>, sequence[, initial])</span><br></pre></td></tr></table></figure>
<p>解释：先将 sequence 的前两个 item 传给 function，即 function(item1, item2)，函数的返回值和 sequence 的下一个 item 再传给 function，即 function(function(item1, item2), item3)，如此迭代，直到 sequence 没有元素，如果有 initial，则作为初始值调用。</p>
<p>也就是说：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduece(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</span><br></pre></td></tr></table></figure>
<p>看一些例子，就能很快理解了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; reduce(lambda x, y: x * y, [1, 2, 3, 4])  <span class="comment"># 相当于 ((1 * 2) * 3) * 4</span></span><br><span class="line">24</span><br><span class="line">&gt;&gt;&gt; reduce(lambda x, y: x * y, [1, 2, 3, 4], 5) <span class="comment"># ((((5 * 1) * 2) * 3)) * 4</span></span><br><span class="line">120</span><br><span class="line">&gt;&gt;&gt; reduce(lambda x, y: x / y, [2, 3, 4], 72)  <span class="comment">#  (((72 / 2) / 3)) / 4</span></span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; reduce(lambda x, y: x + y, [1, 2, 3, 4], 5)  <span class="comment"># ((((5 + 1) + 2) + 3)) + 4</span></span><br><span class="line">15</span><br><span class="line">&gt;&gt;&gt; reduce(lambda x, y: x - y, [8, 5, 1], 20)  <span class="comment"># ((20 - 8) - 5) - 1</span></span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; f = lambda a, b: a <span class="keyword">if</span> (a &gt; b) <span class="keyword">else</span> b   <span class="comment"># 两两比较，取最大值</span></span><br><span class="line">&gt;&gt;&gt; reduce(f, [5, 8, 1, 10])</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<h2 id="0x2-3filter"><a href="#0x2-3filter" class="headerlink" title="0x2.3filter"></a>0x2.3filter</h2><p>filter 函数用于过滤元素，它的使用形式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter(<span class="keyword">function</span>, sequnce)</span><br></pre></td></tr></table></figure>
<p>解释：将 function 依次作用于 sequnce 的每个 item，即 function(item)，将返回值为 True 的 item 组成一个 List/String/Tuple (取决于 sequnce 的类型，python3 统一返回迭代器) 返回。</p>
<p>看一些例子。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; even_num = list(filter(lambda x: x % 2 == 0, [1, 2, 3, 4, 5, 6]))</span><br><span class="line">&gt;&gt;&gt; even_num</span><br><span class="line">[2, 4, 6]</span><br><span class="line">&gt;&gt;&gt; odd_num = list(filter(lambda x: x % 2, [1, 2, 3, 4, 5, 6]))</span><br><span class="line">&gt;&gt;&gt; odd_num</span><br><span class="line">[1, 3, 5]</span><br><span class="line">&gt;&gt;&gt; filter(lambda x: x &lt; <span class="string">'g'</span>, <span class="string">'hijack'</span>)</span><br><span class="line"><span class="string">'ac'</span>        <span class="comment"># python2</span></span><br><span class="line">&gt;&gt;&gt; filter(lambda x: x &lt; <span class="string">'g'</span>, <span class="string">'hijack'</span>)</span><br><span class="line">&lt;filter object at 0x1034b4080&gt;   <span class="comment"># python3</span></span><br></pre></td></tr></table></figure>
<h2 id="0x2-4sorted"><a href="#0x2-4sorted" class="headerlink" title="0x2.4sorted"></a>0x2.4sorted</h2><p>sorted() 也是一个高阶函数，接收一个函数来实现自定义的排序。</p>
<p>例如按绝对值排序代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(sorted([-34,5,-2,43],key=abs))</span><br><span class="line">``` </span><br><span class="line"><span class="comment"># 0x3匿名函数  </span></span><br><span class="line"></span><br><span class="line">在 Python 中，我们使用 def 语句来定义函数，比如：</span><br><span class="line">```bash</span><br><span class="line">def double(x):</span><br><span class="line">    <span class="built_in">return</span> 2 * x</span><br></pre></td></tr></table></figure>
<p>除了用上面的方式定义函数，Python 还提供了一个关键字 lambda，让我们可以创建一个匿名函数，也就是没有名称的函数。它的形式如下：</p>
<p>lambda 参数: 表达式<br>关键字 lambda 说明它是一个匿名函数，冒号 : 前面的变量是该匿名函数的参数，冒号后面是函数的返回值，注意这里不需使用 return 关键字。</p>
<p>我们将上面的 double 函数改写成一个匿名函数，如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lambda x: 2 * x</span><br></pre></td></tr></table></figure>
<p>那怎么调用匿名函数呢？可以直接这样使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; (lambda x: 2 * x)(8)</span><br><span class="line">16</span><br></pre></td></tr></table></figure>
<p>由于匿名函数本质上是一个函数对象，也可以将其赋值给另一个变量，再由该变量来调用函数，如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = lambda x: 2 * x   <span class="comment"># 将匿名函数赋给变量 f  </span></span><br><span class="line">&gt;&gt;&gt; f</span><br><span class="line">&lt;<span class="keyword">function</span> &lt;lambda&gt; at 0x7f835a696578&gt;</span><br><span class="line">&gt;&gt;&gt; f(8)</span><br><span class="line">16</span><br></pre></td></tr></table></figure>

<p>使用场景<br>lambda 函数一般适用于创建一些临时性的，小巧的函数。比如上面的 double 函数，我们当然可以使用 def 来定义，但使用 lambda 来创建会显得很简洁，尤其是在高阶函数的使用中。</p>
<p>看一个例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def func(g, arr):</span><br><span class="line">    <span class="built_in">return</span> [g(x) <span class="keyword">for</span> x <span class="keyword">in</span> arr]</span><br></pre></td></tr></table></figure>
<p>现在给一个列表 [1, 2, 3, 4]，利用上面的函数，对列表中的元素加 1，返回一个新的列表，你可能这样用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def add_one(x):</span><br><span class="line">    <span class="built_in">return</span> x + 1</span><br><span class="line"></span><br><span class="line">arr = func(add_one, [1, 2, 3, 4])</span><br></pre></td></tr></table></figure>
<p>这样做没什么错，可是 add_one 这个函数太简单了，使用 def 定义未免有点小题大作，我们改用 lambda：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr = func(lambda x: x + 1, [1, 2, 3, 4])</span><br></pre></td></tr></table></figure>
<p>是不是很简洁、易懂？        </p>
<h1 id="0x4闭包"><a href="#0x4闭包" class="headerlink" title="0x4闭包"></a>0x4闭包</h1><p>闭包的一些注意点:  </p>
<ul>
<li>闭包是携带自由变量的函数，即使创建闭包的外部函数的生命周期结束了，闭包所引用的自由变量仍会存在。</li>
<li>闭包在运行可以有多个实例。</li>
<li>尽量不要在闭包中引用循环变量，或者后续会发生变化的变量。</li>
</ul>
<h2 id="0x4-1闭包理解"><a href="#0x4-1闭包理解" class="headerlink" title="0x4.1闭包理解"></a>0x4.1闭包理解</h2><p>在 Python 中，函数也是一个对象。因此，我们在定义函数时，可以再嵌套定义一个函数，并将该嵌套函数返回，比如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from math import pow</span><br><span class="line"></span><br><span class="line">def make_pow(n):</span><br><span class="line">    def inner_func(x):     <span class="comment"># 嵌套定义了 inner_func</span></span><br><span class="line">        <span class="built_in">return</span> pow(x, n)   <span class="comment"># 注意这里引用了外部函数的 n</span></span><br><span class="line">    <span class="built_in">return</span> inner_func      <span class="comment"># 返回 inner_func</span></span><br></pre></td></tr></table></figure>
<p>上面的代码中，函数 make_pow 里面又定义了一个内部函数 inner_func，然后将该函数返回。因此，我们可以使用 make_pow 来生成另一个函数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; pow2 = make_pow(2)  <span class="comment"># pow2 是一个函数，参数 2 是一个自由变量</span></span><br><span class="line">&gt;&gt;&gt; pow2</span><br><span class="line">&lt;<span class="keyword">function</span> inner_func at 0x10271faa0&gt;</span><br><span class="line">&gt;&gt;&gt; pow2(6)</span><br><span class="line">36.0</span><br></pre></td></tr></table></figure>
<p>我们还注意到，内部函数 inner_func 引用了外部函数 make_pow 的自由变量 n，这也就意味着，当函数 make_pow 的生命周期结束之后，n 这个变量依然会保存在 inner_func 中，它被 inner_func 所引用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; del make_pow         <span class="comment"># 删除 make_pow</span></span><br><span class="line">&gt;&gt;&gt; pow3 = make_pow(3)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line 1, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: name <span class="string">'make_pow'</span> is not defined</span><br><span class="line">&gt;&gt;&gt; pow2(9)     <span class="comment"># pow2 仍可正常调用，自由变量 2 仍保存在 pow2 中</span></span><br><span class="line">81.0</span><br></pre></td></tr></table></figure>
<p>像上面这种情况，一个函数返回了一个内部函数，该内部函数引用了外部函数的相关参数和变量，我们把该返回的内部函数称为闭包（Closure）。</p>
<p>在上面的例子中，inner_func 就是一个闭包，它引用了自由变量 n。</p>
<h2 id="0x4-2闭包的作用"><a href="#0x4-2闭包的作用" class="headerlink" title="0x4.2闭包的作用"></a>0x4.2闭包的作用</h2><ul>
<li>闭包的最大特点就是引用了自由变量，即使生成闭包的环境已经释放，闭包仍然存在。</li>
<li>闭包在运行时可以有多个实例，即使传入的参数相同。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; pow_a = make_pow(2)</span><br><span class="line">&gt;&gt;&gt; pow_b = make_pow(2)</span><br><span class="line">&gt;&gt;&gt; pow_a == pow_b</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>利用闭包，我们还可以模拟类的实例。<br>这里构造一个类，用于求一个点到另一个点的距离：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from math import sqrt</span><br><span class="line"></span><br><span class="line">class Point(object):</span><br><span class="line">    def __init__(self, x, y):</span><br><span class="line">        self.x, self.y = x, y</span><br><span class="line"></span><br><span class="line">    def get_distance(self, u, v):</span><br><span class="line">        distance = sqrt((self.x - u) ** 2 + (self.y - v) ** 2)</span><br><span class="line">        <span class="built_in">return</span> distance</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; pt = Point(7, 2)        <span class="comment"># 创建一个点</span></span><br><span class="line">&gt;&gt;&gt; pt.get_distance(10, 6)  <span class="comment"># 求到另一个点的距离</span></span><br><span class="line">5.0</span><br></pre></td></tr></table></figure>
<p>用闭包来实现：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def point(x, y):</span><br><span class="line">    def get_distance(u, v):</span><br><span class="line">        <span class="built_in">return</span> sqrt((x - u) ** 2 + (y - v) ** 2)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> get_distance</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; pt = point(7, 2)</span><br><span class="line">&gt;&gt;&gt; pt(10, 6)</span><br><span class="line">5.0</span><br></pre></td></tr></table></figure>
<p>可以看到，结果是一样的，但使用闭包实现比使用类更加简洁。</p>
<h2 id="0x4-3闭包的误区"><a href="#0x4-3闭包的误区" class="headerlink" title="0x4.3闭包的误区"></a>0x4.3闭包的误区</h2><p>闭包的概念很简单，但实现起来却容易出现一些误区，比如下面的例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def count():</span><br><span class="line">    funcs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> [1, 2, 3]:</span><br><span class="line">        def f():</span><br><span class="line">            <span class="built_in">return</span> i</span><br><span class="line">        funcs.append(f)</span><br><span class="line">    <span class="built_in">return</span> funcs</span><br></pre></td></tr></table></figure>
<p>在该例子中，我们在每次 for 循环中创建了一个函数，并将它存到 funcs 中。现在，调用上面的函数，你可能认为返回结果是 1, 2, 3，事实上却不是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f1, f2, f3 = count()</span><br><span class="line">&gt;&gt;&gt; f1()</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; f2()</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; f3()</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p>为什么呢？原因在于上面的函数 f 引用了变量 i，但函数 f 并非立刻执行，当 for 循环结束时，此时变量 i 的值是3，funcs 里面的函数引用的变量都是 3，最终结果也就全为 3。</p>
<p>因此，我们应尽量避免在闭包中引用循环变量，或者后续会发生变化的变量。</p>
<p>那上面这种情况应该怎么解决呢？我们可以再创建一个函数，并将循环变量的值传给该函数，如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def count():</span><br><span class="line">    funcs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> [1, 2, 3]:</span><br><span class="line">        def g(param):</span><br><span class="line">            f = lambda : param    <span class="comment"># 这里创建了一个匿名函数</span></span><br><span class="line">            <span class="built_in">return</span> f</span><br><span class="line">        funcs.append(g(i))        <span class="comment"># 将循环变量的值传给 g</span></span><br><span class="line">    <span class="built_in">return</span> funcs</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; f1, f2, f3 = count()</span><br><span class="line">&gt;&gt;&gt; f1()</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; f2()</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; f3()</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h1 id="0x5偏函数-partial"><a href="#0x5偏函数-partial" class="headerlink" title="0x5偏函数(partial)"></a>0x5偏函数(partial)</h1><ul>
<li><p>partial() 接受参数 (function, arg1, arg2, …, kwarg1=value1,<br>kwarg2=value2)。</p>
</li>
<li><p>partial 的功能：固定函数参数，返回一个新的函数。</p>
</li>
<li><p>当函数参数太多，需要固定某些参数时，可以使用 functools.partial 创建一个新的函数。</p>
</li>
</ul>
<p>Python 提供了一个 functools 的模块，该模块为高阶函数提供支持，partial 就是其中的一个函数，该函数的形式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">functools.partial(func[,*args][, **kwargs])</span><br></pre></td></tr></table></figure>
<p>这里先举个例子，看看它是怎么用的。</p>
<p>假设有如下函数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def multiply(x, y):</span><br><span class="line">    <span class="built_in">return</span> x * y</span><br></pre></td></tr></table></figure>
<p>现在，我们想返回某个数的双倍，即：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; multiply(3, y=2)</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; multiply(4, y=2)</span><br><span class="line">8</span><br><span class="line">&gt;&gt;&gt; multiply(5, y=2)</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>上面的调用有点繁琐，每次都要传入 y=2，我们想到可以定义一个新的函数，把 y=2 作为默认值，即：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def double(x, y=2):</span><br><span class="line">    <span class="built_in">return</span> multiply(x, y)</span><br></pre></td></tr></table></figure>
<p>现在，我们可以这样调用了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; double(3)</span><br><span class="line">6</span><br><span class="line">&gt;&gt;&gt; double(4)</span><br><span class="line">8</span><br><span class="line">&gt;&gt;&gt; double(5)</span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>事实上，我们可以不用自己定义 double，利用 partial，我们可以这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from functools import partial</span><br><span class="line"></span><br><span class="line">double = partial(multiply, y=2)</span><br></pre></td></tr></table></figure>
<p>partial 接收函数 multiply 作为参数，固定 multiply 的参数 y=2，并返回一个新的函数给 double，这跟我们自己定义 double 函数的效果是一样的。</p>
<p>所以，简单而言，partial 函数的功能就是：把一个函数的某些参数给固定住，返回一个新的函数。</p>
<p>需要注意的是，我们上面是固定了 multiply 的关键字参数 y=2，如果直接使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double = partial(multiply, 2)</span><br></pre></td></tr></table></figure>
<p>则 2 是赋给了 multiply 最左边的参数 x，不信？我们可以验证一下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from functools import partial</span><br><span class="line"></span><br><span class="line">def subtraction(x, y):</span><br><span class="line">    <span class="built_in">return</span> x - y</span><br><span class="line"></span><br><span class="line">f = partial(subtraction, 4)  <span class="comment"># 4 赋给了 x</span></span><br><span class="line">&gt;&gt;&gt; f(10)   <span class="comment"># 4 - 10</span></span><br><span class="line">-6</span><br></pre></td></tr></table></figure>

<h1 id="0x6装饰器"><a href="#0x6装饰器" class="headerlink" title="0x6装饰器"></a>0x6装饰器</h1><p>详细可看:<a href="http://funhacks.net/explore-python/Functional/decorator.html" target="_blank" rel="noopener">http://funhacks.net/explore-python/Functional/decorator.html</a></p>
<br>
<br>
<br>
<br>
<br>

<p>参考文章:<br>函数编程: <a href="http://funhacks.net/explore-python/Function/" target="_blank" rel="noopener">http://funhacks.net/explore-python/Function/</a></p>
</div><div class="post-copyright"><div class="post-copyright-author"><span class="post-copyright-meta">本文作者: </span><span class="post-copyright-info"><a href="mailto:undefined">ye1s</a></span></div><div class="post-copyright-type"><span class="post-copyright-meta">本文链接: </span><span class="post-copyright-info"><a href="https://blog.cfyqy.com/article/5e2ba329.html">https://blog.cfyqy.com/article/5e2ba329.html</a></span></div><div class="post-copyright-notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.cfyqy.com">ye1s</a>！</span></div></div><div class="post-copyright" id="comments-container"><script src="/js/comments/gitment.js"></script></div><script>let arr = location.href.split('/#more')[0].split('/');
let title = arr[arr.length - 1];
if (title === '') {
    title = arr[arr.length - 2]
}
var flag = false;
var gitFun = function () {
    try {
        var gitmentObj = window.GLOBAL_CONFIG.gitment;
        var gitment = new Gitment({
            id: decodeURI(title), // 可选。默认为 location.href
            owner: gitmentObj.owner,
            repo: gitmentObj.repo,
            oauth: {
                client_id: gitmentObj.client_id,
                client_secret: gitmentObj.client_secret
            },
        });
        gitment.render('comments-container');
        flag = true;
    } catch (e) {
        flag = false;
    }
}
var setIn = setInterval(() => {
    if (!flag) {
        gitFun();
    } else {
        clearInterval(setIn);
    }
}, 200);</script></article><div id="pagination"><div class="prev-post pull-left"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/article/c616b095.html"><i class="fas fa-angle-left">&nbsp;</i><span>python的上下文管理器</span></a></div><div class="next-post pull-right"><span class="line line-top"></span><span class="line line-right"></span><span class="line line-bottom"></span><span class="line line-left"></span><a href="/article/cf5605e2.html"><span>python的元编程</span><span>&nbsp;</span><i class="fas fa-angle-right"></i></a></div></div><!--div!= paginator()--></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fas fa-file-o"></i></span><span id="busuanzi_value_page_pv"></span><span></span></div><div class="copyright">&copy;2017 ～ 2021 By ye1s</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/daovoice.js"></script><!--script(src=url)--><div class="search-dialog"><div id="algolia-search-title">Algolia</div><div class="search-close-button"><i class="fa fa-times"></i></div><!--div#current-refined-values--><!--div#clear-all--><div id="search-box"></div><!--div#refinement-list--><hr><div id="hits"></div><div id="algolia-pagination"></div></div><div class="search-mask"></div><script src="/js/search/algolia.js"></script></body></html>