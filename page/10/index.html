<!DOCTYPE html><html><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords"><meta name="author" content="ye1s,undefined"><meta name="copyright" content="ye1s"><title>【ye1s】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch-theme-algolia.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4"></script><!-- link(rel="dns-prefetch" href="https://cdn.jsdelivr.net")--><!-- link(rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css")--><!-- script(src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer)--><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"LKL6Q0GQJM","apiKey":"03829f64e2f5c11e4a5e2b8e51e24eb9","indexName":"blog","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  gitment: {"owner":"ye1sec","repo":"comments","client_id":"d5ece338867af32b6dfa","client_secret":"2caf36bbd47977524017f95105315fc9e65f0577"},
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="ye1s" type="application/atom+xml">
</head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="author-info"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">ye1s</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/ye1sec" target="_blank">GitHub<i class="icon-dot bg-color4"></i></a><a class="links-button button-hover" href="mailto:431774437@qq.com" target="_blank">E-Mail<i class="icon-dot bg-color8"></i></a><a class="links-button button-hover" href="tencent://message/?uin=431774437&amp;Site=&amp;Menu=yes" target="_blank">QQ<i class="icon-dot bg-color3"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">177</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">151</span></a><a class="author-info-articles-categories article-meta" href="/categories"><span class="pull-top">分类</span><span class="pull-bottom">12</span></a></div><div class="friend-link"><a class="friend-link-text" href="http://www.m00nback.xyz/" target="_blank">MoonBack</a><a class="friend-link-text" target="_blank">待定</a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="search social-icon"><i class="fas fa-search"></i><span> 搜索</span></a><a class="title-name" href="/">ye1s</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><div id="recent-posts"><!-- each post in page.posts.sort('date', -1).limit(10).toArray()--><!-- config中配置按照什么排序--><div class="recent-post-item"><a class="post-title" href="/article/f92eff5d.html">回溯</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-13</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/">编程算法</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E5%9B%9E%E6%BA%AF/">回溯</a></div></div><div class="post-content"><div class="main-content content"><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>  回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</p>
<p>   回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p>
<p>  许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。</p>
<h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><p>   在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。</p>
<p>   若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。</p>
<p>而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。</p>
<h1 id="一般步骤："><a href="#一般步骤：" class="headerlink" title="一般步骤："></a>一般步骤：</h1><p>（1）针对所给问题，确定问题的解空间：</p>
<p>   首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。</p>
<p>（2）确定结点的扩展搜索规则</p>
<p>（3）以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。</p>
<h1 id="算法框架"><a href="#算法框架" class="headerlink" title="算法框架"></a>算法框架</h1><p>递归</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int a[n];</span><br><span class="line">try(int i)</span><br><span class="line">&#123;</span><br><span class="line">   if(i&gt;n)</span><br><span class="line">      输出结果;</span><br><span class="line">    else</span><br><span class="line">   &#123;</span><br><span class="line">      for(j &#x3D; 下界; j &lt;&#x3D; 上界; j&#x3D;j+1)  &#x2F;&#x2F; 枚举i所有可能的路径</span><br><span class="line">      &#123;</span><br><span class="line">         if(fun(j))                 &#x2F;&#x2F; 满足限界函数和约束条件</span><br><span class="line">           &#123;</span><br><span class="line">              a[i] &#x3D; j;</span><br><span class="line">           ...                         &#x2F;&#x2F; 其他操作</span><br><span class="line">             try(i+1);</span><br><span class="line">          回溯前的清理工作（如a[i]置空值等）;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非递归</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int a[n],i;</span><br><span class="line">初始化数组a[];</span><br><span class="line">i &#x3D; 1;</span><br><span class="line">while (i&gt;0(有路可走)   and  (未达到目标))  &#x2F;&#x2F; 还未回溯到头</span><br><span class="line">&#123;</span><br><span class="line">   if(i &gt; n)                                              &#x2F;&#x2F; 搜索到叶结点</span><br><span class="line">  &#123;   </span><br><span class="line">        搜索到一个解，输出；</span><br><span class="line">   &#125;</span><br><span class="line">   else                                                   &#x2F;&#x2F; 处理第i个元素</span><br><span class="line">   &#123; </span><br><span class="line">       a[i]第一个可能的值；</span><br><span class="line">        while(a[i]在不满足约束条件且在搜索空间内)</span><br><span class="line">       &#123;</span><br><span class="line">          a[i]下一个可能的值；</span><br><span class="line">       &#125;</span><br><span class="line">      if(a[i]在搜索空间内)</span><br><span class="line">      &#123;</span><br><span class="line">          标识占用的资源；</span><br><span class="line">          i &#x3D; i+1;                              &#x2F;&#x2F; 扩展下一个结点</span><br><span class="line">      &#125;</span><br><span class="line">      else </span><br><span class="line">      &#123;</span><br><span class="line">           清理所占的状态空间；            &#x2F;&#x2F; 回溯</span><br><span class="line">           i &#x3D; i –1; </span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="子集树与排列树"><a href="#子集树与排列树" class="headerlink" title="子集树与排列树"></a>子集树与排列树</h1><p>下面的两棵解空间树是回溯法解题时常遇到的两类典型的解空间树。</p>
<p>(1)当所给问题是从n个元素的集合S中找出S满足某种性质的子集时，相应的解空间树称为子集树。例如从n个物品的0-1背包问题(如下图)所相应的解空间树是一棵子集树，这类子集树通常有2^n个叶结点，其结点总个数为2^(n+1)-1。遍历子集树的算法需Ω(2^n)计算时间。</p>
<p><img src="../../images/arithmetic/20160619182945120.png" alt=""></p>
<p>用回溯法搜索子集树的一般算法可描述为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * output(x)     记录或输出得到的可行解x</span></span><br><span class="line"><span class="comment"> * constraint(t) 当前结点的约束函数</span></span><br><span class="line"><span class="comment"> * bount(t)      当前结点的限界函数</span></span><br><span class="line"><span class="comment"> * @param t  t为当前解空间的层数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t &gt;= n)</span><br><span class="line">		output(x);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; i++) &#123;</span><br><span class="line">			x[t] = i;</span><br><span class="line">			<span class="keyword">if</span>(constraint(t) &amp;&amp; bount(t))</span><br><span class="line">				backtrack(t+<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>(2)当所给问题是确定n个元素满足某种性质的排列时，相应的解空间树称为排列树。例如旅行售货员问题(如下图)的解空间树是一棵排列树，这类排列树通常有n!个叶结点。遍历子集树的算法需Ω(n!)计算时间。<br><img src="../../images/arithmetic/20160619183051325.png" alt=""></p>
<p>用回溯法搜索排列树的一般算法可描述为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * output(x)     记录或输出得到的可行解x</span></span><br><span class="line"><span class="comment"> * constraint(t) 当前结点的约束函数</span></span><br><span class="line"><span class="comment"> * bount(t)      当前结点的限界函数</span></span><br><span class="line"><span class="comment"> * @param t  t为当前解空间的层数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(t &gt;= n)</span><br><span class="line">		output(x);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = t; i &lt;= n; i++) &#123;</span><br><span class="line">			swap(x[t], x[i]);</span><br><span class="line">			<span class="keyword">if</span>(constraint(t) &amp;&amp; bount(t))</span><br><span class="line">				backtrack(t+<span class="number">1</span>);</span><br><span class="line">			swap(x[t], x[i]);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><ol>
<li>数字键盘组合</li>
<li>IP 地址划分</li>
<li>在矩阵中寻找字符串</li>
<li>输出二叉树中所有从根到叶子的路径</li>
<li>排列</li>
<li>含有相同元素求排列</li>
<li>组合</li>
<li>组合求和</li>
<li>含有相同元素的组合求和</li>
<li>1-9 数字的组合求和</li>
<li>子集</li>
<li>含有相同元素求子集</li>
<li>分割字符串使得每个部分都是回文数</li>
<li>数独</li>
<li>N 皇后</li>
</ol>
<p><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%90%9C%E7%B4%A2.md#backtracking" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%90%9C%E7%B4%A2.md#backtracking</a></p>
<p>参考文章</p>
<p><a href="https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741376.html" target="_blank" rel="noopener">五大常用算法之四：回溯法</a><br><a href="https://blog.csdn.net/why_still_confused/article/details/51713415" target="_blank" rel="noopener">回溯法的解题步骤与例子解析</a></p>
</div></div><a class="button-hover more" href="/article/f92eff5d.html#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/article/7f3bcd7f.html">分治法</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-13</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/">编程算法</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E5%88%86%E6%B2%BB/">分治</a></div></div><div class="post-content"><div class="main-content content"><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>在计算机科学中，分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……</p>
<h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><p>   分治法的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。</p>
<p>   分治策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。</p>
<p>   如果原问题可分割成k个子问题，1&lt;k≤n，且这些子问题都可解并可利用这些子问题的解求出原问题的解，那么这种分治法就是可行的。由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。</p>
<h1 id="适用情况"><a href="#适用情况" class="headerlink" title="适用情况"></a>适用情况</h1><p>分治法所能解决的问题一般具有以下几个特征：</p>
<p>1) 该问题的规模缩小到一定的程度就可以容易地解决</p>
<p>2) 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。</p>
<p>3) 利用该问题分解出的子问题的解可以合并为该问题的解；</p>
<p>4) 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。</p>
<p>第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；</p>
<p>第二条特征是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用；、</p>
<p>第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。</p>
<p>第四条特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。</p>
<h1 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h1><p>分治法在每一层递归上都有三个步骤：</p>
<p>step1 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；</p>
<p>step2 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题</p>
<p>step3 合并：将各个子问题的解合并为原问题的解。</p>
<p>它的一般的算法设计模式如下：</p>
<p> Divide-and-Conquer(P)</p>
<ol>
<li><p>if |P|≤n0</p>
</li>
<li><p>then return(ADHOC(P))</p>
</li>
<li><p>将P分解为较小的子问题 P1 ,P2 ,…,Pk</p>
</li>
<li><p>for i←1 to k</p>
</li>
<li><p>do yi ← Divide-and-Conquer(Pi) △ 递归解决Pi</p>
</li>
<li><p>T ← MERGE(y1,y2,…,yk) △ 合并子问题</p>
</li>
<li><p>return(T)</p>
</li>
</ol>
<p>其中|P|表示问题P的规模；n0为一阈值，表示当问题P的规模不超过n0时，问题已容易直接解出，不必再继续分解。ADHOC(P)是该分治法中的基本子算法，用于直接解小规模的问题P。因此，当P的规模不超过n0时直接用算法ADHOC(P)求解。算法MERGE(y1,y2,…,yk)是该分治法中的合并子算法，用于将P的子问题P1 ,P2 ,…,Pk的相应的解y1,y2,…,yk合并为P的解。</p>
<h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><p>一个分治法将规模为n的问题分成k个规模为n／m的子问题去解。设分解阀值n0=1，且adhoc解规模为1的问题耗费1个单位时间。再设将原问题分解为k个子问题以及用merge将k个子问题的解合并为原问题的解需用f(n)个单位时间。用T(n)表示该分治法解规模为|P|=n的问题所需的计算时间，则有：</p>
<p> T（n）= k T(n/m)+f(n)</p>
<p>通过迭代法求得方程的解：</p>
<p>递归方程及其解只给出n等于m的方幂时T(n)的值，但是如果认为T(n)足够平滑，那么由n等于m的方幂时T(n)的值可以估计T(n)的增长速度。通常假定T(n)是单调上升的，从而当                  mi≤n&lt;mi+1时，T(mi)≤T(n)&lt;T(mi+1)。</p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>（1）二分搜索<br>（2）大整数乘法<br> （3）Strassen矩阵乘法<br>（4）棋盘覆盖<br>（5）合并排序<br>（6）快速排序<br>（7）线性时间选择<br>（8）最接近点对问题<br>（9）循环赛日程表<br>（10）汉诺塔   </p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><ol>
<li>给表达式加括号</li>
<li>不同的二叉搜索树   </li>
</ol>
<p><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%88%86%E6%B2%BB.md" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%88%86%E6%B2%BB.md</a></p>
<p>参考文章:</p>
<p><a href="https://blog.csdn.net/effective_coder/article/details/8697789" target="_blank" rel="noopener">分治法详解</a></p>
</div></div><a class="button-hover more" href="/article/7f3bcd7f.html#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/article/649c2087.html">二分法</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-13</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/">编程算法</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E4%BA%8C%E5%88%86%E6%B3%95/">二分法</a></div></div><div class="post-content"><div class="main-content content"><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>二分法查找，也称为折半法，是一种在有序数组中查找特定元素的搜索算法。</p>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>二分法查找的思路如下：</p>
<p>（1）首先，从数组的中间元素开始搜索，如果该元素正好是目标元素，则搜索过程结束，否则执行下一步。</p>
<p>（2）如果目标元素大于/小于中间元素，则在数组大于/小于中间元素的那一半区域查找，然后重复步骤（1）的操作。</p>
<p>（3）如果某一步数组为空，则表示找不到目标元素。</p>
<p>二分法查找的时间复杂度O(logn)。</p>
<h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><p>非递归方法:</p>
<h1 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h1><p><a href="https://blog.csdn.net/chaoyue1216/article/details/7556241" target="_blank" rel="noopener">二分查找，要注意的地方</a></p>
<p>闭区间 <code>[L,R]</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> <span class="built_in">size</span>,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> R = <span class="built_in">size</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(L &lt;= R)        <span class="comment">//查找区间，以两个数据为例子，L,R 都完成比较</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = L + (R - L)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(p == a[mid])</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p &gt; a[mid])&#123;</span><br><span class="line">            L = mid +<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>左闭右开 <code>[L,R)</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> <span class="built_in">size</span>,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> R = <span class="built_in">size</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(L &lt; R)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = L + (R -L)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(p == a[mid])</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p &lt; a[mid])&#123;</span><br><span class="line">            R = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            L = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>左开右开 <code>(L ,R)</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> <span class="built_in">size</span>,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> R = <span class="built_in">size</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(R-L &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = L + (R-L)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid] == p)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p &lt; a[mid])&#123;</span><br><span class="line">            R = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            L = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><ol>
<li>求开方</li>
<li>大于给定元素的最小元素</li>
<li>有序数组的 Single Element</li>
<li>第一个错误的版本</li>
<li>旋转数组的最小数字</li>
<li>查找区间</li>
</ol>
<p><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.md" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.md</a>    </p>
<p>参考文章:</p>
<p><a href="https://blog.csdn.net/u012194956/article/details/79103843" target="_blank" rel="noopener">算法-二分查找</a></p>
<p><a href="https://blog.csdn.net/chaoyue1216/article/details/7556241" target="_blank" rel="noopener">二分查找，要注意的地方</a></p>
</div></div><a class="button-hover more" href="/article/649c2087.html#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/article/528f01d9.html">two指针</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-13</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/">编程算法</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/two%E6%8C%87%E9%92%88/">two指针</a></div></div><div class="post-content"><div class="main-content content"><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>双指针，顾名思义，就是利用两个指针去遍历数组，一般来说，遍历数组采用的是单指针（index）去遍历，两个指针一般是在有序数组中使用，一个放首，一个放尾，同时向中间遍历，直到两个指针相交，完成遍历，时间复杂度也是O(n)。</p>
<p>使用场景</p>
<ul>
<li>时间复杂度：O(n) 并且 One Pass</li>
<li>空间要求：in place</li>
<li>两数之和满足某条件<ul>
<li>先对数组排序，再采用两个指针，分别从前和后往中间遍历，front增大，tail减小，通过对条件的判断，可以在O(n)内遍历，而非使用双重循环。</li>
</ul>
</li>
<li>in place交换<ul>
<li>一个指针正常遍历，另一个指针去找可以用来交换的元素。</li>
</ul>
</li>
</ul>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><ol>
<li>有序数组的 Two Sum</li>
<li>两数平方和</li>
<li>反转字符串中的元音字符</li>
<li>回文字符串</li>
<li>归并两个有序数组</li>
<li>判断链表是否存在环</li>
<li>最长子序列</li>
</ol>
<p><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8F%8C%E6%8C%87%E9%92%88.md" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8F%8C%E6%8C%87%E9%92%88.md</a> </p>
<p>参考文章:</p>
<p><a href="https://linzhenglearn.github.io/2017/03/29/TwoPointer/" target="_blank" rel="noopener">算法之双指针</a></p>
</div></div><a class="button-hover more" href="/article/528f01d9.html#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/article/73952078.html">贪心思想</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-13</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/">编程算法</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E8%B4%AA%E5%BF%83%E6%80%9D%E6%83%B3/">贪心思想</a></div></div><div class="post-content"><div class="main-content content"><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。</p>
<p>贪婪算法所得到的结果往往不是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果。</p>
<ul>
<li>贪婪算法并没有固定的算法解决框架，算法的关键是贪婪策略的选择，根据不同的问题选择不同的策略。</li>
</ul>
<p>必须注意的是策略的选择必须具备无后效性，即某个状态的选择不会影响到之前的状态，只与当前状态有关，所以对采用的贪婪的策略一定要仔细分析其是否满足无后效性</p>
<h1 id="基本思路："><a href="#基本思路：" class="headerlink" title="基本思路："></a>基本思路：</h1><blockquote>
<p>1.建立数学模型来描述问题。<br>    2.把求解的问题分成若干个子问题。<br>    3.对每一子问题求解，得到子问题的局部最优解。<br>    4.把子问题的解局部最优解合成原来解问题的一个解。</p>
</blockquote>
<h1 id="适用性问题"><a href="#适用性问题" class="headerlink" title="适用性问题"></a>适用性问题</h1><p>贪心策略适用的前提是：局部最优策略能导致产生全局最优解。<br>    实际上，贪心算法适用的情况很少。一般，对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可做出判断。</p>
<h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">从问题的某一初始解出发；</span><br><span class="line">    <span class="keyword">while</span> （能朝给定总目标前进一步）</span><br><span class="line">    &#123; </span><br><span class="line">          利用可行的决策，求出可行解的一个解元素；</span><br><span class="line">    &#125;</span><br><span class="line">    由所有解元素组合成问题的一个可行解；</span><br></pre></td></tr></table></figure>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><ol>
<li>分配饼干</li>
<li>不重叠的区间个数</li>
<li>投飞镖刺破气球</li>
<li>根据身高和序号重组队列</li>
<li>买卖股票最大的收益</li>
<li>买卖股票的最大收益 II</li>
<li>种植花朵</li>
<li>判断是否为子序列</li>
<li>修改一个数成为非递减数组</li>
<li>子数组最大的和</li>
<li>分隔字符串使同种字符出现在一起</li>
</ol>
<p><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E8%B4%AA%E5%BF%83%E6%80%9D%E6%83%B3.md" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E8%B4%AA%E5%BF%83%E6%80%9D%E6%83%B3.md</a>  </p>
<p>参考文章:   </p>
<p><a href="https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741375.html" target="_blank" rel="noopener">五大常用算法之三：贪心算法</a><br><a href="https://blog.csdn.net/ds19980228/article/details/82714478" target="_blank" rel="noopener">贪心算法</a></p>
</div></div><a class="button-hover more" href="/article/73952078.html#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/article/1857aa15.html">深度优先搜索</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-13</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/">编程算法</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/">深度优先搜索</a></div></div><div class="post-content"><div class="main-content content"><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>它的思想是从一个顶点V0开始，沿着一条路一直走到底，如果发现不能到达目标解，那就返回到上一个节点，然后从另一条路开始走到底，这种尽量往深处走的概念即是深度优先的概念。</p>
<p>在程序实现 DFS 时需要考虑以下问题：</p>
<ul>
<li>栈：用栈来保存当前节点信息，当遍历新节点返回时能够继续遍历当前节点。可以使用递归栈。</li>
<li>标记：和 BFS 一样同样需要对已经遍历过的节点进行标记。</li>
</ul>
<h1 id="模板框架"><a href="#模板框架" class="headerlink" title="模板框架"></a>模板框架</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * DFS核心伪代码</span><br><span class="line"> * 前置条件是visit数组全部设置成<span class="literal">false</span></span><br><span class="line"> * @param n 当前开始搜索的节点</span><br><span class="line"> * @param d 当前到达的深度</span><br><span class="line"> * @<span class="built_in">return</span> 是否有解</span><br><span class="line"> */</span><br><span class="line">bool DFS(Node n, int d)&#123;</span><br><span class="line">	<span class="keyword">if</span> (isEnd(n, d))&#123;//一旦搜索深度到达一个结束状态，就返回<span class="literal">true</span></span><br><span class="line">		<span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> (Node nextNode <span class="keyword">in</span> n)&#123;//遍历n相邻的节点nextNode</span><br><span class="line">		<span class="keyword">if</span> (!visit[nextNode])&#123;//</span><br><span class="line">			visit[nextNode] = <span class="literal">true</span>;//在下一步搜索中，nextNode不能再次出现</span><br><span class="line">			<span class="keyword">if</span> (DFS(nextNode, d+1))&#123;//如果搜索出有解</span><br><span class="line">				//做些其他事情，例如记录结果深度等</span><br><span class="line">				<span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line"> </span><br><span class="line">			//重新设置成<span class="literal">false</span>，因为它有可能出现在下一次搜索的别的路径中</span><br><span class="line">			visit[nextNode] = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> <span class="literal">false</span>;//本次搜索无解</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><ol>
<li>查找最大的连通面积</li>
<li>矩阵中的连通分量数目</li>
<li>好友关系的连通分量数目</li>
<li>填充封闭区域</li>
<li>能到达的太平洋和大西洋的区域</li>
</ol>
<p><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%90%9C%E7%B4%A2.md#dfs" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%90%9C%E7%B4%A2.md#dfs</a></p>
<p>参考文章:       </p>
<p><a href="https://blog.csdn.net/raphealguo/article/details/7560918" target="_blank" rel="noopener">深度优先搜索(DFS)</a></p>
</div></div><a class="button-hover more" href="/article/1857aa15.html#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/article/a3e0a169.html">广度优先搜索</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-13</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/">编程算法</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/">广度优先搜索</a></div></div><div class="post-content"><div class="main-content content"><h1 id="算法概念"><a href="#算法概念" class="headerlink" title="算法概念"></a>算法概念</h1><p> 也称宽度优先搜索，顾名思义，就是将一棵树一层一层往下搜。算法首先搜索和s距离为k的所有顶点，然后再去搜索和S距离为k+l的其他顶点。BFS是一种完备策略，即只要问题有解，它就一定可以找到解。并且，广度优先搜索找到的解，还一定是路径最短的解。但是它盲目性较大，尤其是当目标节点距初始节点较远时，将产生许多无用的节点，因此其搜索效率较低。需要保存所有扩展出的状态，占用的空间大</p>
<p> 在程序实现 BFS 时需要考虑以下问题：</p>
<ul>
<li>队列：用来存储每一轮遍历得到的节点；</li>
<li>标记：对于遍历过的节点，应该将它标记，防止重复遍历。</li>
</ul>
<p> BFS可用于解决2类问题：</p>
<ul>
<li>从A出发是否存在到达B的路径；         </li>
<li>从A出发到达B的最短路径(这个应该叫最少步骤合理)；  </li>
</ul>
<h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BFS()</span><br><span class="line">&#123;</span><br><span class="line">初始化队列</span><br><span class="line"><span class="keyword">while</span>(队列不为空且未找到目标节点)</span><br><span class="line">&#123;</span><br><span class="line">取队首节点扩展，并将扩展出的节点放入队尾；</span><br><span class="line">必要时要记住每个节点的父节点；</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><ol>
<li>计算在网格中从原点到特定点的最短路径长度</li>
<li>组成整数的最小平方数数量</li>
<li>最短单词路径</li>
</ol>
<p><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%90%9C%E7%B4%A2.md#bfs" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%90%9C%E7%B4%A2.md#bfs</a></p>
</div></div><a class="button-hover more" href="/article/a3e0a169.html#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/article/5b174d38.html">linux磁盘分区</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-13</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/linux/">linux</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/">磁盘分区</a></div></div><div class="post-content"><div class="main-content content"><p>最近要下载一大堆的资料到服务器上，服务器系统盘的磁盘容量有点不够，还有一个11T的机械硬盘没有使用，但没有分区也没挂载，直接挂载有点浪费，先分区一下。</p></div></div><a class="button-hover more" href="/article/5b174d38.html#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/article/23eb42c6.html">elasticsearch安装教程</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-13</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E5%BC%80%E5%8F%91/">开发</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E6%95%B0%E6%8D%AE%E6%A3%80%E7%B4%A2/">数据检索</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/elasticsearch/">elasticsearch</a></div></div><div class="post-content"><div class="main-content content"><p>docker下的安装</p></div></div><a class="button-hover more" href="/article/23eb42c6.html#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/article/12345678.html">java排序算法</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-13</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/">编程算法</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/java/">java</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">排序算法</a></div></div><div class="post-content"><div class="main-content content"><p>冒泡排序法    </p></div></div><a class="button-hover more" href="/article/12345678.html#more">阅读全文</a></div></div><div id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/9/">&lt;i class&#x3D;&quot;fas fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/11/">&lt;i class&#x3D;&quot;fas fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a></div></div></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fas fa-user"></i></span><span id="busuanzi_value_site_uv"></span><span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fas fa-eye"></i></span><span id="busuanzi_value_site_pv"></span><span></span></div><div class="copyright">&copy;2017 ～ 2021 By ye1s</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/daovoice.js"></script><!--script(src=url)--><div class="search-dialog"><div id="algolia-search-title">Algolia</div><div class="search-close-button"><i class="fa fa-times"></i></div><!--div#current-refined-values--><!--div#clear-all--><div id="search-box"></div><!--div#refinement-list--><hr><div id="hits"></div><div id="algolia-pagination"></div></div><div class="search-mask"></div><script src="/js/search/algolia.js"></script></body></html>