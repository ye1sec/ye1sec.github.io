<!DOCTYPE html><html><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content=""><meta name="keywords"><meta name="author" content="ye1s,undefined"><meta name="copyright" content="ye1s"><title>【ye1s】</title><link rel="stylesheet" href="/css/fan.css"><link rel="stylesheet" href="/css/thirdparty/jquery.mCustomScrollbar.min.css"><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4/dist/instantsearch-theme-algolia.min.css"><script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.10.4"></script><!-- link(rel="dns-prefetch" href="https://cdn.jsdelivr.net")--><!-- link(rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.css")--><!-- script(src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.1.1/dist/instantsearch.min.js" defer)--><!-- script(src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML")--><script src="/js/mathjax/mathjax.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
});
</script><script>var isPassword = '' || false;
if (isPassword) {
    if (prompt('请输入文章密码') !== '') {
        alert('密码错误！');
        history.back();
    }
}</script><script>window.GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"LKL6Q0GQJM","apiKey":"03829f64e2f5c11e4a5e2b8e51e24eb9","indexName":"blog","hits":{"per_page":10},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容:${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  gitment: {"owner":"ye1sec","repo":"comments","client_id":"d5ece338867af32b6dfa","client_secret":"2caf36bbd47977524017f95105315fc9e65f0577"},
}</script><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="ye1s" type="application/atom+xml">
</head><body><canvas id="universe"></canvas><!--#body--><div id="sidebar"><div class="author-info"><div class="author-info-avatar"><img class="author-info-avatar-img" src="/avatar.png"></div><div class="author-info-name">ye1s</div><div class="author-info-description"></div><div class="links-buttons"><a class="links-button button-hover" href="https://github.com/ye1sec" target="_blank">GitHub<i class="icon-dot bg-color4"></i></a><a class="links-button button-hover" href="mailto:431774437@qq.com" target="_blank">E-Mail<i class="icon-dot bg-color6"></i></a><a class="links-button button-hover" href="tencent://message/?uin=431774437&amp;Site=&amp;Menu=yes" target="_blank">QQ<i class="icon-dot bg-color2"></i></a></div><div class="author-info-articles"><a class="author-info-articles-archives article-meta" href="/archives"><span class="pull-top">日志</span><span class="pull-bottom">177</span></a><a class="author-info-articles-tags article-meta" href="/tags"><span class="pull-top">标签</span><span class="pull-bottom">151</span></a><a class="author-info-articles-categories article-meta" href="/categories"><span class="pull-top">分类</span><span class="pull-bottom">12</span></a></div><div class="friend-link"><a class="friend-link-text" href="http://www.m00nback.xyz/" target="_blank">MoonBack</a><a class="friend-link-text" target="_blank">待定</a></div></div></div><div id="main-container"><header><div id="menu-outer"><i class="menu-list-icon fas fa-bars"></i><nav id="menu-inner"><a class="menu-item" href="/">首页</a><a class="menu-item" href="/tags">标签</a><a class="menu-item" href="/categories">分类</a><a class="menu-item" href="/archives">归档</a><a class="menu-item" href="/about">关于</a></nav><div class="right-info"><a class="search social-icon"><i class="fas fa-search"></i><span> 搜索</span></a><a class="title-name" href="/">ye1s</a><span id="now-time"></span></div></div></header><div id="content-outer"><div id="content-inner"><div id="recent-posts"><!-- each post in page.posts.sort('date', -1).limit(10).toArray()--><!-- config中配置按照什么排序--><div class="recent-post-item"><a class="post-title" href="/article/b8b03ac2.html">java虚拟机</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-13</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/">编程算法</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/java/">java</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/java%E8%99%9A%E6%8B%9F%E6%9C%BA/">java虚拟机</a></div></div><div class="post-content"><div class="main-content content"><p>java虚拟机 </p></div></div><a class="button-hover more" href="/article/b8b03ac2.html#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/article/b8b03ac1.html">java IO</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-13</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/">编程算法</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/java/">java</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/java-IO/">java IO</a></div></div><div class="post-content"><div class="main-content content"><p>java IO操作  </p></div></div><a class="button-hover more" href="/article/b8b03ac1.html#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/article/b8b034cd.html">java并发</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-13</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/">编程算法</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/java/">java</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/java%E5%B9%B6%E5%8F%91/">java并发</a></div></div><div class="post-content"><div class="main-content content"><p>Java并发结构     </p></div></div><a class="button-hover more" href="/article/b8b034cd.html#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/article/b8b03acd.html">剑指offer</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-13</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/">编程算法</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/java/">java</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E5%89%91%E6%8C%87offer/">剑指offer</a></div></div><div class="post-content"><div class="main-content content"><p>本书精选谷歌、微软等知名IT企业的50余道典型面试题，系统地总结了如何在面试时写出高质量代码，如何优化代码效率，以及分析、解决难题的常用方法。</p></div></div><a class="button-hover more" href="/article/b8b03acd.html#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/article/012345678.html">java容器</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-13</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/">编程算法</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/java%E5%AE%B9%E5%99%A8/">java容器</a></div></div><div class="post-content"><div class="main-content content"><p>容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。 </p></div></div><a class="button-hover more" href="/article/012345678.html#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/article/b8b0eacd.html">java基础</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-13</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/">编程算法</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/java/">java</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/java%E5%9F%BA%E7%A1%80/">java基础</a></div></div><div class="post-content"><div class="main-content content"><p>java入门的一些基础知识    </p></div></div><a class="button-hover more" href="/article/b8b0eacd.html#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/article/664b37a4.html">elasticsearch总结</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-13</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E5%BC%80%E5%8F%91/">开发</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E6%95%B0%E6%8D%AE%E6%A3%80%E7%B4%A2/">数据检索</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/elasticsearch/">elasticsearch</a></div></div><div class="post-content"><div class="main-content content"><p>Elasticsearch是一个基于Apache Lucene(TM)的开源搜索引擎。无论在开源还是专有领域，Lucene可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。但是，Lucene只是一个库。想要使用它，你必须使用Java来作为开发语言并将其直接集成到你的应用中，更糟糕的是，Lucene非常复杂，你需要深入了解检索的相关知识来理解它是如何工作的。  </p></div></div><a class="button-hover more" href="/article/664b37a4.html#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/article/1d63f3f6.html">django运行环境的搭建</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-13</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E5%BC%80%E5%8F%91/">开发</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/python/">python</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/django/">django</a></div></div><div class="post-content"><div class="main-content content"><p>django运行环境搭建</p></div></div><a class="button-hover more" href="/article/1d63f3f6.html#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/article/6a6101d4.html">python进程、线程和协程</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-13</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/">编程算法</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/python/">python</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E7%BA%BF%E7%A8%8B/">线程</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E8%BF%9B%E7%A8%8B/">进程</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E5%8D%8F%E7%A8%8B/">协程</a></div></div><div class="post-content"><div class="main-content content"><h1 id="0x1进程"><a href="#0x1进程" class="headerlink" title="0x1进程"></a>0x1进程</h1><p><strong>进程（process）是正在运行的程序的实例，但一个程序可能会产生多个进程。</strong><br>比如，打开 Chrome 浏览器程序，它可能会产生多个进程，主程序需要一个进程，一个网页标签需要一个进程，一个插件也需要一个进程，等等。</p>
<p>进程时一个具有一定功能的程序在一个数据集上的一次动态执行过程。<br>进程由程序，数据集合和进程控制块三部分组成。</p>
<ul>
<li>程序用于描述进程要完成的功能，是控制进程执行的指令集；</li>
<li>数据集合是程序在执行时需要的数据和工作区；</li>
<li>程序控制块（PCB）包含程序的描述信息和控制信息，是进程存在的唯一标志。</li>
</ul>
<h2 id="0x1-1fork"><a href="#0x1-1fork" class="headerlink" title="0x1.1fork()"></a>0x1.1fork()</h2><p>在介绍 Python 的进程编程之前，让我们先看看 Unix/Linux 中的 fork 函数。在 Unix/Linux 系统中，fork 函数被用于创建进程。这个函数很特殊，对于普通的函数，调用它一次，返回一次，但是调用 fork 一次，它返回两次。事实上，fork 函数创建了新的进程，我们把它称为子进程，子进程几乎是当前进程（即父进程）的一个拷贝：它会复制父进程的代码段，堆栈段和数据段。</p>
<p>对于父进程，fork 函数返回了子进程的进程号 pid，对于子进程，fork 函数则返回 0，这也是 fork 函数返回两次的原因，根据返回值，我们可以判断进程是父进程还是子进程。</p>
<p>下面我们看一段 C 代码，它展示了 fork 的基本使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int pid;</span><br><span class="line">    pid = fork();    // 使用 fork 函数</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; 0) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Fail to create process\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == 0) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am child process (%d) and my parent is (%d)\n"</span>, getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I (%d) just created a child process (%d)\n"</span>, getpid(), pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，getpid 用于获取当前进程号，getppid 用于获取父进程号。</p>
<p>事实上，Python 的 os 模块包含了普遍的操作系统功能，该模块也提供了 fork 函数，把上面的代码改成用 Python 来实现，如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">pid = os.fork()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> pid &lt; 0:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">'Fail to create process'</span></span><br><span class="line"><span class="keyword">elif</span> pid == 0:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">'I am child process (%s) and my parent is (%s).'</span> % (os.getpid(), os.getppid())</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">'I (%s) just created a child process (%s).'</span> % (os.getpid(), pid)</span><br></pre></td></tr></table></figure>
<p>运行上面的代码，产生如下输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I (86645) just created a child process (86646).</span><br><span class="line">I am child process (86646) and my parent is (86645).</span><br></pre></td></tr></table></figure>
<p>需要注意的是，虽然子进程复制了父进程的代码段和数据段等，但是一旦子进程开始运行，子进程和父进程就是相互独立的，它们之间不再共享任何数据。</p>
<h2 id="0x1-2多进程"><a href="#0x1-2多进程" class="headerlink" title="0x1.2多进程"></a>0x1.2多进程</h2><p>Python 提供了一个 multiprocessing 模块，利用它，我们可以来编写跨平台的多进程程序，但需要注意的是 multiprocessing 在 Windows 和 Linux 平台的不一致性：一样的代码在 Windows 和 Linux 下运行的结果可能不同。因为 Windows 的进程模型和 Linux 不一样，Windows 下没有 fork。</p>
<p>我们先来看一个简单的例子，该例子演示了在主进程中启动一个子进程，并等待其结束，代码如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">from multiprocessing import Process</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子进程要执行的代码</span></span><br><span class="line">def child_proc(name):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">'Run child process %s (%s)...'</span> % (name, os.getpid())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">'Parent process %s.'</span> % os.getpid()</span><br><span class="line">    p = Process(target=child_proc, args=(<span class="string">'test'</span>,))</span><br><span class="line">    <span class="built_in">print</span> <span class="string">'Process will start.'</span></span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line">    <span class="built_in">print</span> <span class="string">'Process end.'</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们从 multiprocessing 模块引入了 Process，Process 是一个用于创建进程对象的类，其中，target 指定了进程要执行的函数，args 指定了参数。在创建了进程实例 p 之后，我们调用 start 方法开始执行该子进程，接着，我们又调用了 join 方法，该方法用于阻塞子进程以外的所有进程（这里指父进程），当子进程执行完毕后，父进程才会继续执行，它通常用于进程间的同步。</p>
<p>可以看到，用上面这种方式来创建进程比直接使用 fork 更简单易懂。现在，让我们看下输出结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Parent process 7170.</span><br><span class="line">Process will start.</span><br><span class="line">Run child process <span class="built_in">test</span> (10075)...</span><br><span class="line">Process end.</span><br></pre></td></tr></table></figure>
<h2 id="0x1-3multiprocessing-与平台有关"><a href="#0x1-3multiprocessing-与平台有关" class="headerlink" title="0x1.3multiprocessing 与平台有关"></a>0x1.3multiprocessing 与平台有关</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line">import os</span><br><span class="line">from multiprocessing import Process</span><br><span class="line"></span><br><span class="line">num = random.randint(0, 100)</span><br><span class="line"></span><br><span class="line">def show_num():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"pid:&#123;&#125;, num is &#123;&#125;"</span>.format(os.getpid(), num))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"pid:&#123;&#125;, num is &#123;&#125;"</span>.format(os.getpid(), num))</span><br><span class="line">    p = Process(target=show_num)</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure>
<p>在 Windows 下运行以上代码，输出的结果如下（你得到不一样的结果也是对的）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pid:6504, num is 25</span><br><span class="line">pid:6880, num is 6</span><br></pre></td></tr></table></figure>
<p>我们发现，num 的值是不一样的！</p>
<p>在 Linux 下运行以上代码，可以看到 num 的值是一样的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pid:11747, num is 13</span><br><span class="line">pid:11748, num is 13</span><br></pre></td></tr></table></figure>
<h2 id="0x1-4进程池Pool"><a href="#0x1-4进程池Pool" class="headerlink" title="0x1.4进程池Pool"></a>0x1.4进程池Pool</h2><p>在上面，我们只是创建了一个进程，如果要创建多个进程呢？Python 提供了进程池的方式，让我们批量创建子进程，让我们看一个简单的示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import os, time</span><br><span class="line">from multiprocessing import Pool</span><br><span class="line"></span><br><span class="line">def foo(x):</span><br><span class="line">    <span class="built_in">print</span> <span class="string">'Run task %s (pid:%s)...'</span> % (x, os.getpid())</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">'Task %s result is: %s'</span> % (x, x * x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">'Parent process %s.'</span> % os.getpid()</span><br><span class="line">    p = Pool(4)         <span class="comment"># 设置进程数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(5):</span><br><span class="line">        p.apply_async(foo, args=(i,))    <span class="comment"># 设置每个进程要执行的函数和参数</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">'Waiting for all subprocesses done...'</span></span><br><span class="line">    p.close()</span><br><span class="line">    p.join()</span><br><span class="line">    <span class="built_in">print</span> <span class="string">'All subprocesses done.'</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，Pool 用于生成进程池，对 Pool 对象调用 apply_async 方法可以使每个进程异步执行任务，也就说不用等上一个任务执行完才执行下一个任务，close 方法用于关闭进程池，确保没有新的进程加入，join 方法会等待所有子进程执行完毕。</p>
<p>看看执行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Parent process 7170.</span><br><span class="line">Run task 1 (pid:10320)...</span><br><span class="line">Run task 0 (pid:10319)...</span><br><span class="line">Run task 3 (pid:10322)...</span><br><span class="line">Run task 2 (pid:10321)...</span><br><span class="line">Waiting <span class="keyword">for</span> all subprocesses <span class="keyword">done</span>...</span><br><span class="line">Task 1 result is: 1</span><br><span class="line">Task 0 result is: 0</span><br><span class="line">Run task 4 (pid:10320)...</span><br><span class="line">Task 3 result is: 9</span><br><span class="line">Task 2 result is: 4</span><br><span class="line">Task 4 result is: 16</span><br><span class="line">All subprocesses <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure>
<h2 id="0x1-5进程间通信"><a href="#0x1-5进程间通信" class="headerlink" title="0x1.5进程间通信"></a>0x1.5进程间通信</h2><p>每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信。假如创建了多个进程，那么进程间的通信是必不可少的。    </p>
<p>Python提供了多种进程通信的方式，其中以Queue和Pipe用得最多。下面分别介绍这两种模式</p>
<h3 id="0x1-5-1Queue"><a href="#0x1-5-1Queue" class="headerlink" title="0x1.5.1Queue"></a>0x1.5.1Queue</h3><p>Queue是一种多进程安全的队列。实现多进程间的通信有两种方法：</p>
<ul>
<li>put() 用于向队列中加入数据。有两个属性：blocked和timeout。blocked为true时（默认为True）且timeout为正值时，如果当队列已满会阻塞timeout时间，在这个时间内如果队列有空位会加入，如果超过时间仍然没有空位会抛出Queue.Full异常。</li>
<li>get() 用于从队列中获取一个数据并将其从队列中删除。有两个属性：blocked和timeout。blocked为true（默认为True）且timeout为正值时，如果当前队列为空会阻塞timeout时间，在这个时间内如果队列有新数据会获取，如果超过时间仍然没有新数据会抛出Queue.Empty异常。</li>
</ul>
<p>下面以队列（Queue）为例，在父进程中创建两个子进程，一个往队列写数据，一个从对列读数据，代码如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">import os</span><br><span class="line">from multiprocessing import Pool,Queue,Process</span><br><span class="line"></span><br><span class="line">def write_task(q):</span><br><span class="line">	try:</span><br><span class="line">		n=1</span><br><span class="line">		<span class="keyword">while</span> n&lt;5:</span><br><span class="line">			<span class="built_in">print</span> <span class="string">"write,%d"</span>%n</span><br><span class="line">			q.put(n)</span><br><span class="line">			time.sleep(1)</span><br><span class="line">			n+=1</span><br><span class="line">	except BaseException:</span><br><span class="line">		<span class="built_in">print</span> <span class="string">"write_task error"</span></span><br><span class="line">	finally:</span><br><span class="line">		<span class="built_in">print</span> <span class="string">"write_task end"</span></span><br><span class="line"></span><br><span class="line">def read_task(q):</span><br><span class="line">	try:</span><br><span class="line">		n=1</span><br><span class="line">		<span class="keyword">while</span> n&lt;5:</span><br><span class="line">			<span class="built_in">print</span> <span class="string">"read,%d"</span>%q.get()</span><br><span class="line">			n+=1</span><br><span class="line">	except BaseException:</span><br><span class="line">		<span class="built_in">print</span> <span class="string">"read_task error"</span></span><br><span class="line">	finally:</span><br><span class="line">		<span class="built_in">print</span> <span class="string">"read_task end"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">	q=Queue()</span><br><span class="line">	pw=Process(target=write_task,args=(q,))</span><br><span class="line">	pr=Process(target=read_task,args=(q,))</span><br><span class="line">	pw.start()</span><br><span class="line">	pr.start()</span><br><span class="line">	pw.join()</span><br><span class="line">	pr.join()</span><br><span class="line">	<span class="built_in">print</span> <span class="string">"DONE"</span></span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">write, 1</span><br><span class="line"><span class="built_in">read</span>, 1</span><br><span class="line">write, 2</span><br><span class="line"><span class="built_in">read</span>, 2</span><br><span class="line">write, 3</span><br><span class="line"><span class="built_in">read</span>, 3</span><br><span class="line">write, 4</span><br><span class="line"><span class="built_in">read</span>, 4</span><br><span class="line">write_task end</span><br><span class="line">read_task end</span><br><span class="line">DONE</span><br></pre></td></tr></table></figure>
<h3 id="0x1-5-2Pipe"><a href="#0x1-5-2Pipe" class="headerlink" title="0x1.5.2Pipe"></a>0x1.5.2Pipe</h3><p>Pipe与Queue不同之处在于Pipe是用于两个进程之间的通信。就像进程位于一根水管的两端。让我们看看Pipe官方文档的描述：</p>
<blockquote>
<p>Returns a pair (conn1, conn2) of Connection objects representing the ends of a pipe.</p>
</blockquote>
<p>Piep返回conn1和conn2代表水管的两端。Pipe还有一个参数duplex（adj. 二倍的，双重的 n. 双工；占两层楼的公寓套房），默认为True。当duplex为True时，开启双工模式，此时水管的两边都可以进行收发。当duplex为False，那么conn1只负责接受信息，conn2只负责发送信息。<br>conn通过send()和recv()来发送和接受信息。值得注意的是，如果管道中没有信息可接受，recv()会一直阻塞直到管道关闭（任意一端进程接结束则管道关闭）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process,Pipe</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">def put_data(p,nums):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'现在的进程编号为：%s，这个一个send进程'</span> % os.getpid())</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        p.send(num)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'%s已经放入管道中啦！'</span> % num)</span><br><span class="line"></span><br><span class="line">def get_data(p):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'现在的进程编号为：%s，这个一个recv进程'</span> % os.getpid())</span><br><span class="line">    <span class="keyword">while</span> True:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'已经从管道中获取%s并从中删除'</span> % p.recv())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = Pipe(duplex=False)</span><br><span class="line">    <span class="comment"># 此时Pipe[1]即是Pipe返回的conn2</span></span><br><span class="line">    p1 = Process(target=put_data,args=(p[1],[<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>],))</span><br><span class="line">    <span class="comment"># 此时Pipe[0]即是Pipe返回的conn1</span></span><br><span class="line">    p3 = Process(target=get_data,args=(p[0],))</span><br><span class="line">    p1.start()</span><br><span class="line">    p3.start()</span><br><span class="line">    p1.join()</span><br><span class="line">    p3.terminate()</span><br></pre></td></tr></table></figure>
<p>让我们看一下输出结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">现在的进程编号为：9868，这个一个recv进程</span><br><span class="line">现在的进程编号为：9072，这个一个send进程</span><br><span class="line">1已经放入管道中啦！</span><br><span class="line">已经从管道中获取1,并从中删除</span><br><span class="line">2已经放入管道中啦！</span><br><span class="line">已经从管道中获取2并从中删除</span><br><span class="line">3已经放入管道中啦！</span><br><span class="line">已经从管道中获取3并从中删除</span><br></pre></td></tr></table></figure>
<h3 id="0x1-5-3Array"><a href="#0x1-5-3Array" class="headerlink" title="0x1.5.3Array"></a>0x1.5.3Array</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing import Process</span><br><span class="line">from multiprocessing import Array</span><br><span class="line"></span><br><span class="line">def func(i, ar):</span><br><span class="line">    ar[i] = i</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> ar:</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"------"</span>)</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">	ar = Array(<span class="string">'i'</span>, 5)</span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(5):</span><br><span class="line">		p = Process(target=func, args=(i, ar,))</span><br><span class="line">		p.start()</span><br><span class="line">	p.join()</span><br></pre></td></tr></table></figure>
<p>Array的局限性在于受制于数组的特性，即需要指定数据类型且长度固定</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据类型对照表</span></span><br><span class="line"><span class="string">'c'</span>: ctypes.c_char,  <span class="string">'u'</span>: ctypes.c_wchar,</span><br><span class="line"><span class="string">'b'</span>: ctypes.c_byte,  <span class="string">'B'</span>: ctypes.c_ubyte,</span><br><span class="line"><span class="string">'h'</span>: ctypes.c_short, <span class="string">'H'</span>: ctypes.c_ushort,</span><br><span class="line"><span class="string">'i'</span>: ctypes.c_int,   <span class="string">'I'</span>: ctypes.c_uint,</span><br><span class="line"><span class="string">'l'</span>: ctypes.c_long,  <span class="string">'L'</span>: ctypes.c_ulong,</span><br><span class="line"><span class="string">'f'</span>: ctypes.c_float, <span class="string">'d'</span>: ctypes.c_double</span><br></pre></td></tr></table></figure>
<h3 id="0x1-5-4manage-dict"><a href="#0x1-5-4manage-dict" class="headerlink" title="0x1.5.4manage.dict()"></a>0x1.5.4manage.dict()</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line">from multiprocessing import Process, Manager</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个子进程执行的函数</span></span><br><span class="line"><span class="comment"># 参数中，传递了一个用于多进程之间数据共享的特殊字典</span></span><br><span class="line">def func(i, d):</span><br><span class="line">    d[i] = i + 100</span><br><span class="line">    <span class="built_in">print</span>(d.values())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">	<span class="comment"># 在主进程中创建特殊字典</span></span><br><span class="line">	m = Manager()</span><br><span class="line">	d = m.dict()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(5):</span><br><span class="line">   		<span class="comment"># 让子进程去修改主进程的特殊字典</span></span><br><span class="line">		p = Process(target=func, args=(i, d))</span><br><span class="line">		p.start()</span><br><span class="line">	p.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">[101]</span><br><span class="line">[100, 101]</span><br><span class="line">[100, 101, 102]</span><br><span class="line">[100, 101, 102, 103]</span><br><span class="line">[100, 101, 102, 103, 104]</span><br></pre></td></tr></table></figure>

<h1 id="0x2线程"><a href="#0x2线程" class="headerlink" title="0x2线程"></a>0x2线程</h1><p><strong>线程（thread）是进程（process）中的一个实体，一个进程至少包含一个线程。</strong>比如，对于视频播放器，显示视频用一个线程，播放音频用另一个线程。如果我们把进程看成一个容器，则线程是此容器的工作单位。</p>
<p>进程和线程的区别主要有：</p>
<ul>
<li>进程之间是相互独立的，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，但互不影响；而同一个进程的多个线程是内存共享的，所有变量都由所有线程共享；</li>
<li>由于进程间是独立的，因此一个进程的崩溃不会影响到其他进程；而线程是包含在进程之内的，线程的崩溃就会引发进程的崩溃，继而导致同一进程内的其他线程也奔溃；</li>
</ul>
<p>线程的生命周期由run方法决定，当run方法结束时线程死亡。可以通过继承Thread，重写run方法改变Thread的功能，最后还是通过start()方法开线程。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from threading import Thread</span><br><span class="line"></span><br><span class="line">class MyThread(Thread):</span><br><span class="line">    def run(self):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">'i am sorry'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t = MyThread()</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>

<p>通过args参数以一个元组的方式给线程中的函数传参。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from threading import Thread</span><br><span class="line"></span><br><span class="line">def sorry(name):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'i am sorry'</span>,name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:  </span><br><span class="line">    t = Thread(target=sorry,args=(<span class="string">'mike'</span>,))</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>

<h2 id="0x2-1threding模块简介"><a href="#0x2-1threding模块简介" class="headerlink" title="0x2.1threding模块简介"></a>0x2.1threding模块简介</h2><p>threding模块的类</p>
<table>
<thead>
<tr>
<th>对象</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Thread</td>
<td>表示一个执行线程的对象</td>
</tr>
<tr>
<td>Lock</td>
<td>锁对象</td>
</tr>
<tr>
<td>RLock</td>
<td>可重入锁对象，使单一线程可以（再次）获得已持有的锁（递归锁）</td>
</tr>
<tr>
<td>Condition</td>
<td>条件变量对象，使得一个线程等待另外一个线程满足特定的条件，比如改变状态或者某个数据值</td>
</tr>
<tr>
<td>Event</td>
<td>条件变量的通用版本，任意数量的线程等待某个事件的发生，在该事件发生后所有的线程都将被激活</td>
</tr>
<tr>
<td>Semaphore</td>
<td>为线程间的有限资源提供一个计数器，如果没有可用资源时会被阻塞</td>
</tr>
<tr>
<td>BoundedSemaphore</td>
<td>于Semaphore相似，不过它不允许超过初始值</td>
</tr>
<tr>
<td>Timer</td>
<td>于Thread类似，不过它要在运行前等待一定时间</td>
</tr>
<tr>
<td>Barrier</td>
<td>创建一个障碍，必须达到指定数量的线程后才可以继续</td>
</tr>
</tbody></table>
<h2 id="0x2-2Thread类"><a href="#0x2-2Thread类" class="headerlink" title="0x2.2Thread类"></a>0x2.2Thread类</h2><h3 id="0x2-2-1使用方法"><a href="#0x2-2-1使用方法" class="headerlink" title="0x2.2.1使用方法"></a>0x2.2.1使用方法</h3><p>Thread是线程类，有<strong>两种使用方法，直接传入要运行的方法或从Thread继承并覆盖run()</strong>：<br>方法一：将要执行的方法作为参数传给Thread的构造方法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def action(arg):</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    <span class="built_in">print</span> <span class="string">'the arg is:%s\r'</span> %arg</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(4):</span><br><span class="line">    t =threading.Thread(target=action,args=(i,))</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">'main thread end!'</span></span><br></pre></td></tr></table></figure>

<p>方法二：从Thread继承，并重写run()</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line">class MyThread(threading.Thread):</span><br><span class="line">    def __init__(self,arg):</span><br><span class="line">        super(MyThread, self).__init__()<span class="comment">#注意：一定要显式的调用父类的初始化函数。</span></span><br><span class="line">        self.arg=arg</span><br><span class="line">    def run(self):<span class="comment">#定义每个线程要运行的函数</span></span><br><span class="line">        time.sleep(1)</span><br><span class="line">        <span class="built_in">print</span> <span class="string">'the arg is:%s\r'</span> % self.arg</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(4):</span><br><span class="line">    t =MyThread(i)</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">'main thread end!'</span></span><br></pre></td></tr></table></figure>
<p>构造方法：<br>Thread(group=None, target=None, name=None, args=(), kwargs={}) </p>
<ul>
<li>group: 线程组，目前还没有实现，库引用中提示必须是None； </li>
<li>target: 要执行的方法； </li>
<li>name: 线程名； </li>
<li>args/kwargs: 要传入方法的参数。</li>
</ul>
<p>实例方法：   </p>
<ul>
<li>isAlive(): 返回线程是否在运行。正在运行指启动后、终止前。 </li>
<li>get/setName(name): 获取/设置线程名。 </li>
<li>start():  线程准备就绪，等待CPU调度</li>
<li>　is/setDaemon(bool): 获取/设置是后台线程（默认前台线程（False））。（在start之前设置）<br> 如果是后台线程，主线程执行过程中，后台线程也在进行，主线程执行完毕后，后台线程不论成功与否，主线程和后台线程均停止。<br> 如果是前台线程，主线程执行过程中，前台线程也在进行，主线程执行完毕后，等待前台线程也执行完成后，程序停止</li>
<li>start(): 启动线程。 </li>
<li>join([timeout]): 阻塞当前上下文环境的线程，直到调用此方法的线程终止或到达指定的timeout（可选参数）。</li>
</ul>
<h3 id="0x2-2-2setDeamon与join"><a href="#0x2-2-2setDeamon与join" class="headerlink" title="0x2.2.2setDeamon与join"></a>0x2.2.2setDeamon与join</h3><p>使用例子一(未设置setDeamon)： </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def action(arg):</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    <span class="built_in">print</span>  <span class="string">'sub thread start! the thread name is:%s\r'</span> % threading.currentThread().getName()</span><br><span class="line">    <span class="built_in">print</span> <span class="string">'the arg is:%s\r'</span> %arg</span><br><span class="line">    time.sleep(1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(4):</span><br><span class="line">    t =threading.Thread(target=action,args=(i,))</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">'main_thread end!'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">main_thread end!</span><br><span class="line">sub thread start!the thread name is:Thread-3</span><br><span class="line"></span><br><span class="line">the arg is:2</span><br><span class="line"></span><br><span class="line">sub thread start!the thread name is:Thread-2</span><br><span class="line">sub thread start!the thread name is:Thread-1</span><br><span class="line"></span><br><span class="line">the arg is:1</span><br><span class="line"></span><br><span class="line">the arg is:0</span><br><span class="line">sub thread start!the thread name is:Thread-4</span><br><span class="line">the arg is:3</span><br><span class="line">[Finished <span class="keyword">in</span> 2.2s]</span><br></pre></td></tr></table></figure>
<p>验证了serDeamon(False)(默认)前台线程，主线程执行过程中，前台线程也在进行，主线程执行完毕后，等待前台线程也执行完成后，主线程停止。   </p>
<p>使用例子二（setDeamon=True）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def action(arg):</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    <span class="built_in">print</span>  <span class="string">'sub thread start!the thread name is:%s\r'</span> % threading.currentThread().getName()</span><br><span class="line">    <span class="built_in">print</span> <span class="string">'the arg is:%s\r'</span> %arg</span><br><span class="line">    time.sleep(1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(4):</span><br><span class="line">    t =threading.Thread(target=action,args=(i,))</span><br><span class="line">    t.setDaemon(True)<span class="comment">#设置线程为后台线程</span></span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">'main_thread end!'</span></span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">main_thread end!</span><br></pre></td></tr></table></figure>
<p>验证了serDeamon(True)后台线程，主线程执行过程中，后台线程也在进行，主线程执行完毕后，后台线程不论成功与否，主、后台线程均停止。     </p>
<p>使用例子三（设置join）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def action(arg):</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    <span class="built_in">print</span>  <span class="string">'sub thread start!the thread name is:%s    '</span> % threading.currentThread().getName()</span><br><span class="line">    <span class="built_in">print</span> <span class="string">'the arg is:%s   '</span> %arg</span><br><span class="line">    time.sleep(1)</span><br><span class="line"></span><br><span class="line">thread_list = []    <span class="comment">#线程存放列表</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(4):</span><br><span class="line">    t =threading.Thread(target=action,args=(i,))</span><br><span class="line">    t.setDaemon(True)</span><br><span class="line">    thread_list.append(t)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> thread_list:</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> thread_list:</span><br><span class="line">    t.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">sub thread start!the thread name is:Thread-2    sub thread start!the thread name is:Thread-1</span><br><span class="line"></span><br><span class="line">the arg is:1   the arg is:0</span><br><span class="line"></span><br><span class="line">sub thread start!the thread name is:Thread-4    sub thread start!the thread name is:Thread-3</span><br><span class="line">the arg is:2</span><br><span class="line"></span><br><span class="line">the arg is:3</span><br><span class="line">[Finished <span class="keyword">in</span> 2.2s]</span><br><span class="line">设置join之后，主线程等待子线程全部执行完成后或者子线程超时后，主线程才结束</span><br></pre></td></tr></table></figure>
<p>验证了 join()阻塞当前上下文环境的线程，直到调用此方法的线程终止或到达指定的timeout，即使设置了setDeamon（True）主线程依然要等待子线程结束。   </p>
<p>使用例子四（join不妥当的用法，使多线程编程顺序执行）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">def action(arg):</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    <span class="built_in">print</span>  <span class="string">'sub thread start!the thread name is:%s    '</span> % threading.currentThread().getName()</span><br><span class="line">    <span class="built_in">print</span> <span class="string">'the arg is:%s   '</span> %arg</span><br><span class="line">    time.sleep(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> xrange(4):</span><br><span class="line">    t =threading.Thread(target=action,args=(i,))</span><br><span class="line">    t.setDaemon(True)</span><br><span class="line">    t.start()</span><br><span class="line">    t.join()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">'main_thread end!'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ouput:</span><br><span class="line">sub thread start!the thread name is:Thread-1</span><br><span class="line">the arg is:0</span><br><span class="line">sub thread start!the thread name is:Thread-2</span><br><span class="line">the arg is:1</span><br><span class="line">sub thread start!the thread name is:Thread-3</span><br><span class="line">the arg is:2</span><br><span class="line">sub thread start!the thread name is:Thread-4</span><br><span class="line">the arg is:3</span><br><span class="line">main_thread end!</span><br><span class="line">[Finished <span class="keyword">in</span> 8.2s]</span><br><span class="line">可以看出此时，程序只能顺序执行，每个线程都被上一个线程的join阻塞，使得“多线程”失去了多线程意义。</span><br></pre></td></tr></table></figure>
<h2 id="0x2-3Lock、Rlock类"><a href="#0x2-3Lock、Rlock类" class="headerlink" title="0x2.3Lock、Rlock类"></a>0x2.3Lock、Rlock类</h2><p>　　由于线程之间随机调度：某线程可能在执行n条后，CPU接着执行其他线程。为了多个线程同时操作一个内存中的资源时不产生混乱，我们使用锁。</p>
<ul>
<li><p>Lock（指令锁）是可用的最低级的同步指令。Lock处于锁定状态时，不被特定的线程拥有。Lock包含两种状态——锁定和非锁定，以及两个基本的方法。</p>
<p>可以认为Lock有一个锁定池，当线程请求锁定时，将线程至于池中，直到获得锁定后出池。池中的线程处于状态图中的同步阻塞状态。</p>
</li>
<li><p>RLock（可重入锁）是一个可以被同一个线程请求多次的同步指令。RLock使用了“拥有的线程”和“递归等级”的概念，处于锁定状态时，RLock被某个线程拥有。拥有RLock的线程可以再次调用acquire()，释放锁时需要调用release()相同次数。</p>
<p>可以认为RLock包含一个锁定池和一个初始值为0的计数器，每次成功调用 acquire()/release()，计数器将+1/-1，为0时锁处于未锁定状态。</p>
</li>
</ul>
<p>简言之：Lock属于全局，Rlock属于线程。</p>
<p>构造方法：<br>Lock()，Rlock（）,推荐使用Rlock()</p>
<p>实例方法： </p>
<ul>
<li>acquire([timeout]): 尝试获得锁定。使线程进入同步阻塞状态。 </li>
<li>release(): 释放锁。使用前线程必须已获得锁定，否则将抛出异常。</li>
</ul>
<p>由于同一个进程之间的线程是内存共享的，所以当多个线程对同一个变量进行修改的时候，就会得到意想不到的结果。</p>
<p>让我们先看一个简单的例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from threading import Thread, current_thread</span><br><span class="line"></span><br><span class="line">num = 0</span><br><span class="line"></span><br><span class="line">def calc():</span><br><span class="line">    global num</span><br><span class="line">    <span class="built_in">print</span> <span class="string">'thread %s is running...'</span> % current_thread().name</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(10000):</span><br><span class="line">        num += 1</span><br><span class="line">    <span class="built_in">print</span> <span class="string">'thread %s ended.'</span> % current_thread().name</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">'thread %s is running...'</span> % current_thread().name</span><br><span class="line"></span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(5):</span><br><span class="line">        threads.append(Thread(target=calc))</span><br><span class="line">        threads[i].start()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(5):</span><br><span class="line">        threads[i].join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> <span class="string">'global num: %d'</span> % num</span><br><span class="line">    <span class="built_in">print</span> <span class="string">'thread %s ended.'</span> % current_thread().name</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们创建了 5 个线程，每个线程对全局变量 num 进行 10000 次的 加 1 操作，这里之所以要循环 10000 次，是为了延长单个线程的执行时间，使线程执行时能出现中断切换的情况。现在问题来了，当这 5 个线程执行完毕时，全局变量的值是多少呢？是 50000 吗？</p>
<p>让我们看下执行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">thread MainThread is running...</span><br><span class="line">thread Thread-34 is running...</span><br><span class="line">thread Thread-34 ended.</span><br><span class="line">thread Thread-35 is running...</span><br><span class="line">thread Thread-36 is running...</span><br><span class="line">thread Thread-37 is running...</span><br><span class="line">thread Thread-38 is running...</span><br><span class="line">thread Thread-35 ended.</span><br><span class="line">thread Thread-38 ended.</span><br><span class="line">thread Thread-36 ended.</span><br><span class="line">thread Thread-37 ended.</span><br><span class="line">global num: 30668</span><br><span class="line">thread MainThread ended.</span><br></pre></td></tr></table></figure>
<p>我们发现 num 的值是 30668，事实上，num 的值是不确定的，你再运行一遍，会发现结果变了。</p>
<p>原因是因为 num += 1 不是一个原子操作，也就是说它在执行时被分成若干步：</p>
<p>计算 num + 1，存入临时变量 tmp 中；<br>将 tmp 的值赋给 num.<br>由于线程是交替运行的，线程在执行时可能中断，就会导致其他线程读到一个脏值。</p>
<p>为了保证计算的准确性，我们就需要给 num += 1 这个操作加上锁。当某个线程开始执行这个操作时，由于该线程获得了锁，因此其他线程不能同时执行该操作，只能等待，直到锁被释放，这样就可以避免修改的冲突。创建一个锁可以通过 threading.Lock() 来实现，代码如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">from threading import Thread, current_thread, Lock</span><br><span class="line"></span><br><span class="line">num = 0</span><br><span class="line">lock = Lock()</span><br><span class="line"></span><br><span class="line">def calc():</span><br><span class="line">    global num</span><br><span class="line">    <span class="built_in">print</span> <span class="string">'thread %s is running...'</span> % current_thread().name</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> xrange(10000):</span><br><span class="line">        lock.acquire()    <span class="comment"># 获取锁</span></span><br><span class="line">        num += 1</span><br><span class="line">        lock.release()    <span class="comment"># 释放锁</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">'thread %s ended.'</span> % current_thread().name</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">'thread %s is running...'</span> % current_thread().name</span><br><span class="line"></span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(5):</span><br><span class="line">        threads.append(Thread(target=calc))</span><br><span class="line">        threads[i].start()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(5):</span><br><span class="line">        threads[i].join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span> <span class="string">'global num: %d'</span> % num</span><br><span class="line">    <span class="built_in">print</span> <span class="string">'thread %s ended.'</span> % current_thread().name</span><br></pre></td></tr></table></figure>
<p>让我们看下执行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">thread MainThread is running...</span><br><span class="line">thread Thread-44 is running...</span><br><span class="line">thread Thread-45 is running...</span><br><span class="line">thread Thread-46 is running...</span><br><span class="line">thread Thread-47 is running...</span><br><span class="line">thread Thread-48 is running...</span><br><span class="line">thread Thread-45 ended.</span><br><span class="line">thread Thread-47 ended.</span><br><span class="line">thread Thread-48 ended.</span><br><span class="line">thread Thread-46 ended.</span><br><span class="line">thread Thread-44 ended.</span><br><span class="line">global num: 50000</span><br><span class="line">thread MainThread ended.</span><br></pre></td></tr></table></figure>

<p>Lock对比Rlock</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"> </span><br><span class="line">import threading</span><br><span class="line">lock = threading.Lock() <span class="comment">#Lock对象</span></span><br><span class="line">lock.acquire()</span><br><span class="line">lock.acquire()  <span class="comment">#产生了死锁。</span></span><br><span class="line">lock.release()</span><br><span class="line">lock.release()</span><br><span class="line"><span class="built_in">print</span> lock.acquire()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">import threading</span><br><span class="line">rLock = threading.RLock()  <span class="comment">#RLock对象</span></span><br><span class="line">rLock.acquire()</span><br><span class="line">rLock.acquire() <span class="comment">#在同一线程内，程序不会堵塞。</span></span><br><span class="line">rLock.release()</span><br><span class="line">rLock.release()</span><br></pre></td></tr></table></figure>
<h2 id="0x2-4Condition类"><a href="#0x2-4Condition类" class="headerlink" title="0x2.4Condition类"></a>0x2.4Condition类</h2><p>　　Condition（条件变量）通常与一个锁关联。需要在多个Contidion中共享一个锁时，可以传递一个Lock/RLock实例给构造方法，否则它将自己生成一个RLock实例。</p>
<p>　　可以认为，除了Lock带有的锁定池外，Condition还包含一个等待池，池中的线程处于等待阻塞状态，直到另一个线程调用notify()/notifyAll()通知；得到通知后线程进入锁定池等待锁定。</p>
<p>构造方法：<br>Condition([lock/rlock])</p>
<p>实例方法： </p>
<ul>
<li>acquire([timeout])/release(): 调用关联的锁的相应方法。 </li>
<li>wait([timeout]): 调用这个方法将使线程进入Condition的等待池等待通知，并释放锁。使用前线程必须已获得锁定，否则将抛出异常。 </li>
<li>notify(): 调用这个方法将从等待池挑选一个线程并通知，收到通知的线程将自动调用acquire()尝试获得锁定（进入锁定池）；其他线程仍然在等待池中。调用这个方法不会释放锁定。使用前线程必须已获得锁定，否则将抛出异常。 </li>
<li>notifyAll(): 调用这个方法将通知等待池中所有的线程，这些线程都将进入锁定池尝试获得锁定。调用这个方法不会释放锁定。使用前线程必须已获得锁定，否则将抛出异常。   </li>
</ul>
<p>例子1</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># encoding: UTF-8</span></span><br><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 商品</span></span><br><span class="line">product = None</span><br><span class="line"><span class="comment"># 条件变量</span></span><br><span class="line">con = threading.Condition()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生产者方法</span></span><br><span class="line">def produce():</span><br><span class="line">    global product</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> con.acquire():</span><br><span class="line">        <span class="keyword">while</span> True:</span><br><span class="line">            <span class="keyword">if</span> product is None:</span><br><span class="line">                <span class="built_in">print</span> <span class="string">'produce...'</span></span><br><span class="line">                product = <span class="string">'anything'</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 通知消费者，商品已经生产</span></span><br><span class="line">                con.notify()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 等待通知</span></span><br><span class="line">            con.wait()</span><br><span class="line">            time.sleep(2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 消费者方法</span></span><br><span class="line">def consume():</span><br><span class="line">    global product</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> con.acquire():</span><br><span class="line">        <span class="keyword">while</span> True:</span><br><span class="line">            <span class="keyword">if</span> product is not None:</span><br><span class="line">                <span class="built_in">print</span> <span class="string">'consume...'</span></span><br><span class="line">                product = None</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 通知生产者，商品已经没了</span></span><br><span class="line">                con.notify()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 等待通知</span></span><br><span class="line">            con.wait()</span><br><span class="line">            time.sleep(2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t1 = threading.Thread(target=produce)</span><br><span class="line">t2 = threading.Thread(target=consume)</span><br><span class="line">t2.start()</span><br><span class="line">t1.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">produce...</span><br><span class="line">consume...</span><br><span class="line">produce...</span><br><span class="line">consume...</span><br><span class="line">produce...</span><br><span class="line">consume...</span><br><span class="line">produce...</span><br><span class="line">consume...</span><br><span class="line">produce...</span><br><span class="line">consume...</span><br><span class="line">produce...</span><br><span class="line">consume...</span><br><span class="line">produce...</span><br><span class="line">consume...</span><br><span class="line">produce...</span><br><span class="line">consume...</span><br><span class="line">produce...</span><br><span class="line">consume...</span><br><span class="line">produce...</span><br><span class="line">consume...</span><br><span class="line">produce...</span><br><span class="line">consume...</span><br><span class="line">produce...</span><br><span class="line">consume...</span><br><span class="line">produce...</span><br><span class="line">consume...</span><br><span class="line">produce...</span><br><span class="line">consume...</span><br><span class="line">produce...</span><br><span class="line"></span><br><span class="line">程序不断循环运行下去。重复生产消费过程。</span><br></pre></td></tr></table></figure>
<p>例子2 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">condition = threading.Condition()</span><br><span class="line">products = 0</span><br><span class="line"></span><br><span class="line">class Producer(threading.Thread):</span><br><span class="line">    def run(self):</span><br><span class="line">        global products</span><br><span class="line">        <span class="keyword">while</span> True:</span><br><span class="line">            <span class="keyword">if</span> condition.acquire():</span><br><span class="line">                <span class="keyword">if</span> products &lt; 10:</span><br><span class="line">                    products += 1;</span><br><span class="line">                    <span class="built_in">print</span> <span class="string">"Producer(%s):deliver one, now products:%s"</span> %(self.name, products)</span><br><span class="line">                    condition.notify()<span class="comment">#不释放锁定，因此需要下面一句</span></span><br><span class="line">                    condition.release()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span> <span class="string">"Producer(%s):already 10, stop deliver, now products:%s"</span> %(self.name, products)</span><br><span class="line">                    condition.wait();<span class="comment">#自动释放锁定</span></span><br><span class="line">                time.sleep(2)</span><br><span class="line"></span><br><span class="line">class Consumer(threading.Thread):</span><br><span class="line">    def run(self):</span><br><span class="line">        global products</span><br><span class="line">        <span class="keyword">while</span> True:</span><br><span class="line">            <span class="keyword">if</span> condition.acquire():</span><br><span class="line">                <span class="keyword">if</span> products &gt; 1:</span><br><span class="line">                    products -= 1</span><br><span class="line">                    <span class="built_in">print</span> <span class="string">"Consumer(%s):consume one, now products:%s"</span> %(self.name, products)</span><br><span class="line">                    condition.notify()</span><br><span class="line">                    condition.release()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span> <span class="string">"Consumer(%s):only 1, stop consume, products:%s"</span> %(self.name, products)</span><br><span class="line">                    condition.wait();</span><br><span class="line">                time.sleep(2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> range(0, 2):</span><br><span class="line">        p = Producer()</span><br><span class="line">        p.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> range(0, 3):</span><br><span class="line">        c = Consumer()</span><br><span class="line">        c.start()</span><br></pre></td></tr></table></figure>

<h2 id="0x2-5Event类"><a href="#0x2-5Event类" class="headerlink" title="0x2.5Event类"></a>0x2.5Event类</h2><p>　Event（事件）是最简单的线程通信机制之一：一个线程通知事件，其他线程等待事件。Event内置了一个初始为False的标志，当调用set()时设为True，调用clear()时重置为 False。wait()将阻塞线程至等待阻塞状态。</p>
<p>　　Event其实就是一个简化版的 Condition。Event没有锁，无法使线程进入同步阻塞状态。</p>
<p>构造方法：<br>Event()</p>
<p>实例方法： </p>
<ul>
<li>isSet(): 当内置标志为True时返回True。 </li>
<li>set(): 将标志设为True，并通知所有处于等待阻塞状态的线程恢复运行状态。 </li>
<li>clear(): 将标志设为False。 </li>
<li>wait([timeout]): 如果标志为True将立即返回，否则阻塞线程至等待阻塞状态，等待其他线程调用set()。</li>
</ul>
<p>例子1</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding: UTF-8</span></span><br><span class="line">import threading</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">event = threading.Event()</span><br><span class="line">def func():</span><br><span class="line">    <span class="comment"># 等待事件，进入等待阻塞状态</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">'%s wait for event...'</span> % threading.currentThread().getName()</span><br><span class="line">    event.wait()</span><br><span class="line">    <span class="comment"># 收到事件后进入运行状态</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">'%s recv event.'</span> % threading.currentThread().getName()</span><br><span class="line">t1 = threading.Thread(target=func)</span><br><span class="line">t2 = threading.Thread(target=func)</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line"></span><br><span class="line">time.sleep(2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送事件通知</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">'MainThread set event.'</span></span><br><span class="line">event.set()</span><br></pre></td></tr></table></figure>

<h2 id="0x2-6-timer类"><a href="#0x2-6-timer类" class="headerlink" title="0x2.6 timer类"></a>0x2.6 timer类</h2><p>Timer（定时器）是Thread的派生类，用于在指定时间后调用一个方法。<br>构造方法：<br>Timer(interval, function, args=[], kwargs={}) </p>
<ul>
<li>interval: 指定的时间 </li>
<li>function: 要执行的方法 </li>
<li>args/kwargs: 方法的参数</li>
</ul>
<p>实例方法：<br>Timer从Thread派生，没有增加实例方法。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding: UTF-8</span></span><br><span class="line">import threading</span><br><span class="line">def func():</span><br><span class="line">    <span class="built_in">print</span> <span class="string">'hello timer!'</span></span><br><span class="line">timer = threading.Timer(5, func)</span><br><span class="line">timer.start()</span><br><span class="line">线程延迟5秒后执行。</span><br></pre></td></tr></table></figure>
<h2 id="0x2-7local类"><a href="#0x2-7local类" class="headerlink" title="0x2.7local类"></a>0x2.7local类</h2><p>local是一个小写字母开头的类，用于管理 thread-local（线程局部的）数据。对于同一个local，线程无法访问其他线程设置的属性；线程设置的属性不会被其他线程设置的同名属性替换。</p>
<p>　　可以把local看成是一个“线程-属性字典”的字典，local封装了从自身使用线程作为 key检索对应的属性字典、再使用属性名作为key检索属性值的细节。 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># encoding: UTF-8</span></span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> = threading.local()</span><br><span class="line">local.tname = <span class="string">'main'</span></span><br><span class="line">def func():</span><br><span class="line">    local.tname = <span class="string">'notmain'</span></span><br><span class="line">    <span class="built_in">print</span> local.tname</span><br><span class="line">t1 = threading.Thread(target=func)</span><br><span class="line">t1.start()</span><br><span class="line">t1.join()</span><br><span class="line"><span class="built_in">print</span> local.tname  </span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">notmain</span><br><span class="line">main</span><br><span class="line">[Finished <span class="keyword">in</span> 0.2s]</span><br></pre></td></tr></table></figure>
<p>具体可看 <a href="http://funhacks.net/explore-python/Process-Thread-Coroutine/threadlocal.html" target="_blank" rel="noopener">http://funhacks.net/explore-python/Process-Thread-Coroutine/threadlocal.html</a>  </p>
<h2 id="0x2-8GIL-锁"><a href="#0x2-8GIL-锁" class="headerlink" title="0x2.8GIL 锁"></a>0x2.8GIL 锁</h2><p>Python 的线程虽然是真正的线程，但解释器执行代码时，有一个 GIL 锁(Global Interpreter Lock)，任何 Python 线程执行前，必须先获得 GIL 锁。每执行 100 条字节码，解释器就自动释放 GIL 锁，让别的线程有机会执行。这个 GIL 全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在 Python 中只能交替执行，即使 100 个线程跑在 100 核 CPU 上，也只能用到 1 个核。</p>
<p>GIL 是 Python 解释器设计的历史遗留问题，通常我们用的解释器是官方实现的 CPython，要真正利用多核，除非重写一个不带 GIL 的解释器。所以，在 Python 如果一定要通过多线程利用多核，那只能通过 C 扩展来实现。</p>
<p>因而，多线程的并发在 Python 中就是一个美丽的梦，如果想真正实现多核任务，还是通过多进程来实现吧。 </p>
<h1 id="0x3-协程"><a href="#0x3-协程" class="headerlink" title="0x3 协程"></a>0x3 协程</h1><p>具体可看此篇文章:<a href="https://thief.one/2017/02/20/Python%E5%8D%8F%E7%A8%8B/" target="_blank" rel="noopener">https://thief.one/2017/02/20/Python%E5%8D%8F%E7%A8%8B/</a> </p>
<h2 id="0x3-1协程的理解"><a href="#0x3-1协程的理解" class="headerlink" title="0x3.1协程的理解"></a>0x3.1协程的理解</h2><p>概念</p>
<blockquote>
<p>协程，又称微线程，纤程，英文名Coroutine。协程的作用，是在执行函数A时，可以随时中断，去执行函数B，然后中断继续执行函数A（可以自由切换）。但这一过程并不是函数调用（没有调用语句），这一整个过程看似像多线程，然而协程只有一个线程执行。</p>
</blockquote>
<p>优势</p>
<ul>
<li>执行效率极高，因为子程序切换（函数）不是线程切换，由程序自身控制，没有切换线程的开销。所以与多线程相比，线程的数量越多，协程性能的优势越明显。</li>
<li>不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在控制共享资源时也不需要加锁，因此执行效率高很多。
　　</li>
</ul>
<p>说明：协程可以处理IO密集型程序的效率问题，但是处理CPU密集型不是它的长处，如要充分发挥CPU利用率可以结合多进程+协程。</p>
<h2 id="0x3-2Python2-x协程"><a href="#0x3-2Python2-x协程" class="headerlink" title="0x3.2Python2.x协程"></a>0x3.2Python2.x协程</h2><p>python2.x协程应用：</p>
<ul>
<li>yield</li>
<li>gevent</li>
</ul>
<h3 id="0x3-2-1-Gevent"><a href="#0x3-2-1-Gevent" class="headerlink" title="0x3.2.1 Gevent"></a>0x3.2.1 Gevent</h3><p>gevent是第三方库，通过greenlet实现协程，其基本思想：<br>当一个greenlet遇到IO操作时，比如访问网络，就自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有greenlet在运行，而不是等待IO。</p>
<p>Gevent使用说明</p>
<ul>
<li>monkey可以使一些阻塞的模块变得不阻塞，机制：遇到IO操作则自动切换，手动切换可以用gevent.sleep(0)（将爬虫代码换成这个，效果一样可以达到切换上下文）</li>
<li>gevent.spawn() 方法会创建一个新的greenlet协程对象，并运行它。</li>
<li>gevent.joinall() 方法会等待所有传入的greenlet协程运行结束后再退出，这个方法可以接受一个”timeout”参数来设置超时时间，单位是秒。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! -*- coding:utf-8 -*-</span></span><br><span class="line">import gevent</span><br><span class="line">from gevent import monkey;monkey.patch_all()</span><br><span class="line">import urllib2</span><br><span class="line">def get_body(i):</span><br><span class="line">	<span class="built_in">print</span> <span class="string">"start"</span>,i</span><br><span class="line">	urllib2.urlopen(<span class="string">"http://cn.bing.com"</span>)</span><br><span class="line">	<span class="built_in">print</span> <span class="string">"end"</span>,i</span><br><span class="line">tasks=[gevent.spawn(get_body,i) <span class="keyword">for</span> i <span class="keyword">in</span> range(3)]</span><br><span class="line">gevent.joinall(tasks)</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">start 0</span><br><span class="line">start 1</span><br><span class="line">start 2</span><br><span class="line">end 0</span><br><span class="line">end 2</span><br><span class="line">end 1</span><br><span class="line">[Finished <span class="keyword">in</span> 11.7s]</span><br></pre></td></tr></table></figure>
<p>说明：从结果上来看，执行get_body的顺序应该先是输出”start”，然后执行到urllib2时碰到IO堵塞，则会自动切换运行下一个程序（继续执行get_body输出start），直到urllib2返回结果，再执行end。也就是说，程序没有等待urllib2请求网站返回结果，而是直接先跳过了，等待执行完毕再回来获取返回值。值得一提的是，在此过程中，只有一个线程在执行，因此这与多线程的概念是不一样的。<br>换成多线程的代码看看:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! -*- coding:utf-8 -*-</span></span><br><span class="line">import threading</span><br><span class="line">import urllib2</span><br><span class="line">def get_body(i):</span><br><span class="line">	<span class="built_in">print</span> <span class="string">"start"</span>,i</span><br><span class="line">	urllib2.urlopen(<span class="string">"http://cn.bing.com"</span>)</span><br><span class="line">	<span class="built_in">print</span> <span class="string">"end"</span>,i</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(3):</span><br><span class="line">	t=threading.Thread(target=get_body,args=(i,))</span><br><span class="line">	t.start()</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">start 0</span><br><span class="line">start 1</span><br><span class="line">start 2</span><br><span class="line">end 2</span><br><span class="line">end 0</span><br><span class="line">end 1</span><br><span class="line">[Finished <span class="keyword">in</span> 11.7s]</span><br></pre></td></tr></table></figure>
<p>说明：从结果来看，多线程与协程的效果一样，都是达到了IO阻塞时切换的功能。不同的是，多线程切换的是线程（线程间切换），协程切换的是上下文（可以理解为执行的函数）。而切换线程的开销明显是要大于切换上下文的开销，因此当线程越多，协程的效率就越比多线程的高。（猜想多进程的切换开销应该是最大的）</p>
<h2 id="0x3-3Python3-x协程"><a href="#0x3-3Python3-x协程" class="headerlink" title="0x3.3Python3.x协程"></a>0x3.3Python3.x协程</h2><p>详情可看此篇;<a href="https://thief.one/2018/06/21/1/" target="_blank" rel="noopener">https://thief.one/2018/06/21/1/</a></p>
<h3 id="0x3-3-1协程函数（异步函数）"><a href="#0x3-3-1协程函数（异步函数）" class="headerlink" title="0x3.3.1协程函数（异步函数）"></a>0x3.3.1协程函数（异步函数）</h3><h4 id="0x3-3-1-1创建协程函数"><a href="#0x3-3-1-1创建协程函数" class="headerlink" title="0x3.3.1.1创建协程函数"></a>0x3.3.1.1创建协程函数</h4><p>先来看下普通函数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def test1():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"1"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"2"</span>)</span><br><span class="line">def test2():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"3"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"4"</span>)</span><br><span class="line">a = test1()</span><br><span class="line">b = test2()</span><br><span class="line"><span class="built_in">print</span>(a,<span class="built_in">type</span>(a))</span><br><span class="line"><span class="built_in">print</span>(b,<span class="built_in">type</span>(b))</span><br></pre></td></tr></table></figure>
<p>运行以上代码得到结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">None &lt;class <span class="string">'NoneType'</span>&gt;</span><br><span class="line">None &lt;class <span class="string">'NoneType'</span>&gt;</span><br></pre></td></tr></table></figure>
<p>说明：程序顺序执行了test1、test2函数，在调用函数的时候就自动进入了函数体，并执行了函数的内容。</p>
<p>然后使用async关键词将普通函数变成协程函数，即异步函数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">async def test1():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"1"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"2"</span>)</span><br><span class="line">async def test2():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"3"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"4"</span>)</span><br><span class="line"><span class="built_in">print</span>(test1())</span><br><span class="line"><span class="built_in">print</span>(test2())</span><br></pre></td></tr></table></figure>
<p>运行以上代码得到结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;coroutine object test1 at 0x109f4c620&gt;</span><br><span class="line">asyncio_python3_test.py:16: RuntimeWarning: coroutine <span class="string">'test1'</span> was never awaited</span><br><span class="line">  <span class="built_in">print</span>(test1())</span><br><span class="line">&lt;coroutine object test2 at 0x109f4c620&gt;</span><br><span class="line">asyncio_python3_test.py:17: RuntimeWarning: coroutine <span class="string">'test2'</span> was never awaited</span><br><span class="line">  <span class="built_in">print</span>(test2())</span><br></pre></td></tr></table></figure>
<p>说明：忽略结果中的告警，可以看到调用函数test1、test2的时候，并没有进入函数体且执行函数内容，而是返回了一个coroutine（协程对象）。</p>
<p>除了函数外，类的方法也可以使用async关键词将其变成协程方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class <span class="built_in">test</span>:</span><br><span class="line">    async def run(self):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"1"</span>)</span><br></pre></td></tr></table></figure>

<h4 id="0x3-3-1-2执行协程函数"><a href="#0x3-3-1-2执行协程函数" class="headerlink" title="0x3.3.1.2执行协程函数"></a>0x3.3.1.2执行协程函数</h4><p>　　 前面我们成功创建了协程函数，并且在调用函数的时候返回了一个协程对象，那么怎么进入函数体并执行函数内容呢？类似于生成器，可以使用send方法执行函数，修改下前面的代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async def test1():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"1"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"2"</span>)</span><br><span class="line">async def test2():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"3"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"4"</span>)</span><br><span class="line">a = test1()</span><br><span class="line">b = test2()</span><br><span class="line">a.send(None)</span><br><span class="line">b.send(None)</span><br></pre></td></tr></table></figure>
<p>运行以上代码得到以下结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"asyncio_python3_test.py"</span>, line 19, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    a.send(None)</span><br><span class="line">StopIteration</span><br><span class="line">sys:1: RuntimeWarning: coroutine <span class="string">'test2'</span> was never awaited</span><br></pre></td></tr></table></figure>
<p>　　 说明：程序先执行了test1协程函数，当test1执行完时报了StopIteration异常，这是协程函数执行完饭回的一个异常，我们可以用try except捕捉，来用判断协程函数是否执行完毕。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">async def test1():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"1"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"2"</span>)</span><br><span class="line">async def test2():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"3"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"4"</span>)</span><br><span class="line">a = test1()</span><br><span class="line">b = test2()</span><br><span class="line">try:</span><br><span class="line">    a.send(None) <span class="comment"># 可以通过调用 send 方法，执行协程函数</span></span><br><span class="line">except StopIteration as e:</span><br><span class="line">    <span class="built_in">print</span>(e.value)</span><br><span class="line">    <span class="comment"># 协程函数执行结束时会抛出一个StopIteration 异常，标志着协程函数执行结束，返回值在value中</span></span><br><span class="line">    pass</span><br><span class="line">try:</span><br><span class="line">    b.send(None) <span class="comment"># 可以通过调用 send 方法，执行协程函数</span></span><br><span class="line">except StopIteration:</span><br><span class="line">    <span class="built_in">print</span>(e.value)</span><br><span class="line">    <span class="comment"># 协程函数执行结束时会抛出一个StopIteration 异常，标志着协程函数执行结束，返回值在value中</span></span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<p>运行以上代码得到以下结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>　　 说明：程序先执行了test1函数，等到test1函数执行完后再执行test2函数。从执行过程上来看目前协程函数与普通函数没有区别，并没有实现异步函数，那么如何交叉运行协程函数呢？  </p>
<h4 id="0x3-3-1-3交叉执行协程函数（await）"><a href="#0x3-3-1-3交叉执行协程函数（await）" class="headerlink" title="0x3.3.1.3交叉执行协程函数（await）"></a>0x3.3.1.3交叉执行协程函数（await）</h4><p>　　 通过以上例子，我们发现定义协程函数可以使用async关键词，执行函数可以使用send方法，那么如何实现在两个协程函数间来回切换执行呢？这里需要使用await关键词，修改一下代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">async def test1():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"1"</span>)</span><br><span class="line">    await asyncio.sleep(1) <span class="comment"># asyncio.sleep(1)返回的也是一个协程对象</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"2"</span>)</span><br><span class="line">async def test2():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"3"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"4"</span>)</span><br><span class="line">a = test1()</span><br><span class="line">b = test2()</span><br><span class="line">try:</span><br><span class="line">    a.send(None) <span class="comment"># 可以通过调用 send 方法，执行协程函数</span></span><br><span class="line">except StopIteration:</span><br><span class="line">    <span class="comment"># 协程函数执行结束时会抛出一个StopIteration 异常，标志着协程函数执行结束</span></span><br><span class="line">    pass</span><br><span class="line">try:</span><br><span class="line">    b.send(None) <span class="comment"># 可以通过调用 send 方法，执行协程函数</span></span><br><span class="line">except StopIteration:</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<p>运行以上函数得到以下结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>　　 说明：程序先执行test1协程函数，在执行到await时，test1函数停止了执行（阻塞）；接着开始执行test2协程函数，直到test2执行完毕。从结果中，我们可以看到，直到程序运行完毕，test1函数也没有执行完（没有执行print(“2”)），那么如何使test1函数执行完毕呢？可以使用asyncio自带的方法循环执行协程函数。</p>
<h4 id="0x3-3-1-4-await与阻塞"><a href="#0x3-3-1-4-await与阻塞" class="headerlink" title="0x3.3.1.4 await与阻塞"></a>0x3.3.1.4 await与阻塞</h4><p>　　 使用async可以定义协程对象，使用await可以针对耗时的操作进行挂起，就像生成器里的yield一样，函数让出控制权。协程遇到await，事件循环将会挂起该协程，执行别的协程，直到其他的协程也挂起或者执行完毕，再进行下一个协程的执行，协程的目的也是让一些耗时的操作异步化。</p>
<p>注意点：await后面跟的必须是一个Awaitable对象，或者实现了相应协议的对象，查看Awaitable抽象类的代码，表明了只要一个类实现了await方法，那么通过它构造出来的实例就是一个Awaitable，并且Coroutine类也继承了Awaitable。</p>
<h4 id="0x3-3-1-5自动循环执行协程函数"><a href="#0x3-3-1-5自动循环执行协程函数" class="headerlink" title="0x3.3.1.5自动循环执行协程函数"></a>0x3.3.1.5自动循环执行协程函数</h4><p>　　 通过前面介绍我们知道执行协程函数需要使用send方法，但一旦协程函数执行过程中切换到其他函数了，那么这个函数就不在被继续运行了，并且使用sned方法不是很高效。那么如何在执行整个程序过程中，自动得执行所有的协程函数呢，就如同多线程、多进程那样，隐式得执行而不是显示的通过send方法去执行函数。</p>
<h6 id="0x3-3-1-5-1事件循环方法"><a href="#0x3-3-1-5-1事件循环方法" class="headerlink" title="0x3.3.1.5.1事件循环方法"></a>0x3.3.1.5.1事件循环方法</h6><p>前面提到的问题就需要用到事件循环方法去解决，即asyncio.get_event_loop方法，修改以上代码如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">async def test1():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"1"</span>)</span><br><span class="line">    await test2()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"2"</span>)</span><br><span class="line">async def test2():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"3"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"4"</span>)</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(test1())</span><br></pre></td></tr></table></figure>
<p>运行以上代码得到以下结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>说明：asyncio.get_event_loop方法可以创建一个事件循环，然后使用run_until_complete将协程注册到事件循环，并启动事件循环。</p>
<h6 id="0x3-3-1-5-2task任务"><a href="#0x3-3-1-5-2task任务" class="headerlink" title="0x3.3.1.5.2task任务"></a>0x3.3.1.5.2task任务</h6><p> 由于协程对象不能直接运行，在注册事件循环的时候，其实是run_until_complete方法将协程包装成为了一个任务（task）对象。所谓task对象是Future类的子类，保存了协程运行后的状态，用于未来获取协程的结果。我们也可以手动将协程对象定义成task，修改以上代码如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">async def test1():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"1"</span>)</span><br><span class="line">    await test2()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"2"</span>)</span><br><span class="line">async def test2():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"3"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"4"</span>)</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">task = loop.create_task(test1())</span><br><span class="line">loop.run_until_complete(task)</span><br></pre></td></tr></table></figure>
<p>　　 说明：前面说到task对象保存了协程运行的状态，并且可以获取协程函数运行的返回值，那么具体该如何获取呢？这里可以分两种方式，一种需要绑定回调函数，另外一种则直接在运行完task任务后输出。值得一提的是，如果使用send方法执行函数，则返回值可以通过捕捉StopIteration异常，利用StopIteration.value获取。</p>
<h6 id="0x3-3-1-5-3直接输出task结果"><a href="#0x3-3-1-5-3直接输出task结果" class="headerlink" title="0x3.3.1.5.3直接输出task结果"></a>0x3.3.1.5.3直接输出task结果</h6><p>当协程函数运行结束后，我们需要得到其返回值，第一种方式就是等到task状态为finish时，调用task的result方法获取返回值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">async def test1():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"1"</span>)</span><br><span class="line">    await test2()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"2"</span>)</span><br><span class="line">    <span class="built_in">return</span> <span class="string">"stop"</span></span><br><span class="line">async def test2():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"3"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"4"</span>)</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">task = asyncio.ensure_future(test1())</span><br><span class="line">loop.run_until_complete(task)</span><br><span class="line"><span class="built_in">print</span>(task.result())</span><br></pre></td></tr></table></figure>
<p>运行以上代码得到以下结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">2</span><br><span class="line">stop</span><br></pre></td></tr></table></figure>
<h6 id="0x3-3-1-5-4回调函数"><a href="#0x3-3-1-5-4回调函数" class="headerlink" title="0x3.3.1.5.4回调函数"></a>0x3.3.1.5.4回调函数</h6><p>　　 获取返回值的第二种方法是可以通过绑定回调函数，在task执行完毕的时候可以获取执行的结果，回调的最后一个参数是future对象，通过该对象可以获取协程返回值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">async def test1():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"1"</span>)</span><br><span class="line">    await test2()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"2"</span>)</span><br><span class="line">    <span class="built_in">return</span> <span class="string">"stop"</span></span><br><span class="line">async def test2():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"3"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"4"</span>)</span><br><span class="line">def callback(future):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Callback:'</span>,future.result()) <span class="comment"># 通过future对象的result方法可以获取协程函数的返回值</span></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">task = asyncio.ensure_future(test1()) <span class="comment"># 创建task，test1()是一个协程对象</span></span><br><span class="line">task.add_done_callback(callback) <span class="comment"># 绑定回调函数</span></span><br><span class="line">loop.run_until_complete(task)</span><br></pre></td></tr></table></figure>
<p>运行以上代码得到以下结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">2</span><br><span class="line">Callback: stop</span><br></pre></td></tr></table></figure>
<p>如果回调函数需要接受多个参数，可以通过偏函数导入，修改代码如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">import functools</span><br><span class="line">async def test1():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"1"</span>)</span><br><span class="line">    await test2()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"2"</span>)</span><br><span class="line">    <span class="built_in">return</span> <span class="string">"stop"</span></span><br><span class="line">async def test2():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"3"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"4"</span>)</span><br><span class="line">def callback(param1,param2,future):</span><br><span class="line">    <span class="built_in">print</span>(param1,param2)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Callback:'</span>,future.result())</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">task = asyncio.ensure_future(test1())</span><br><span class="line">task.add_done_callback(functools.partial(callback,<span class="string">"param1"</span>,<span class="string">"param2"</span>))</span><br><span class="line">loop.run_until_complete(task)</span><br></pre></td></tr></table></figure>
<p>说明：回调函数中的future对象就是创建的task对象。</p>
<h6 id="0x3-3-1-5-5future对象"><a href="#0x3-3-1-5-5future对象" class="headerlink" title="0x3.3.1.5.5future对象"></a>0x3.3.1.5.5future对象</h6><p>　　 future对象有几个状态：Pending、Running、Done、Cancelled。创建future的时候，task为pending，事件循环调用执行的时候当然就是running，调用完毕自然就是done，如果需要停止事件循环，就需要先把task取消，可以使用asyncio.Task获取事件循环的task。</p>
<h6 id="0x3-3-1-5-6协程停止"><a href="#0x3-3-1-5-6协程停止" class="headerlink" title="0x3.3.1.5.6协程停止"></a>0x3.3.1.5.6协程停止</h6><p>　　 前面介绍了使用事件循环执行协程函数，那么怎么停止执行呢？在停止执行协程前，需要先取消task，然后再停止loop事件循环。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">async def test1():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"1"</span>)</span><br><span class="line">    await asyncio.sleep(3)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"2"</span>)</span><br><span class="line">    <span class="built_in">return</span> <span class="string">"stop"</span></span><br><span class="line">tasks = [</span><br><span class="line">    asyncio.ensure_future(test1()),</span><br><span class="line">    asyncio.ensure_future(test1()),</span><br><span class="line">    asyncio.ensure_future(test1()),</span><br><span class="line">]</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">try:</span><br><span class="line">    loop.run_until_complete(asyncio.wait(tasks))</span><br><span class="line">except KeyboardInterrupt as e:</span><br><span class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> asyncio.Task.all_tasks():</span><br><span class="line">        task.cancel()</span><br><span class="line">    loop.stop()</span><br><span class="line">    loop.run_forever()</span><br><span class="line">finally:</span><br><span class="line">    loop.close()</span><br></pre></td></tr></table></figure>
<p>运行以上代码，按ctrl+c可以结束执行。</p>
<h3 id="0x3-3-2本文中用到的一些概念及方法"><a href="#0x3-3-2本文中用到的一些概念及方法" class="headerlink" title="0x3.3.2本文中用到的一些概念及方法"></a>0x3.3.2本文中用到的一些概念及方法</h3><p>event_loop事件循环：程序开启一个无限的循环，当把一些函数注册到事件循环上时，满足事件发生条件即调用相应的函数。</p>
<ul>
<li>coroutine协程对象：指一个使用async关键字定义的函数，它的调用不会立即执行函数，而是会返回一个协程对象，协程对象需要注册到事件循环，由事件循环调用。</li>
<li>task任务：一个协程对象就是一个原生可以挂起的函数，任务则是对协程进一步封装，其中包含任务的各种状态。</li>
<li>future：代表将来执行或没有执行的任务的结果，它和task上没有本质的区别</li>
<li>async/await关键字：python3.5用于定义协程的关键字，async定义一个协程，await用于挂起阻塞的异步调用接口。</li>
</ul>
<h3 id="0x3-3-3并发与并行"><a href="#0x3-3-3并发与并行" class="headerlink" title="0x3.3.3并发与并行"></a>0x3.3.3并发与并行</h3><p>　　 并发通常指有多个任务需要同时进行，并行则是同一时刻有多个任务执行。用多线程、多进程、协程来说，协程实现并发，多线程与多进程实现并行。</p>
<h4 id="0x3-3-3-1asyncio协程如何实现并发"><a href="#0x3-3-3-1asyncio协程如何实现并发" class="headerlink" title="0x3.3.3.1asyncio协程如何实现并发"></a>0x3.3.3.1asyncio协程如何实现并发</h4><p>　　 asyncio想要实现并发，就需要多个协程来完成任务，每当有任务阻塞的时候就await，然后其他协程继续工作，这需要创建多个协程的列表，然后将这些协程注册到事件循环中。这里指的多个协程，可以是多个协程函数，也可以是一个协程函数的多个协程对象。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">async def test1():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"1"</span>)</span><br><span class="line">    await asyncio.sleep(1)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"2"</span>)</span><br><span class="line">    <span class="built_in">return</span> <span class="string">"stop"</span></span><br><span class="line">a = test1()</span><br><span class="line">b = test1()</span><br><span class="line">c = test1()</span><br><span class="line">tasks = [</span><br><span class="line">    asyncio.ensure_future(a),</span><br><span class="line">    asyncio.ensure_future(b),</span><br><span class="line">    asyncio.ensure_future(c),</span><br><span class="line">]</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks)) <span class="comment"># 注意asyncio.wait方法</span></span><br><span class="line"><span class="keyword">for</span> task <span class="keyword">in</span> tasks:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"task result is "</span>,task.result())</span><br></pre></td></tr></table></figure>
<p>运行以上代码得到以下结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">task result is  stop</span><br><span class="line">task result is  stop</span><br><span class="line">task result is  stop</span><br></pre></td></tr></table></figure>
<p>说明：代码先是定义了三个协程对象，然后通过asyncio.ensure_future方法创建了三个task，并且将所有的task加入到了task列表，最终使用loop.run_until_complete将task列表添加到事件循环中。</p>
<h3 id="0x3-3-4协程爬虫"><a href="#0x3-3-4协程爬虫" class="headerlink" title="0x3.3.4协程爬虫"></a>0x3.3.4协程爬虫</h3><p>　　 前面介绍了如何使用async与await创建协程函数，使用asyncio.get_event_loop创建事件循环并执行协程函数。例子很好地展示了协程并发的高效，但在实际应用场景中该如何开发协程程序？比如说异步爬虫。我尝试用requests模块、urllib模块写异步爬虫，但实际操作发现并不支持asyncio异步，因此可以使用aiohttp模块编写异步爬虫。</p>
<h4 id="0x3-3-4-1aiohttp实现"><a href="#0x3-3-4-1aiohttp实现" class="headerlink" title="0x3.3.4.1aiohttp实现"></a>0x3.3.4.1aiohttp实现</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">import aiohttp</span><br><span class="line">async def run(url):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"start spider "</span>,url)</span><br><span class="line">    async with aiohttp.ClientSession() as session:</span><br><span class="line">        async with session.get(url) as resp:</span><br><span class="line">            <span class="built_in">print</span>(resp.url)</span><br><span class="line">url_list = [<span class="string">"https://thief.one"</span>,<span class="string">"https://home.nmask.cn"</span>,<span class="string">"https://movie.nmask.cn"</span>,<span class="string">"https://tool.nmask.cn"</span>]</span><br><span class="line">tasks = [asyncio.ensure_future(run(url)) <span class="keyword">for</span> url <span class="keyword">in</span> url_list]</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br></pre></td></tr></table></figure>
<p>运行以上代码得到以下结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">start spider  https://thief.one</span><br><span class="line">start spider  https://home.nmask.cn</span><br><span class="line">start spider  https://movie.nmask.cn</span><br><span class="line">start spider  https://tool.nmask.cn</span><br><span class="line">https://movie.nmask.cn</span><br><span class="line">https://home.nmask.cn</span><br><span class="line">https://tool.nmask.cn</span><br><span class="line">https://thief.one</span><br></pre></td></tr></table></figure>
<p>说明：aiohttp基于asyncio实现，既可以用来写webserver，也可以当爬虫使用。</p>
<h4 id="0x3-3-4-2requests实现"><a href="#0x3-3-4-2requests实现" class="headerlink" title="0x3.3.4.2requests实现"></a>0x3.3.4.2requests实现</h4><p>　　 由于requests模块阻塞了客户代码与asycio事件循环的唯一线程，因此在执行调用时，整个应用程序都会冻结，但如果一定要用requests模块，可以使用事件循环对象的run_in_executor方法，通过run_in_executor方法来新建一个线程来执行耗时函数，因此可以这样修改代码实现：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">import requests</span><br><span class="line">async def run(url):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"start "</span>,url)</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    response = await loop.run_in_executor(None, requests.get, url)</span><br><span class="line">    <span class="built_in">print</span>(response.url)</span><br><span class="line">    </span><br><span class="line">url_list = [<span class="string">"https://thief.one"</span>,<span class="string">"https://home.nmask.cn"</span>,<span class="string">"https://movie.nmask.cn"</span>,<span class="string">"https://tool.nmask.cn"</span>]</span><br><span class="line">tasks = [asyncio.ensure_future(run(url)) <span class="keyword">for</span> url <span class="keyword">in</span> url_list]</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br></pre></td></tr></table></figure>
<p>如果要给requests带上参数，可以使用functools：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">import requests</span><br><span class="line">import functools</span><br><span class="line">async def run(url):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"start "</span>,url)</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    try:</span><br><span class="line">        response = await loop.run_in_executor(None,functools.partial(requests.get,url=url,params=<span class="string">""</span>,timeout=1))</span><br><span class="line">    except Exception as e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(response.url)</span><br><span class="line">url_list = [<span class="string">"https://thief.one"</span>,<span class="string">"https://home.nmask.cn"</span>,<span class="string">"https://movie.nmask.cn"</span>,<span class="string">"https://tool.nmask.cn"</span>]</span><br><span class="line">tasks = [asyncio.ensure_future(run(url)) <span class="keyword">for</span> url <span class="keyword">in</span> url_list]</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br></pre></td></tr></table></figure>
<h3 id="0x3-3-5asyncio中使用阻塞函数"><a href="#0x3-3-5asyncio中使用阻塞函数" class="headerlink" title="0x3.3.5asyncio中使用阻塞函数"></a>0x3.3.5asyncio中使用阻塞函数</h3><p>　　 如同前面介绍如何在asyncio中使用requests模块一样，如果想在asyncio中使用其他阻塞函数，该怎么实现呢？虽然目前有异步函数支持asyncio，但实际问题是大部分IO模块还不支持asyncio。</p>
<p><strong>阻塞函数在asyncio中使用的问题</strong><br>　　 阻塞函数(例如io读写，requests网络请求)阻塞了客户代码与asycio事件循环的唯一线程，因此在执行调用时，整个应用程序都会冻结。</p>
<p><strong>解决方案</strong><br>　　 这个问题的解决方法是使用事件循环对象的run_in_executor方法。asyncio的事件循环在背后维护着一个ThreadPoolExecutor对象，我们可以调用run_in_executor方法，把可调用对象发给它执行，即可以通过run_in_executor方法来新建一个线程来执行耗时函数。</p>
<p><strong>run_in_executor方法</strong>  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AbstractEventLoop.run_in_executor(executor, func, *args)</span><br></pre></td></tr></table></figure>
<ul>
<li>executor 参数应该是一个 Executor 实例。如果为 None，则使用默认 executor。</li>
<li>func 就是要执行的函数</li>
<li>args 就是传递给 func 的参数<br>实际例子（使用time.sleep()）：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">import time</span><br><span class="line">async def run(url):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"start "</span>,url)</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    try:</span><br><span class="line">        await loop.run_in_executor(None,time.sleep,1)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"stop "</span>,url)</span><br><span class="line">url_list = [<span class="string">"https://thief.one"</span>,<span class="string">"https://home.nmask.cn"</span>,<span class="string">"https://movie.nmask.cn"</span>,<span class="string">"https://tool.nmask.cn"</span>]</span><br><span class="line">tasks = [asyncio.ensure_future(run(url)) <span class="keyword">for</span> url <span class="keyword">in</span> url_list]</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(asyncio.wait(tasks))</span><br></pre></td></tr></table></figure>
<p>运行以上代码得到以下函数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">start  https://thief.one</span><br><span class="line">start  https://home.nmask.cn</span><br><span class="line">start  https://movie.nmask.cn</span><br><span class="line">start  https://tool.nmask.cn</span><br><span class="line">stop  https://thief.one</span><br><span class="line">stop  https://movie.nmask.cn</span><br><span class="line">stop  https://home.nmask.cn</span><br><span class="line">stop  https://tool.nmask.cn</span><br></pre></td></tr></table></figure>
<p>说明：有了run_in_executor方法，我们就可以使用之前熟悉的模块创建协程并发了，而不需要使用特定的模块进行IO异步开发。</p>
<p>参考文章:<br>进程线程协程:<a href="http://funhacks.net/explore-python/Process-Thread-Coroutine/process.html" target="_blank" rel="noopener">http://funhacks.net/explore-python/Process-Thread-Coroutine/process.html</a><br>Python之路：(十五）进程、线程和协程:<a href="http://www.liangxiansen.cn/2016/08/08/python-thread-process-gevent/" target="_blank" rel="noopener">http://www.liangxiansen.cn/2016/08/08/python-thread-process-gevent/</a><br>Python中多进程之间的数据共享:<a href="https://docs.lvrui.io/2016/07/24/Python%E4%B8%AD%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB/" target="_blank" rel="noopener">https://docs.lvrui.io/2016/07/24/Python%E4%B8%AD%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB/</a><br>多线程总结:<a href="https://www.cnblogs.com/tkqasn/p/5700281.html" target="_blank" rel="noopener">https://www.cnblogs.com/tkqasn/p/5700281.html</a></p>
<p>Python协程：<a href="https://thief.one/2017/02/20/Python%E5%8D%8F%E7%A8%8B/" target="_blank" rel="noopener">https://thief.one/2017/02/20/Python%E5%8D%8F%E7%A8%8B/</a><br>Python3.5协程学习研究:<a href="https://thief.one/2018/06/21/1/" target="_blank" rel="noopener">https://thief.one/2018/06/21/1/</a></p>
</div></div><a class="button-hover more" href="/article/6a6101d4.html#more">阅读全文</a></div><div class="recent-post-item"><a class="post-title" href="/article/c616b095.html">python的上下文管理器</a><div class="container"><time class="button-hover post-date"><i class="fas fa-calendar-alt article-icon" aria-hidden="true"></i> 更新于 2020-04-13</time><div class="button-hover categories"><i class="fa fa-inbox article-icon" aria-hidden="true"></i><a class="link-a" href="/categories/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95/">编程算法</a></div><div class="button-hover tags"><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/python/">python</a><span>&nbsp;|&nbsp;</span><i class="fa fa-tag article-icon" aria-hidden="true"></i><a class="link-a" href="/tags/%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8/">上下文管理器</a></div></div><div class="post-content"><div class="main-content content"><p>转载此文件:<a href="http://funhacks.net/explore-python/Advanced-Features/context.html" target="_blank" rel="noopener">http://funhacks.net/explore-python/Advanced-Features/context.html</a>  </p></div></div><a class="button-hover more" href="/article/c616b095.html#more">阅读全文</a></div></div><div id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/10/">&lt;i class&#x3D;&quot;fas fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/12/">&lt;i class&#x3D;&quot;fas fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a></div></div></div></div><div class="button-hover" id="return-top"><i class="fas fa-arrow-up" aria-hidden="true"></i></div><footer><div id="footer"><div class="button-hover" id="side-button"><i class="fas fa-arrow-right"></i></div><div class="right-content"><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fas fa-user"></i></span><span id="busuanzi_value_site_uv"></span><span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fas fa-eye"></i></span><span id="busuanzi_value_site_pv"></span><span></span></div><div class="copyright">&copy;2017 ～ 2021 By ye1s</div></div></div></footer></div><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery-3.3.1.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/velocity.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/thirdparty/jquery.mCustomScrollbar.concat.min.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/fan.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/canvas_bg.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/utils.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/scroll.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/sidebar.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/copy.js"></script><!--script(src=url)--><!--js(src=url_for(url) + '?version=' + version())--><script src="/js/daovoice.js"></script><!--script(src=url)--><div class="search-dialog"><div id="algolia-search-title">Algolia</div><div class="search-close-button"><i class="fa fa-times"></i></div><!--div#current-refined-values--><!--div#clear-all--><div id="search-box"></div><!--div#refinement-list--><hr><div id="hits"></div><div id="algolia-pagination"></div></div><div class="search-mask"></div><script src="/js/search/algolia.js"></script></body></html>